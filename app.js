(function(global_object) {
  "use strict";

  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var console;

  // Detect the global object
  if (typeof(globalThis) !== 'undefined') { global_object = globalThis; }
  else if (typeof(global) !== 'undefined') { global_object = global; }
  else if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else if (global_object.console == null) {
    console = global_object.console = {};
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(global_object.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return global_object.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal object that is exposed globally
  var Opal = global_object.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;
  global_object.Opal = Opal;

  // Configure runtime behavior with regards to require and unsupported features
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    enable_stack_trace: true                  // true, false
  };

  // Minify common function calls
  var $has_own   = Object.hasOwnProperty;
  var $bind      = Function.prototype.bind;
  var $set_proto = Object.setPrototypeOf;
  var $slice     = Array.prototype.slice;
  var $splice    = Array.prototype.splice;

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  Opal.uid = function() {
    unique_id += 2;
    return unique_id;
  };

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id != null) {
      return obj.$$id;
    }
    $defineProperty(obj, '$$id', Opal.uid());
    return obj.$$id;
  };

  // Globals table
  Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function() {
    Opal.gvars["!"] = Opal.exceptions.pop() || nil;
  };

  // Inspect any kind of object, including non Ruby ones
  Opal.inspect = function(obj) {
    if (obj === undefined) {
      return "undefined";
    }
    else if (obj === null) {
      return "null";
    }
    else if (!obj.$$class) {
      return obj.toString();
    }
    else {
      return obj.$inspect();
    }
  };

  function $defineProperty(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and null do not support it.
      object[name] = initialValue;
    } else {
      Object.defineProperty(object, name, {
        value: initialValue,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
  }

  Opal.defineProperty = $defineProperty;

  Opal.slice = $slice;


  // Helpers
  // -----

  Opal.truthy = function(val) {
    return (val !== nil && val != null && (!val.$$is_boolean || val == true));
  };

  Opal.falsy = function(val) {
    return (val === nil || val == null || (val.$$is_boolean && val == false))
  };

  Opal.type_error = function(object, type, method, coerced) {
    object = object.$$class;

    if (coerced && method) {
      coerced = coerced.$$class;
      return Opal.TypeError.$new(
        "can't convert " + object + " into " + type +
        " (" + object + "#" + method + " gives " + coerced + ")"
      )
    } else {
      return Opal.TypeError.$new(
        "no implicit conversion of " + object + " into " + type
      )
    }
  };

  Opal.coerce_to = function(object, type, method, args) {
    if (type['$==='](object)) return object;

    if (!object['$respond_to?'](method)) {
      throw Opal.type_error(object, type);
    }

    if (args == null) args = [];
    return Opal.send(object, method, args);
  }

  Opal.respond_to = function(obj, jsid, include_all) {
    if (obj == null || !obj.$$class) return false;
    include_all = !!include_all;
    var body = obj[jsid];

    if (obj['$respond_to?'].$$pristine) {
      if (obj['$respond_to_missing?'].$$pristine) {
        return typeof(body) === "function" && !body.$$stub;
      } else {
        return Opal.send(obj, obj['$respond_to_missing?'], [jsid.substr(1), include_all]);
      }
    } else {
      return Opal.send(obj, obj['$respond_to?'], [jsid.substr(1), include_all]);
    }
  }


  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) return cref.$$const[name];
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) return constant;
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, ancestors;

    if (cref == null) return;

    ancestors = Opal.ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $has_own.call(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name, skip_missing) {
    if (!skip_missing) {
      return (cref || _Object).$const_missing(name);
    }
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);              if (result != null) return result;
    result = const_missing(cref, name, skip_missing); if (result != null) return result;
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $defineProperty(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $defineProperty(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  Opal.const_set = function(cref, name, value) {
    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));
    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $defineProperty(cref, name, value);

    return value;
  };

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat(Opal.ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Do not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload != null && cref.$$autoload[name] != null) {
      delete cref.$$autoload[name];
      return nil;
    }

    throw Opal.NameError.$new("constant "+cref+"::"+cref.$name()+" not defined");
  };

  // Setup some shortcuts to reduce compiled size
  Opal.$$ = Opal.const_get_relative;
  Opal.$$$ = Opal.const_get_qualified;


  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass  [Class,null] superclass of the new class (may be null)
  // @param id          [String] the name of the class to be created
  // @param constructor [JS.Function] function to use as constructor
  //
  // @return new [Class]  or existing ruby class
  //
  Opal.allocate_class = function(name, superclass) {
    var klass, constructor;

    if (superclass != null && superclass.$$bridge) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      constructor = function() {
        var args = $slice.call(arguments),
            self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();

        // and replacing a __proto__ manually
        $set_proto(self, klass.$$prototype);
        return self;
      }
    } else {
      constructor = function(){};
    }

    if (name) {
      $defineProperty(constructor, 'displayName', '::'+name);
    }

    klass = constructor;

    $defineProperty(klass, '$$name', name);
    $defineProperty(klass, '$$constructor', constructor);
    $defineProperty(klass, '$$prototype', constructor.prototype);
    $defineProperty(klass, '$$const', {});
    $defineProperty(klass, '$$is_class', true);
    $defineProperty(klass, '$$is_a_module', true);
    $defineProperty(klass, '$$super', superclass);
    $defineProperty(klass, '$$cvars', {});
    $defineProperty(klass, '$$own_included_modules', []);
    $defineProperty(klass, '$$own_prepended_modules', []);
    $defineProperty(klass, '$$ancestors', []);
    $defineProperty(klass, '$$ancestors_cache_version', null);

    $defineProperty(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $set_proto(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $set_proto(klass.$$prototype, superclass.$$prototype);

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        throw Opal.TypeError.$new(name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      throw Opal.TypeError.$new("superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (
      superclass != null && (!superclass.hasOwnProperty || (
        superclass.hasOwnProperty && !superclass.hasOwnProperty('$$is_class')
      ))
    ) {
      if (superclass.constructor && superclass.constructor.name == "Function") {
        bridged = superclass;
        superclass = _Object;
      } else {
        throw Opal.TypeError.$new("superclass must be a Class (" + (
          (superclass.constructor && (superclass.constructor.name || superclass.constructor.$$name)) ||
          typeof(superclass)
        ) + " given)");
      }
    }

    var klass = find_existing_class(scope, name);

    if (klass) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }
      return klass;
    }

    // Class doesn't exist, create a new one with given superclass...

    // Not specifying a superclass means we can assume it to be Object
    if (superclass == null) {
      superclass = _Object;
    }

    // Create the class object (instance of Class)
    klass = Opal.allocate_class(name, superclass);
    Opal.const_set(scope, name, klass);

    // Call .inherited() hook with new class on the superclass
    if (superclass.$inherited) {
      superclass.$inherited(klass);
    }

    if (bridged) {
      Opal.bridge(bridged, klass);
    }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  Opal.allocate_module = function(name) {
    var constructor = function(){};
    if (name) {
      $defineProperty(constructor, 'displayName', name+'.$$constructor');
    }

    var module = constructor;

    if (name)
      $defineProperty(constructor, 'displayName', name+'.constructor');

    $defineProperty(module, '$$name', name);
    $defineProperty(module, '$$prototype', constructor.prototype);
    $defineProperty(module, '$$const', {});
    $defineProperty(module, '$$is_module', true);
    $defineProperty(module, '$$is_a_module', true);
    $defineProperty(module, '$$cvars', {});
    $defineProperty(module, '$$iclasses', []);
    $defineProperty(module, '$$own_included_modules', []);
    $defineProperty(module, '$$own_prepended_modules', []);
    $defineProperty(module, '$$ancestors', [module]);
    $defineProperty(module, '$$ancestors_cache_version', null);

    $set_proto(module, Opal.Module.prototype);

    return module;
  };

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        throw Opal.TypeError.$new(name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module) {
      return module;
    }

    // Module doesnt exist, create a new one...
    module = Opal.allocate_module(name);
    Opal.const_set(scope, name, module);

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singleton_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    var superclass, meta;

    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    meta = Opal.allocate_class(null, superclass, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', klass);
    $defineProperty(klass, '$$meta', meta);
    $set_proto(klass, meta.$$prototype);
    // Restoring ClassName.class
    $defineProperty(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singleton_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = Opal.allocate_class(null, Opal.Module, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', mod);
    $defineProperty(mod, '$$meta', meta);
    $set_proto(mod, meta.$$prototype);
    // Restoring ModuleName.class
    $defineProperty(mod, '$$class', Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = Opal.allocate_class(nil, superclass, function(){});

    $defineProperty(klass, '$$is_singleton', true);
    $defineProperty(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    $defineProperty(object, '$$meta', klass);

    $set_proto(object, object.$$meta.$$prototype);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  };

  Opal.instance_methods = function(mod) {
    var exclude = [], results = [], ancestors = Opal.ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (Opal.is_method(prop)) {
          var method_name = prop.slice(1),
              method = proto[prop];

          if (method.$$stub && exclude.indexOf(method_name) === -1) {
            exclude.push(method_name);
          }

          if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
            results.push(method_name);
          }
        }
      }
    }

    return results;
  };

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function(obj) {
    return Opal.instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.own_methods = function(obj) {
    return Opal.own_instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  // Gets class variable with specified +name+ from provided +module+
  //
  // @param module [Module]
  // @param name [String]
  Opal.class_variable_get = function(module, name, tolerant) {
    if ($has_own.call(module.$$cvars, name))
      return module.$$cvars[name];

    var ancestors = Opal.ancestors(module),
      i, length = ancestors.length;

    for (i = 0; i < length; i++) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        return ancestor.$$cvars[name];
      }
    }

    if (!tolerant)
      throw Opal.NameError.$new('uninitialized class variable '+name+' in '+module.$name());

    return nil;
  }

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      throw Opal.ArgumentError.$new('cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = Opal.ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var parent = includer.$$prototype, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (module_iclass.$$module === module && isRoot(module_iclass)) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      if (module_iclass) {
        // module has been directly included
        var next_ancestor = Object.getPrototypeOf(module_iclass);

        // skip non-root iclasses (that were recursively included)
        while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
          next_ancestor = Object.getPrototypeOf(next_ancestor);
        }

        start_chain_after = parent;
        end_chain_on = next_ancestor;
      } else {
        // module has not been directly included but was in ancestor chain because it was included by another module
        // include it directly
        start_chain_after = includer.$$prototype;
        end_chain_on = Object.getPrototypeOf(includer.$$prototype);
      }
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      throw Opal.ArgumentError.$new('cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $defineProperty(dummy_prepender, '$$dummy', true);
      $defineProperty(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $set_proto(dummy_prepender, prepender_iclass);
      $set_proto(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = Opal.ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      throw Opal.RuntimeError.$new("Prepending a module multiple times is not supported");
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $defineProperty(iclass, prop, proto[prop]);
    }

    $defineProperty(iclass, '$$iclass', true);
    $defineProperty(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $defineProperty(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $set_proto(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      throw Opal.ArgumentError.$new("already bridged");
    }

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $defineProperty(native_klass, '$$bridge', klass);
    $set_proto(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $defineProperty(klass, '$$prototype', native_klass.prototype);

    $defineProperty(klass.$$prototype, '$$class', klass);
    $defineProperty(klass, '$$constructor', native_klass);
    $defineProperty(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  Opal.ancestors = function(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = Opal.ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs(["$foo", "$bar", "$baz="]);
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;

    for (var i = 0, length = stubs.length; i < length; i++) {
      var stub = stubs[i], existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    var method_missing_stub = Opal.stub_for(stub);
    $defineProperty(prototype, stub, method_missing_stub);
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {

    function method_missing_stub() {
      /* jshint validthis: true */

      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }

      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments(' + actual + ' for ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (' + actual + ' for ' + expected + ')');
  };

  // Super dispatcher
  Opal.find_super_dispatcher = function(obj, mid, current_func, defcheck, allow_stubs) {
    var jsid = '$' + mid, ancestors, super_method;

    if (obj.hasOwnProperty('$$meta')) {
      ancestors = Opal.ancestors(obj.$$meta);
    } else {
      ancestors = Opal.ancestors(obj.$$class);
    }

    var current_index = ancestors.indexOf(current_func.$$owner);

    for (var i = current_index + 1; i < ancestors.length; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        super_method = proto[jsid];
        break;
      }
    }

    if (!defcheck && super_method && super_method.$$stub && obj.$method_missing.$$pristine) {
      // method_missing hasn't been explicitly defined
      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return (super_method.$$stub && !allow_stubs) ? null : super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      throw Opal.RuntimeError.$new("super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      throw Opal.RuntimeError.$new("implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly");
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super_dispatcher(obj, call_jsid, current_func, defcheck);
  };

  // Used to return as an expression. Sometimes, we can't simply return from
  // a javascript function as if we were a method, as the return is used as
  // an expression, or even inside a block which must "return" to the outer
  // method. This helper simply throws an error which is then caught by the
  // method. This approach is expensive, so it is only used when absolutely
  // needed.
  //
  Opal.ret = function(val) {
    Opal.returner.$v = val;
    throw Opal.returner;
  };

  // Used to break out of a block.
  Opal.brk = function(val, breaker) {
    breaker.$v = val;
    throw breaker;
  };

  // Builds a new unique breaker, this is to avoid multiple nested breaks to get
  // in the way of each other.
  Opal.new_brk = function() {
    return new Error('unexpected break');
  };

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error) {
        return candidate;
      }
      else if (candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return (klass.$$is_integer_class) ? (object % 1) === 0 : true;
    }

    var i, length, ancestors = Opal.ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    for (i = 0, length = ancestors.length; i < length; i++) {
      if (ancestors[i] === klass) {
        return true;
      }
    }

    return false;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      throw Opal.TypeError.$new("no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && Opal.respond_to(kwargs, '$to_hash', true)) {
      $splice.call(parameters, parameters.length - 1, 1);
      return kwargs.$to_hash();
    }
    else {
      return Opal.hash2([], {});
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var keys      = [],
        map       = {},
        key           ,
        given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block) {
    var body;

    if (typeof(method) === 'function') {
      body = method;
      method = null;
    } else if (typeof(method) === 'string') {
      body = recv['$'+method];
    } else {
      throw Opal.NameError.$new("Passed method should be a string or a function");
    }

    return Opal.send2(recv, body, method, args, block);
  };

  Opal.send2 = function(recv, body, method, args, block) {
    if (body == null && method != null && recv.$method_missing) {
      body = recv.$method_missing;
      args = [method].concat(args);
    }

    if (typeof block === 'function') body.$$p = block;
    return body.apply(recv, args);
  };

  Opal.lambda = function(block) {
    block.$$is_lambda = true;
    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @return [null]
  //
  Opal.def = function(obj, jsid, body) {
    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      Opal.defn(Opal.Object, jsid, body)
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      Opal.defn(obj, jsid, body);
    }
    else {
      Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    body.displayName = jsid;
    body.$$owner = module;

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $defineProperty(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $defineProperty(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(jsid.substr(1));
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(jsid.substr(1));
    }
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body) {
    if (obj.$$is_string || obj.$$is_number) {
      throw Opal.TypeError.$new("can't define singleton");
    }
    Opal.defn(Opal.get_singleton_class(obj), jsid, body)
  };

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$has_own.call(obj.$$prototype, jsid)) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = '$' + name,
        old_id = '$' + old,
        body   = obj.$$prototype['$' + old],
        alias;

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        throw Opal.NameError.$new("undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be overwritten on the original body.
    alias = function() {
      var block = alias.$$p, args, i, ii;

      args = new Array(arguments.length);
      for(i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      if (block != null) { alias.$$p = null }

      return Opal.send(this, body, args, block);
    };

    // Assign the 'length' value with defineProperty because
    // in strict mode the property is not writable.
    // It doesn't work in older browsers (like Chrome 38), where
    // an exception is thrown breaking Opal altogether.
    try {
      Object.defineProperty(alias, 'length', { value: body.length });
    } catch (e) {}

    // Try to make the browser pick the right name
    alias.displayName       = name;

    alias.$$arity           = body.$$arity;
    alias.$$parameters      = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of        = body;
    alias.$$alias_name      = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_native = function(obj, name, native_name) {
    var id   = '$' + name,
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      throw Opal.NameError.$new("undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function(hash) {
    hash.$$smap = Object.create(null);
    hash.$$map  = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function(hash, key, value) {
    if (key.$$is_string) {
      if (!$has_own.call(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function(hash, key) {
    if (key.$$is_string) {
      if ($has_own.call(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($has_own.call(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key['$eql?'](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function(hash, key) {
    var i, keys = hash.$$keys, length = keys.length, value;

    if (key.$$is_string) {
      if (typeof key !== "string") key = key.valueOf();

      if (!$has_own.call(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        if (keys[i] === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash], last_bucket;

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        }
        else if (last_bucket) {
          delete last_bucket.next;
        }
        else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        }
        else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function(hash) {
    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {

      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          }
          else if (last_bucket) {
            delete last_bucket.next;
          }
          else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          }
          else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$has_own.call(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function() {
    var arguments_length = arguments.length, args, hash, i, length, key, value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash();
    Opal.hash_init(hash);

    if (arguments_length === 1 && arguments[0].$$is_array) {
      args = arguments[0];
      length = args.length;

      for (i = 0; i < length; i++) {
        if (args[i].length !== 2) {
          throw Opal.ArgumentError.$new("value not of length 2: " + args[i].$inspect());
        }

        key = args[i][0];
        value = args[i][1];

        Opal.hash_put(hash, key, value);
      }

      return hash;
    }

    if (arguments_length === 1) {
      args = arguments[0];
      for (key in args) {
        if ($has_own.call(args, key)) {
          value = args[key];

          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    }

    if (arguments_length % 2 !== 0) {
      throw Opal.ArgumentError.$new("odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    var hash = new Opal.Hash();

    hash.$$smap = smap;
    hash.$$map  = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (
        // properties
        name === "constructor" ||
        name === "displayName" ||
        name === "__count__" ||
        name === "__noSuchMethod__" ||
        name === "__parent__" ||
        name === "__proto__" ||

        // methods
        name === "hasOwnProperty" ||
        name === "valueOf"
       )
    {
      return name + "$";
    }

    return name;
  };


  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function(pattern) {
    var result;
    if (pattern.multiline) {
      if (pattern.global) {
        return pattern; // RegExp already has the global and multiline flag
      }
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g != null) {
        result = pattern.$$g;
      } else {
        result = pattern.$$g = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
      }
    } else if (pattern.$$gm != null) {
      result = pattern.$$gm;
    } else {
      result = pattern.$$gm = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Combine multiple regexp parts together
  Opal.regexp = function(parts, flags) {
    var part;
    var ignoreCase = typeof flags !== 'undefined' && flags && flags.indexOf('i') >= 0;

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part instanceof RegExp) {
        if (part.ignoreCase !== ignoreCase)
          Opal.Kernel.$warn(
            "ignore case doesn't match for " + part.source.$inspect(),
            Opal.hash({uplevel: 1})
          )

        part = part.source;
      }
      if (part === '') part = '(?:' + part + ')';
      parts[i] = part;
    }

    if (flags) {
      return new RegExp(parts.join(''), flags);
    } else {
      return new RegExp(parts.join(''));
    }
  };

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      module(Opal);
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        if (Opal.LoadError) {
          throw Opal.LoadError.$new(message)
        } else {
          throw message
        }
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load(path);
  };


  // Strings
  // -------

  Opal.encodings = Object.create(null);

  // Sets the encoding on a string, will treat string literals as frozen strings
  // raising a FrozenError.
  //
  // @param str [String] the string on which the encoding should be set
  // @param name [String] the canonical name of the encoding
  // @param type [String] possible values are either `"encoding"`, `"internal_encoding"`, or `undefined
  Opal.set_encoding = function(str, name, type) {
    if (typeof type === "undefined") type = "encoding";
    if (typeof str === 'string' || str.$$frozen === true)
      throw Opal.FrozenError.$new("can't modify frozen String");

    var encoding = Opal.find_encoding(name);

    if (encoding === str[type]) { return str; }

    str[type] = encoding;

    return str;
  };

  // Fetches the encoding for the given name or raises ArgumentError.
  Opal.find_encoding = function(name) {
    var register = Opal.encodings;
    var encoding = register[name] || register[name.toUpperCase()];
    if (!encoding) throw Opal.ArgumentError.$new("unknown encoding name - " + name);
    return encoding;
  }

  // @returns a String object with the encoding set from a string literal
  Opal.enc = function(str, name) {
    var dup = new String(str);
    dup = Opal.set_encoding(dup, name);
    dup.internal_encoding = dup.encoding;
    return dup
  }

  // @returns a String object with the internal encoding set to Binary
  Opal.binary = function(str) {
    var dup = new String(str);
    return Opal.set_encoding(dup, "binary", "internal_encoding");
  }


  // Initialization
  // --------------
  function $BasicObject() {}
  function $Object() {}
  function $Module() {}
  function $Class() {}

  Opal.BasicObject = BasicObject = Opal.allocate_class('BasicObject', null, $BasicObject);
  Opal.Object      = _Object     = Opal.allocate_class('Object', Opal.BasicObject, $Object);
  Opal.Module      = Module      = Opal.allocate_class('Module', Opal.Object, $Module);
  Opal.Class       = Class       = Opal.allocate_class('Class', Opal.Module, $Class);

  $set_proto(Opal.BasicObject, Opal.Class.$$prototype);
  $set_proto(Opal.Object, Opal.Class.$$prototype);
  $set_proto(Opal.Module, Opal.Class.$$prototype);
  $set_proto(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const["BasicObject"] = BasicObject;

  // Assign basic constants
  Opal.const_set(_Object, "BasicObject",  BasicObject);
  Opal.const_set(_Object, "Object",       _Object);
  Opal.const_set(_Object, "Module",       Module);
  Opal.const_set(_Object, "Class",        Class);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;

  // Forward .toString() to #to_s
  $defineProperty(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $defineProperty(_Object.$$prototype, '$require', Opal.require);

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = function() { return 'main' };
  Opal.top.$define_method = top_define_method;

  // Foward calls to define_method on the top object to Object
  function top_define_method() {
    var args = Opal.slice.call(arguments, 0, arguments.length);
    var block = top_define_method.$$p;
    top_define_method.$$p = null;
    return Opal.send(_Object, 'define_method', args, block)
  };


  // Nil
  function $NilClass() {}
  Opal.NilClass = Opal.allocate_class('NilClass', Opal.Object, $NilClass);
  Opal.const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };

  // Errors
  Opal.breaker  = new Error('unexpected break (old)');
  Opal.returner = new Error('unexpected return');
  TypeError.$$super = Error;
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
/* Generated by Opal 1.2.0 */
Opal.modules["corelib/helpers"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $type_error = Opal.type_error, $coerce_to = Opal.coerce_to, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$===', '$raise', '$respond_to?', '$nil?', '$__send__', '$<=>', '$class', '$coerce_to!', '$new', '$!=', '$[]', '$upcase']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $Opal_bridge$1, $Opal_coerce_to$excl$2, $Opal_coerce_to$ques$3, $Opal_try_convert$4, $Opal_compare$5, $Opal_destructure$6, $Opal_respond_to$ques$7, $Opal_instance_variable_name$excl$8, $Opal_class_variable_name$excl$9, $Opal_const_name$excl$10, $Opal_pristine$11;

    
    Opal.defs(self, '$bridge', $Opal_bridge$1 = function $$bridge(constructor, klass) {
      var self = this;

      return Opal.bridge(constructor, klass);
    }, $Opal_bridge$1.$$arity = 2);
    Opal.defs(self, '$coerce_to!', $Opal_coerce_to$excl$2 = function(object, type, method, $a) {
      var $post_args, args, self = this, coerced = nil;

      
      
      $post_args = Opal.slice.call(arguments, 3, arguments.length);
      
      args = $post_args;;
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$excl$2.$$arity = -4);
    Opal.defs(self, '$coerce_to?', $Opal_coerce_to$ques$3 = function(object, type, method, $a) {
      var $post_args, args, self = this, coerced = nil;

      
      
      $post_args = Opal.slice.call(arguments, 3, arguments.length);
      
      args = $post_args;;
      if ($truthy(object['$respond_to?'](method))) {
      } else {
        return nil
      };
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(coerced['$nil?']())) {
        return nil};
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$ques$3.$$arity = -4);
    Opal.defs(self, '$try_convert', $Opal_try_convert$4 = function $$try_convert(object, type, method) {
      var self = this;

      
      if ($truthy(type['$==='](object))) {
        return object};
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    }, $Opal_try_convert$4.$$arity = 3);
    Opal.defs(self, '$compare', $Opal_compare$5 = function $$compare(a, b) {
      var self = this, compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")};
      return compare;
    }, $Opal_compare$5.$$arity = 2);
    Opal.defs(self, '$destructure', $Opal_destructure$6 = function $$destructure(args) {
      var self = this;

      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    }, $Opal_destructure$6.$$arity = 1);
    Opal.defs(self, '$respond_to?', $Opal_respond_to$ques$7 = function(obj, method, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, $Opal_respond_to$ques$7.$$arity = -3);
    Opal.defs(self, '$instance_variable_name!', $Opal_instance_variable_name$excl$8 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    }, $Opal_instance_variable_name$excl$8.$$arity = 1);
    Opal.defs(self, '$class_variable_name!', $Opal_class_variable_name$excl$9 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        self.$raise($$($nesting, 'NameError').$new("" + "`" + (name) + "' is not allowed as a class variable name", name))};
      return name;
    }, $Opal_class_variable_name$excl$9.$$arity = 1);
    Opal.defs(self, '$const_name!', $Opal_const_name$excl$10 = function(const_name) {
      var self = this;

      
      const_name = $$($nesting, 'Opal')['$coerce_to!'](const_name, $$($nesting, 'String'), "to_str");
      if ($truthy(const_name['$[]'](0)['$!='](const_name['$[]'](0).$upcase()))) {
        self.$raise($$($nesting, 'NameError'), "" + "wrong constant name " + (const_name))};
      return const_name;
    }, $Opal_const_name$excl$10.$$arity = 1);
    return (Opal.defs(self, '$pristine', $Opal_pristine$11 = function $$pristine(owner_class, $a) {
      var $post_args, method_names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      method_names = $post_args;;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype['$'+method_name];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, $Opal_pristine$11.$$arity = -2), nil) && 'pristine';
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/module"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $lambda = Opal.lambda, $range = Opal.range, $send2 = Opal.send2;

  Opal.add_stubs(['$module_eval', '$to_proc', '$===', '$raise', '$equal?', '$<', '$>', '$nil?', '$attr_reader', '$attr_writer', '$warn', '$attr_accessor', '$class_variable_name!', '$const_name!', '$=~', '$new', '$inject', '$split', '$const_get', '$==', '$!~', '$start_with?', '$bind', '$call', '$class', '$append_features', '$included', '$name', '$cover?', '$size', '$merge', '$compile', '$proc', '$any?', '$prepend_features', '$prepended', '$to_s', '$__id__', '$constants', '$include?', '$copy_class_variables', '$copy_constants']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_allocate$1, $Module_initialize$2, $Module_$eq_eq_eq$3, $Module_$lt$4, $Module_$lt_eq$5, $Module_$gt$6, $Module_$gt_eq$7, $Module_$lt_eq_gt$8, $Module_alias_method$9, $Module_alias_native$10, $Module_ancestors$11, $Module_append_features$12, $Module_attr_accessor$13, $Module_attr$14, $Module_attr_reader$15, $Module_attr_writer$16, $Module_autoload$17, $Module_class_variables$18, $Module_class_variable_get$19, $Module_class_variable_set$20, $Module_class_variable_defined$ques$21, $Module_remove_class_variable$22, $Module_constants$23, $Module_constants$24, $Module_nesting$25, $Module_const_defined$ques$26, $Module_const_get$27, $Module_const_missing$29, $Module_const_set$30, $Module_public_constant$31, $Module_define_method$32, $Module_remove_method$34, $Module_singleton_class$ques$35, $Module_include$36, $Module_included_modules$37, $Module_include$ques$38, $Module_instance_method$39, $Module_instance_methods$40, $Module_included$41, $Module_extended$42, $Module_extend_object$43, $Module_method_added$44, $Module_method_removed$45, $Module_method_undefined$46, $Module_module_eval$47, $Module_module_exec$49, $Module_method_defined$ques$50, $Module_module_function$51, $Module_name$52, $Module_prepend$53, $Module_prepend_features$54, $Module_prepended$55, $Module_remove_const$56, $Module_to_s$57, $Module_undef_method$58, $Module_instance_variables$59, $Module_dup$60, $Module_copy_class_variables$61, $Module_copy_constants$62;

    
    Opal.defs(self, '$allocate', $Module_allocate$1 = function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    }, $Module_allocate$1.$$arity = 0);
    
    Opal.def(self, '$initialize', $Module_initialize$2 = function $$initialize() {
      var $iter = $Module_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Module_initialize$2.$$p = null;
      
      
      if ($iter) $Module_initialize$2.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    }, $Module_initialize$2.$$arity = 0);
    
    Opal.def(self, '$===', $Module_$eq_eq_eq$3 = function(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false};
      return Opal.is_a(object, self);;
    }, $Module_$eq_eq_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Module_$lt$4 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    }, $Module_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Module_$lt_eq$5 = function(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_lt(self, other)
      }
    }, $Module_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$>', $Module_$gt$6 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    }, $Module_$gt$6.$$arity = 1);
    
    Opal.def(self, '$>=', $Module_$gt_eq$7 = function(other) {
      var self = this, $ret_or_2 = nil;

      if ($truthy(($ret_or_2 = self['$equal?'](other)))) {
        return $ret_or_2
      } else {
        return $rb_gt(self, other)
      }
    }, $Module_$gt_eq$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Module_$lt_eq_gt$8 = function(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil};
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    }, $Module_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$alias_method', $Module_alias_method$9 = function $$alias_method(newname, oldname) {
      var self = this;

      
      newname = $coerce_to(newname, $$($nesting, 'String'), 'to_str');
      oldname = $coerce_to(oldname, $$($nesting, 'String'), 'to_str');
      Opal.alias(self, newname, oldname);
      return self;
    }, $Module_alias_method$9.$$arity = 2);
    
    Opal.def(self, '$alias_native', $Module_alias_native$10 = function $$alias_native(mid, jsid) {
      var self = this;

      
      
      if (jsid == null) {
        jsid = mid;
      };
      Opal.alias_native(self, mid, jsid);
      return self;
    }, $Module_alias_native$10.$$arity = -2);
    
    Opal.def(self, '$ancestors', $Module_ancestors$11 = function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    }, $Module_ancestors$11.$$arity = 0);
    
    Opal.def(self, '$append_features', $Module_append_features$12 = function $$append_features(includer) {
      var self = this;

      
      Opal.append_features(self, includer);
      return self;
    }, $Module_append_features$12.$$arity = 1);
    
    Opal.def(self, '$attr_accessor', $Module_attr_accessor$13 = function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      $send(self, 'attr_reader', Opal.to_a(names));
      return $send(self, 'attr_writer', Opal.to_a(names));
    }, $Module_attr_accessor$13.$$arity = -1);
    
    Opal.def(self, '$attr', $Module_attr$14 = function $$attr($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (args.length == 2 && (args[1] === true || args[1] === false)) {
        self.$warn("optional boolean argument is obsoleted", $hash2(["uplevel"], {"uplevel": 1}))

        args[1] ? self.$attr_accessor(args[0]) : self.$attr_reader(args[0]);
        return nil;
      }
    ;
      return $send(self, 'attr_reader', Opal.to_a(args));
    }, $Module_attr$14.$$arity = -1);
    
    Opal.def(self, '$attr_reader', $Module_attr_reader$15 = function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name,
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar) {
          return function() {
            if (this[ivar] == null) {
              return nil;
            }
            else {
              return this[ivar];
            }
          };
        })(ivar);

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_reader$15.$$arity = -1);
    
    Opal.def(self, '$attr_writer', $Module_attr_writer$16 = function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name + '=',
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar){
          return function(value) {
            return this[ivar] = value;
          }
        })(ivar);

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_writer$16.$$arity = -1);
    
    Opal.def(self, '$autoload', $Module_autoload$17 = function $$autoload(const$, path) {
      var self = this;

      
      if (self.$$autoload == null) self.$$autoload = {};
      Opal.const_cache_version++;
      self.$$autoload[const$] = path;
      return nil;
    
    }, $Module_autoload$17.$$arity = 2);
    
    Opal.def(self, '$class_variables', $Module_class_variables$18 = function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    }, $Module_class_variables$18.$$arity = 0);
    
    Opal.def(self, '$class_variable_get', $Module_class_variable_get$19 = function $$class_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variable_get(self, name, false);;
    }, $Module_class_variable_get$19.$$arity = 1);
    
    Opal.def(self, '$class_variable_set', $Module_class_variable_set$20 = function $$class_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    }, $Module_class_variable_set$20.$$arity = 2);
    
    Opal.def(self, '$class_variable_defined?', $Module_class_variable_defined$ques$21 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    }, $Module_class_variable_defined$ques$21.$$arity = 1);
    
    Opal.def(self, '$remove_class_variable', $Module_remove_class_variable$22 = function $$remove_class_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        self.$raise($$($nesting, 'NameError'), "" + "cannot remove " + (name) + " for " + (self))
      }
    ;
    }, $Module_remove_class_variable$22.$$arity = 1);
    
    Opal.def(self, '$constants', $Module_constants$23 = function $$constants(inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      return Opal.constants(self, inherit);;
    }, $Module_constants$23.$$arity = -1);
    Opal.defs(self, '$constants', $Module_constants$24 = function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat(Opal.Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, $Module_constants$24.$$arity = -1);
    Opal.defs(self, '$nesting', $Module_nesting$25 = function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    }, $Module_nesting$25.$$arity = 0);
    
    Opal.def(self, '$const_defined?', $Module_const_defined$ques$26 = function(name, inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) {
          return true;
        }
      }

      return false;
    ;
    }, $Module_const_defined$ques$26.$$arity = -2);
    
    Opal.def(self, '$const_get', $Module_const_get$27 = function $$const_get(name, inherit) {
      var $$28, self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], ($$28 = function(o, c){var self = $$28.$$s == null ? this : $$28.$$s;

        
          
          if (o == null) {
            o = nil;
          };
          
          if (c == null) {
            c = nil;
          };
          return o.$const_get(c);}, $$28.$$s = self, $$28.$$arity = 2, $$28))};
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return $$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, $Module_const_get$27.$$arity = -2);
    
    Opal.def(self, '$const_missing', $Module_const_missing$29 = function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      
      if (self.$$autoload) {
        var file = self.$$autoload[name];

        if (file) {
          self.$require(file);

          return self.$const_get(name);
        }
      }
    ;
      full_const_name = (function() {if (self['$==']($$($nesting, 'Object'))) {
        return name
      } else {
        return "" + (self) + "::" + (name)
      }; return nil; })();
      return self.$raise($$($nesting, 'NameError').$new("" + "uninitialized constant " + (full_const_name), name));
    }, $Module_const_missing$29.$$arity = 1);
    
    Opal.def(self, '$const_set', $Module_const_set$30 = function $$const_set(name, value) {
      var self = this, $ret_or_3 = nil;

      
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy((function() {if ($truthy(($ret_or_3 = name['$!~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP'))))) {
        return $ret_or_3
      } else {
        return name['$start_with?']("::")
      }; return nil; })())) {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))};
      Opal.const_set(self, name, value);
      return value;
    }, $Module_const_set$30.$$arity = 2);
    
    Opal.def(self, '$public_constant', $Module_public_constant$31 = function $$public_constant(const_name) {
      var self = this;

      return nil
    }, $Module_public_constant$31.$$arity = 1);
    
    Opal.def(self, '$define_method', $Module_define_method$32 = function $$define_method(name, method) {
      var $iter = $Module_define_method$32.$$p, block = $iter || nil, $$33, self = this, $ret_or_4 = nil, $case = nil;

      if ($iter) $Module_define_method$32.$$p = null;
      
      
      if ($iter) $Module_define_method$32.$$p = null;;
      ;
      if ($truthy(method === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")};
      block = (function() {if ($truthy(($ret_or_4 = block))) {
        return $ret_or_4
      } else {
        return (function() {$case = method;
        if ($$($nesting, 'Proc')['$===']($case)) {return method}
        else if ($$($nesting, 'Method')['$===']($case)) {return method.$to_proc().$$unbound}
        else if ($$($nesting, 'UnboundMethod')['$===']($case)) {return $lambda(($$33 = function($a){var self = $$33.$$s == null ? this : $$33.$$s, $post_args, args, bound = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          bound = method.$bind(self);
          return $send(bound, 'call', Opal.to_a(args));}, $$33.$$s = self, $$33.$$arity = -1, $$33))}
        else {return self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (block.$class()) + " (expected Proc/Method)")}})()
      }; return nil; })();
      
      var id = '$' + name;

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      Opal.defn(self, id, block);

      return name;
    ;
    }, $Module_define_method$32.$$arity = -2);
    
    Opal.def(self, '$remove_method', $Module_remove_method$34 = function $$remove_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.rdef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_remove_method$34.$$arity = -1);
    
    Opal.def(self, '$singleton_class?', $Module_singleton_class$ques$35 = function() {
      var self = this;

      return !!self.$$is_singleton;
    }, $Module_singleton_class$ques$35.$$arity = 0);
    
    Opal.def(self, '$include', $Module_include$36 = function $$include($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, $Module_include$36.$$arity = -1);
    
    Opal.def(self, '$included_modules', $Module_included_modules$37 = function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    }, $Module_included_modules$37.$$arity = 0);
    
    Opal.def(self, '$include?', $Module_include$ques$38 = function(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    }, $Module_include$ques$38.$$arity = 1);
    
    Opal.def(self, '$instance_method', $Module_instance_method$39 = function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return $$($nesting, 'UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    }, $Module_instance_method$39.$$arity = 1);
    
    Opal.def(self, '$instance_methods', $Module_instance_methods$40 = function $$instance_methods(include_super) {
      var self = this;

      
      
      if (include_super == null) {
        include_super = true;
      };
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, $Module_instance_methods$40.$$arity = -1);
    
    Opal.def(self, '$included', $Module_included$41 = function $$included(mod) {
      var self = this;

      return nil
    }, $Module_included$41.$$arity = 1);
    
    Opal.def(self, '$extended', $Module_extended$42 = function $$extended(mod) {
      var self = this;

      return nil
    }, $Module_extended$42.$$arity = 1);
    
    Opal.def(self, '$extend_object', $Module_extend_object$43 = function $$extend_object(object) {
      var self = this;

      return nil
    }, $Module_extend_object$43.$$arity = 1);
    
    Opal.def(self, '$method_added', $Module_method_added$44 = function $$method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_added$44.$$arity = -1);
    
    Opal.def(self, '$method_removed', $Module_method_removed$45 = function $$method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_removed$45.$$arity = -1);
    
    Opal.def(self, '$method_undefined', $Module_method_undefined$46 = function $$method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_undefined$46.$$arity = -1);
    
    Opal.def(self, '$module_eval', $Module_module_eval$47 = function $$module_eval($a) {
      var $iter = $Module_module_eval$47.$$p, block = $iter || nil, $post_args, args, $b, $$48, self = this, $ret_or_5 = nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_6 = nil, compiling_options = nil, compiled = nil;

      if ($iter) $Module_module_eval$47.$$p = null;
      
      
      if ($iter) $Module_module_eval$47.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_5 = block['$nil?']()))) {
        return !!Opal.compile;
      } else {
        return $ret_or_5
      }; return nil; })())) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": (function() {if ($truthy(($ret_or_6 = file))) {
          return $ret_or_6
        } else {
          return "(eval)"
        }; return nil; })(), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$($nesting, 'Opal').$compile(string, compiling_options);
        block = $send($$($nesting, 'Kernel'), 'proc', [], ($$48 = function(){var self = $$48.$$s == null ? this : $$48.$$s;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$48.$$s = self, $$48.$$arity = 0, $$48));
      } else if ($truthy(args['$any?']())) {
        $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "" + ("" + "wrong number of arguments (" + (args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")};
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, $Module_module_eval$47.$$arity = -1);
    Opal.alias(self, "class_eval", "module_eval");
    
    Opal.def(self, '$module_exec', $Module_module_exec$49 = function $$module_exec($a) {
      var $iter = $Module_module_exec$49.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Module_module_exec$49.$$p = null;
      
      
      if ($iter) $Module_module_exec$49.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block === nil) {
        self.$raise($$($nesting, 'LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, $Module_module_exec$49.$$arity = -1);
    Opal.alias(self, "class_exec", "module_exec");
    
    Opal.def(self, '$method_defined?', $Module_method_defined$ques$50 = function(method) {
      var self = this;

      
      var body = self.$$prototype['$' + method];
      return (!!body) && !body.$$stub;
    
    }, $Module_method_defined$ques$50.$$arity = 1);
    
    Opal.def(self, '$module_function', $Module_module_function$51 = function $$module_function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = true;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = '$' + meth,
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
      }

      return self;
    ;
    }, $Module_module_function$51.$$arity = -1);
    
    Opal.def(self, '$name', $Module_name$52 = function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === Opal.Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    }, $Module_name$52.$$arity = 0);
    
    Opal.def(self, '$prepend', $Module_prepend$53 = function $$prepend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      if (mods.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, $Module_prepend$53.$$arity = -1);
    
    Opal.def(self, '$prepend_features', $Module_prepend_features$54 = function $$prepend_features(prepender) {
      var self = this;

      
      
      if (!self.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    }, $Module_prepend_features$54.$$arity = 1);
    
    Opal.def(self, '$prepended', $Module_prepended$55 = function $$prepended(mod) {
      var self = this;

      return nil
    }, $Module_prepended$55.$$arity = 1);
    
    Opal.def(self, '$remove_const', $Module_remove_const$56 = function $$remove_const(name) {
      var self = this;

      return Opal.const_remove(self, name);
    }, $Module_remove_const$56.$$arity = 1);
    
    Opal.def(self, '$to_s', $Module_to_s$57 = function $$to_s() {
      var self = this, $ret_or_7 = nil;

      if ($truthy(($ret_or_7 = Opal.Module.$name.call(self)))) {
        return $ret_or_7
      } else {
        return "" + "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">"
      }
    }, $Module_to_s$57.$$arity = 0);
    
    Opal.def(self, '$undef_method', $Module_undef_method$58 = function $$undef_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.udef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_undef_method$58.$$arity = -1);
    
    Opal.def(self, '$instance_variables', $Module_instance_variables$59 = function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      }

      return result;
    ;
    }, $Module_instance_variables$59.$$arity = 0);
    
    Opal.def(self, '$dup', $Module_dup$60 = function $$dup() {
      var $iter = $Module_dup$60.$$p, $yield = $iter || nil, self = this, copy = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Module_dup$60.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      copy = $send2(self, Opal.find_super_dispatcher(self, 'dup', $Module_dup$60, false, true), 'dup', $zuper, $iter);
      copy.$copy_class_variables(self);
      copy.$copy_constants(self);
      return copy;
    }, $Module_dup$60.$$arity = 0);
    
    Opal.def(self, '$copy_class_variables', $Module_copy_class_variables$61 = function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    }, $Module_copy_class_variables$61.$$arity = 1);
    return (Opal.def(self, '$copy_constants', $Module_copy_constants$62 = function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        Opal.const_set(self, name, other_constants[name]);
      }
    
    }, $Module_copy_constants$62.$$arity = 1), nil) && 'copy_constants';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/class"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $send2 = Opal.send2;

  Opal.add_stubs(['$require', '$class_eval', '$to_proc', '$initialize_copy', '$allocate', '$name', '$to_s']);
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $Class_new$1, $Class_allocate$2, $Class_inherited$3, $Class_initialize_dup$4, $Class_new$5, $Class_superclass$6, $Class_to_s$7;

    
    Opal.defs(self, '$new', $Class_new$1 = function(superclass) {
      var $iter = $Class_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Class_new$1.$$p = null;
      
      
      if ($iter) $Class_new$1.$$p = null;;
      
      if (superclass == null) {
        superclass = $$($nesting, 'Object');
      };
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      (function() {if ((block !== nil)) {
        return $send((klass), 'class_eval', [], block.$to_proc())
      } else {
        return nil
      }; return nil; })()
      return klass;
    ;
    }, $Class_new$1.$$arity = -1);
    
    Opal.def(self, '$allocate', $Class_allocate$2 = function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    }, $Class_allocate$2.$$arity = 0);
    
    Opal.def(self, '$inherited', $Class_inherited$3 = function $$inherited(cls) {
      var self = this;

      return nil
    }, $Class_inherited$3.$$arity = 1);
    
    Opal.def(self, '$initialize_dup', $Class_initialize_dup$4 = function $$initialize_dup(original) {
      var self = this;

      
      self.$initialize_copy(original);
      
      self.$$name = null;
      self.$$full_name = null;
    ;
    }, $Class_initialize_dup$4.$$arity = 1);
    
    Opal.def(self, '$new', $Class_new$5 = function($a) {
      var $iter = $Class_new$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Class_new$5.$$p = null;
      
      
      if ($iter) $Class_new$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, $Class_new$5.$$arity = -1);
    
    Opal.def(self, '$superclass', $Class_superclass$6 = function $$superclass() {
      var self = this;

      return self.$$super || nil;
    }, $Class_superclass$6.$$arity = 0);
    return (Opal.def(self, '$to_s', $Class_to_s$7 = function $$to_s() {
      var $iter = $Class_to_s$7.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Class_to_s$7.$$p = null;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && singleton_of.$$is_a_module) {
        return "" + "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "" + "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }

      return $send2(self, Opal.find_super_dispatcher(self, 'to_s', $Class_to_s$7, false, true), 'to_s', [], null);
    
    }, $Class_to_s$7.$$arity = 0), nil) && 'to_s';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/basic_object"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$==', '$!', '$nil?', '$cover?', '$size', '$raise', '$merge', '$compile', '$proc', '$any?', '$inspect', '$new']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'BasicObject');

    var $nesting = [self].concat($parent_nesting), $BasicObject_initialize$1, $BasicObject_$eq_eq$2, $BasicObject_eql$ques$3, $BasicObject___id__$4, $BasicObject___send__$5, $BasicObject_$excl$6, $BasicObject_$not_eq$7, $BasicObject_instance_eval$8, $BasicObject_instance_exec$10, $BasicObject_singleton_method_added$11, $BasicObject_singleton_method_removed$12, $BasicObject_singleton_method_undefined$13, $BasicObject_method_missing$14, $BasicObject_respond_to_missing$ques$15;

    
    
    Opal.def(self, '$initialize', $BasicObject_initialize$1 = function $$initialize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_initialize$1.$$arity = -1);
    
    Opal.def(self, '$==', $BasicObject_$eq_eq$2 = function(other) {
      var self = this;

      return self === other;
    }, $BasicObject_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$eql?', $BasicObject_eql$ques$3 = function(other) {
      var self = this;

      return self['$=='](other)
    }, $BasicObject_eql$ques$3.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    
    Opal.def(self, '$__id__', $BasicObject___id__$4 = function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.defineProperty(self, '$$id', Opal.uid());
      return self.$$id;
    
    }, $BasicObject___id__$4.$$arity = 0);
    
    Opal.def(self, '$__send__', $BasicObject___send__$5 = function $$__send__(symbol, $a) {
      var $iter = $BasicObject___send__$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject___send__$5.$$p = null;
      
      
      if ($iter) $BasicObject___send__$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      var func = self['$' + symbol]

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, $BasicObject___send__$5.$$arity = -2);
    
    Opal.def(self, '$!', $BasicObject_$excl$6 = function() {
      var self = this;

      return false
    }, $BasicObject_$excl$6.$$arity = 0);
    
    Opal.def(self, '$!=', $BasicObject_$not_eq$7 = function(other) {
      var self = this;

      return self['$=='](other)['$!']()
    }, $BasicObject_$not_eq$7.$$arity = 1);
    
    Opal.def(self, '$instance_eval', $BasicObject_instance_eval$8 = function $$instance_eval($a) {
      var $iter = $BasicObject_instance_eval$8.$$p, block = $iter || nil, $post_args, args, $b, $$9, self = this, $ret_or_1 = nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_2 = nil, compiling_options = nil, compiled = nil;

      if ($iter) $BasicObject_instance_eval$8.$$p = null;
      
      
      if ($iter) $BasicObject_instance_eval$8.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_1 = block['$nil?']()))) {
        return !!Opal.compile;
      } else {
        return $ret_or_1
      }; return nil; })())) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": (function() {if ($truthy(($ret_or_2 = file))) {
          return $ret_or_2
        } else {
          return "(eval)"
        }; return nil; })(), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$$('::', 'Opal').$compile(string, compiling_options);
        block = $send($$$('::', 'Kernel'), 'proc', [], ($$9 = function(){var self = $$9.$$s == null ? this : $$9.$$s;

        
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$9.$$s = self, $$9.$$arity = 0, $$9));
      } else if ($truthy(args['$any?']())) {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "" + "wrong number of arguments (" + (args.$size()) + " for 0)")};
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, $BasicObject_instance_eval$8.$$arity = -1);
    
    Opal.def(self, '$instance_exec', $BasicObject_instance_exec$10 = function $$instance_exec($a) {
      var $iter = $BasicObject_instance_exec$10.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject_instance_exec$10.$$p = null;
      
      
      if ($iter) $BasicObject_instance_exec$10.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(block)) {
      } else {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, $BasicObject_instance_exec$10.$$arity = -1);
    
    Opal.def(self, '$singleton_method_added', $BasicObject_singleton_method_added$11 = function $$singleton_method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_added$11.$$arity = -1);
    
    Opal.def(self, '$singleton_method_removed', $BasicObject_singleton_method_removed$12 = function $$singleton_method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_removed$12.$$arity = -1);
    
    Opal.def(self, '$singleton_method_undefined', $BasicObject_singleton_method_undefined$13 = function $$singleton_method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_undefined$13.$$arity = -1);
    
    Opal.def(self, '$method_missing', $BasicObject_method_missing$14 = function $$method_missing(symbol, $a) {
      var $iter = $BasicObject_method_missing$14.$$p, block = $iter || nil, $post_args, args, self = this, message = nil;

      if ($iter) $BasicObject_method_missing$14.$$p = null;
      
      
      if ($iter) $BasicObject_method_missing$14.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      message = (function() {if ($truthy(self.$inspect && !self.$inspect.$$stub)) {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$inspect()) + ":" + (self.$$class)
      } else {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$$class)
      }; return nil; })();
      return $$$('::', 'Kernel').$raise($$$('::', 'NoMethodError').$new(message, symbol));
    }, $BasicObject_method_missing$14.$$arity = -2);
    return (Opal.def(self, '$respond_to_missing?', $BasicObject_respond_to_missing$ques$15 = function(method_name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return false;
    }, $BasicObject_respond_to_missing$ques$15.$$arity = -2), nil) && 'respond_to_missing?';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/kernel"] = function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $module = Opal.module, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $klass = Opal.klass;

  Opal.add_stubs(['$raise', '$new', '$inspect', '$!', '$=~', '$==', '$object_id', '$class', '$coerce_to?', '$<<', '$allocate', '$copy_instance_variables', '$copy_singleton_methods', '$initialize_clone', '$initialize_copy', '$define_method', '$singleton_class', '$to_proc', '$initialize_dup', '$for', '$empty?', '$pop', '$call', '$append_features', '$extend_object', '$extended', '$__id__', '$to_s', '$instance_variable_name!', '$respond_to?', '$to_int', '$coerce_to!', '$Integer', '$nil?', '$===', '$enum_for', '$result', '$any?', '$print', '$format', '$puts', '$each', '$<=', '$length', '$[]', '$<', '$first', '$caller', '$+', '$map', '$exception', '$is_a?', '$rand', '$respond_to_missing?', '$pristine', '$try_convert!', '$expand_path', '$join', '$start_with?', '$new_seed', '$srand', '$sym', '$arg', '$open', '$include']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_method_missing$1, $Kernel_$eq_tilde$2, $Kernel_$excl_tilde$3, $Kernel_$eq_eq_eq$4, $Kernel_$lt_eq_gt$5, $Kernel_method$6, $Kernel_methods$7, $Kernel_public_methods$8, $Kernel_Array$9, $Kernel_at_exit$10, $Kernel_caller$11, $Kernel_class$12, $Kernel_copy_instance_variables$13, $Kernel_copy_singleton_methods$14, $Kernel_clone$15, $Kernel_initialize_clone$16, $Kernel_define_singleton_method$17, $Kernel_dup$18, $Kernel_initialize_dup$19, $Kernel_enum_for$20, $Kernel_equal$ques$21, $Kernel_exit$22, $Kernel_extend$23, $Kernel_hash$24, $Kernel_initialize_copy$25, $Kernel_inspect$26, $Kernel_instance_of$ques$27, $Kernel_instance_variable_defined$ques$28, $Kernel_instance_variable_get$29, $Kernel_instance_variable_set$30, $Kernel_remove_instance_variable$31, $Kernel_instance_variables$32, $Kernel_Integer$33, $Kernel_Float$34, $Kernel_Hash$35, $Kernel_is_a$ques$36, $Kernel_itself$37, $Kernel_lambda$38, $Kernel_load$39, $Kernel_loop$40, $Kernel_nil$ques$42, $Kernel_printf$43, $Kernel_proc$44, $Kernel_puts$45, $Kernel_p$46, $Kernel_print$48, $Kernel_warn$49, $Kernel_raise$51, $Kernel_rand$52, $Kernel_respond_to$ques$53, $Kernel_respond_to_missing$ques$54, $Kernel_require$55, $Kernel_require_relative$56, $Kernel_require_tree$57, $Kernel_singleton_class$58, $Kernel_sleep$59, $Kernel_srand$60, $Kernel_String$61, $Kernel_tap$62, $Kernel_to_proc$63, $Kernel_to_s$64, $Kernel_catch$65, $Kernel_throw$66, $Kernel_open$67, $Kernel_yield_self$68;

    
    
    Opal.def(self, '$method_missing', $Kernel_method_missing$1 = function $$method_missing(symbol, $a) {
      var $iter = $Kernel_method_missing$1.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_method_missing$1.$$p = null;
      
      
      if ($iter) $Kernel_method_missing$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `" + (symbol) + "' for " + (self.$inspect()), symbol, args));
    }, $Kernel_method_missing$1.$$arity = -2);
    
    Opal.def(self, '$=~', $Kernel_$eq_tilde$2 = function(obj) {
      var self = this;

      return false
    }, $Kernel_$eq_tilde$2.$$arity = 1);
    
    Opal.def(self, '$!~', $Kernel_$excl_tilde$3 = function(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    }, $Kernel_$excl_tilde$3.$$arity = 1);
    
    Opal.def(self, '$===', $Kernel_$eq_eq_eq$4 = function(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$object_id()['$=='](other.$object_id())))) {
        return $ret_or_1
      } else {
        return self['$=='](other)
      }
    }, $Kernel_$eq_eq_eq$4.$$arity = 1);
    
    Opal.def(self, '$<=>', $Kernel_$lt_eq_gt$5 = function(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    }, $Kernel_$lt_eq_gt$5.$$arity = 1);
    
    Opal.def(self, '$method', $Kernel_method$6 = function $$method(name) {
      var self = this;

      
      var meth = self['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return $$($nesting, 'Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    }, $Kernel_method$6.$$arity = 1);
    
    Opal.def(self, '$methods', $Kernel_methods$7 = function $$methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, $Kernel_methods$7.$$arity = -1);
    
    Opal.def(self, '$public_methods', $Kernel_public_methods$8 = function $$public_methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, $Kernel_public_methods$8.$$arity = -1);
    
    Opal.def(self, '$Array', $Kernel_Array$9 = function $$Array(object) {
      var self = this;

      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    }, $Kernel_Array$9.$$arity = 1);
    
    Opal.def(self, '$at_exit', $Kernel_at_exit$10 = function $$at_exit() {
      var $iter = $Kernel_at_exit$10.$$p, block = $iter || nil, self = this, $ret_or_2 = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      if ($iter) $Kernel_at_exit$10.$$p = null;
      
      
      if ($iter) $Kernel_at_exit$10.$$p = null;;
      $gvars.__at_exit__ = (function() {if ($truthy(($ret_or_2 = $gvars.__at_exit__))) {
        return $ret_or_2
      } else {
        return []
      }; return nil; })();
      $gvars.__at_exit__['$<<'](block);
      return block;
    }, $Kernel_at_exit$10.$$arity = 0);
    
    Opal.def(self, '$caller', $Kernel_caller$11 = function $$caller(start, length) {
      var self = this;

      
      
      if (start == null) {
        start = 1;
      };
      
      if (length == null) {
        length = nil;
      };
      
      var stack, result

      stack = (new Error().stack || "").split("\n")
      result = []

      // Skip the initial line ("Error:") and Kernel#caller with i=3
      for (var i = 3, ii = stack.length; i < ii; i++) {
        if (!stack[i].match("runtime.js")) {
          result.push(stack[i].replace(/^ *\w+ +/, ''))
          if (length && result.length == length) break
        }
      }
      return result
    ;
    }, $Kernel_caller$11.$$arity = -1);
    
    Opal.def(self, '$class', $Kernel_class$12 = function() {
      var self = this;

      return self.$$class;
    }, $Kernel_class$12.$$arity = 0);
    
    Opal.def(self, '$copy_instance_variables', $Kernel_copy_instance_variables$13 = function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_instance_variables$13.$$arity = 1);
    
    Opal.def(self, '$copy_singleton_methods', $Kernel_copy_singleton_methods$14 = function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta')) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_singleton_methods$14.$$arity = 1);
    
    Opal.def(self, '$clone', $Kernel_clone$15 = function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $Kernel_clone$15.$$arity = -1);
    
    Opal.def(self, '$initialize_clone', $Kernel_initialize_clone$16 = function $$initialize_clone(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_clone$16.$$arity = 1);
    
    Opal.def(self, '$define_singleton_method', $Kernel_define_singleton_method$17 = function $$define_singleton_method(name, method) {
      var $iter = $Kernel_define_singleton_method$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_define_singleton_method$17.$$p = null;
      
      
      if ($iter) $Kernel_define_singleton_method$17.$$p = null;;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, $Kernel_define_singleton_method$17.$$arity = -2);
    
    Opal.def(self, '$dup', $Kernel_dup$18 = function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, $Kernel_dup$18.$$arity = 0);
    
    Opal.def(self, '$initialize_dup', $Kernel_initialize_dup$19 = function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_dup$19.$$arity = 1);
    
    Opal.def(self, '$enum_for', $Kernel_enum_for$20 = function $$enum_for($a, $b) {
      var $iter = $Kernel_enum_for$20.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Kernel_enum_for$20.$$p = null;
      
      
      if ($iter) $Kernel_enum_for$20.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      return $send($$($nesting, 'Enumerator'), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Kernel_enum_for$20.$$arity = -1);
    Opal.alias(self, "to_enum", "enum_for");
    
    Opal.def(self, '$equal?', $Kernel_equal$ques$21 = function(other) {
      var self = this;

      return self === other;
    }, $Kernel_equal$ques$21.$$arity = 1);
    
    Opal.def(self, '$exit', $Kernel_exit$22 = function $$exit(status) {
      var $a, self = this, $ret_or_3 = nil, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      
      if (status == null) {
        status = true;
      };
      $gvars.__at_exit__ = (function() {if ($truthy(($ret_or_3 = $gvars.__at_exit__))) {
        return $ret_or_3
      } else {
        return []
      }; return nil; })();
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
        
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $coerce_to(status, $$($nesting, 'Integer'), 'to_int')
      }

      Opal.exit(status);
    ;
      return nil;
    }, $Kernel_exit$22.$$arity = -1);
    
    Opal.def(self, '$extend', $Kernel_extend$23 = function $$extend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, $Kernel_extend$23.$$arity = -1);
    
    Opal.def(self, '$hash', $Kernel_hash$24 = function $$hash() {
      var self = this;

      return self.$__id__()
    }, $Kernel_hash$24.$$arity = 0);
    
    Opal.def(self, '$initialize_copy', $Kernel_initialize_copy$25 = function $$initialize_copy(other) {
      var self = this;

      return nil
    }, $Kernel_initialize_copy$25.$$arity = 1);
    
    Opal.def(self, '$inspect', $Kernel_inspect$26 = function $$inspect() {
      var self = this;

      return self.$to_s()
    }, $Kernel_inspect$26.$$arity = 0);
    
    Opal.def(self, '$instance_of?', $Kernel_instance_of$ques$27 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    }, $Kernel_instance_of$ques$27.$$arity = 1);
    
    Opal.def(self, '$instance_variable_defined?', $Kernel_instance_variable_defined$ques$28 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    }, $Kernel_instance_variable_defined$ques$28.$$arity = 1);
    
    Opal.def(self, '$instance_variable_get', $Kernel_instance_variable_get$29 = function $$instance_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    }, $Kernel_instance_variable_get$29.$$arity = 1);
    
    Opal.def(self, '$instance_variable_set', $Kernel_instance_variable_set$30 = function $$instance_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    }, $Kernel_instance_variable_set$30.$$arity = 2);
    
    Opal.def(self, '$remove_instance_variable', $Kernel_remove_instance_variable$31 = function $$remove_instance_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return self.$raise($$($nesting, 'NameError'), "" + "instance variable " + (name) + " not defined");
    }, $Kernel_remove_instance_variable$31.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Kernel_instance_variables$32 = function $$instance_variables() {
      var self = this;

      
      var result = [], ivar;

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {
          if (name.substr(-1) === '$') {
            ivar = name.slice(0, name.length - 1);
          } else {
            ivar = name;
          }
          result.push('@' + ivar);
        }
      }

      return result;
    
    }, $Kernel_instance_variables$32.$$arity = 0);
    
    Opal.def(self, '$Integer', $Kernel_Integer$33 = function $$Integer(value, base) {
      var self = this;

      
      ;
      
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "base specified for non string value")
        }
        if (value === nil) {
          self.$raise($$($nesting, 'TypeError'), "can't convert nil into Integer")
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            self.$raise($$($nesting, 'FloatDomainError'), value)
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (i !== nil) {
            return i;
          }
        }
        return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Integer'), "to_i");
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $coerce_to(base, $$($nesting, 'Integer'), 'to_int');
        if (base === 1 || base < 0 || base > 36) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
        }
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      return i;
    ;
    }, $Kernel_Integer$33.$$arity = -2);
    
    Opal.def(self, '$Float', $Kernel_Float$34 = function $$Float(value) {
      var self = this;

      
      var str;

      if (value === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert nil into Float")
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return self.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Float(): \"" + (value) + "\"")
        }

        return parseFloat(str);
      }

      return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Float'), "to_f");
    
    }, $Kernel_Float$34.$$arity = 1);
    
    Opal.def(self, '$Hash', $Kernel_Hash$35 = function $$Hash(arg) {
      var self = this, $ret_or_4 = nil;

      
      if ($truthy((function() {if ($truthy(($ret_or_4 = arg['$nil?']()))) {
        return $ret_or_4
      } else {
        return arg['$==']([])
      }; return nil; })())) {
        return $hash2([], {})};
      if ($truthy($$($nesting, 'Hash')['$==='](arg))) {
        return arg};
      return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'Hash'), "to_hash");
    }, $Kernel_Hash$35.$$arity = 1);
    
    Opal.def(self, '$is_a?', $Kernel_is_a$ques$36 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    }, $Kernel_is_a$ques$36.$$arity = 1);
    
    Opal.def(self, '$itself', $Kernel_itself$37 = function $$itself() {
      var self = this;

      return self
    }, $Kernel_itself$37.$$arity = 0);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$lambda', $Kernel_lambda$38 = function $$lambda() {
      var $iter = $Kernel_lambda$38.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_lambda$38.$$p = null;
      
      
      if ($iter) $Kernel_lambda$38.$$p = null;;
      return Opal.lambda(block);;
    }, $Kernel_lambda$38.$$arity = 0);
    
    Opal.def(self, '$load', $Kernel_load$39 = function $$load(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.load(file);
    }, $Kernel_load$39.$$arity = 1);
    
    Opal.def(self, '$loop', $Kernel_loop$40 = function $$loop() {
      var $$41, $a, $iter = $Kernel_loop$40.$$p, $yield = $iter || nil, self = this, e = nil;

      if ($iter) $Kernel_loop$40.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["loop"], ($$41 = function(){var self = $$41.$$s == null ? this : $$41.$$s;

        return $$$($$($nesting, 'Float'), 'INFINITY')}, $$41.$$s = self, $$41.$$arity = 0, $$41))
      };
      while ($truthy(true)) {
        
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StopIteration')])) {(e = $err)
            try {
              return e.$result()
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };
      };
      return self;
    }, $Kernel_loop$40.$$arity = 0);
    
    Opal.def(self, '$nil?', $Kernel_nil$ques$42 = function() {
      var self = this;

      return false
    }, $Kernel_nil$ques$42.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$printf', $Kernel_printf$43 = function $$printf($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(args['$any?']())) {
        self.$print($send(self, 'format', Opal.to_a(args)))};
      return nil;
    }, $Kernel_printf$43.$$arity = -1);
    
    Opal.def(self, '$proc', $Kernel_proc$44 = function $$proc() {
      var $iter = $Kernel_proc$44.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_proc$44.$$p = null;
      
      
      if ($iter) $Kernel_proc$44.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    }, $Kernel_proc$44.$$arity = 0);
    
    Opal.def(self, '$puts', $Kernel_puts$45 = function $$puts($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'puts', Opal.to_a(strs));
    }, $Kernel_puts$45.$$arity = -1);
    
    Opal.def(self, '$p', $Kernel_p$46 = function $$p($a) {
      var $post_args, args, $$47, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      $send(args, 'each', [], ($$47 = function(obj){var self = $$47.$$s == null ? this : $$47.$$s;
        if ($gvars.stdout == null) $gvars.stdout = nil;

      
        
        if (obj == null) {
          obj = nil;
        };
        return $gvars.stdout.$puts(obj.$inspect());}, $$47.$$s = self, $$47.$$arity = 1, $$47));
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, $Kernel_p$46.$$arity = -1);
    
    Opal.def(self, '$print', $Kernel_print$48 = function $$print($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'print', Opal.to_a(strs));
    }, $Kernel_print$48.$$arity = -1);
    
    Opal.def(self, '$warn', $Kernel_warn$49 = function $$warn($a, $b) {
      var $post_args, $kwargs, strs, uplevel, $$50, self = this, location = nil, $ret_or_5 = nil;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      strs = $post_args;;
      
      uplevel = $kwargs.$$smap["uplevel"];
      if (uplevel == null) {
        uplevel = nil
      };
      if ($truthy(uplevel)) {
        
        uplevel = $$($nesting, 'Opal')['$coerce_to!'](uplevel, $$($nesting, 'Integer'), "to_str");
        if ($truthy($rb_lt(uplevel, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "negative level (" + (uplevel) + ")")};
        location = self.$caller($rb_plus(uplevel, 2), 1).$first();
        if ($truthy(location)) {
          location = "" + (location) + ": "};
        strs = $send(strs, 'map', [], ($$50 = function(s){var self = $$50.$$s == null ? this : $$50.$$s;

        
          
          if (s == null) {
            s = nil;
          };
          return "" + (location) + "warning: " + (s);}, $$50.$$s = self, $$50.$$arity = 1, $$50));};
      if ($truthy((function() {if ($truthy(($ret_or_5 = $gvars.VERBOSE['$nil?']()))) {
        return $ret_or_5
      } else {
        return strs['$empty?']()
      }; return nil; })())) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', Opal.to_a(strs))
      };
    }, $Kernel_warn$49.$$arity = -1);
    
    Opal.def(self, '$raise', $Kernel_raise$51 = function $$raise(exception, string, _backtrace) {
      var self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      ;
      
      if (string == null) {
        string = nil;
      };
      
      if (_backtrace == null) {
        _backtrace = nil;
      };
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$($nesting, 'RuntimeError').$new();
      }
      else if (exception.$$is_string) {
        exception = $$($nesting, 'RuntimeError').$new(exception);
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && exception['$respond_to?']("exception")) {
        exception = exception.$exception(string);
      }
      else if (exception['$is_a?']($$($nesting, 'Exception'))) {
        // exception is fine
      }
      else {
        exception = $$($nesting, 'TypeError').$new("exception class/object expected");
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;

      throw exception;
    ;
    }, $Kernel_raise$51.$$arity = -1);
    Opal.alias(self, "fail", "raise");
    
    Opal.def(self, '$rand', $Kernel_rand$52 = function $$rand(max) {
      var self = this;

      
      ;
      
      if (max === undefined) {
        return $$$($$($nesting, 'Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$($nesting, 'Random'), 'DEFAULT').$rand(max);
    }, $Kernel_rand$52.$$arity = -1);
    
    Opal.def(self, '$respond_to?', $Kernel_respond_to$ques$53 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      
      var body = self['$' + name];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }

      if (self['$respond_to_missing?'].$$pristine === true) {
        return false;
      } else {
        return self['$respond_to_missing?'](name, include_all);
      }
    ;
    }, $Kernel_respond_to$ques$53.$$arity = -2);
    
    Opal.def(self, '$respond_to_missing?', $Kernel_respond_to_missing$ques$54 = function(method_name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return false;
    }, $Kernel_respond_to_missing$ques$54.$$arity = -2);
    $$($nesting, 'Opal').$pristine(self, "respond_to?", "respond_to_missing?");
    
    Opal.def(self, '$require', $Kernel_require$55 = function $$require(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.require(file);
    }, $Kernel_require$55.$$arity = 1);
    
    Opal.def(self, '$require_relative', $Kernel_require_relative$56 = function $$require_relative(file) {
      var self = this;

      
      $$($nesting, 'Opal')['$try_convert!'](file, $$($nesting, 'String'), "to_str");
      file = $$($nesting, 'File').$expand_path($$($nesting, 'File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    }, $Kernel_require_relative$56.$$arity = 1);
    
    Opal.def(self, '$require_tree', $Kernel_require_tree$57 = function $$require_tree(path) {
      var self = this;

      
      var result = [];

      path = $$($nesting, 'File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          result.push([name, Opal.require(name)]);
        }
      }

      return result;
    
    }, $Kernel_require_tree$57.$$arity = 1);
    Opal.alias(self, "send", "__send__");
    Opal.alias(self, "public_send", "__send__");
    
    Opal.def(self, '$singleton_class', $Kernel_singleton_class$58 = function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, $Kernel_singleton_class$58.$$arity = 0);
    
    Opal.def(self, '$sleep', $Kernel_sleep$59 = function $$sleep(seconds) {
      var self = this;

      
      
      if (seconds == null) {
        seconds = nil;
      };
      
      if (seconds === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return Math.round(seconds);
    ;
    }, $Kernel_sleep$59.$$arity = -1);
    
    Opal.def(self, '$srand', $Kernel_srand$60 = function $$srand(seed) {
      var self = this;

      
      
      if (seed == null) {
        seed = $$($nesting, 'Random').$new_seed();
      };
      return $$($nesting, 'Random').$srand(seed);
    }, $Kernel_srand$60.$$arity = -1);
    
    Opal.def(self, '$String', $Kernel_String$61 = function $$String(str) {
      var self = this, $ret_or_6 = nil;

      if ($truthy(($ret_or_6 = $$($nesting, 'Opal')['$coerce_to?'](str, $$($nesting, 'String'), "to_str")))) {
        return $ret_or_6
      } else {
        return $$($nesting, 'Opal')['$coerce_to!'](str, $$($nesting, 'String'), "to_s")
      }
    }, $Kernel_String$61.$$arity = 1);
    
    Opal.def(self, '$tap', $Kernel_tap$62 = function $$tap() {
      var $iter = $Kernel_tap$62.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_tap$62.$$p = null;
      
      
      if ($iter) $Kernel_tap$62.$$p = null;;
      Opal.yield1(block, self);
      return self;
    }, $Kernel_tap$62.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Kernel_to_proc$63 = function $$to_proc() {
      var self = this;

      return self
    }, $Kernel_to_proc$63.$$arity = 0);
    
    Opal.def(self, '$to_s', $Kernel_to_s$64 = function $$to_s() {
      var self = this;

      return "" + "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    }, $Kernel_to_s$64.$$arity = 0);
    
    Opal.def(self, '$catch', $Kernel_catch$65 = function(sym) {
      var $iter = $Kernel_catch$65.$$p, $yield = $iter || nil, self = this, e = nil;

      if ($iter) $Kernel_catch$65.$$p = null;
      try {
        return Opal.yieldX($yield, []);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'UncaughtThrowError')])) {(e = $err)
          try {
            
            if (e.$sym()['$=='](sym)) {
              return e.$arg()};
            return self.$raise();
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Kernel_catch$65.$$arity = 1);
    
    Opal.def(self, '$throw', $Kernel_throw$66 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'UncaughtThrowError'), args);
    }, $Kernel_throw$66.$$arity = -1);
    
    Opal.def(self, '$open', $Kernel_open$67 = function $$open($a) {
      var $iter = $Kernel_open$67.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_open$67.$$p = null;
      
      
      if ($iter) $Kernel_open$67.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send($$($nesting, 'File'), 'open', Opal.to_a(args), block.$to_proc());
    }, $Kernel_open$67.$$arity = -1);
    
    Opal.def(self, '$yield_self', $Kernel_yield_self$68 = function $$yield_self() {
      var $$69, $iter = $Kernel_yield_self$68.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Kernel_yield_self$68.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["yield_self"], ($$69 = function(){var self = $$69.$$s == null ? this : $$69.$$s;

        return 1}, $$69.$$s = self, $$69.$$arity = 0, $$69))
      };
      return Opal.yield1($yield, self);;
    }, $Kernel_yield_self$68.$$arity = 0);
    Opal.alias(self, "then", "yield_self");
    return $$($nesting, 'Opal').$pristine(self, "method_missing");
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting);

    return self.$include($$($nesting, 'Kernel'))
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/error"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $module = Opal.module, $send2 = Opal.send2, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new', '$clone', '$to_s', '$empty?', '$class', '$raise', '$+', '$attr_reader', '$[]', '$>', '$length', '$inspect']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $Exception_new$1, $Exception_exception$2, $Exception_initialize$3, $Exception_backtrace$4, $Exception_exception$5, $Exception_message$6, $Exception_inspect$7, $Exception_set_backtrace$8, $Exception_to_s$9;

    self.$$prototype.message = nil;
    
    var stack_trace_limit;
    Opal.defs(self, '$new', $Exception_new$1 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, $Exception_new$1.$$arity = -1);
    stack_trace_limit = self.$new;
    Opal.defs(self, '$exception', $Exception_exception$2 = function $$exception($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $Exception_exception$2.$$arity = -1);
    
    Opal.def(self, '$initialize', $Exception_initialize$3 = function $$initialize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, $Exception_initialize$3.$$arity = -1);
    
    Opal.def(self, '$backtrace', $Exception_backtrace$4 = function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (typeof(backtrace) === 'string') {
        return backtrace.split("\n").slice(0, 15);
      }
      else if (backtrace) {
        return backtrace.slice(0, 15);
      }

      return [];
    
    }, $Exception_backtrace$4.$$arity = 0);
    
    Opal.def(self, '$exception', $Exception_exception$5 = function $$exception(str) {
      var self = this;

      
      
      if (str == null) {
        str = nil;
      };
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      cloned.stack = self.stack;
      return cloned;
    ;
    }, $Exception_exception$5.$$arity = -1);
    
    Opal.def(self, '$message', $Exception_message$6 = function $$message() {
      var self = this;

      return self.$to_s()
    }, $Exception_message$6.$$arity = 0);
    
    Opal.def(self, '$inspect', $Exception_inspect$7 = function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "" + "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    }, $Exception_inspect$7.$$arity = 0);
    
    Opal.def(self, '$set_backtrace', $Exception_set_backtrace$8 = function $$set_backtrace(backtrace) {
      var self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
        self.stack = '';
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
        self.stack = backtrace;
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          self.$raise($$($nesting, 'TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
        self.stack = backtrace.join('\n');
      }

      return backtrace;
    
    }, $Exception_set_backtrace$8.$$arity = 1);
    return (Opal.def(self, '$to_s', $Exception_to_s$9 = function $$to_s() {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      if ($truthy(($ret_or_1 = (function() {if ($truthy(($ret_or_2 = self.message))) {
        return self.message.$to_s()
      } else {
        return $ret_or_2
      }; return nil; })()))) {
        return $ret_or_1
      } else {
        return self.$class().$to_s()
      }
    }, $Exception_to_s$9.$$arity = 0), nil) && 'to_s';
  })($nesting[0], Error, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ScriptError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SyntaxError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LoadError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NotImplementedError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemExit');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMemoryError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SignalException');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Interrupt');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SecurityError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StandardError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'EncodingError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ZeroDivisionError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'NameError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RuntimeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FrozenError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RuntimeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LocalJumpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'TypeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ArgumentError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IndexError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RangeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FloatDomainError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RangeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IOError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EINVAL');

      var $nesting = [self].concat($parent_nesting), $EINVAL_new$10;

      return (Opal.defs(self, '$new', $EINVAL_new$10 = function(name) {
        var $iter = $EINVAL_new$10.$$p, $yield = $iter || nil, self = this, message = nil;

        if ($iter) $EINVAL_new$10.$$p = null;
        
        
        if (name == null) {
          name = nil;
        };
        message = "Invalid argument";
        if ($truthy(name)) {
          message = $rb_plus(message, "" + " - " + (name))};
        return $send2(self, Opal.find_super_dispatcher(self, 'new', $EINVAL_new$10, false, true), 'new', [message], null);
      }, $EINVAL_new$10.$$arity = -1), nil) && 'new'
    })($nesting[0], $$($nesting, 'SystemCallError'), $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $nesting = [self].concat($parent_nesting), $UncaughtThrowError_initialize$11;

    self.$$prototype.sym = nil;
    
    self.$attr_reader("sym", "arg");
    return (Opal.def(self, '$initialize', $UncaughtThrowError_initialize$11 = function $$initialize(args) {
      var $iter = $UncaughtThrowError_initialize$11.$$p, $yield = $iter || nil, self = this;

      if ($iter) $UncaughtThrowError_initialize$11.$$p = null;
      
      self.sym = args['$[]'](0);
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.arg = args['$[]'](1)};
      return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $UncaughtThrowError_initialize$11, false, true), 'initialize', ["" + "uncaught throw " + (self.sym.$inspect())], null);
    }, $UncaughtThrowError_initialize$11.$$arity = 1), nil) && 'initialize';
  })($nesting[0], $$($nesting, 'ArgumentError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting), $NameError_initialize$12;

    
    self.$attr_reader("name");
    return (Opal.def(self, '$initialize', $NameError_initialize$12 = function $$initialize(message, name) {
      var $iter = $NameError_initialize$12.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NameError_initialize$12.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $NameError_initialize$12, false, true), 'initialize', [message], null);
      return (self.name = name);
    }, $NameError_initialize$12.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting), $NoMethodError_initialize$13;

    
    self.$attr_reader("args");
    return (Opal.def(self, '$initialize', $NoMethodError_initialize$13 = function $$initialize(message, name, args) {
      var $iter = $NoMethodError_initialize$13.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NoMethodError_initialize$13.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      
      if (args == null) {
        args = [];
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $NoMethodError_initialize$13, false, true), 'initialize', [message, name], null);
      return (self.args = args);
    }, $NoMethodError_initialize$13.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return self.$attr_reader("result")
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting), $KeyError_initialize$14, $KeyError_receiver$15, $KeyError_key$16;

    self.$$prototype.receiver = self.$$prototype.key = nil;
    
    
    Opal.def(self, '$initialize', $KeyError_initialize$14 = function $$initialize(message, $kwargs) {
      var receiver, key, $iter = $KeyError_initialize$14.$$p, $yield = $iter || nil, self = this;

      if ($iter) $KeyError_initialize$14.$$p = null;
      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      receiver = $kwargs.$$smap["receiver"];
      if (receiver == null) {
        receiver = nil
      };
      
      key = $kwargs.$$smap["key"];
      if (key == null) {
        key = nil
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $KeyError_initialize$14, false, true), 'initialize', [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, $KeyError_initialize$14.$$arity = -2);
    
    Opal.def(self, '$receiver', $KeyError_receiver$15 = function $$receiver() {
      var self = this, $ret_or_3 = nil;

      if ($truthy(($ret_or_3 = self.receiver))) {
        return $ret_or_3
      } else {
        return self.$raise($$($nesting, 'ArgumentError'), "no receiver is available")
      }
    }, $KeyError_receiver$15.$$arity = 0);
    return (Opal.def(self, '$key', $KeyError_key$16 = function $$key() {
      var self = this, $ret_or_4 = nil;

      if ($truthy(($ret_or_4 = self.key))) {
        return $ret_or_4
      } else {
        return self.$raise($$($nesting, 'ArgumentError'), "no key is available")
      }
    }, $KeyError_key$16.$$arity = 0), nil) && 'key';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Error');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/constants"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  
  Opal.const_set($nesting[0], 'RUBY_PLATFORM', "opal");
  Opal.const_set($nesting[0], 'RUBY_ENGINE', "opal");
  Opal.const_set($nesting[0], 'RUBY_VERSION', "3.0.2");
  Opal.const_set($nesting[0], 'RUBY_ENGINE_VERSION', "1.2.0");
  Opal.const_set($nesting[0], 'RUBY_RELEASE_DATE', "2021-07-28");
  Opal.const_set($nesting[0], 'RUBY_PATCHLEVEL', 0);
  Opal.const_set($nesting[0], 'RUBY_REVISION', "0");
  Opal.const_set($nesting[0], 'RUBY_COPYRIGHT', "opal - Copyright (C) 2013-2021 Adam Beynon and the Opal contributors");
  return Opal.const_set($nesting[0], 'RUBY_DESCRIPTION', "" + "opal " + ($$($nesting, 'RUBY_ENGINE_VERSION')) + " (" + ($$($nesting, 'RUBY_RELEASE_DATE')) + " revision " + ($$($nesting, 'RUBY_REVISION')) + ")");
};

/* Generated by Opal 1.2.0 */
Opal.modules["opal/base"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  
  self.$require("corelib/runtime");
  self.$require("corelib/helpers");
  self.$require("corelib/module");
  self.$require("corelib/class");
  self.$require("corelib/basic_object");
  self.$require("corelib/kernel");
  self.$require("corelib/error");
  return self.$require("corelib/constants");
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/nil"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$name', '$new', '$>', '$length', '$Rational']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_$excl$2, $NilClass_$$3, $NilClass_$$4, $NilClass_$$5, $NilClass_$eq_eq$6, $NilClass_dup$7, $NilClass_clone$8, $NilClass_inspect$9, $NilClass_nil$ques$10, $NilClass_singleton_class$11, $NilClass_to_a$12, $NilClass_to_h$13, $NilClass_to_i$14, $NilClass_to_s$15, $NilClass_to_c$16, $NilClass_rationalize$17, $NilClass_to_r$18, $NilClass_instance_variables$19;

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$!', $NilClass_$excl$2 = function() {
      var self = this;

      return true
    }, $NilClass_$excl$2.$$arity = 0);
    
    Opal.def(self, '$&', $NilClass_$$3 = function(other) {
      var self = this;

      return false
    }, $NilClass_$$3.$$arity = 1);
    
    Opal.def(self, '$|', $NilClass_$$4 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$4.$$arity = 1);
    
    Opal.def(self, '$^', $NilClass_$$5 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$5.$$arity = 1);
    
    Opal.def(self, '$==', $NilClass_$eq_eq$6 = function(other) {
      var self = this;

      return other === nil;
    }, $NilClass_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$dup', $NilClass_dup$7 = function $$dup() {
      var self = this;

      return nil
    }, $NilClass_dup$7.$$arity = 0);
    
    Opal.def(self, '$clone', $NilClass_clone$8 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return nil;
    }, $NilClass_clone$8.$$arity = -1);
    
    Opal.def(self, '$inspect', $NilClass_inspect$9 = function $$inspect() {
      var self = this;

      return "nil"
    }, $NilClass_inspect$9.$$arity = 0);
    
    Opal.def(self, '$nil?', $NilClass_nil$ques$10 = function() {
      var self = this;

      return true
    }, $NilClass_nil$ques$10.$$arity = 0);
    
    Opal.def(self, '$singleton_class', $NilClass_singleton_class$11 = function $$singleton_class() {
      var self = this;

      return $$($nesting, 'NilClass')
    }, $NilClass_singleton_class$11.$$arity = 0);
    
    Opal.def(self, '$to_a', $NilClass_to_a$12 = function $$to_a() {
      var self = this;

      return []
    }, $NilClass_to_a$12.$$arity = 0);
    
    Opal.def(self, '$to_h', $NilClass_to_h$13 = function $$to_h() {
      var self = this;

      return Opal.hash();
    }, $NilClass_to_h$13.$$arity = 0);
    
    Opal.def(self, '$to_i', $NilClass_to_i$14 = function $$to_i() {
      var self = this;

      return 0
    }, $NilClass_to_i$14.$$arity = 0);
    Opal.alias(self, "to_f", "to_i");
    
    Opal.def(self, '$to_s', $NilClass_to_s$15 = function $$to_s() {
      var self = this;

      return ""
    }, $NilClass_to_s$15.$$arity = 0);
    
    Opal.def(self, '$to_c', $NilClass_to_c$16 = function $$to_c() {
      var self = this;

      return $$($nesting, 'Complex').$new(0, 0)
    }, $NilClass_to_c$16.$$arity = 0);
    
    Opal.def(self, '$rationalize', $NilClass_rationalize$17 = function $$rationalize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.$raise($$($nesting, 'ArgumentError'))};
      return self.$Rational(0, 1);
    }, $NilClass_rationalize$17.$$arity = -1);
    
    Opal.def(self, '$to_r', $NilClass_to_r$18 = function $$to_r() {
      var self = this;

      return self.$Rational(0, 1)
    }, $NilClass_to_r$18.$$arity = 0);
    return (Opal.def(self, '$instance_variables', $NilClass_instance_variables$19 = function $$instance_variables() {
      var self = this;

      return []
    }, $NilClass_instance_variables$19.$$arity = 0), nil) && 'instance_variables';
  })($nesting[0], null, $nesting);
  return Opal.const_set($nesting[0], 'NIL', nil);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/boolean"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2;

  Opal.add_stubs(['$raise', '$name']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean___id__$2, $Boolean_$excl$3, $Boolean_$$4, $Boolean_$$5, $Boolean_$$6, $Boolean_$eq_eq$7, $Boolean_singleton_class$8, $Boolean_to_s$9, $Boolean_dup$10, $Boolean_clone$11;

    
    Opal.defineProperty(self.$$prototype, '$$is_boolean', true);
    Opal.defineProperty(self.$$prototype, '$$meta', self);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$__id__', $Boolean___id__$2 = function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    }, $Boolean___id__$2.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$!', $Boolean_$excl$3 = function() {
      var self = this;

      return self != true;
    }, $Boolean_$excl$3.$$arity = 0);
    
    Opal.def(self, '$&', $Boolean_$$4 = function(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    }, $Boolean_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Boolean_$$5 = function(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    }, $Boolean_$$5.$$arity = 1);
    
    Opal.def(self, '$^', $Boolean_$$6 = function(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    }, $Boolean_$$6.$$arity = 1);
    
    Opal.def(self, '$==', $Boolean_$eq_eq$7 = function(other) {
      var self = this;

      return (self == true) === other.valueOf();
    }, $Boolean_$eq_eq$7.$$arity = 1);
    Opal.alias(self, "equal?", "==");
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$singleton_class', $Boolean_singleton_class$8 = function $$singleton_class() {
      var self = this;

      return $$($nesting, 'Boolean')
    }, $Boolean_singleton_class$8.$$arity = 0);
    
    Opal.def(self, '$to_s', $Boolean_to_s$9 = function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, $Boolean_to_s$9.$$arity = 0);
    
    Opal.def(self, '$dup', $Boolean_dup$10 = function $$dup() {
      var self = this;

      return self
    }, $Boolean_dup$10.$$arity = 0);
    return (Opal.def(self, '$clone', $Boolean_clone$11 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Boolean_clone$11.$$arity = -1), nil) && 'clone';
  })($nesting[0], Boolean, $nesting);
  Opal.const_set($nesting[0], 'TrueClass', $$($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'FalseClass', $$($nesting, 'Boolean'));
  Opal.const_set($nesting[0], 'TRUE', true);
  return Opal.const_set($nesting[0], 'FALSE', false);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/comparable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$>', '$<', '$===', '$raise', '$class', '$<=>', '$equal?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Comparable');

    var $nesting = [self].concat($parent_nesting), $Comparable_$eq_eq$1, $Comparable_$gt$2, $Comparable_$gt_eq$3, $Comparable_$lt$4, $Comparable_$lt_eq$5, $Comparable_between$ques$6, $Comparable_clamp$7, $case = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (function() {$case = rhs;
    if (nil['$===']($case) || true['$===']($case) || false['$===']($case) || $$($nesting, 'Integer')['$===']($case) || $$($nesting, 'Float')['$===']($case)) {return class_name = rhs.$inspect();}
    else {return class_name = rhs.$$class;}})()
      self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if ($falsy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    Opal.def(self, '$==', $Comparable_$eq_eq$1 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true};
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        return false
      };
      return normalize(cmp) == 0;;
    }, $Comparable_$eq_eq$1.$$arity = 1);
    
    Opal.def(self, '$>', $Comparable_$gt$2 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    }, $Comparable_$gt$2.$$arity = 1);
    
    Opal.def(self, '$>=', $Comparable_$gt_eq$3 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    }, $Comparable_$gt_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Comparable_$lt$4 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    }, $Comparable_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Comparable_$lt_eq$5 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    }, $Comparable_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$between?', $Comparable_between$ques$6 = function(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false};
      if ($rb_gt(self, max)) {
        return false};
      return true;
    }, $Comparable_between$ques$6.$$arity = 2);
    return (Opal.def(self, '$clamp', $Comparable_clamp$7 = function $$clamp(min, max) {
      var self = this;

      
      
      if (max == null) {
        max = nil;
      };
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          self.$raise($$($nesting, 'ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        self.$raise($$($nesting, 'ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, $Comparable_clamp$7.$$arity = -2), nil) && 'clamp';
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/regexp"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send2 = Opal.send2, $truthy = Opal.truthy, $gvars = Opal.gvars, $send = Opal.send;

  Opal.add_stubs(['$nil?', '$[]', '$raise', '$escape', '$options', '$to_str', '$new', '$join', '$coerce_to!', '$!', '$match', '$coerce_to?', '$begin', '$=~', '$attr_reader', '$===', '$inspect', '$to_a']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RegexpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $Regexp_$eq_eq$6, $Regexp_$eq_eq_eq$7, $Regexp_$eq_tilde$8, $Regexp_inspect$9, $Regexp_match$10, $Regexp_match$ques$11, $Regexp_$$12, $Regexp_source$13, $Regexp_options$14, $Regexp_casefold$ques$15;

    
    Opal.const_set($nesting[0], 'IGNORECASE', 1);
    Opal.const_set($nesting[0], 'EXTENDED', 2);
    Opal.const_set($nesting[0], 'MULTILINE', 4);
    Opal.defineProperty(self.$$prototype, '$$is_regexp', true);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1, $escape$2, $last_match$3, $union$4, $new$5;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var $iter = $allocate$1.$$p, $yield = $iter || nil, self = this, allocated = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $allocate$1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        allocated = $send2(self, Opal.find_super_dispatcher(self, 'allocate', $allocate$1, false, true), 'allocate', $zuper, $iter);
        allocated.uninitialized = true;
        return allocated;
      }, $allocate$1.$$arity = 0);
      
      Opal.def(self, '$escape', $escape$2 = function $$escape(string) {
        var self = this;

        return Opal.escape_regexp(string);
      }, $escape$2.$$arity = 1);
      
      Opal.def(self, '$last_match', $last_match$3 = function $$last_match(n) {
        var self = this;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        
        if (n == null) {
          n = nil;
        };
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else {
          return $gvars["~"]['$[]'](n)
        };
      }, $last_match$3.$$arity = -1);
      Opal.alias(self, "quote", "escape");
      
      Opal.def(self, '$union', $union$4 = function $$union($a) {
        var $post_args, parts, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        parts = $post_args;;
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              self.$raise($$($nesting, 'TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, $union$4.$$arity = -1);
      
      Opal.def(self, '$new', $new$5 = function(regexp, options) {
        var self = this;

        
        ;
        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = $$($nesting, 'Opal')['$coerce_to!'](regexp, $$($nesting, 'String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          self.$raise($$($nesting, 'RegexpError'), "" + "too short escape sequence: /" + (regexp) + "/")
        }

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if ($$($nesting, 'IGNORECASE') & options) { temp += 'i'; }
          if ($$($nesting, 'MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      ;
      }, $new$5.$$arity = -2);
      return Opal.alias(self, "compile", "new");
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$==', $Regexp_$eq_eq$6 = function(other) {
      var self = this;

      return other instanceof RegExp && self.toString() === other.toString();
    }, $Regexp_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$===', $Regexp_$eq_eq_eq$7 = function(string) {
      var self = this;

      return self.$match($$($nesting, 'Opal')['$coerce_to?'](string, $$($nesting, 'String'), "to_str")) !== nil
    }, $Regexp_$eq_eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$=~', $Regexp_$eq_tilde$8 = function(string) {
      var self = this, $ret_or_1 = nil;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($truthy(($ret_or_1 = self.$match(string)))) {
        return $gvars["~"].$begin(0)
      } else {
        return $ret_or_1
      }
    }, $Regexp_$eq_tilde$8.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$inspect', $Regexp_inspect$9 = function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    }, $Regexp_inspect$9.$$arity = 0);
    
    Opal.def(self, '$match', $Regexp_match$10 = function $$match(string, pos) {
      var $iter = $Regexp_match$10.$$p, block = $iter || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($iter) $Regexp_match$10.$$p = null;
      
      
      if ($iter) $Regexp_match$10.$$p = null;;
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($coerce_to(string, $$($nesting, 'String'), 'to_str'));
        if (m) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $coerce_to(pos, $$($nesting, 'Integer'), 'to_int');

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $coerce_to(string, $$($nesting, 'String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, $Regexp_match$10.$$arity = -2);
    
    Opal.def(self, '$match?', $Regexp_match$ques$11 = function(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($coerce_to(string, $$($nesting, 'String'), 'to_str'));
      }

      pos = $coerce_to(pos, $$($nesting, 'Integer'), 'to_int');

      if (string === nil) {
        return false;
      }

      string = $coerce_to(string, $$($nesting, 'String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, $Regexp_match$ques$11.$$arity = -2);
    
    Opal.def(self, '$~', $Regexp_$$12 = function() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    }, $Regexp_$$12.$$arity = 0);
    
    Opal.def(self, '$source', $Regexp_source$13 = function $$source() {
      var self = this;

      return self.source;
    }, $Regexp_source$13.$$arity = 0);
    
    Opal.def(self, '$options', $Regexp_options$14 = function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= $$($nesting, 'MULTILINE');
      }
      if (self.ignoreCase) {
        result |= $$($nesting, 'IGNORECASE');
      }
      return result;
    
    }, $Regexp_options$14.$$arity = 0);
    
    Opal.def(self, '$casefold?', $Regexp_casefold$ques$15 = function() {
      var self = this;

      return self.ignoreCase;
    }, $Regexp_casefold$ques$15.$$arity = 0);
    return Opal.alias(self, "to_s", "source");
  })($nesting[0], RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $MatchData_initialize$16, $MatchData_$$$17, $MatchData_offset$18, $MatchData_$eq_eq$19, $MatchData_begin$20, $MatchData_end$21, $MatchData_captures$22, $MatchData_inspect$23, $MatchData_length$24, $MatchData_to_a$25, $MatchData_to_s$26, $MatchData_values_at$27;

    self.$$prototype.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    Opal.def(self, '$initialize', $MatchData_initialize$16 = function $$initialize(regexp, match_groups) {
      var self = this;

      
      $gvars["~"] = self;
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, $MatchData_initialize$16.$$arity = 2);
    
    Opal.def(self, '$[]', $MatchData_$$$17 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self.matches, '[]', Opal.to_a(args));
    }, $MatchData_$$$17.$$arity = -1);
    
    Opal.def(self, '$offset', $MatchData_offset$18 = function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    }, $MatchData_offset$18.$$arity = 1);
    
    Opal.def(self, '$==', $MatchData_$eq_eq$19 = function(other) {
      var self = this, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil;

      
      if ($truthy($$($nesting, 'MatchData')['$==='](other))) {
      } else {
        return false
      };
      if ($truthy(($ret_or_2 = (function() {if ($truthy(($ret_or_3 = (function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = self.string == other.string))) {
        return self.regexp.toString() == other.regexp.toString();
      } else {
        return $ret_or_5
      }; return nil; })()))) {
        return self.pre_match == other.pre_match;
      } else {
        return $ret_or_4
      }; return nil; })()))) {
        return self.post_match == other.post_match;
      } else {
        return $ret_or_3
      }; return nil; })()))) {
        return self.begin == other.begin;
      } else {
        return $ret_or_2
      };
    }, $MatchData_$eq_eq$19.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$begin', $MatchData_begin$20 = function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    }, $MatchData_begin$20.$$arity = 1);
    
    Opal.def(self, '$end', $MatchData_end$21 = function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    }, $MatchData_end$21.$$arity = 1);
    
    Opal.def(self, '$captures', $MatchData_captures$22 = function $$captures() {
      var self = this;

      return self.matches.slice(1)
    }, $MatchData_captures$22.$$arity = 0);
    
    Opal.def(self, '$inspect', $MatchData_inspect$23 = function $$inspect() {
      var self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      for (var i = 1, length = self.matches.length; i < length; i++) {
        str += " " + i + ":" + (self.matches[i]).$inspect();
      }

      return str + ">";
    
    }, $MatchData_inspect$23.$$arity = 0);
    
    Opal.def(self, '$length', $MatchData_length$24 = function $$length() {
      var self = this;

      return self.matches.length
    }, $MatchData_length$24.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $MatchData_to_a$25 = function $$to_a() {
      var self = this;

      return self.matches
    }, $MatchData_to_a$25.$$arity = 0);
    
    Opal.def(self, '$to_s', $MatchData_to_s$26 = function $$to_s() {
      var self = this;

      return self.matches[0]
    }, $MatchData_to_s$26.$$arity = 0);
    return (Opal.def(self, '$values_at', $MatchData_values_at$27 = function $$values_at($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $$($nesting, 'Opal')['$coerce_to!'](args[i], $$($nesting, 'Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, $MatchData_values_at$27.$$arity = -1), nil) && 'values_at';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/string"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$initialize', '$===', '$format', '$raise', '$respond_to?', '$to_s', '$to_str', '$<=>', '$==', '$=~', '$new', '$force_encoding', '$casecmp', '$empty?', '$ljust', '$ceil', '$/', '$+', '$rjust', '$floor', '$coerce_to!', '$copy_singleton_methods', '$initialize_clone', '$initialize_dup', '$enum_for', '$chomp', '$[]', '$to_i', '$each_line', '$to_proc', '$to_a', '$class', '$match', '$match?', '$captures', '$proc', '$succ', '$escape', '$include?', '$upcase', '$unicode_normalize', '$pristine']);
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String___id__$1, $String_try_convert$2, $String_new$3, $String_initialize$4, $String_$percent$5, $String_$$6, $String_$plus$7, $String_$lt_eq_gt$8, $String_$eq_eq$9, $String_$eq_tilde$10, $String_$$$11, $String_b$12, $String_capitalize$13, $String_casecmp$14, $String_casecmp$ques$15, $String_center$16, $String_chomp$17, $String_chop$18, $String_chr$19, $String_clone$20, $String_dup$21, $String_count$22, $String_delete$23, $String_delete_prefix$24, $String_delete_suffix$25, $String_downcase$26, $String_each_line$27, $String_empty$ques$28, $String_end_with$ques$29, $String_gsub$30, $String_hash$31, $String_hex$32, $String_include$ques$33, $String_index$34, $String_inspect$35, $String_intern$36, $String_lines$37, $String_ljust$38, $String_lstrip$39, $String_ascii_only$ques$40, $String_match$41, $String_match$ques$42, $String_next$43, $String_oct$44, $String_ord$45, $String_partition$46, $String_reverse$47, $String_rindex$48, $String_rjust$49, $String_rpartition$50, $String_rstrip$51, $String_scan$52, $String_split$53, $String_squeeze$54, $String_start_with$ques$55, $String_strip$56, $String_sub$57, $String_sum$58, $String_swapcase$59, $String_to_f$60, $String_to_i$61, $String_to_proc$62, $String_to_s$64, $String_tr$65, $String_tr_s$66, $String_upcase$67, $String_upto$68, $String_instance_variables$69, $String__load$70, $String_unicode_normalize$71, $String_unicode_normalized$ques$72, $String_unpack$73, $String_unpack1$74, $String_freeze$75, $String_$minus$$76, $String_frozen$ques$77;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.defineProperty(self.$$prototype, '$$is_string', true);

    Opal.defineProperty(self.$$prototype, '$$cast', function(string) {
      var klass = this.$$class;
      if (klass.$$constructor === String) {
        return string;
      } else {
        return new klass.$$constructor(string);
      }
    });
  ;
    
    Opal.def(self, '$__id__', $String___id__$1 = function $$__id__() {
      var self = this;

      return self.toString();
    }, $String___id__$1.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    Opal.defs(self, '$try_convert', $String_try_convert$2 = function $$try_convert(what) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](what, $$($nesting, 'String'), "to_str")
    }, $String_try_convert$2.$$arity = 1);
    Opal.defs(self, '$new', $String_new$3 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var str = args[0] || "";
      var opts = args[args.length-1];
      str = $coerce_to(str, $$($nesting, 'String'), 'to_str');
      if (opts && opts.$$is_hash) {
        if (opts.$$smap.encoding) str = str.$force_encoding(opts.$$smap.encoding);
      }
      str = new self.$$constructor(str);
      if (!str.$initialize.$$pristine) $send((str), 'initialize', Opal.to_a(args));
      return str;
    ;
    }, $String_new$3.$$arity = -1);
    
    Opal.def(self, '$initialize', $String_initialize$4 = function $$initialize($a, $b) {
      var $post_args, $kwargs, str, encoding, capacity, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) {
        str = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      encoding = $kwargs.$$smap["encoding"];
      if (encoding == null) {
        encoding = nil
      };
      
      capacity = $kwargs.$$smap["capacity"];
      if (capacity == null) {
        capacity = nil
      };
      return nil;
    }, $String_initialize$4.$$arity = -1);
    
    Opal.def(self, '$%', $String_$percent$5 = function(data) {
      var self = this;

      if ($truthy($$($nesting, 'Array')['$==='](data))) {
        return $send(self, 'format', [self].concat(Opal.to_a(data)))
      } else {
        return self.$format(self, data)
      }
    }, $String_$percent$5.$$arity = 1);
    
    Opal.def(self, '$*', $String_$$6 = function(count) {
      var self = this;

      
      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return self.$$cast('');
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        self.$raise($$($nesting, 'RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return self.$$cast(result);
    
    }, $String_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $String_$plus$7 = function(other) {
      var self = this;

      
      other = $coerce_to(other, $$($nesting, 'String'), 'to_str');
      
      if (other == "" && self.$$class === Opal.String) return self;
      if (self == "" && other.$$class === Opal.String) return other;
      var out = self + other;
      if (self.encoding === out.encoding && other.encoding === out.encoding) return out;
      if (self.encoding.name === "UTF-8" || other.encoding.name === "UTF-8") return out;
      return Opal.enc(out, self.encoding);
    ;
    }, $String_$plus$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $String_$lt_eq_gt$8 = function(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    }, $String_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$==', $String_$eq_eq$9 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($respond_to(other, '$to_str')) {
        return other['$=='](self);
      }
      return false;
    
    }, $String_$eq_eq$9.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    Opal.alias(self, "===", "==");
    
    Opal.def(self, '$=~', $String_$eq_tilde$10 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        self.$raise($$($nesting, 'TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    }, $String_$eq_tilde$10.$$arity = 1);
    
    Opal.def(self, '$[]', $String_$$$11 = function(index, length) {
      var self = this;

      
      ;
      
      var size = self.length, exclude;

      if (index.$$is_range) {
        exclude = index.excl;
        length  = $coerce_to(index.end, $$($nesting, 'Integer'), 'to_int');
        index   = $coerce_to(index.begin, $$($nesting, 'Integer'), 'to_int');

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.$$cast(self.substr(index, length));
      }


      if (index.$$is_string) {
        if (length != null) {
          self.$raise($$($nesting, 'TypeError'))
        }
        return self.indexOf(index) !== -1 ? self.$$cast(index) : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = $$($nesting, 'MatchData').$new(index, match))

        if (length == null) {
          return self.$$cast(match[0]);
        }

        length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');

        if (length < 0 && -length < match.length) {
          return self.$$cast(match[length += match.length]);
        }

        if (length >= 0 && length < match.length) {
          return self.$$cast(match[length]);
        }

        return nil;
      }


      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.$$cast(self.substr(index, 1));
      }

      length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.$$cast(self.substr(index, length));
    ;
    }, $String_$$$11.$$arity = -2);
    Opal.alias(self, "byteslice", "[]");
    
    Opal.def(self, '$b', $String_b$12 = function $$b() {
      var self = this;

      return (new String(self)).$force_encoding("binary")
    }, $String_b$12.$$arity = 0);
    
    Opal.def(self, '$capitalize', $String_capitalize$13 = function $$capitalize() {
      var self = this;

      return self.$$cast(self.charAt(0).toUpperCase() + self.substr(1).toLowerCase());
    }, $String_capitalize$13.$$arity = 0);
    
    Opal.def(self, '$casecmp', $String_casecmp$14 = function $$casecmp(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
      } else {
        return nil
      };
      other = ($coerce_to(other, $$($nesting, 'String'), 'to_str')).$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    }, $String_casecmp$14.$$arity = 1);
    
    Opal.def(self, '$casecmp?', $String_casecmp$ques$15 = function(other) {
      var self = this;

      
      var cmp = self.$casecmp(other);
      if (cmp === nil) {
        return nil;
      } else {
        return cmp === 0;
      }
    
    }, $String_casecmp$ques$15.$$arity = 1);
    
    Opal.def(self, '$center', $String_center$16 = function $$center(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$($nesting, 'String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return self.$$cast(rjustified + ljustified.slice(self.length));
    ;
    }, $String_center$16.$$arity = -2);
    
    Opal.def(self, '$chomp', $String_chomp$17 = function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ($truthy(separator === nil || self.length === 0)) {
        return self};
      separator = $$($nesting, 'Opal')['$coerce_to!'](separator, $$($nesting, 'String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          result = self.substr(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return self.$$cast(result);
      }
    ;
      return self;
    }, $String_chomp$17.$$arity = -1);
    
    Opal.def(self, '$chop', $String_chop$18 = function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substr(0, length - 2);
      } else {
        result = self.substr(0, length - 1);
      }

      return self.$$cast(result);
    
    }, $String_chop$18.$$arity = 0);
    
    Opal.def(self, '$chr', $String_chr$19 = function $$chr() {
      var self = this;

      return self.charAt(0);
    }, $String_chr$19.$$arity = 0);
    
    Opal.def(self, '$clone', $String_clone$20 = function $$clone() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $String_clone$20.$$arity = 0);
    
    Opal.def(self, '$dup', $String_dup$21 = function $$dup() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$initialize_dup(self);
      return copy;
    }, $String_dup$21.$$arity = 0);
    
    Opal.def(self, '$count', $String_count$22 = function $$count($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    ;
    }, $String_count$22.$$arity = -1);
    
    Opal.def(self, '$delete', $String_delete$23 = function($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp(char_class, 'g'), ''));
    ;
    }, $String_delete$23.$$arity = -1);
    
    Opal.def(self, '$delete_prefix', $String_delete_prefix$24 = function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        prefix = $coerce_to(prefix, $$($nesting, 'String'), 'to_str');
      }

      if (self.slice(0, prefix.length) === prefix) {
        return self.$$cast(self.slice(prefix.length));
      } else {
        return self;
      }
    
    }, $String_delete_prefix$24.$$arity = 1);
    
    Opal.def(self, '$delete_suffix', $String_delete_suffix$25 = function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        suffix = $coerce_to(suffix, $$($nesting, 'String'), 'to_str');
      }

      if (self.slice(self.length - suffix.length) === suffix) {
        return self.$$cast(self.slice(0, self.length - suffix.length));
      } else {
        return self;
      }
    
    }, $String_delete_suffix$25.$$arity = 1);
    
    Opal.def(self, '$downcase', $String_downcase$26 = function $$downcase() {
      var self = this;

      return self.$$cast(self.toLowerCase());
    }, $String_downcase$26.$$arity = 0);
    
    Opal.def(self, '$each_line', $String_each_line$27 = function $$each_line(separator) {
      var $iter = $String_each_line$27.$$p, block = $iter || nil, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_each_line$27.$$p = null;
      
      
      if ($iter) $String_each_line$27.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_line", separator)
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $coerce_to(separator, $$($nesting, 'String'), 'to_str')

      var a, i, n, length, chomped, trailing, splitted;

      if (separator.length === 0) {
        for (a = self.split(/(\n{2,})/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            var value = (a[i] || "") + (a[i + 1] || "");
            Opal.yield1(block, self.$$cast(value));
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        if (i < length - 1 || trailing) {
          Opal.yield1(block, self.$$cast(splitted[i] + separator));
        }
        else {
          Opal.yield1(block, self.$$cast(splitted[i]));
        }
      }
    ;
      return self;
    }, $String_each_line$27.$$arity = -1);
    
    Opal.def(self, '$empty?', $String_empty$ques$28 = function() {
      var self = this;

      return self.length === 0;
    }, $String_empty$ques$28.$$arity = 0);
    
    Opal.def(self, '$end_with?', $String_end_with$ques$29 = function($a) {
      var $post_args, suffixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      suffixes = $post_args;;
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = $coerce_to(suffixes[i], $$($nesting, 'String'), 'to_str').$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, $String_end_with$ques$29.$$arity = -1);
    Opal.alias(self, "equal?", "===");
    
    Opal.def(self, '$gsub', $String_gsub$30 = function $$gsub(pattern, replacement) {
      var $iter = $String_gsub$30.$$p, block = $iter || nil, self = this;

      if ($iter) $String_gsub$30.$$p = null;
      
      
      if ($iter) $String_gsub$30.$$p = null;;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$($nesting, 'MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $coerce_to(replacement, $$($nesting, 'String'), 'to_str');
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (self.slice(index, match.index) + _replacement + (self[match.index] || ""));
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return self.$$cast(result);
    ;
    }, $String_gsub$30.$$arity = -2);
    
    Opal.def(self, '$hash', $String_hash$31 = function $$hash() {
      var self = this;

      return self.toString();
    }, $String_hash$31.$$arity = 0);
    
    Opal.def(self, '$hex', $String_hex$32 = function $$hex() {
      var self = this;

      return self.$to_i(16)
    }, $String_hex$32.$$arity = 0);
    
    Opal.def(self, '$include?', $String_include$ques$33 = function(other) {
      var self = this;

      
      if (!other.$$is_string) {
        other = $coerce_to(other, $$($nesting, 'String'), 'to_str');
      }
      return self.indexOf(other) !== -1;
    
    }, $String_include$ques$33.$$arity = 1);
    
    Opal.def(self, '$index', $String_index$34 = function $$index(search, offset) {
      var self = this;

      
      ;
      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = $coerce_to(offset, $$($nesting, 'Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = Opal.global_multiline_regexp(search);
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$($nesting, 'MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $coerce_to(search, $$($nesting, 'String'), 'to_str');
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, $String_index$34.$$arity = -2);
    
    Opal.def(self, '$inspect', $String_inspect$35 = function $$inspect() {
      var self = this;

      
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            if (meta[chr]) return meta[chr];
            chr = chr.charCodeAt(0);
            if (chr <= 0xff && (self.encoding["$binary?"]() || self.internal_encoding["$binary?"]())) {
              return '\\x' + ('00' + chr.toString(16).toUpperCase()).slice(-2);
            } else {
              return '\\u' + ('0000' + chr.toString(16).toUpperCase()).slice(-4);
            }
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
    
    }, $String_inspect$35.$$arity = 0);
    
    Opal.def(self, '$intern', $String_intern$36 = function $$intern() {
      var self = this;

      return self.toString();
    }, $String_intern$36.$$arity = 0);
    
    Opal.def(self, '$lines', $String_lines$37 = function $$lines(separator) {
      var $iter = $String_lines$37.$$p, block = $iter || nil, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_lines$37.$$p = null;
      
      
      if ($iter) $String_lines$37.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      e = $send(self, 'each_line', [separator], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, $String_lines$37.$$arity = -1);
    
    Opal.def(self, '$ljust', $String_ljust$38 = function $$ljust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$($nesting, 'String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self.$$cast(self + result.slice(0, width));
    ;
    }, $String_ljust$38.$$arity = -2);
    
    Opal.def(self, '$lstrip', $String_lstrip$39 = function $$lstrip() {
      var self = this;

      return self.replace(/^\s*/, '');
    }, $String_lstrip$39.$$arity = 0);
    
    Opal.def(self, '$ascii_only?', $String_ascii_only$ques$40 = function() {
      var self = this;

      
      if (!self.encoding.ascii) return false;
      return /^[\x00-\x7F]*$/.test(self);
    
    }, $String_ascii_only$ques$40.$$arity = 0);
    
    Opal.def(self, '$match', $String_match$41 = function $$match(pattern, pos) {
      var $iter = $String_match$41.$$p, block = $iter || nil, self = this, $ret_or_1 = nil;

      if ($iter) $String_match$41.$$p = null;
      
      
      if ($iter) $String_match$41.$$p = null;;
      ;
      if ($truthy((function() {if ($truthy(($ret_or_1 = $$($nesting, 'String')['$==='](pattern)))) {
        return $ret_or_1
      } else {
        return pattern['$respond_to?']("to_str")
      }; return nil; })())) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, $String_match$41.$$arity = -2);
    
    Opal.def(self, '$match?', $String_match$ques$42 = function(pattern, pos) {
      var self = this, $ret_or_2 = nil;

      
      ;
      if ($truthy((function() {if ($truthy(($ret_or_2 = $$($nesting, 'String')['$==='](pattern)))) {
        return $ret_or_2
      } else {
        return pattern['$respond_to?']("to_str")
      }; return nil; })())) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, $String_match$ques$42.$$arity = -2);
    
    Opal.def(self, '$next', $String_next$43 = function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return self.$$cast('');
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return self.$$cast(result);
    
    }, $String_next$43.$$arity = 0);
    
    Opal.def(self, '$oct', $String_oct$44 = function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    }, $String_oct$44.$$arity = 0);
    
    Opal.def(self, '$ord', $String_ord$45 = function $$ord() {
      var self = this;

      
      if (typeof self.codePointAt === "function") {
        return self.codePointAt(0);
      }
      else {
        return self.charCodeAt(0);
      }
    
    }, $String_ord$45.$$arity = 0);
    
    Opal.def(self, '$partition', $String_partition$46 = function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $coerce_to(sep, $$($nesting, 'String'), 'to_str');
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_partition$46.$$arity = 1);
    
    Opal.def(self, '$reverse', $String_reverse$47 = function $$reverse() {
      var self = this;

      return self.split('').reverse().join('');
    }, $String_reverse$47.$$arity = 0);
    
    Opal.def(self, '$rindex', $String_rindex$48 = function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = $coerce_to(offset, $$($nesting, 'Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = $coerce_to(search, $$($nesting, 'String'), 'to_str');
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    ;
    }, $String_rindex$48.$$arity = -2);
    
    Opal.def(self, '$rjust', $String_rjust$49 = function $$rjust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$($nesting, 'String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return self.$$cast(result + padstr.slice(0, remaining) + self);
    ;
    }, $String_rjust$49.$$arity = -2);
    
    Opal.def(self, '$rpartition', $String_rpartition$50 = function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $coerce_to(sep, $$($nesting, 'String'), 'to_str');
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_rpartition$50.$$arity = 1);
    
    Opal.def(self, '$rstrip', $String_rstrip$51 = function $$rstrip() {
      var self = this;

      return self.replace(/[\s\u0000]*$/, '');
    }, $String_rstrip$51.$$arity = 0);
    
    Opal.def(self, '$scan', $String_scan$52 = function $$scan(pattern) {
      var $iter = $String_scan$52.$$p, block = $iter || nil, self = this;

      if ($iter) $String_scan$52.$$p = null;
      
      
      if ($iter) $String_scan$52.$$p = null;;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$($nesting, 'MatchData').$new(pattern, match);
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? block(match[0]) : block.call(self, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      ($gvars["~"] = match_data)

      return (block !== nil ? self : result);
    ;
    }, $String_scan$52.$$arity = 1);
    Opal.alias(self, "slice", "[]");
    
    Opal.def(self, '$split', $String_split$53 = function $$split(pattern, limit) {
      var self = this, $ret_or_3 = nil;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      ;
      ;
      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = (function() {if ($truthy(($ret_or_3 = $gvars[";"]))) {
        return $ret_or_3
      } else {
        return " "
      }; return nil; })();
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i, ii;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str').$to_s();
        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return [self.$$cast(result[0])];
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      function castResult() {
        for (i = 0; i < result.length; i++) {
          result[i] = self.$$cast(result[i]);
        }
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.length -= 1;
        }
        castResult();
        return result;
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, ii = match.length; i < ii; i++) {
            result.push('');
          }
        }
        castResult();
        return result;
      }

      if (match !== null && match[0] === '') {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
        castResult();
        return result;
      }

      if (limit >= result.length) {
        castResult();
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(limit - 1, result.length - 1, string.slice(index));
      castResult();
      return result;
    ;
    }, $String_split$53.$$arity = -1);
    
    Opal.def(self, '$squeeze', $String_squeeze$54 = function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        return self.$$cast(self.replace(/(.)\1+/g, '$1'));
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1'));
    ;
    }, $String_squeeze$54.$$arity = -1);
    
    Opal.def(self, '$start_with?', $String_start_with$ques$55 = function($a) {
      var $post_args, prefixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      prefixes = $post_args;;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        if (prefixes[i].$$is_regexp) {
          var regexp = prefixes[i];
          var match = regexp.exec(self);

          if (match != null && match.index === 0) {
            ($gvars["~"] = $$($nesting, 'MatchData').$new(regexp, match));
            return true;
          } else {
            ($gvars["~"] = nil)
          }
        } else {
          var prefix = $coerce_to(prefixes[i], $$($nesting, 'String'), 'to_str').$to_s();

          if (self.indexOf(prefix) === 0) {
            return true;
          }
        }
      }

      return false;
    ;
    }, $String_start_with$ques$55.$$arity = -1);
    
    Opal.def(self, '$strip', $String_strip$56 = function $$strip() {
      var self = this;

      return self.replace(/^\s*/, '').replace(/[\s\u0000]*$/, '');
    }, $String_strip$56.$$arity = 0);
    
    Opal.def(self, '$sub', $String_sub$57 = function $$sub(pattern, replacement) {
      var $iter = $String_sub$57.$$p, block = $iter || nil, self = this;

      if ($iter) $String_sub$57.$$p = null;
      
      
      if ($iter) $String_sub$57.$$p = null;;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$($nesting, 'MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $coerce_to(replacement, $$($nesting, 'String'), 'to_str');

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return self.$$cast(result);
    ;
    }, $String_sub$57.$$arity = -2);
    Opal.alias(self, "succ", "next");
    
    Opal.def(self, '$sum', $String_sum$58 = function $$sum(n) {
      var self = this;

      
      
      if (n == null) {
        n = 16;
      };
      
      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, $String_sum$58.$$arity = -1);
    
    Opal.def(self, '$swapcase', $String_swapcase$59 = function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      if (self.constructor === String) {
        return str;
      }

      return self.$class().$new(str);
    
    }, $String_swapcase$59.$$arity = 0);
    
    Opal.def(self, '$to_f', $String_to_f$60 = function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    }, $String_to_f$60.$$arity = 0);
    
    Opal.def(self, '$to_i', $String_to_i$61 = function $$to_i(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      
      var result,
          string = self.toLowerCase(),
          radix = $coerce_to(base, $$($nesting, 'Integer'), 'to_int');

      if (radix === 1 || radix < 0 || radix > 36) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, $String_to_i$61.$$arity = -1);
    
    Opal.def(self, '$to_proc', $String_to_proc$62 = function $$to_proc() {
      var $$63, $iter = $String_to_proc$62.$$p, $yield = $iter || nil, self = this, method_name = nil;

      if ($iter) $String_to_proc$62.$$p = null;
      
      method_name = $rb_plus("$", self.valueOf());
      return $send(self, 'proc', [], ($$63 = function($a){var self = $$63.$$s == null ? this : $$63.$$s, $iter = $$63.$$p, block = $iter || nil, $post_args, args;

      
        
        if ($iter) $$63.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        
        if (args.length === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv[method_name];

        if (!body) {
          return recv.$method_missing.apply(recv, args);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 1) {
          return body.call(recv);
        } else {
          return body.apply(recv, args.slice(1));
        }
      ;}, $$63.$$s = self, $$63.$$arity = -1, $$63));
    }, $String_to_proc$62.$$arity = 0);
    
    Opal.def(self, '$to_s', $String_to_s$64 = function $$to_s() {
      var self = this;

      return self.toString();
    }, $String_to_s$64.$$arity = 0);
    Opal.alias(self, "to_str", "to_s");
    Opal.alias(self, "to_sym", "intern");
    
    Opal.def(self, '$tr', $String_tr$65 = function $$tr(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$($nesting, 'String'), 'to_str').$to_s();
      to = $coerce_to(to, $$($nesting, 'String'), 'to_str').$to_s();

      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return self.$$cast(new_str);
    
    }, $String_tr$65.$$arity = 2);
    
    Opal.def(self, '$tr_s', $String_tr_s$66 = function $$tr_s(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$($nesting, 'String'), 'to_str').$to_s();
      to = $coerce_to(to, $$($nesting, 'String'), 'to_str').$to_s();

      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return self.$$cast(new_str);
    
    }, $String_tr_s$66.$$arity = 2);
    
    Opal.def(self, '$upcase', $String_upcase$67 = function $$upcase() {
      var self = this;

      return self.$$cast(self.toUpperCase());
    }, $String_upcase$67.$$arity = 0);
    
    Opal.def(self, '$upto', $String_upto$68 = function $$upto(stop, excl) {
      var $iter = $String_upto$68.$$p, block = $iter || nil, self = this;

      if ($iter) $String_upto$68.$$p = null;
      
      
      if ($iter) $String_upto$68.$$p = null;;
      
      if (excl == null) {
        excl = false;
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("upto", stop, excl)
      };
      
      var a, b, s = self.toString();

      stop = $coerce_to(stop, $$($nesting, 'String'), 'to_str');

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, $String_upto$68.$$arity = -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = $coerce_to(sets[i], $$($nesting, 'String'), 'to_str');
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + $$($nesting, 'Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$($nesting, 'Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    Opal.def(self, '$instance_variables', $String_instance_variables$69 = function $$instance_variables() {
      var self = this;

      return []
    }, $String_instance_variables$69.$$arity = 0);
    Opal.defs(self, '$_load', $String__load$70 = function $$_load($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $String__load$70.$$arity = -1);
    
    Opal.def(self, '$unicode_normalize', $String_unicode_normalize$71 = function $$unicode_normalize(form) {
      var self = this;

      
      
      if (form == null) {
        form = "nfc";
      };
      if ($truthy(["nfc", "nfd", "nfkc", "nfkd"]['$include?'](form))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "Invalid normalization form " + (form))
      };
      return self.normalize(form.$upcase());
    }, $String_unicode_normalize$71.$$arity = -1);
    
    Opal.def(self, '$unicode_normalized?', $String_unicode_normalized$ques$72 = function(form) {
      var self = this;

      
      
      if (form == null) {
        form = "nfc";
      };
      return self.$unicode_normalize(form)['$=='](self);
    }, $String_unicode_normalized$ques$72.$$arity = -1);
    
    Opal.def(self, '$unpack', $String_unpack$73 = function $$unpack(format) {
      var self = this;

      return self.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    }, $String_unpack$73.$$arity = 1);
    
    Opal.def(self, '$unpack1', $String_unpack1$74 = function $$unpack1(format) {
      var self = this;

      return self.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    }, $String_unpack1$74.$$arity = 1);
    
    Opal.def(self, '$freeze', $String_freeze$75 = function $$freeze() {
      var self = this;

      
      if (typeof self === 'string') return self;
      self.$$frozen = true;
      return self;
    
    }, $String_freeze$75.$$arity = 0);
    Opal.alias(self, "+@", "dup");
    
    Opal.def(self, '$-@', $String_$minus$$76 = function() {
      var self = this;

      
      if (typeof self === 'string') return self;
      if (self.$$frozen === true) return self;
      if (self.encoding.name == 'UTF-8' && self.internal_encoding.name == 'UTF-8') return self.toString();
      return self.$dup().$freeze();
    
    }, $String_$minus$$76.$$arity = 0);
    
    Opal.def(self, '$frozen?', $String_frozen$ques$77 = function() {
      var self = this;

      return typeof self === 'string' || self.$$frozen === true;
    }, $String_frozen$ques$77.$$arity = 0);
    return $$($nesting, 'Opal').$pristine(self, "initialize");
  })($nesting[0], String, $nesting);
  return Opal.const_set($nesting[0], 'Symbol', $$($nesting, 'String'));
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/enumerable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $module = Opal.module, $send = Opal.send, $hash2 = Opal.hash2, $lambda = Opal.lambda;

  Opal.add_stubs(['$each', '$public_send', '$destructure', '$to_enum', '$enumerator_size', '$new', '$yield', '$raise', '$slice_when', '$!', '$enum_for', '$flatten', '$map', '$warn', '$proc', '$==', '$nil?', '$respond_to?', '$coerce_to!', '$>', '$*', '$try_convert', '$<', '$+', '$-', '$ceil', '$/', '$size', '$select', '$to_proc', '$__send__', '$length', '$<=', '$[]', '$push', '$<<', '$[]=', '$===', '$inspect', '$<=>', '$first', '$reverse', '$sort', '$take', '$sort_by', '$compare', '$call', '$dup', '$to_a', '$sort!', '$map!', '$key?', '$values', '$transform_values', '$group_by', '$to_h', '$coerce_to?', '$class', '$zip']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $Enumerable_all$ques$1, $Enumerable_any$ques$5, $Enumerable_chunk$9, $Enumerable_chunk_while$12, $Enumerable_collect$14, $Enumerable_collect_concat$16, $Enumerable_count$19, $Enumerable_cycle$23, $Enumerable_detect$25, $Enumerable_drop$27, $Enumerable_drop_while$28, $Enumerable_each_cons$29, $Enumerable_each_entry$31, $Enumerable_each_slice$33, $Enumerable_each_with_index$35, $Enumerable_each_with_object$37, $Enumerable_entries$39, $Enumerable_filter_map$40, $Enumerable_find_all$42, $Enumerable_find_index$44, $Enumerable_first$47, $Enumerable_grep$50, $Enumerable_grep_v$52, $Enumerable_group_by$54, $Enumerable_include$ques$56, $Enumerable_inject$58, $Enumerable_lazy$59, $Enumerable_enumerator_size$61, $Enumerable_max$62, $Enumerable_max_by$63, $Enumerable_min$65, $Enumerable_min_by$67, $Enumerable_minmax$69, $Enumerable_minmax_by$71, $Enumerable_none$ques$73, $Enumerable_one$ques$77, $Enumerable_partition$81, $Enumerable_reject$83, $Enumerable_reverse_each$85, $Enumerable_slice_before$87, $Enumerable_slice_after$89, $Enumerable_slice_when$92, $Enumerable_sort$94, $Enumerable_sort_by$96, $Enumerable_sum$101, $Enumerable_take$103, $Enumerable_take_while$104, $Enumerable_uniq$106, $Enumerable_tally$108, $Enumerable_to_h$109, $Enumerable_zip$110;

    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    Opal.def(self, '$all?', $Enumerable_all$ques$1 = function(pattern) {try {

      var $iter = $Enumerable_all$ques$1.$$p, block = $iter || nil, $$2, $$3, $$4, self = this;

      if ($iter) $Enumerable_all$ques$1.$$p = null;
      
      
      if ($iter) $Enumerable_all$ques$1.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$2 = function($a){var self = $$2.$$s == null ? this : $$2.$$s, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$2.$$s = self, $$2.$$arity = -1, $$2))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$3 = function($a){var self = $$3.$$s == null ? this : $$3.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$3.$$s = self, $$3.$$arity = -1, $$3))
      } else {
        $send(self, 'each', [], ($$4 = function($a){var self = $$4.$$s == null ? this : $$4.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$4.$$s = self, $$4.$$arity = -1, $$4))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_all$ques$1.$$arity = -1);
    
    Opal.def(self, '$any?', $Enumerable_any$ques$5 = function(pattern) {try {

      var $iter = $Enumerable_any$ques$5.$$p, block = $iter || nil, $$6, $$7, $$8, self = this;

      if ($iter) $Enumerable_any$ques$5.$$p = null;
      
      
      if ($iter) $Enumerable_any$ques$5.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$6 = function($a){var self = $$6.$$s == null ? this : $$6.$$s, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$6.$$s = self, $$6.$$arity = -1, $$6))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$7 = function($a){var self = $$7.$$s == null ? this : $$7.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$7.$$s = self, $$7.$$arity = -1, $$7))
      } else {
        $send(self, 'each', [], ($$8 = function($a){var self = $$8.$$s == null ? this : $$8.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$8.$$s = self, $$8.$$arity = -1, $$8))
      };
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_any$ques$5.$$arity = -1);
    
    Opal.def(self, '$chunk', $Enumerable_chunk$9 = function $$chunk() {
      var $iter = $Enumerable_chunk$9.$$p, block = $iter || nil, $$10, $$11, self = this;

      if ($iter) $Enumerable_chunk$9.$$p = null;
      
      
      if ($iter) $Enumerable_chunk$9.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["chunk"], ($$10 = function(){var self = $$10.$$s == null ? this : $$10.$$s;

        return self.$enumerator_size()}, $$10.$$s = self, $$10.$$arity = 0, $$10))
      };
      return $send($$$('::', 'Enumerator'), 'new', [], ($$11 = function(yielder){var self = $$11.$$s == null ? this : $$11.$$s;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = Opal.yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, $$11.$$s = self, $$11.$$arity = 1, $$11));
    }, $Enumerable_chunk$9.$$arity = 0);
    
    Opal.def(self, '$chunk_while', $Enumerable_chunk_while$12 = function $$chunk_while() {
      var $iter = $Enumerable_chunk_while$12.$$p, block = $iter || nil, $$13, self = this;

      if ($iter) $Enumerable_chunk_while$12.$$p = null;
      
      
      if ($iter) $Enumerable_chunk_while$12.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], ($$13 = function(before, after){var self = $$13.$$s == null ? this : $$13.$$s;

      
        
        if (before == null) {
          before = nil;
        };
        
        if (after == null) {
          after = nil;
        };
        return Opal.yieldX(block, [before, after])['$!']();}, $$13.$$s = self, $$13.$$arity = 2, $$13));
    }, $Enumerable_chunk_while$12.$$arity = 0);
    
    Opal.def(self, '$collect', $Enumerable_collect$14 = function $$collect() {
      var $iter = $Enumerable_collect$14.$$p, block = $iter || nil, $$15, self = this;

      if ($iter) $Enumerable_collect$14.$$p = null;
      
      
      if ($iter) $Enumerable_collect$14.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$15 = function(){var self = $$15.$$s == null ? this : $$15.$$s;

        return self.$enumerator_size()}, $$15.$$s = self, $$15.$$arity = 0, $$15))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = Opal.yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_collect$14.$$arity = 0);
    
    Opal.def(self, '$collect_concat', $Enumerable_collect_concat$16 = function $$collect_concat() {
      var $iter = $Enumerable_collect_concat$16.$$p, block = $iter || nil, $$17, $$18, self = this;

      if ($iter) $Enumerable_collect_concat$16.$$p = null;
      
      
      if ($iter) $Enumerable_collect_concat$16.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect_concat"], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s;

        return self.$enumerator_size()}, $$17.$$s = self, $$17.$$arity = 0, $$17))
      };
      return $send(self, 'map', [], ($$18 = function(item){var self = $$18.$$s == null ? this : $$18.$$s;

      
        
        if (item == null) {
          item = nil;
        };
        return Opal.yield1(block, item);;}, $$18.$$s = self, $$18.$$arity = 1, $$18)).$flatten(1);
    }, $Enumerable_collect_concat$16.$$arity = 0);
    
    Opal.def(self, '$count', $Enumerable_count$19 = function $$count(object) {
      var $iter = $Enumerable_count$19.$$p, block = $iter || nil, $$20, $$21, $$22, self = this, result = nil;

      if ($iter) $Enumerable_count$19.$$p = null;
      
      
      if ($iter) $Enumerable_count$19.$$p = null;;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send(self, 'proc', [], ($$20 = function($a){var self = $$20.$$s == null ? this : $$20.$$s, $post_args, args;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $$($nesting, 'Opal').$destructure(args)['$=='](object);}, $$20.$$s = self, $$20.$$arity = -1, $$20))
      } else if ($truthy(block['$nil?']())) {
        block = $send(self, 'proc', [], ($$21 = function(){var self = $$21.$$s == null ? this : $$21.$$s;

        return true}, $$21.$$s = self, $$21.$$arity = 0, $$21))};
      $send(self, 'each', [], ($$22 = function($a){var self = $$22.$$s == null ? this : $$22.$$s, $post_args, args;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($truthy(Opal.yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, $$22.$$s = self, $$22.$$arity = -1, $$22));
      return result;
    }, $Enumerable_count$19.$$arity = -1);
    
    Opal.def(self, '$cycle', $Enumerable_cycle$23 = function $$cycle(n) {
      var $iter = $Enumerable_cycle$23.$$p, block = $iter || nil, $$24, self = this;

      if ($iter) $Enumerable_cycle$23.$$p = null;
      
      
      if ($iter) $Enumerable_cycle$23.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$24 = function(){var self = $$24.$$s == null ? this : $$24.$$s;

        if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$($nesting, 'Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$24.$$s = self, $$24.$$arity = 0, $$24))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil};
      };
      
      var all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, $Enumerable_cycle$23.$$arity = -1);
    
    Opal.def(self, '$detect', $Enumerable_detect$25 = function $$detect(ifnone) {try {

      var $iter = $Enumerable_detect$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Enumerable_detect$25.$$p = null;
      
      
      if ($iter) $Enumerable_detect$25.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], ($$26 = function($a){var self = $$26.$$s == null ? this : $$26.$$s, $post_args, args, value = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          Opal.ret(value)
        } else {
          return nil
        };}, $$26.$$s = self, $$26.$$arity = -1, $$26));
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_detect$25.$$arity = -1);
    
    Opal.def(self, '$drop', $Enumerable_drop$27 = function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(number < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($$($nesting, 'Opal').$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    }, $Enumerable_drop$27.$$arity = 1);
    
    Opal.def(self, '$drop_while', $Enumerable_drop_while$28 = function $$drop_while() {
      var $iter = $Enumerable_drop_while$28.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_drop_while$28.$$p = null;
      
      
      if ($iter) $Enumerable_drop_while$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        if (dropping) {
          var value = Opal.yield1(block, param);

          if ($falsy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_drop_while$28.$$arity = 0);
    
    Opal.def(self, '$each_cons', $Enumerable_each_cons$29 = function $$each_cons(n) {
      var $iter = $Enumerable_each_cons$29.$$p, block = $iter || nil, $$30, self = this;

      if ($iter) $Enumerable_each_cons$29.$$p = null;
      
      
      if ($iter) $Enumerable_each_cons$29.$$p = null;;
      if ($truthy(arguments.length != 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 1)")};
      n = $$($nesting, 'Opal').$try_convert(n, $$($nesting, 'Integer'), "to_int");
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_cons", n], ($$30 = function(){var self = $$30.$$s == null ? this : $$30.$$s, enum_size = nil, $ret_or_1 = nil;

        
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if ($truthy((function() {if ($truthy(($ret_or_1 = enum_size['$=='](0)))) {
            return $ret_or_1
          } else {
            return $rb_lt(enum_size, n)
          }; return nil; })())) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, $$30.$$s = self, $$30.$$arity = 0, $$30))
      };
      
      var buffer = [];

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          Opal.yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return nil;
    ;
    }, $Enumerable_each_cons$29.$$arity = 1);
    
    Opal.def(self, '$each_entry', $Enumerable_each_entry$31 = function $$each_entry($a) {
      var $iter = $Enumerable_each_entry$31.$$p, block = $iter || nil, $post_args, data, $$32, self = this;

      if ($iter) $Enumerable_each_entry$31.$$p = null;
      
      
      if ($iter) $Enumerable_each_entry$31.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      data = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["each_entry"].concat(Opal.to_a(data)), ($$32 = function(){var self = $$32.$$s == null ? this : $$32.$$s;

        return self.$enumerator_size()}, $$32.$$s = self, $$32.$$arity = 0, $$32))
      };
      
      self.$each.$$p = function() {
        var item = $$($nesting, 'Opal').$destructure(arguments);

        Opal.yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, $Enumerable_each_entry$31.$$arity = -1);
    
    Opal.def(self, '$each_slice', $Enumerable_each_slice$33 = function $$each_slice(n) {
      var $iter = $Enumerable_each_slice$33.$$p, block = $iter || nil, $$34, self = this;

      if ($iter) $Enumerable_each_slice$33.$$p = null;
      
      
      if ($iter) $Enumerable_each_slice$33.$$p = null;;
      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid slice size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_slice", n], ($$34 = function(){var self = $$34.$$s == null ? this : $$34.$$s;

        if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, $$34.$$s = self, $$34.$$arity = 0, $$34))
      };
      
      var slice = []

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          Opal.yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        Opal.yield1(block, slice);
      }
    ;
      return nil;
    }, $Enumerable_each_slice$33.$$arity = 1);
    
    Opal.def(self, '$each_with_index', $Enumerable_each_with_index$35 = function $$each_with_index($a) {
      var $iter = $Enumerable_each_with_index$35.$$p, block = $iter || nil, $post_args, args, $$36, self = this;

      if ($iter) $Enumerable_each_with_index$35.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_index$35.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_index"].concat(Opal.to_a(args)), ($$36 = function(){var self = $$36.$$s == null ? this : $$36.$$s;

        return self.$enumerator_size()}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      var index = 0;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);
    ;
      return self;
    }, $Enumerable_each_with_index$35.$$arity = -1);
    
    Opal.def(self, '$each_with_object', $Enumerable_each_with_object$37 = function $$each_with_object(object) {
      var $iter = $Enumerable_each_with_object$37.$$p, block = $iter || nil, $$38, self = this;

      if ($iter) $Enumerable_each_with_object$37.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_object$37.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_object", object], ($$38 = function(){var self = $$38.$$s == null ? this : $$38.$$s;

        return self.$enumerator_size()}, $$38.$$s = self, $$38.$$arity = 0, $$38))
      };
      
      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, object);
      };

      self.$each();
    ;
      return object;
    }, $Enumerable_each_with_object$37.$$arity = 1);
    
    Opal.def(self, '$entries', $Enumerable_entries$39 = function $$entries($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($$($nesting, 'Opal').$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, $Enumerable_entries$39.$$arity = -1);
    
    Opal.def(self, '$filter_map', $Enumerable_filter_map$40 = function $$filter_map() {
      var $iter = $Enumerable_filter_map$40.$$p, block = $iter || nil, $$41, self = this;

      if ($iter) $Enumerable_filter_map$40.$$p = null;
      
      
      if ($iter) $Enumerable_filter_map$40.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["filter_map"], ($$41 = function(){var self = $$41.$$s == null ? this : $$41.$$s;

        return self.$enumerator_size()}, $$41.$$s = self, $$41.$$arity = 0, $$41))
      };
      return $send($send(self, 'map', [], block.$to_proc()), 'select', [], "itself".$to_proc());
    }, $Enumerable_filter_map$40.$$arity = 0);
    Opal.alias(self, "find", "detect");
    
    Opal.def(self, '$find_all', $Enumerable_find_all$42 = function $$find_all() {
      var $iter = $Enumerable_find_all$42.$$p, block = $iter || nil, $$43, self = this;

      if ($iter) $Enumerable_find_all$42.$$p = null;
      
      
      if ($iter) $Enumerable_find_all$42.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["find_all"], ($$43 = function(){var self = $$43.$$s == null ? this : $$43.$$s;

        return self.$enumerator_size()}, $$43.$$s = self, $$43.$$arity = 0, $$43))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_find_all$42.$$arity = 0);
    Opal.alias(self, "filter", "find_all");
    
    Opal.def(self, '$find_index', $Enumerable_find_index$44 = function $$find_index(object) {try {

      var $iter = $Enumerable_find_index$44.$$p, block = $iter || nil, $$45, $$46, self = this, index = nil;

      if ($iter) $Enumerable_find_index$44.$$p = null;
      
      
      if ($iter) $Enumerable_find_index$44.$$p = null;;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")};
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], ($$45 = function($a){var self = $$45.$$s == null ? this : $$45.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($$($nesting, 'Opal').$destructure(value)['$=='](object)) {
            Opal.ret(index)};
          return index += 1;;}, $$45.$$s = self, $$45.$$arity = -1, $$45))
      } else {
        $send(self, 'each', [], ($$46 = function($a){var self = $$46.$$s == null ? this : $$46.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(index)};
          return index += 1;;}, $$46.$$s = self, $$46.$$arity = -1, $$46))
      };
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_find_index$44.$$arity = -1);
    
    Opal.def(self, '$first', $Enumerable_first$47 = function $$first(number) {try {

      var $$48, $$49, self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], ($$48 = function(value){var self = $$48.$$s == null ? this : $$48.$$s;

        
          
          if (value == null) {
            value = nil;
          };
          Opal.ret(value);}, $$48.$$s = self, $$48.$$arity = 1, $$48))
      } else {
        
        result = [];
        number = $coerce_to(number, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(number < 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        if ($truthy(number == 0)) {
          return []};
        current = 0;
        $send(self, 'each', [], ($$49 = function($a){var self = $$49.$$s == null ? this : $$49.$$s, $post_args, args;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          result.push($$($nesting, 'Opal').$destructure(args));
          if ($truthy(number <= ++current)) {
            Opal.ret(result)
          } else {
            return nil
          };}, $$49.$$s = self, $$49.$$arity = -1, $$49));
        return result;
      };
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_first$47.$$arity = -1);
    Opal.alias(self, "flat_map", "collect_concat");
    
    Opal.def(self, '$grep', $Enumerable_grep$50 = function $$grep(pattern) {
      var $iter = $Enumerable_grep$50.$$p, block = $iter || nil, $$51, self = this, result = nil;

      if ($iter) $Enumerable_grep$50.$$p = null;
      
      
      if ($iter) $Enumerable_grep$50.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$51 = function($a){var self = $$51.$$s == null ? this : $$51.$$s, $post_args, value, cmp = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
        } else {
          return nil;
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$51.$$s = self, $$51.$$arity = -1, $$51));
      return result;
    }, $Enumerable_grep$50.$$arity = 1);
    
    Opal.def(self, '$grep_v', $Enumerable_grep_v$52 = function $$grep_v(pattern) {
      var $iter = $Enumerable_grep_v$52.$$p, block = $iter || nil, $$53, self = this, result = nil;

      if ($iter) $Enumerable_grep_v$52.$$p = null;
      
      
      if ($iter) $Enumerable_grep_v$52.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$53 = function($a){var self = $$53.$$s == null ? this : $$53.$$s, $post_args, value, cmp = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
          return nil;};
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$53.$$s = self, $$53.$$arity = -1, $$53));
      return result;
    }, $Enumerable_grep_v$52.$$arity = 1);
    
    Opal.def(self, '$group_by', $Enumerable_group_by$54 = function $$group_by() {
      var $iter = $Enumerable_group_by$54.$$p, block = $iter || nil, $$55, self = this, hash = nil, $ret_or_2 = nil, $writer = nil;

      if ($iter) $Enumerable_group_by$54.$$p = null;
      
      
      if ($iter) $Enumerable_group_by$54.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["group_by"], ($$55 = function(){var self = $$55.$$s == null ? this : $$55.$$s;

        return self.$enumerator_size()}, $$55.$$s = self, $$55.$$arity = 0, $$55))
      };
      hash = $hash2([], {});
      
      var result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        (function() {if ($truthy(($ret_or_2 = hash['$[]'](value)))) {
        return $ret_or_2
      } else {
        
        $writer = [value, []];
        $send(hash, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }; return nil; })()['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    }, $Enumerable_group_by$54.$$arity = 0);
    
    Opal.def(self, '$include?', $Enumerable_include$ques$56 = function(obj) {try {

      var $$57, self = this;

      
      $send(self, 'each', [], ($$57 = function($a){var self = $$57.$$s == null ? this : $$57.$$s, $post_args, args;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($$($nesting, 'Opal').$destructure(args)['$=='](obj)) {
          Opal.ret(true)
        } else {
          return nil
        };}, $$57.$$s = self, $$57.$$arity = -1, $$57));
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_include$ques$56.$$arity = 1);
    
    Opal.def(self, '$inject', $Enumerable_inject$58 = function $$inject(object, sym) {
      var $iter = $Enumerable_inject$58.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_inject$58.$$p = null;
      
      
      if ($iter) $Enumerable_inject$58.$$p = null;;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = Opal.yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$($nesting, 'Symbol')['$==='](object)) {
            self.$raise($$($nesting, 'TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, $Enumerable_inject$58.$$arity = -1);
    
    Opal.def(self, '$lazy', $Enumerable_lazy$59 = function $$lazy() {
      var $$60, self = this;

      return $send($$$($$($nesting, 'Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], ($$60 = function(enum$, $a){var self = $$60.$$s == null ? this : $$60.$$s, $post_args, args;

      
        
        if (enum$ == null) {
          enum$ = nil;
        };
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        args = $post_args;;
        return $send(enum$, 'yield', Opal.to_a(args));}, $$60.$$s = self, $$60.$$arity = -2, $$60))
    }, $Enumerable_lazy$59.$$arity = 0);
    
    Opal.def(self, '$enumerator_size', $Enumerable_enumerator_size$61 = function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    }, $Enumerable_enumerator_size$61.$$arity = 0);
    Opal.alias(self, "map", "collect");
    
    Opal.def(self, '$max', $Enumerable_max$62 = function $$max(n) {
      var $iter = $Enumerable_max$62.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_max$62.$$p = null;
      
      
      if ($iter) $Enumerable_max$62.$$p = null;;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = Opal.yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }

      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
    ;
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, $Enumerable_max$62.$$arity = -1);
    
    Opal.def(self, '$max_by', $Enumerable_max_by$63 = function $$max_by(n) {
      var $iter = $Enumerable_max_by$63.$$p, block = $iter || nil, $$64, self = this;

      if ($iter) $Enumerable_max_by$63.$$p = null;
      
      
      if ($iter) $Enumerable_max_by$63.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["max_by", n], ($$64 = function(){var self = $$64.$$s == null ? this : $$64.$$s;

        return self.$enumerator_size()}, $$64.$$s = self, $$64.$$arity = 0, $$64))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        return $send(self, 'sort_by', [], block.$to_proc()).$reverse().$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_max_by$63.$$arity = -1);
    Opal.alias(self, "member?", "include?");
    
    Opal.def(self, '$min', $Enumerable_min$65 = function $$min(n) {
      var $iter = $Enumerable_min$65.$$p, block = $iter || nil, $$66, self = this;

      if ($iter) $Enumerable_min$65.$$p = null;
      
      
      if ($iter) $Enumerable_min$65.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ($truthy(n['$nil?']())) {
      } else if ((block !== nil)) {
        return $send(self, 'sort', [], ($$66 = function(a, b){var self = $$66.$$s == null ? this : $$66.$$s;

        
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return Opal.yieldX(block, [a, b]);;}, $$66.$$s = self, $$66.$$arity = 2, $$66)).$take(n)
      } else {
        return self.$sort().$take(n)
      };
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($$($nesting, 'Opal').$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min$65.$$arity = -1);
    
    Opal.def(self, '$min_by', $Enumerable_min_by$67 = function $$min_by(n) {
      var $iter = $Enumerable_min_by$67.$$p, block = $iter || nil, $$68, self = this;

      if ($iter) $Enumerable_min_by$67.$$p = null;
      
      
      if ($iter) $Enumerable_min_by$67.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["min_by", n], ($$68 = function(){var self = $$68.$$s == null ? this : $$68.$$s;

        return self.$enumerator_size()}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        return $send(self, 'sort_by', [], block.$to_proc()).$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min_by$67.$$arity = -1);
    
    Opal.def(self, '$minmax', $Enumerable_minmax$69 = function $$minmax() {
      var $iter = $Enumerable_minmax$69.$$p, block = $iter || nil, $$70, self = this, $ret_or_3 = nil;

      if ($iter) $Enumerable_minmax$69.$$p = null;
      
      
      if ($iter) $Enumerable_minmax$69.$$p = null;;
      block = (function() {if ($truthy(($ret_or_3 = block))) {
        return $ret_or_3
      } else {
        return $send(self, 'proc', [], ($$70 = function(a, b){var self = $$70.$$s == null ? this : $$70.$$s;

        
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return a['$<=>'](b);}, $$70.$$s = self, $$70.$$arity = 2, $$70))
      }; return nil; })();
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    }, $Enumerable_minmax$69.$$arity = 0);
    
    Opal.def(self, '$minmax_by', $Enumerable_minmax_by$71 = function $$minmax_by() {
      var $iter = $Enumerable_minmax_by$71.$$p, block = $iter || nil, $$72, self = this;

      if ($iter) $Enumerable_minmax_by$71.$$p = null;
      
      
      if ($iter) $Enumerable_minmax_by$71.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["minmax_by"], ($$72 = function(){var self = $$72.$$s == null ? this : $$72.$$s;

        return self.$enumerator_size()}, $$72.$$s = self, $$72.$$arity = 0, $$72))
      };
      
      var min_result = nil,
          max_result = nil,
          min_by,
          max_by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ((min_by === undefined) || (value)['$<=>'](min_by) < 0) {
          min_result = param;
          min_by     = value;
        }

        if ((max_by === undefined) || (value)['$<=>'](max_by) > 0) {
          max_result = param;
          max_by     = value;
        }
      };

      self.$each();

      return [min_result, max_result];
    ;
    }, $Enumerable_minmax_by$71.$$arity = 0);
    
    Opal.def(self, '$none?', $Enumerable_none$ques$73 = function(pattern) {try {

      var $iter = $Enumerable_none$ques$73.$$p, block = $iter || nil, $$74, $$75, $$76, self = this;

      if ($iter) $Enumerable_none$ques$73.$$p = null;
      
      
      if ($iter) $Enumerable_none$ques$73.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$74 = function($a){var self = $$74.$$s == null ? this : $$74.$$s, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$74.$$s = self, $$74.$$arity = -1, $$74))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$75 = function($a){var self = $$75.$$s == null ? this : $$75.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$75.$$s = self, $$75.$$arity = -1, $$75))
      } else {
        $send(self, 'each', [], ($$76 = function($a){var self = $$76.$$s == null ? this : $$76.$$s, $post_args, value, item = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          item = $$($nesting, 'Opal').$destructure(value);
          if ($truthy(item)) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$76.$$s = self, $$76.$$arity = -1, $$76))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_none$ques$73.$$arity = -1);
    
    Opal.def(self, '$one?', $Enumerable_one$ques$77 = function(pattern) {try {

      var $iter = $Enumerable_one$ques$77.$$p, block = $iter || nil, $$78, $$79, $$80, self = this, count = nil;

      if ($iter) $Enumerable_one$ques$77.$$p = null;
      
      
      if ($iter) $Enumerable_one$ques$77.$$p = null;;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$78 = function($a){var self = $$78.$$s == null ? this : $$78.$$s, $post_args, value, comparable = nil;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              Opal.ret(false)
            } else {
              return nil
            };
          } else {
            return nil
          };}, $$78.$$s = self, $$78.$$arity = -1, $$78))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$79 = function($a){var self = $$79.$$s == null ? this : $$79.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$79.$$s = self, $$79.$$arity = -1, $$79))
      } else {
        $send(self, 'each', [], ($$80 = function($a){var self = $$80.$$s == null ? this : $$80.$$s, $post_args, value;

        
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$80.$$s = self, $$80.$$arity = -1, $$80))
      };
      return count['$=='](1);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_one$ques$77.$$arity = -1);
    
    Opal.def(self, '$partition', $Enumerable_partition$81 = function $$partition() {
      var $iter = $Enumerable_partition$81.$$p, block = $iter || nil, $$82, self = this;

      if ($iter) $Enumerable_partition$81.$$p = null;
      
      
      if ($iter) $Enumerable_partition$81.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["partition"], ($$82 = function(){var self = $$82.$$s == null ? this : $$82.$$s;

        return self.$enumerator_size()}, $$82.$$s = self, $$82.$$arity = 0, $$82))
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    }, $Enumerable_partition$81.$$arity = 0);
    Opal.alias(self, "reduce", "inject");
    
    Opal.def(self, '$reject', $Enumerable_reject$83 = function $$reject() {
      var $iter = $Enumerable_reject$83.$$p, block = $iter || nil, $$84, self = this;

      if ($iter) $Enumerable_reject$83.$$p = null;
      
      
      if ($iter) $Enumerable_reject$83.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$84 = function(){var self = $$84.$$s == null ? this : $$84.$$s;

        return self.$enumerator_size()}, $$84.$$s = self, $$84.$$arity = 0, $$84))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($falsy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_reject$83.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Enumerable_reverse_each$85 = function $$reverse_each() {
      var $iter = $Enumerable_reverse_each$85.$$p, block = $iter || nil, $$86, self = this;

      if ($iter) $Enumerable_reverse_each$85.$$p = null;
      
      
      if ($iter) $Enumerable_reverse_each$85.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$86 = function(){var self = $$86.$$s == null ? this : $$86.$$s;

        return self.$enumerator_size()}, $$86.$$s = self, $$86.$$arity = 0, $$86))
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        Opal.yieldX(block, result[i]);
      }

      return result;
    ;
    }, $Enumerable_reverse_each$85.$$arity = 0);
    Opal.alias(self, "select", "find_all");
    
    Opal.def(self, '$slice_before', $Enumerable_slice_before$87 = function $$slice_before(pattern) {
      var $iter = $Enumerable_slice_before$87.$$p, block = $iter || nil, $$88, self = this;

      if ($iter) $Enumerable_slice_before$87.$$p = null;
      
      
      if ($iter) $Enumerable_slice_before$87.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$88 = function(e){var self = $$88.$$s == null ? this : $$88.$$s;

      
        
        if (e == null) {
          e = nil;
        };
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = Opal.yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $$($nesting, 'Opal').$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, $$88.$$s = self, $$88.$$arity = 1, $$88));
    }, $Enumerable_slice_before$87.$$arity = -1);
    
    Opal.def(self, '$slice_after', $Enumerable_slice_after$89 = function $$slice_after(pattern) {
      var $iter = $Enumerable_slice_after$89.$$p, block = $iter || nil, $$90, $$91, self = this;

      if ($iter) $Enumerable_slice_after$89.$$p = null;
      
      
      if ($iter) $Enumerable_slice_after$89.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      if ($truthy(pattern !== undefined)) {
        block = $send(self, 'proc', [], ($$90 = function(e){var self = $$90.$$s == null ? this : $$90.$$s;

        
          
          if (e == null) {
            e = nil;
          };
          return pattern['$==='](e);}, $$90.$$s = self, $$90.$$arity = 1, $$90))};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$91 = function(yielder){var self = $$91.$$s == null ? this : $$91.$$s;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $$($nesting, 'Opal').$destructure(arguments),
              end_chunk = Opal.yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, $$91.$$s = self, $$91.$$arity = 1, $$91));
    }, $Enumerable_slice_after$89.$$arity = -1);
    
    Opal.def(self, '$slice_when', $Enumerable_slice_when$92 = function $$slice_when() {
      var $iter = $Enumerable_slice_when$92.$$p, block = $iter || nil, $$93, self = this;

      if ($iter) $Enumerable_slice_when$92.$$p = null;
      
      
      if ($iter) $Enumerable_slice_when$92.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$93 = function(yielder){var self = $$93.$$s == null ? this : $$93.$$s;

      
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $$($nesting, 'Opal').$destructure(arguments),
              before = params[0],
              after = params[1],
              match = Opal.yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, $$93.$$s = self, $$93.$$arity = 1, $$93));
    }, $Enumerable_slice_when$92.$$arity = 0);
    
    Opal.def(self, '$sort', $Enumerable_sort$94 = function $$sort() {
      var $iter = $Enumerable_sort$94.$$p, block = $iter || nil, $$95, self = this, ary = nil;

      if ($iter) $Enumerable_sort$94.$$p = null;
      
      
      if ($iter) $Enumerable_sort$94.$$p = null;;
      ary = self.$to_a();
      if ((block !== nil)) {
      } else {
        block = $lambda(($$95 = function(a, b){var self = $$95.$$s == null ? this : $$95.$$s;

        
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return a['$<=>'](b);}, $$95.$$s = self, $$95.$$arity = 2, $$95))
      };
      return $send(ary, 'sort', [], block.$to_proc());
    }, $Enumerable_sort$94.$$arity = 0);
    
    Opal.def(self, '$sort_by', $Enumerable_sort_by$96 = function $$sort_by() {
      var $iter = $Enumerable_sort_by$96.$$p, block = $iter || nil, $$97, $$98, $$99, $$100, self = this, dup = nil;

      if ($iter) $Enumerable_sort_by$96.$$p = null;
      
      
      if ($iter) $Enumerable_sort_by$96.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by"], ($$97 = function(){var self = $$97.$$s == null ? this : $$97.$$s;

        return self.$enumerator_size()}, $$97.$$s = self, $$97.$$arity = 0, $$97))
      };
      dup = $send(self, 'map', [], ($$98 = function(){var self = $$98.$$s == null ? this : $$98.$$s, arg = nil;

      
        arg = $$($nesting, 'Opal').$destructure(arguments);
        return [Opal.yield1(block, arg), arg];}, $$98.$$s = self, $$98.$$arity = 0, $$98));
      $send(dup, 'sort!', [], ($$99 = function(a, b){var self = $$99.$$s == null ? this : $$99.$$s;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return (a[0])['$<=>'](b[0]);}, $$99.$$s = self, $$99.$$arity = 2, $$99));
      return $send(dup, 'map!', [], ($$100 = function(i){var self = $$100.$$s == null ? this : $$100.$$s;

      
        
        if (i == null) {
          i = nil;
        };
        return i[1];;}, $$100.$$s = self, $$100.$$arity = 1, $$100));
    }, $Enumerable_sort_by$96.$$arity = 0);
    
    Opal.def(self, '$sum', $Enumerable_sum$101 = function $$sum(initial) {
      var $$102, $iter = $Enumerable_sum$101.$$p, $yield = $iter || nil, self = this, result = nil;

      if ($iter) $Enumerable_sum$101.$$p = null;
      
      
      if (initial == null) {
        initial = 0;
      };
      result = initial;
      $send(self, 'each', [], ($$102 = function($a){var self = $$102.$$s == null ? this : $$102.$$s, $post_args, args, item = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        item = (function() {if (($yield !== nil)) {
          return Opal.yieldX($yield, Opal.to_a(args));
        } else {
          return $$($nesting, 'Opal').$destructure(args)
        }; return nil; })();
        return (result = $rb_plus(result, item));}, $$102.$$s = self, $$102.$$arity = -1, $$102));
      return result;
    }, $Enumerable_sum$101.$$arity = -1);
    
    Opal.def(self, '$take', $Enumerable_take$103 = function $$take(num) {
      var self = this;

      return self.$first(num)
    }, $Enumerable_take$103.$$arity = 1);
    
    Opal.def(self, '$take_while', $Enumerable_take_while$104 = function $$take_while() {try {

      var $iter = $Enumerable_take_while$104.$$p, block = $iter || nil, $$105, self = this, result = nil;

      if ($iter) $Enumerable_take_while$104.$$p = null;
      
      
      if ($iter) $Enumerable_take_while$104.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], ($$105 = function($a){var self = $$105.$$s == null ? this : $$105.$$s, $post_args, args, value = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
        } else {
          Opal.ret(result)
        };
        return result.push(value);;}, $$105.$$s = self, $$105.$$arity = -1, $$105));
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_take_while$104.$$arity = 0);
    
    Opal.def(self, '$uniq', $Enumerable_uniq$106 = function $$uniq() {
      var $iter = $Enumerable_uniq$106.$$p, block = $iter || nil, $$107, self = this, hash = nil;

      if ($iter) $Enumerable_uniq$106.$$p = null;
      
      
      if ($iter) $Enumerable_uniq$106.$$p = null;;
      hash = $hash2([], {});
      $send(self, 'each', [], ($$107 = function($a){var self = $$107.$$s == null ? this : $$107.$$s, $post_args, args, value = nil, produced = nil, $writer = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        produced = (function() {if ((block !== nil)) {
          return Opal.yield1(block, value);
        } else {
          return value
        }; return nil; })();
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          
          $writer = [produced, value];
          $send(hash, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        };}, $$107.$$s = self, $$107.$$arity = -1, $$107));
      return hash.$values();
    }, $Enumerable_uniq$106.$$arity = 0);
    
    Opal.def(self, '$tally', $Enumerable_tally$108 = function $$tally() {
      var self = this;

      return $send($send(self, 'group_by', [], "itself".$to_proc()), 'transform_values', [], "count".$to_proc())
    }, $Enumerable_tally$108.$$arity = 0);
    Opal.alias(self, "to_a", "entries");
    
    Opal.def(self, '$to_h', $Enumerable_to_h$109 = function $$to_h($a) {
      var $iter = $Enumerable_to_h$109.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Enumerable_to_h$109.$$p = null;
      
      
      if ($iter) $Enumerable_to_h$109.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', Opal.to_a(args))};
      
      var hash = $hash2([], {});

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);
        var ary = $$($nesting, 'Opal')['$coerce_to?'](param, $$($nesting, 'Array'), "to_ary"), key, val;
        if (!ary.$$is_array) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong element type " + ((ary).$class()) + " (expected array)")
        }
        if (ary.length !== 2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong array length (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];

        Opal.hash_put(hash, key, val);
      };

      self.$each.apply(self, args);

      return hash;
    ;
    }, $Enumerable_to_h$109.$$arity = -1);
    return (Opal.def(self, '$zip', $Enumerable_zip$110 = function $$zip($a) {
      var $iter = $Enumerable_zip$110.$$p, block = $iter || nil, $post_args, others, self = this;

      if ($iter) $Enumerable_zip$110.$$p = null;
      
      
      if ($iter) $Enumerable_zip$110.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      return $send(self.$to_a(), 'zip', Opal.to_a(others));
    }, $Enumerable_zip$110.$$arity = -1), nil) && 'zip';
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/enumerator"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $breaker = Opal.breaker, $slice = Opal.slice, $falsy = Opal.falsy, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send = Opal.send, $send2 = Opal.send2;

  Opal.add_stubs(['$require', '$include', '$allocate', '$new', '$to_proc', '$!', '$respond_to?', '$nil?', '$empty?', '$+', '$class', '$__send__', '$call', '$enum_for', '$size', '$destructure', '$inspect', '$any?', '$[]', '$raise', '$yield', '$each', '$enumerator_size', '$try_convert', '$<', '$===', '$for']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $Enumerator_for$1, $Enumerator_initialize$2, $Enumerator_each$3, $Enumerator_size$4, $Enumerator_with_index$5, $Enumerator_each_with_index$7, $Enumerator_inspect$9;

    self.$$prototype.size = self.$$prototype.args = self.$$prototype.object = self.$$prototype.method = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    Opal.defs(self, '$for', $Enumerator_for$1 = function(object, $a, $b) {
      var $iter = $Enumerator_for$1.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Enumerator_for$1.$$p = null;
      
      
      if ($iter) $Enumerator_for$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;

      return obj;
    ;
    }, $Enumerator_for$1.$$arity = -2);
    
    Opal.def(self, '$initialize', $Enumerator_initialize$2 = function $$initialize($a) {
      var $iter = $Enumerator_initialize$2.$$p, block = $iter || nil, $post_args, self = this, $ret_or_1 = nil;

      if ($iter) $Enumerator_initialize$2.$$p = null;
      
      
      if ($iter) $Enumerator_initialize$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      if ($truthy(block)) {
        
        self.object = $send($$($nesting, 'Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if ($truthy((function() {if ($truthy(($ret_or_1 = self.size))) {
          return self.size['$respond_to?']("call")['$!']()
        } else {
          return $ret_or_1
        }; return nil; })())) {
          return (self.size = $coerce_to(self.size, $$($nesting, 'Integer'), 'to_int'))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice.call(arguments, 2);
        return (self.size = nil);
      };
    }, $Enumerator_initialize$2.$$arity = -1);
    
    Opal.def(self, '$each', $Enumerator_each$3 = function $$each($a) {
      var $iter = $Enumerator_each$3.$$p, block = $iter || nil, $post_args, args, self = this, $ret_or_2 = nil;

      if ($iter) $Enumerator_each$3.$$p = null;
      
      
      if ($iter) $Enumerator_each$3.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_2 = block['$nil?']()))) {
        return args['$empty?']()
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return self};
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat(Opal.to_a(args)))};
      return $send(self.object, '__send__', [self.method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Enumerator_each$3.$$arity = -1);
    
    Opal.def(self, '$size', $Enumerator_size$4 = function $$size() {
      var self = this;

      if ($truthy(self.size['$respond_to?']("call"))) {
        return $send(self.size, 'call', Opal.to_a(self.args))
      } else {
        return self.size
      }
    }, $Enumerator_size$4.$$arity = 0);
    
    Opal.def(self, '$with_index', $Enumerator_with_index$5 = function $$with_index(offset) {
      var $iter = $Enumerator_with_index$5.$$p, block = $iter || nil, $$6, self = this;

      if ($iter) $Enumerator_with_index$5.$$p = null;
      
      
      if ($iter) $Enumerator_with_index$5.$$p = null;;
      
      if (offset == null) {
        offset = 0;
      };
      offset = (function() {if ($truthy(offset)) {
        return $coerce_to(offset, $$($nesting, 'Integer'), 'to_int')
      } else {
        return 0
      }; return nil; })();
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["with_index", offset], ($$6 = function(){var self = $$6.$$s == null ? this : $$6.$$s;

        return self.$size()}, $$6.$$s = self, $$6.$$arity = 0, $$6))
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, $Enumerator_with_index$5.$$arity = -1);
    Opal.alias(self, "with_object", "each_with_object");
    
    Opal.def(self, '$each_with_index', $Enumerator_each_with_index$7 = function $$each_with_index() {
      var $iter = $Enumerator_each_with_index$7.$$p, block = $iter || nil, $$8, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Enumerator_each_with_index$7.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Enumerator_each_with_index$7.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_index"], ($$8 = function(){var self = $$8.$$s == null ? this : $$8.$$s;

        return self.$size()}, $$8.$$s = self, $$8.$$arity = 0, $$8))
      };
      $send2(self, Opal.find_super_dispatcher(self, 'each_with_index', $Enumerator_each_with_index$7, false, true), 'each_with_index', $zuper, $iter);
      return self.object;
    }, $Enumerator_each_with_index$7.$$arity = 0);
    
    Opal.def(self, '$inspect', $Enumerator_inspect$9 = function $$inspect() {
      var self = this, result = nil;

      
      result = "" + "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "" + "(" + (self.args.$inspect()['$[]']($$($nesting, 'Range').$new(1, -2))) + ")")};
      return $rb_plus(result, ">");
    }, $Enumerator_inspect$9.$$arity = 0);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $Generator_initialize$10, $Generator_each$11;

      self.$$prototype.block = nil;
      
      self.$include($$($nesting, 'Enumerable'));
      
      Opal.def(self, '$initialize', $Generator_initialize$10 = function $$initialize() {
        var $iter = $Generator_initialize$10.$$p, block = $iter || nil, self = this;

        if ($iter) $Generator_initialize$10.$$p = null;
        
        
        if ($iter) $Generator_initialize$10.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'LocalJumpError'), "no block given")
        };
        return (self.block = block);
      }, $Generator_initialize$10.$$arity = 0);
      return (Opal.def(self, '$each', $Generator_each$11 = function $$each($a) {
        var $iter = $Generator_each$11.$$p, block = $iter || nil, $post_args, args, self = this, yielder = nil;

        if ($iter) $Generator_each$11.$$p = null;
        
        
        if ($iter) $Generator_each$11.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        yielder = $send($$($nesting, 'Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e === $breaker) {
            return $breaker.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, $Generator_each$11.$$arity = -1), nil) && 'each';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Yielder');

      var $nesting = [self].concat($parent_nesting), $Yielder_initialize$12, $Yielder_yield$13, $Yielder_$lt$lt$14;

      self.$$prototype.block = nil;
      
      
      Opal.def(self, '$initialize', $Yielder_initialize$12 = function $$initialize() {
        var $iter = $Yielder_initialize$12.$$p, block = $iter || nil, self = this;

        if ($iter) $Yielder_initialize$12.$$p = null;
        
        
        if ($iter) $Yielder_initialize$12.$$p = null;;
        return (self.block = block);
      }, $Yielder_initialize$12.$$arity = 0);
      
      Opal.def(self, '$yield', $Yielder_yield$13 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        
        var value = Opal.yieldX(self.block, values);

        if (value === $breaker) {
          throw $breaker;
        }

        return value;
      ;
      }, $Yielder_yield$13.$$arity = -1);
      return (Opal.def(self, '$<<', $Yielder_$lt$lt$14 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        $send(self, 'yield', Opal.to_a(values));
        return self;
      }, $Yielder_$lt$lt$14.$$arity = -1), nil) && '<<';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $Lazy_initialize$15, $Lazy_lazy$18, $Lazy_collect$19, $Lazy_collect_concat$21, $Lazy_drop$25, $Lazy_drop_while$27, $Lazy_enum_for$29, $Lazy_find_all$30, $Lazy_grep$32, $Lazy_reject$35, $Lazy_take$37, $Lazy_take_while$39, $Lazy_inspect$41;

      self.$$prototype.enumerator = nil;
      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StopLazyError');

        var $nesting = [self].concat($parent_nesting);

        return nil
      })($nesting[0], $$($nesting, 'Exception'), $nesting);
      
      Opal.def(self, '$initialize', $Lazy_initialize$15 = function $$initialize(object, size) {
        var $iter = $Lazy_initialize$15.$$p, block = $iter || nil, $$16, self = this;

        if ($iter) $Lazy_initialize$15.$$p = null;
        
        
        if ($iter) $Lazy_initialize$15.$$p = null;;
        
        if (size == null) {
          size = nil;
        };
        if ((block !== nil)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $Lazy_initialize$15, false, true), 'initialize', [size], ($$16 = function(yielder, $a){var self = $$16.$$s == null ? this : $$16.$$s, $post_args, each_args, $$17;

        
          
          if (yielder == null) {
            yielder = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          each_args = $post_args;;
          try {
            return $send(object, 'each', Opal.to_a(each_args), ($$17 = function($b){var self = $$17.$$s == null ? this : $$17.$$s, $post_args, args;

            
              
              $post_args = Opal.slice.call(arguments, 0, arguments.length);
              
              args = $post_args;;
              
            args.unshift(yielder);

            Opal.yieldX(block, args);
          ;}, $$17.$$s = self, $$17.$$arity = -1, $$17))
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'Exception')])) {
              try {
                return nil
              } finally { Opal.pop_exception() }
            } else { throw $err; }
          };}, $$16.$$s = self, $$16.$$arity = -2, $$16));
      }, $Lazy_initialize$15.$$arity = -2);
      Opal.alias(self, "force", "to_a");
      
      Opal.def(self, '$lazy', $Lazy_lazy$18 = function $$lazy() {
        var self = this;

        return self
      }, $Lazy_lazy$18.$$arity = 0);
      
      Opal.def(self, '$collect', $Lazy_collect$19 = function $$collect() {
        var $iter = $Lazy_collect$19.$$p, block = $iter || nil, $$20, self = this;

        if ($iter) $Lazy_collect$19.$$p = null;
        
        
        if ($iter) $Lazy_collect$19.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, self.$enumerator_size()], ($$20 = function(enum$, $a){var self = $$20.$$s == null ? this : $$20.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          enum$.$yield(value);
        ;}, $$20.$$s = self, $$20.$$arity = -2, $$20));
      }, $Lazy_collect$19.$$arity = 0);
      
      Opal.def(self, '$collect_concat', $Lazy_collect_concat$21 = function $$collect_concat() {
        var $iter = $Lazy_collect_concat$21.$$p, block = $iter || nil, $$22, self = this;

        if ($iter) $Lazy_collect_concat$21.$$p = null;
        
        
        if ($iter) $Lazy_collect_concat$21.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$22 = function(enum$, $a){var self = $$22.$$s == null ? this : $$22.$$s, $post_args, args, $$23, $$24;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], ($$23 = function(v){var self = $$23.$$s == null ? this : $$23.$$s;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$23.$$s = self, $$23.$$arity = 1, $$23))
          }
          else {
            var array = $$($nesting, 'Opal').$try_convert(value, $$($nesting, 'Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], ($$24 = function(v){var self = $$24.$$s == null ? this : $$24.$$s;

          
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$24.$$s = self, $$24.$$arity = 1, $$24));
            }
          }
        ;}, $$22.$$s = self, $$22.$$arity = -2, $$22));
      }, $Lazy_collect_concat$21.$$arity = 0);
      
      Opal.def(self, '$drop', $Lazy_drop$25 = function $$drop(n) {
        var $$26, self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        dropped = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$26 = function(enum$, $a){var self = $$26.$$s == null ? this : $$26.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$26.$$s = self, $$26.$$arity = -2, $$26));
      }, $Lazy_drop$25.$$arity = 1);
      
      Opal.def(self, '$drop_while', $Lazy_drop_while$27 = function $$drop_while() {
        var $iter = $Lazy_drop_while$27.$$p, block = $iter || nil, $$28, self = this, succeeding = nil;

        if ($iter) $Lazy_drop_while$27.$$p = null;
        
        
        if ($iter) $Lazy_drop_while$27.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$28 = function(enum$, $a){var self = $$28.$$s == null ? this : $$28.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy(succeeding)) {
            
            var value = Opal.yieldX(block, args);

            if ($falsy(value)) {
              succeeding = false;

              $send(enum$, 'yield', Opal.to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$28.$$s = self, $$28.$$arity = -2, $$28));
      }, $Lazy_drop_while$27.$$arity = 0);
      
      Opal.def(self, '$enum_for', $Lazy_enum_for$29 = function $$enum_for($a, $b) {
        var $iter = $Lazy_enum_for$29.$$p, block = $iter || nil, $post_args, method, args, self = this;

        if ($iter) $Lazy_enum_for$29.$$p = null;
        
        
        if ($iter) $Lazy_enum_for$29.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        if ($post_args.length > 0) {
          method = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (method == null) {
          method = "each";
        };
        
        args = $post_args;;
        return $send(self.$class(), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
      }, $Lazy_enum_for$29.$$arity = -1);
      Opal.alias(self, "filter", "find_all");
      
      Opal.def(self, '$find_all', $Lazy_find_all$30 = function $$find_all() {
        var $iter = $Lazy_find_all$30.$$p, block = $iter || nil, $$31, self = this;

        if ($iter) $Lazy_find_all$30.$$p = null;
        
        
        if ($iter) $Lazy_find_all$30.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$31 = function(enum$, $a){var self = $$31.$$s == null ? this : $$31.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$31.$$s = self, $$31.$$arity = -2, $$31));
      }, $Lazy_find_all$30.$$arity = 0);
      Opal.alias(self, "flat_map", "collect_concat");
      
      Opal.def(self, '$grep', $Lazy_grep$32 = function $$grep(pattern) {
        var $iter = $Lazy_grep$32.$$p, block = $iter || nil, $$33, $$34, self = this;

        if ($iter) $Lazy_grep$32.$$p = null;
        
        
        if ($iter) $Lazy_grep$32.$$p = null;;
        if ($truthy(block)) {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$33 = function(enum$, $a){var self = $$33.$$s == null ? this : $$33.$$s, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = Opal.yield1(block, param);

              enum$.$yield(Opal.yield1(block, param));
            }
          ;}, $$33.$$s = self, $$33.$$arity = -2, $$33))
        } else {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$34 = function(enum$, $a){var self = $$34.$$s == null ? this : $$34.$$s, $post_args, args;

          
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, $$34.$$s = self, $$34.$$arity = -2, $$34))
        };
      }, $Lazy_grep$32.$$arity = 1);
      Opal.alias(self, "map", "collect");
      Opal.alias(self, "select", "find_all");
      
      Opal.def(self, '$reject', $Lazy_reject$35 = function $$reject() {
        var $iter = $Lazy_reject$35.$$p, block = $iter || nil, $$36, self = this;

        if ($iter) $Lazy_reject$35.$$p = null;
        
        
        if ($iter) $Lazy_reject$35.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$36 = function(enum$, $a){var self = $$36.$$s == null ? this : $$36.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($falsy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$36.$$s = self, $$36.$$arity = -2, $$36));
      }, $Lazy_reject$35.$$arity = 0);
      
      Opal.def(self, '$take', $Lazy_take$37 = function $$take(n) {
        var $$38, self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        taken = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$38 = function(enum$, $a){var self = $$38.$$s == null ? this : $$38.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', Opal.to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return self.$raise($$($nesting, 'StopLazyError'))
          };}, $$38.$$s = self, $$38.$$arity = -2, $$38));
      }, $Lazy_take$37.$$arity = 1);
      
      Opal.def(self, '$take_while', $Lazy_take_while$39 = function $$take_while() {
        var $iter = $Lazy_take_while$39.$$p, block = $iter || nil, $$40, self = this;

        if ($iter) $Lazy_take_while$39.$$p = null;
        
        
        if ($iter) $Lazy_take_while$39.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$40 = function(enum$, $a){var self = $$40.$$s == null ? this : $$40.$$s, $post_args, args;

        
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
          else {
            self.$raise($$($nesting, 'StopLazyError'));
          }
        ;}, $$40.$$s = self, $$40.$$arity = -2, $$40));
      }, $Lazy_take_while$39.$$arity = 0);
      Opal.alias(self, "to_enum", "enum_for");
      return (Opal.def(self, '$inspect', $Lazy_inspect$41 = function $$inspect() {
        var self = this;

        return "" + "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      }, $Lazy_inspect$41.$$arity = 0), nil) && 'inspect';
    })($nesting[0], self, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ArithmeticSequence');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/numeric"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$instance_of?', '$class', '$Float', '$respond_to?', '$coerce', '$__send__', '$===', '$raise', '$equal?', '$-', '$*', '$div', '$<', '$-@', '$ceil', '$to_f', '$denominator', '$to_r', '$==', '$floor', '$/', '$%', '$Complex', '$zero?', '$numerator', '$abs', '$arg', '$coerce_to!', '$round', '$<=>', '$compare', '$enum_for', '$to_proc', '$negative?', '$>=', '$<=', '$+', '$to_i', '$truncate', '$>']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_coerce$1, $Numeric___coerced__$2, $Numeric_$lt_eq_gt$3, $Numeric_$plus$$4, $Numeric_$minus$$5, $Numeric_$percent$6, $Numeric_abs$7, $Numeric_abs2$8, $Numeric_angle$9, $Numeric_ceil$10, $Numeric_conj$11, $Numeric_denominator$12, $Numeric_div$13, $Numeric_divmod$14, $Numeric_fdiv$15, $Numeric_floor$16, $Numeric_i$17, $Numeric_imag$18, $Numeric_integer$ques$19, $Numeric_nonzero$ques$20, $Numeric_numerator$21, $Numeric_polar$22, $Numeric_quo$23, $Numeric_real$24, $Numeric_real$ques$25, $Numeric_rect$26, $Numeric_round$27, $Numeric_step$28, $Numeric_to_c$29, $Numeric_to_int$30, $Numeric_truncate$31, $Numeric_zero$ques$32, $Numeric_positive$ques$33, $Numeric_negative$ques$34, $Numeric_dup$35, $Numeric_clone$36, $Numeric_finite$ques$37, $Numeric_infinite$ques$38;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.def(self, '$coerce', $Numeric_coerce$1 = function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]};
      return [self.$Float(other), self.$Float(self)];
    }, $Numeric_coerce$1.$$arity = 1);
    
    Opal.def(self, '$__coerced__', $Numeric___coerced__$2 = function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil, $case = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = Opal.to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else {
        return (function() {$case = method;
        if ("+"['$===']($case) || "-"['$===']($case) || "*"['$===']($case) || "/"['$===']($case) || "%"['$===']($case) || "&"['$===']($case) || "|"['$===']($case) || "^"['$===']($case) || "**"['$===']($case)) {return self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Numeric")}
        else if (">"['$===']($case) || ">="['$===']($case) || "<"['$===']($case) || "<="['$===']($case) || "<=>"['$===']($case)) {return self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")}
        else { return nil }})()
      }
    }, $Numeric___coerced__$2.$$arity = 2);
    
    Opal.def(self, '$<=>', $Numeric_$lt_eq_gt$3 = function(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0};
      return nil;
    }, $Numeric_$lt_eq_gt$3.$$arity = 1);
    
    Opal.def(self, '$+@', $Numeric_$plus$$4 = function() {
      var self = this;

      return self
    }, $Numeric_$plus$$4.$$arity = 0);
    
    Opal.def(self, '$-@', $Numeric_$minus$$5 = function() {
      var self = this;

      return $rb_minus(0, self)
    }, $Numeric_$minus$$5.$$arity = 0);
    
    Opal.def(self, '$%', $Numeric_$percent$6 = function(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    }, $Numeric_$percent$6.$$arity = 1);
    
    Opal.def(self, '$abs', $Numeric_abs$7 = function $$abs() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return self['$-@']()
      } else {
        return self
      }
    }, $Numeric_abs$7.$$arity = 0);
    
    Opal.def(self, '$abs2', $Numeric_abs2$8 = function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    }, $Numeric_abs2$8.$$arity = 0);
    
    Opal.def(self, '$angle', $Numeric_angle$9 = function $$angle() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return $$$($$($nesting, 'Math'), 'PI')
      } else {
        return 0
      }
    }, $Numeric_angle$9.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    
    Opal.def(self, '$ceil', $Numeric_ceil$10 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$ceil(ndigits);
    }, $Numeric_ceil$10.$$arity = -1);
    
    Opal.def(self, '$conj', $Numeric_conj$11 = function $$conj() {
      var self = this;

      return self
    }, $Numeric_conj$11.$$arity = 0);
    Opal.alias(self, "conjugate", "conj");
    
    Opal.def(self, '$denominator', $Numeric_denominator$12 = function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    }, $Numeric_denominator$12.$$arity = 0);
    
    Opal.def(self, '$div', $Numeric_div$13 = function $$div(other) {
      var self = this;

      
      if (other['$=='](0)) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by o")};
      return $rb_divide(self, other).$floor();
    }, $Numeric_div$13.$$arity = 1);
    
    Opal.def(self, '$divmod', $Numeric_divmod$14 = function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    }, $Numeric_divmod$14.$$arity = 1);
    
    Opal.def(self, '$fdiv', $Numeric_fdiv$15 = function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    }, $Numeric_fdiv$15.$$arity = 1);
    
    Opal.def(self, '$floor', $Numeric_floor$16 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$floor(ndigits);
    }, $Numeric_floor$16.$$arity = -1);
    
    Opal.def(self, '$i', $Numeric_i$17 = function $$i() {
      var self = this;

      return self.$Complex(0, self)
    }, $Numeric_i$17.$$arity = 0);
    
    Opal.def(self, '$imag', $Numeric_imag$18 = function $$imag() {
      var self = this;

      return 0
    }, $Numeric_imag$18.$$arity = 0);
    Opal.alias(self, "imaginary", "imag");
    
    Opal.def(self, '$integer?', $Numeric_integer$ques$19 = function() {
      var self = this;

      return false
    }, $Numeric_integer$ques$19.$$arity = 0);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.def(self, '$nonzero?', $Numeric_nonzero$ques$20 = function() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    }, $Numeric_nonzero$ques$20.$$arity = 0);
    
    Opal.def(self, '$numerator', $Numeric_numerator$21 = function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    }, $Numeric_numerator$21.$$arity = 0);
    Opal.alias(self, "phase", "arg");
    
    Opal.def(self, '$polar', $Numeric_polar$22 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, $Numeric_polar$22.$$arity = 0);
    
    Opal.def(self, '$quo', $Numeric_quo$23 = function $$quo(other) {
      var self = this;

      return $rb_divide($$($nesting, 'Opal')['$coerce_to!'](self, $$($nesting, 'Rational'), "to_r"), other)
    }, $Numeric_quo$23.$$arity = 1);
    
    Opal.def(self, '$real', $Numeric_real$24 = function $$real() {
      var self = this;

      return self
    }, $Numeric_real$24.$$arity = 0);
    
    Opal.def(self, '$real?', $Numeric_real$ques$25 = function() {
      var self = this;

      return true
    }, $Numeric_real$ques$25.$$arity = 0);
    
    Opal.def(self, '$rect', $Numeric_rect$26 = function $$rect() {
      var self = this;

      return [self, 0]
    }, $Numeric_rect$26.$$arity = 0);
    Opal.alias(self, "rectangular", "rect");
    
    Opal.def(self, '$round', $Numeric_round$27 = function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, $Numeric_round$27.$$arity = -1);
    
    Opal.def(self, '$step', $Numeric_step$28 = function $$step($a, $b, $c) {
      var $iter = $Numeric_step$28.$$p, block = $iter || nil, $post_args, $kwargs, limit, step, to, by, $d, self = this, counter = nil;

      if ($iter) $Numeric_step$28.$$p = null;
      
      
      if ($iter) $Numeric_step$28.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) {
        limit = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      if ($post_args.length > 0) {
        step = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      to = $kwargs.$$smap["to"];;
      
      by = $kwargs.$$smap["by"];;
      
      if (limit !== undefined && to !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "step is given twice")
      }

      if (to !== undefined) {
        limit = to;
      }

      if (by !== undefined) {
        step = by;
      }

      if (limit === undefined) {
        limit = nil;
      }

      function validateParameters() {
        if (step === nil) {
          self.$raise($$($nesting, 'TypeError'), "step must be numeric")
        }

        if (step != null && step['$=='](0)) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$($nesting, 'Float'), 'INFINITY') : $$$($$($nesting, 'Float'), 'INFINITY')['$-@']();
        }

        $$($nesting, 'Opal').$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$($nesting, 'Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }

    ;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["step", limit, step], (stepSize).$to_proc())
      };
      
      validateParameters();

      var isDesc = step['$negative?'](),
          isInf = step['$=='](0) ||
                  (limit === Infinity && !isDesc) ||
                  (limit === -Infinity && isDesc);

      if (self.$$is_number && step.$$is_number && limit.$$is_number) {
        if (self % 1 === 0 && (isInf || limit % 1 === 0) && step % 1 === 0) {
          var value = self;

          if (isInf) {
            for (;; value += step) {
              block(value);
            }
          } else if (isDesc) {
            for (; value >= limit; value += step) {
              block(value);
            }
          } else {
            for (; value <= limit; value += step) {
              block(value);
            }
          }

          return self;
        } else {
          var begin = self.$to_f().valueOf();
          step = step.$to_f().valueOf();
          limit = limit.$to_f().valueOf();

          var n = stepFloatSize();

          if (!isFinite(step)) {
            if (n !== 0) block(begin);
          } else if (step === 0) {
            while (true) {
              block(begin);
            }
          } else {
            for (var i = 0; i < n; i++) {
              var d = i * step + self;
              if (step >= 0 ? limit < d : limit > d) {
                d = limit;
              }
              block(d);
            }
          }

          return self;
        }
      }
    ;
      counter = self;
      while ($truthy(isDesc ? $rb_ge(counter, limit) : $rb_le(counter, limit))) {
        
        Opal.yield1(block, counter);
        counter = $rb_plus(counter, step);
      };
    }, $Numeric_step$28.$$arity = -1);
    
    Opal.def(self, '$to_c', $Numeric_to_c$29 = function $$to_c() {
      var self = this;

      return self.$Complex(self, 0)
    }, $Numeric_to_c$29.$$arity = 0);
    
    Opal.def(self, '$to_int', $Numeric_to_int$30 = function $$to_int() {
      var self = this;

      return self.$to_i()
    }, $Numeric_to_int$30.$$arity = 0);
    
    Opal.def(self, '$truncate', $Numeric_truncate$31 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$truncate(ndigits);
    }, $Numeric_truncate$31.$$arity = -1);
    
    Opal.def(self, '$zero?', $Numeric_zero$ques$32 = function() {
      var self = this;

      return self['$=='](0)
    }, $Numeric_zero$ques$32.$$arity = 0);
    
    Opal.def(self, '$positive?', $Numeric_positive$ques$33 = function() {
      var self = this;

      return $rb_gt(self, 0)
    }, $Numeric_positive$ques$33.$$arity = 0);
    
    Opal.def(self, '$negative?', $Numeric_negative$ques$34 = function() {
      var self = this;

      return $rb_lt(self, 0)
    }, $Numeric_negative$ques$34.$$arity = 0);
    
    Opal.def(self, '$dup', $Numeric_dup$35 = function $$dup() {
      var self = this;

      return self
    }, $Numeric_dup$35.$$arity = 0);
    
    Opal.def(self, '$clone', $Numeric_clone$36 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Numeric_clone$36.$$arity = -1);
    
    Opal.def(self, '$finite?', $Numeric_finite$ques$37 = function() {
      var self = this;

      return true
    }, $Numeric_finite$ques$37.$$arity = 0);
    return (Opal.def(self, '$infinite?', $Numeric_infinite$ques$38 = function() {
      var self = this;

      return nil
    }, $Numeric_infinite$ques$38.$$arity = 0), nil) && 'infinite?';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/array"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $falsy = Opal.falsy, $hash_ids = Opal.hash_ids, $yield1 = Opal.yield1, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $klass = Opal.klass, $hash2 = Opal.hash2, $send2 = Opal.send2, $send = Opal.send, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$to_a', '$warn', '$raise', '$replace', '$respond_to?', '$to_ary', '$coerce_to?', '$===', '$join', '$to_str', '$hash', '$<=>', '$==', '$object_id', '$inspect', '$enum_for', '$class', '$bsearch_index', '$to_proc', '$nil?', '$coerce_to!', '$>', '$*', '$enumerator_size', '$empty?', '$size', '$map', '$equal?', '$dup', '$each', '$reduce', '$-', '$[]', '$dig', '$eql?', '$length', '$exclude_end?', '$flatten', '$__id__', '$&', '$to_s', '$new', '$max', '$min', '$!', '$>=', '$**', '$delete_if', '$reverse', '$rotate', '$rand', '$at', '$keep_if', '$shuffle!', '$<', '$sort', '$sort_by', '$!=', '$times', '$[]=', '$<<', '$uniq', '$|', '$values', '$is_a?', '$last', '$first', '$upto', '$reject', '$pristine', '$singleton_class']);
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_$$$1, $Array_initialize$2, $Array_try_convert$3, $Array_$$4, $Array_$$5, $Array_$$6, $Array_$plus$7, $Array_$minus$8, $Array_$lt$lt$9, $Array_$lt_eq_gt$10, $Array_$eq_eq$11, $Array_$$$12, $Array_$$$eq$13, $Array_any$ques$14, $Array_assoc$15, $Array_at$16, $Array_bsearch_index$17, $Array_bsearch$18, $Array_cycle$19, $Array_clear$21, $Array_count$22, $Array_initialize_copy$23, $Array_collect$24, $Array_collect$excl$26, $Array_combination$28, $Array_repeated_combination$30, $Array_compact$32, $Array_compact$excl$33, $Array_concat$34, $Array_delete$37, $Array_delete_at$38, $Array_delete_if$39, $Array_difference$41, $Array_dig$43, $Array_drop$44, $Array_dup$45, $Array_each$46, $Array_each_index$48, $Array_empty$ques$50, $Array_eql$ques$51, $Array_fetch$52, $Array_fill$53, $Array_first$54, $Array_flatten$55, $Array_flatten$excl$56, $Array_hash$57, $Array_include$ques$58, $Array_index$59, $Array_insert$60, $Array_inspect$61, $Array_intersection$62, $Array_join$64, $Array_keep_if$65, $Array_last$67, $Array_length$68, $Array_max$69, $Array_min$70, $Array_permutation$71, $Array_repeated_permutation$73, $Array_pop$75, $Array_product$76, $Array_push$77, $Array_rassoc$78, $Array_reject$79, $Array_reject$excl$81, $Array_replace$83, $Array_reverse$84, $Array_reverse$excl$85, $Array_reverse_each$86, $Array_rindex$88, $Array_rotate$89, $Array_rotate$excl$90, $Array_sample$93, $Array_select$94, $Array_select$excl$96, $Array_shift$98, $Array_shuffle$99, $Array_shuffle$excl$100, $Array_slice$excl$101, $Array_sort$102, $Array_sort$excl$103, $Array_sort_by$excl$104, $Array_take$106, $Array_take_while$107, $Array_to_a$108, $Array_to_ary$109, $Array_to_h$110, $Array_transpose$111, $Array_union$114, $Array_uniq$116, $Array_uniq$excl$117, $Array_unshift$118, $Array_values_at$119, $Array_zip$122, $Array_inherited$123, $Array_instance_variables$124, $Array_pack$126;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defineProperty(self.$$prototype, '$$is_array', true);
    
    // Recent versions of V8 (> 7.1) only use an optimized implementation when Array.prototype is unmodified.
    // For instance, "array-splice.tq" has a "fast path" (ExtractFastJSArray, defined in "src/codegen/code-stub-assembler.cc")
    // but it's only enabled when "IsPrototypeInitialArrayPrototype()" is true.
    //
    // Older versions of V8 were using relatively fast JS-with-extensions code even when Array.prototype is modified:
    // https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642
    //
    // In short, Array operations are slow in recent versions of V8 when the Array.prototype has been tampered.
    // So, when possible, we are using faster open-coded version to boost the performance.

    // As of V8 8.4, depending on the size of the array, this is up to ~25x times faster than Array#shift()
    // Implementation is heavily inspired by: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L341-L347
    function shiftNoArg(list) {
      var r = list[0];
      var index = 1;
      var length = list.length;
      for (; index < length; index++) {
        list[index - 1] = list[index];
      }
      list.pop();
      return r;
    }

    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }

    // A helper for keep_if and delete_if, filter is either Opal.truthy
    // or Opal.falsy.
    function filterIf(self, filter, block) {
      var value, raised = null, updated = new Array(self.length);

      for (var i = 0, i2 = 0, length = self.length; i < length; i++) {
        if (!raised) {
          try {
            value = $yield1(block, self[i])
          } catch(error) {
            raised = error;
          }
        }

        if (raised || filter(value)) {
          updated[i2] = self[i]
          i2 += 1;
        }
      }

      if (i2 !== i) {
        self.splice.apply(self, [0, updated.length].concat(updated));
        self.splice(i2, updated.length);
      }

      if (raised) throw raised;
    }
  ;
    Opal.defs(self, '$[]', $Array_$$$1 = function($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      return toArraySubclass(objects, self);;
    }, $Array_$$$1.$$arity = -1);
    
    Opal.def(self, '$initialize', $Array_initialize$2 = function $$initialize(size, obj) {
      var $iter = $Array_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_initialize$2.$$p = null;
      
      
      if ($iter) $Array_initialize$2.$$p = null;;
      
      if (size == null) {
        size = nil;
      };
      
      if (obj == null) {
        obj = nil;
      };
      
      if (obj !== nil && block !== nil) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$($nesting, 'Integer'), 'MAX')) {
        self.$raise($$($nesting, 'ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $coerce_to(size, $$($nesting, 'Integer'), 'to_int');

      if (size < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, $Array_initialize$2.$$arity = -1);
    Opal.defs(self, '$try_convert', $Array_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Array'), "to_ary")
    }, $Array_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$&', $Array_$$4 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Array_$$5 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      
      var hash = $hash2([], {}), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        $hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    }, $Array_$$5.$$arity = 1);
    
    Opal.def(self, '$*', $Array_$$6 = function(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())};
      other = $coerce_to(other, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(other < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")};
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return result;
    ;
    }, $Array_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $Array_$plus$7 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      return self.concat(other);;
    }, $Array_$plus$7.$$arity = 1);
    
    Opal.def(self, '$-', $Array_$minus$8 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(other.length === 0)) {
        return self.slice()};
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$minus$8.$$arity = 1);
    
    Opal.def(self, '$<<', $Array_$lt$lt$9 = function(object) {
      var self = this;

      
      self.push(object);
      return self;
    }, $Array_$lt$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=>', $Array_$lt_eq_gt$10 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Array')['$==='](other))) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self.$hash() === other.$hash()) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    }, $Array_$lt_eq_gt$10.$$arity = 1);
    
    Opal.def(self, '$==', $Array_$eq_eq$11 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($respond_to(other, '$to_ary')) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    }, $Array_$eq_eq$11.$$arity = 1);
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = $coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = $coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude) {
        to += 1;
      }

      result = self.slice(from, to);
      return result;
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = $coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = $coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return result;
    }
  ;
    
    Opal.def(self, '$[]', $Array_$$$12 = function(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, $Array_$$$12.$$arity = -2);
    
    Opal.def(self, '$[]=', $Array_$$$eq$13 = function(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
            var i, size = self.length;;
      if ($truthy($$($nesting, 'Range')['$==='](index))) {
        
        data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
          return value.$to_a()
        } else if ($truthy(value['$respond_to?']("to_ary"))) {
          return value.$to_ary().$to_a()
        } else {
          return [value]
        }; return nil; })();
        
        var exclude = index.excl,
            from    = $coerce_to(index.begin, $$($nesting, 'Integer'), 'to_int'),
            to      = $coerce_to(index.end, $$($nesting, 'Integer'), 'to_int');

        if (from < 0) {
          from += size;

          if (from < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      ;
      } else {
        
        if ($truthy(extra === undefined)) {
          length = 1
        } else {
          
          length = value;
          value = extra;
          data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
            return value.$to_a()
          } else if ($truthy(value['$respond_to?']("to_ary"))) {
            return value.$to_ary().$to_a()
          } else {
            return [value]
          }; return nil; })();
        };
        
        var old;

        index  = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');
        length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          self.$raise($$($nesting, 'IndexError'), "" + "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      ;
      };
    }, $Array_$$$eq$13.$$arity = -3);
    
    Opal.def(self, '$any?', $Array_any$ques$14 = function(pattern) {
      var $iter = $Array_any$ques$14.$$p, block = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_any$ques$14.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_any$ques$14.$$p = null;;
      ;
      if (self.length === 0) return false;
      return $send2(self, Opal.find_super_dispatcher(self, 'any?', $Array_any$ques$14, false, true), 'any?', $zuper, $iter);
    }, $Array_any$ques$14.$$arity = -1);
    
    Opal.def(self, '$assoc', $Array_assoc$15 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    }, $Array_assoc$15.$$arity = 1);
    
    Opal.def(self, '$at', $Array_at$16 = function $$at(index) {
      var self = this;

      
      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int')

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    
    }, $Array_at$16.$$arity = 1);
    
    Opal.def(self, '$bsearch_index', $Array_bsearch_index$17 = function $$bsearch_index() {
      var $iter = $Array_bsearch_index$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_bsearch_index$17.$$p = null;
      
      
      if ($iter) $Array_bsearch_index$17.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = $yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    }, $Array_bsearch_index$17.$$arity = 0);
    
    Opal.def(self, '$bsearch', $Array_bsearch$18 = function $$bsearch() {
      var $iter = $Array_bsearch$18.$$p, block = $iter || nil, self = this, index = nil;

      if ($iter) $Array_bsearch$18.$$p = null;
      
      
      if ($iter) $Array_bsearch$18.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    }, $Array_bsearch$18.$$arity = 0);
    
    Opal.def(self, '$cycle', $Array_cycle$19 = function $$cycle(n) {
      var $iter = $Array_cycle$19.$$p, block = $iter || nil, $$20, self = this, $ret_or_1 = nil;

      if ($iter) $Array_cycle$19.$$p = null;
      
      
      if ($iter) $Array_cycle$19.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$20 = function(){var self = $$20.$$s == null ? this : $$20.$$s;

        if ($truthy(n['$nil?']())) {
            return $$$($$($nesting, 'Float'), 'INFINITY')
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$20.$$s = self, $$20.$$arity = 0, $$20))
      };
      if ($truthy((function() {if ($truthy(($ret_or_1 = self['$empty?']()))) {
        return $ret_or_1
      } else {
        return n['$=='](0)
      }; return nil; })())) {
        return nil};
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }
        }
      }
      else {
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, $Array_cycle$19.$$arity = -1);
    
    Opal.def(self, '$clear', $Array_clear$21 = function $$clear() {
      var self = this;

      
      self.splice(0, self.length);
      return self;
    }, $Array_clear$21.$$arity = 0);
    
    Opal.def(self, '$count', $Array_count$22 = function $$count(object) {
      var $iter = $Array_count$22.$$p, block = $iter || nil, self = this, $ret_or_2 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_count$22.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_count$22.$$p = null;;
      
      if (object == null) {
        object = nil;
      };
      if ($truthy((function() {if ($truthy(($ret_or_2 = object))) {
        return $ret_or_2
      } else {
        return block
      }; return nil; })())) {
        return $send2(self, Opal.find_super_dispatcher(self, 'count', $Array_count$22, false, true), 'count', $zuper, $iter)
      } else {
        return self.$size()
      };
    }, $Array_count$22.$$arity = -1);
    
    Opal.def(self, '$initialize_copy', $Array_initialize_copy$23 = function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    }, $Array_initialize_copy$23.$$arity = 1);
    
    Opal.def(self, '$collect', $Array_collect$24 = function $$collect() {
      var $iter = $Array_collect$24.$$p, block = $iter || nil, $$25, self = this;

      if ($iter) $Array_collect$24.$$p = null;
      
      
      if ($iter) $Array_collect$24.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$25 = function(){var self = $$25.$$s == null ? this : $$25.$$s;

        return self.$size()}, $$25.$$s = self, $$25.$$arity = 0, $$25))
      };
      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        result.push(value);
      }

      return result;
    ;
    }, $Array_collect$24.$$arity = 0);
    
    Opal.def(self, '$collect!', $Array_collect$excl$26 = function() {
      var $iter = $Array_collect$excl$26.$$p, block = $iter || nil, $$27, self = this;

      if ($iter) $Array_collect$excl$26.$$p = null;
      
      
      if ($iter) $Array_collect$excl$26.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect!"], ($$27 = function(){var self = $$27.$$s == null ? this : $$27.$$s;

        return self.$size()}, $$27.$$s = self, $$27.$$arity = 0, $$27))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    }, $Array_collect$excl$26.$$arity = 0);
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    Opal.def(self, '$combination', $Array_combination$28 = function $$combination(n) {
      var $$29, $iter = $Array_combination$28.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_combination$28.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["combination", num], ($$29 = function(){var self = $$29.$$s == null ? this : $$29.$$s;

        return binomial_coefficient(self.length, num)}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    }, $Array_combination$28.$$arity = 1);
    
    Opal.def(self, '$repeated_combination', $Array_repeated_combination$30 = function $$repeated_combination(n) {
      var $$31, $iter = $Array_repeated_combination$30.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_combination$30.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_combination", num], ($$31 = function(){var self = $$31.$$s == null ? this : $$31.$$s;

        return binomial_coefficient(self.length + num - 1, num);}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    }, $Array_repeated_combination$30.$$arity = 1);
    
    Opal.def(self, '$compact', $Array_compact$32 = function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    }, $Array_compact$32.$$arity = 0);
    
    Opal.def(self, '$compact!', $Array_compact$excl$33 = function() {
      var self = this;

      
      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    }, $Array_compact$excl$33.$$arity = 0);
    
    Opal.def(self, '$concat', $Array_concat$34 = function $$concat($a) {
      var $post_args, others, $$35, $$36, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      others = $send(others, 'map', [], ($$35 = function(other){var self = $$35.$$s == null ? this : $$35.$$s;

      
        
        if (other == null) {
          other = nil;
        };
        other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
          return other.$to_a()
        } else {
          return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
        }; return nil; })();
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()};
        return other;}, $$35.$$s = self, $$35.$$arity = 1, $$35));
      $send(others, 'each', [], ($$36 = function(other){var self = $$36.$$s == null ? this : $$36.$$s;

      
        
        if (other == null) {
          other = nil;
        };
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, $$36.$$s = self, $$36.$$arity = 1, $$36));
      return self;
    }, $Array_concat$34.$$arity = -1);
    
    Opal.def(self, '$delete', $Array_delete$37 = function(object) {
      var $iter = $Array_delete$37.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Array_delete$37.$$p = null;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    }, $Array_delete$37.$$arity = 1);
    
    Opal.def(self, '$delete_at', $Array_delete_at$38 = function $$delete_at(index) {
      var self = this;

      
      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    }, $Array_delete_at$38.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Array_delete_if$39 = function $$delete_if() {
      var $iter = $Array_delete_if$39.$$p, block = $iter || nil, $$40, self = this;

      if ($iter) $Array_delete_if$39.$$p = null;
      
      
      if ($iter) $Array_delete_if$39.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$40 = function(){var self = $$40.$$s == null ? this : $$40.$$s;

        return self.$size()}, $$40.$$s = self, $$40.$$arity = 0, $$40))
      };
      filterIf(self, $falsy, block);
      return self;
    }, $Array_delete_if$39.$$arity = 0);
    
    Opal.def(self, '$difference', $Array_difference$41 = function $$difference($a) {
      var $post_args, arrays, $$42, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], ($$42 = function(a, b){var self = $$42.$$s == null ? this : $$42.$$s;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return $rb_minus(a, b);}, $$42.$$s = self, $$42.$$arity = 2, $$42));
    }, $Array_difference$41.$$arity = -1);
    
    Opal.def(self, '$dig', $Array_dig$43 = function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      idxs = $post_args;;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(idxs));
    }, $Array_dig$43.$$arity = -2);
    
    Opal.def(self, '$drop', $Array_drop$44 = function $$drop(number) {
      var self = this;

      
      if (number < 0) {
        self.$raise($$($nesting, 'ArgumentError'))
      }

      return self.slice(number);
    
    }, $Array_drop$44.$$arity = 1);
    
    Opal.def(self, '$dup', $Array_dup$45 = function $$dup() {
      var $iter = $Array_dup$45.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_dup$45.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send2(self, Opal.find_super_dispatcher(self, 'dup', $Array_dup$45, false, true), 'dup', $zuper, $iter);
    }, $Array_dup$45.$$arity = 0);
    
    Opal.def(self, '$each', $Array_each$46 = function $$each() {
      var $iter = $Array_each$46.$$p, block = $iter || nil, $$47, self = this;

      if ($iter) $Array_each$46.$$p = null;
      
      
      if ($iter) $Array_each$46.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$47 = function(){var self = $$47.$$s == null ? this : $$47.$$s;

        return self.$size()}, $$47.$$s = self, $$47.$$arity = 0, $$47))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
      }
    ;
      return self;
    }, $Array_each$46.$$arity = 0);
    
    Opal.def(self, '$each_index', $Array_each_index$48 = function $$each_index() {
      var $iter = $Array_each_index$48.$$p, block = $iter || nil, $$49, self = this;

      if ($iter) $Array_each_index$48.$$p = null;
      
      
      if ($iter) $Array_each_index$48.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_index"], ($$49 = function(){var self = $$49.$$s == null ? this : $$49.$$s;

        return self.$size()}, $$49.$$s = self, $$49.$$arity = 0, $$49))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, i);
      }
    ;
      return self;
    }, $Array_each_index$48.$$arity = 0);
    
    Opal.def(self, '$empty?', $Array_empty$ques$50 = function() {
      var self = this;

      return self.length === 0;
    }, $Array_empty$ques$50.$$arity = 0);
    
    Opal.def(self, '$eql?', $Array_eql$ques$51 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    }, $Array_eql$ques$51.$$arity = 1);
    
    Opal.def(self, '$fetch', $Array_fetch$52 = function $$fetch(index, defaults) {
      var $iter = $Array_fetch$52.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_fetch$52.$$p = null;
      
      
      if ($iter) $Array_fetch$52.$$p = null;;
      ;
      
      var original = index;

      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    ;
    }, $Array_fetch$52.$$arity = -2);
    
    Opal.def(self, '$fill', $Array_fill$53 = function $$fill($a) {
      var $iter = $Array_fill$53.$$p, block = $iter || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      if ($iter) $Array_fill$53.$$p = null;
      
      
      if ($iter) $Array_fill$53.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
            var i, length, value;;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 0..2)")};
        $c = args, $b = Opal.to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 1..3)")};
        $c = args, $b = Opal.to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($truthy($$($nesting, 'Range')['$==='](one))) {
        
        if ($truthy(two)) {
          self.$raise($$($nesting, 'TypeError'), "length invalid with range")};
        left = $coerce_to(one.begin, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          self.$raise($$($nesting, 'RangeError'), "" + (one.$inspect()) + " out of range")};
        right = $coerce_to(one.end, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(right < 0)) {
          right += this.length};
        if ($truthy(one['$exclude_end?']())) {
        } else {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self};
      } else if ($truthy(one)) {
        
        left = $coerce_to(one, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          left = 0};
        if ($truthy(two)) {
          
          right = $coerce_to(two, $$($nesting, 'Integer'), 'to_int');
          if ($truthy(right == 0)) {
            return self};
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      };
      if ($truthy(right > this.length)) {
        this.length = right};
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, $Array_fill$53.$$arity = -1);
    
    Opal.def(self, '$first', $Array_first$54 = function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, $Array_first$54.$$arity = -1);
    
    Opal.def(self, '$flatten', $Array_flatten$55 = function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$respond_to(item, '$to_ary', true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            self.$raise($$($nesting, 'TypeError'));
          }

          if (ary === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            result.push.apply(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $coerce_to(level, $$($nesting, 'Integer'), 'to_int');
      }

      return _flatten(self, level);
    ;
    }, $Array_flatten$55.$$arity = -1);
    
    Opal.def(self, '$flatten!', $Array_flatten$excl$56 = function(level) {
      var self = this;

      
      ;
      
      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, $Array_flatten$excl$56.$$arity = -1);
    
    Opal.def(self, '$hash', $Array_hash$57 = function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          result = ['A'],
          hash_id = self.$object_id(),
          item, i, key;

      try {
        if (top) {
          $hash_ids = Object.create(null);
        }

        // return early for recursive structures
        if ($hash_ids[hash_id]) {
          return 'self';
        }

        for (key in $hash_ids) {
          item = $hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        $hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result.push(item.$hash());
        }

        return result.join(',');
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    }, $Array_hash$57.$$arity = 0);
    
    Opal.def(self, '$include?', $Array_include$ques$58 = function(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    }, $Array_include$ques$58.$$arity = 1);
    
    Opal.def(self, '$index', $Array_index$59 = function $$index(object) {
      var $iter = $Array_index$59.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_index$59.$$p = null;
      
      
      if ($iter) $Array_index$59.$$p = null;;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0, length = self.length; i < length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, $Array_index$59.$$arity = -1);
    
    Opal.def(self, '$insert', $Array_insert$60 = function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      objects = $post_args;;
      
      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, $Array_insert$60.$$arity = -2);
    
    Opal.def(self, '$inspect', $Array_inspect$61 = function $$inspect() {
      var self = this;

      
      var result = [],
          id     = self.$__id__();

      for (var i = 0, length = self.length; i < length; i++) {
        var item = self['$[]'](i);

        if ((item).$__id__() === id) {
          result.push('[...]');
        }
        else {
          result.push((item).$inspect());
        }
      }

      return '[' + result.join(', ') + ']';
    
    }, $Array_inspect$61.$$arity = 0);
    
    Opal.def(self, '$intersection', $Array_intersection$62 = function $$intersection($a) {
      var $post_args, arrays, $$63, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], ($$63 = function(a, b){var self = $$63.$$s == null ? this : $$63.$$s;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a['$&'](b);}, $$63.$$s = self, $$63.$$arity = 2, $$63));
    }, $Array_intersection$62.$$arity = -1);
    
    Opal.def(self, '$join', $Array_join$64 = function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      
      if (sep == null) {
        sep = nil;
      };
      if ($truthy(self.length === 0)) {
        return ""};
      if ($truthy(sep === nil)) {
        sep = $gvars[","]};
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($respond_to(item, '$to_str')) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($respond_to(item, '$to_ary')) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($respond_to(item, '$to_s')) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        self.$raise($$($nesting, 'NoMethodError').$new("" + (Opal.inspect(item)) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($$($nesting, 'Opal')['$coerce_to!'](sep, $$($nesting, 'String'), "to_str").$to_s());
      }
    ;
    }, $Array_join$64.$$arity = -1);
    
    Opal.def(self, '$keep_if', $Array_keep_if$65 = function $$keep_if() {
      var $iter = $Array_keep_if$65.$$p, block = $iter || nil, $$66, self = this;

      if ($iter) $Array_keep_if$65.$$p = null;
      
      
      if ($iter) $Array_keep_if$65.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$66 = function(){var self = $$66.$$s == null ? this : $$66.$$s;

        return self.$size()}, $$66.$$s = self, $$66.$$arity = 0, $$66))
      };
      filterIf(self, $truthy, block);
      return self;
    }, $Array_keep_if$65.$$arity = 0);
    
    Opal.def(self, '$last', $Array_last$67 = function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, $Array_last$67.$$arity = -1);
    
    Opal.def(self, '$length', $Array_length$68 = function $$length() {
      var self = this;

      return self.length;
    }, $Array_length$68.$$arity = 0);
    Opal.alias(self, "map", "collect");
    Opal.alias(self, "map!", "collect!");
    
    Opal.def(self, '$max', $Array_max$69 = function $$max(n) {
      var $iter = $Array_max$69.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_max$69.$$p = null;
      
      
      if ($iter) $Array_max$69.$$p = null;;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, $Array_max$69.$$arity = -1);
    
    Opal.def(self, '$min', $Array_min$70 = function $$min() {
      var $iter = $Array_min$70.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_min$70.$$p = null;
      
      
      if ($iter) $Array_min$70.$$p = null;;
      return $send(self.$each(), 'min', [], block.$to_proc());
    }, $Array_min$70.$$arity = 0);
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    Opal.def(self, '$permutation', $Array_permutation$71 = function $$permutation(num) {
      var $iter = $Array_permutation$71.$$p, block = $iter || nil, $$72, self = this, perm = nil, used = nil;

      if ($iter) $Array_permutation$71.$$p = null;
      
      
      if ($iter) $Array_permutation$71.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["permutation", num], ($$72 = function(){var self = $$72.$$s == null ? this : $$72.$$s;

        return descending_factorial(self.length, num === undefined ? self.length : num);}, $$72.$$s = self, $$72.$$arity = 0, $$72))
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $coerce_to(num, $$($nesting, 'Integer'), 'to_int');
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$($nesting, 'Array').$new(num));
        (used = $$($nesting, 'Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                $yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, $Array_permutation$71.$$arity = -1);
    
    Opal.def(self, '$repeated_permutation', $Array_repeated_permutation$73 = function $$repeated_permutation(n) {
      var $$74, $iter = $Array_repeated_permutation$73.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_permutation$73.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_permutation", num], ($$74 = function(){var self = $$74.$$s == null ? this : $$74.$$s;

        if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, $$74.$$s = self, $$74.$$arity = 0, $$74))
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    }, $Array_repeated_permutation$73.$$arity = 1);
    
    Opal.def(self, '$pop', $Array_pop$75 = function $$pop(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return self.pop();};
      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(count === 1)) {
        return [self.pop()];
      } else if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, $Array_pop$75.$$arity = -1);
    
    Opal.def(self, '$product', $Array_product$76 = function $$product($a) {
      var $iter = $Array_product$76.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Array_product$76.$$p = null;
      
      
      if ($iter) $Array_product$76.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $coerce_to(args[i - 1], $$($nesting, 'Array'), 'to_ary');
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          self.$raise($$($nesting, 'RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, $Array_product$76.$$arity = -1);
    
    Opal.def(self, '$push', $Array_push$77 = function $$push($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      for (var i = 0, length = objects.length; i < length; i++) {
        self.push(objects[i]);
      }
    ;
      return self;
    }, $Array_push$77.$$arity = -1);
    Opal.alias(self, "append", "push");
    
    Opal.def(self, '$rassoc', $Array_rassoc$78 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    }, $Array_rassoc$78.$$arity = 1);
    
    Opal.def(self, '$reject', $Array_reject$79 = function $$reject() {
      var $iter = $Array_reject$79.$$p, block = $iter || nil, $$80, self = this;

      if ($iter) $Array_reject$79.$$p = null;
      
      
      if ($iter) $Array_reject$79.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$80 = function(){var self = $$80.$$s == null ? this : $$80.$$s;

        return self.$size()}, $$80.$$s = self, $$80.$$arity = 0, $$80))
      };
      
      var result = [];

      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    }, $Array_reject$79.$$arity = 0);
    
    Opal.def(self, '$reject!', $Array_reject$excl$81 = function() {
      var $iter = $Array_reject$excl$81.$$p, block = $iter || nil, $$82, self = this, original = nil;

      if ($iter) $Array_reject$excl$81.$$p = null;
      
      
      if ($iter) $Array_reject$excl$81.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$82 = function(){var self = $$82.$$s == null ? this : $$82.$$s;

        return self.$size()}, $$82.$$s = self, $$82.$$arity = 0, $$82))
      };
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if (self.$length()['$=='](original)) {
        return nil
      } else {
        return self
      };
    }, $Array_reject$excl$81.$$arity = 0);
    
    Opal.def(self, '$replace', $Array_replace$83 = function $$replace(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      
      self.splice(0, self.length);
      self.push.apply(self, other);
    ;
      return self;
    }, $Array_replace$83.$$arity = 1);
    
    Opal.def(self, '$reverse', $Array_reverse$84 = function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    }, $Array_reverse$84.$$arity = 0);
    
    Opal.def(self, '$reverse!', $Array_reverse$excl$85 = function() {
      var self = this;

      return self.reverse();
    }, $Array_reverse$excl$85.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Array_reverse_each$86 = function $$reverse_each() {
      var $iter = $Array_reverse_each$86.$$p, block = $iter || nil, $$87, self = this;

      if ($iter) $Array_reverse_each$86.$$p = null;
      
      
      if ($iter) $Array_reverse_each$86.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$87 = function(){var self = $$87.$$s == null ? this : $$87.$$s;

        return self.$size()}, $$87.$$s = self, $$87.$$arity = 0, $$87))
      };
      $send(self.$reverse(), 'each', [], block.$to_proc());
      return self;
    }, $Array_reverse_each$86.$$arity = 0);
    
    Opal.def(self, '$rindex', $Array_rindex$88 = function $$rindex(object) {
      var $iter = $Array_rindex$88.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_rindex$88.$$p = null;
      
      
      if ($iter) $Array_rindex$88.$$p = null;;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, $Array_rindex$88.$$arity = -1);
    
    Opal.def(self, '$rotate', $Array_rotate$89 = function $$rotate(n) {
      var self = this;

      
      
      if (n == null) {
        n = 1;
      };
      
      var ary, idx, firstPart, lastPart;

      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int')

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, $Array_rotate$89.$$arity = -1);
    
    Opal.def(self, '$rotate!', $Array_rotate$excl$90 = function(cnt) {
      var self = this, ary = nil;

      
      
      if (cnt == null) {
        cnt = 1;
      };
      
      if (self.length === 0 || self.length === 1) {
        return self;
      }
      cnt = $coerce_to(cnt, $$($nesting, 'Integer'), 'to_int');
    ;
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, $Array_rotate$excl$90.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SampleRandom');

      var $nesting = [self].concat($parent_nesting), $SampleRandom_initialize$91, $SampleRandom_rand$92;

      self.$$prototype.rng = nil;
      
      
      Opal.def(self, '$initialize', $SampleRandom_initialize$91 = function $$initialize(rng) {
        var self = this;

        return (self.rng = rng)
      }, $SampleRandom_initialize$91.$$arity = 1);
      return (Opal.def(self, '$rand', $SampleRandom_rand$92 = function $$rand(size) {
        var self = this, random = nil;

        
        random = $coerce_to(self.rng.$rand(size), $$($nesting, 'Integer'), 'to_int');
        if ($truthy(random < 0)) {
          self.$raise($$($nesting, 'RangeError'), "random value must be >= 0")};
        if ($truthy(random < size)) {
        } else {
          self.$raise($$($nesting, 'RangeError'), "random value must be less than Array size")
        };
        return random;
      }, $SampleRandom_rand$92.$$arity = 1), nil) && 'rand';
    })($nesting[0], null, $nesting);
    
    Opal.def(self, '$sample', $Array_sample$93 = function $$sample(count, options) {
      var self = this, o = nil, $ret_or_3 = nil, rng = nil, $ret_or_4 = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($$($nesting, 'Kernel').$rand(self.length))};
      if ($truthy(options === undefined)) {
        if ($truthy((o = $$($nesting, 'Opal')['$coerce_to?'](count, $$($nesting, 'Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
        }
      } else {
        
        count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
        options = $coerce_to(options, $$($nesting, 'Hash'), 'to_hash');
      };
      if ($truthy((function() {if ($truthy(($ret_or_3 = count))) {
        return count < 0;
      } else {
        return $ret_or_3
      }; return nil; })())) {
        self.$raise($$($nesting, 'ArgumentError'), "count must be greater than 0")};
      if ($truthy(options)) {
        rng = options['$[]']("random")};
      rng = (function() {if ($truthy((function() {if ($truthy(($ret_or_4 = rng))) {
        return rng['$respond_to?']("rand")
      } else {
        return $ret_or_4
      }; return nil; })())) {
        return $$($nesting, 'SampleRandom').$new(rng)
      } else {
        return $$($nesting, 'Kernel')
      }; return nil; })();
      if ($truthy(count)) {
      } else {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length);
          if (i === j) {
            j = i === 0 ? i + 1 : i - 1;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$($nesting, 'Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length);
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, $Array_sample$93.$$arity = -1);
    
    Opal.def(self, '$select', $Array_select$94 = function $$select() {
      var $iter = $Array_select$94.$$p, block = $iter || nil, $$95, self = this;

      if ($iter) $Array_select$94.$$p = null;
      
      
      if ($iter) $Array_select$94.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$95 = function(){var self = $$95.$$s == null ? this : $$95.$$s;

        return self.$size()}, $$95.$$s = self, $$95.$$arity = 0, $$95))
      };
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = $yield1(block, item);

        if ($truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_select$94.$$arity = 0);
    
    Opal.def(self, '$select!', $Array_select$excl$96 = function() {
      var $iter = $Array_select$excl$96.$$p, block = $iter || nil, $$97, self = this;

      if ($iter) $Array_select$excl$96.$$p = null;
      
      
      if ($iter) $Array_select$excl$96.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$97 = function(){var self = $$97.$$s == null ? this : $$97.$$s;

        return self.$size()}, $$97.$$s = self, $$97.$$arity = 0, $$97))
      };
      
      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    }, $Array_select$excl$96.$$arity = 0);
    Opal.alias(self, "filter", "select");
    Opal.alias(self, "filter!", "select!");
    
    Opal.def(self, '$shift', $Array_shift$98 = function $$shift(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return shiftNoArg(self);};
      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      return self.splice(0, count);;
    }, $Array_shift$98.$$arity = -1);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$shuffle', $Array_shuffle$99 = function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, $Array_shuffle$99.$$arity = -1);
    
    Opal.def(self, '$shuffle!', $Array_shuffle$excl$100 = function(rng) {
      var self = this;

      
      ;
      
      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $$($nesting, 'Opal')['$coerce_to?'](rng, $$($nesting, 'Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too small " + (j))
          }

          if (j >= i) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, $Array_shuffle$excl$100.$$arity = -1);
    Opal.alias(self, "slice", "[]");
    
    Opal.def(self, '$slice!', $Array_slice$excl$101 = function(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      result = nil;
      if ($truthy(length === undefined)) {
        if ($truthy($$($nesting, 'Range')['$==='](index))) {
          
          range = index;
          result = self['$[]'](range);
          range_start = $coerce_to(range.begin, $$($nesting, 'Integer'), 'to_int');
          range_end = $coerce_to(range.end, $$($nesting, 'Integer'), 'to_int');
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');
        length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, $Array_slice$excl$101.$$arity = -2);
    
    Opal.def(self, '$sort', $Array_sort$102 = function $$sort() {
      var $iter = $Array_sort$102.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$102.$$p = null;
      
      
      if ($iter) $Array_sort$102.$$p = null;;
      if ($truthy(self.length > 1)) {
      } else {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    }, $Array_sort$102.$$arity = 0);
    
    Opal.def(self, '$sort!', $Array_sort$excl$103 = function() {
      var $iter = $Array_sort$excl$103.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$excl$103.$$p = null;
      
      
      if ($iter) $Array_sort$excl$103.$$p = null;;
      
      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    }, $Array_sort$excl$103.$$arity = 0);
    
    Opal.def(self, '$sort_by!', $Array_sort_by$excl$104 = function() {
      var $iter = $Array_sort_by$excl$104.$$p, block = $iter || nil, $$105, self = this;

      if ($iter) $Array_sort_by$excl$104.$$p = null;
      
      
      if ($iter) $Array_sort_by$excl$104.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by!"], ($$105 = function(){var self = $$105.$$s == null ? this : $$105.$$s;

        return self.$size()}, $$105.$$s = self, $$105.$$arity = 0, $$105))
      };
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    }, $Array_sort_by$excl$104.$$arity = 0);
    
    Opal.def(self, '$take', $Array_take$106 = function $$take(count) {
      var self = this;

      
      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'));
      }

      return self.slice(0, count);
    
    }, $Array_take$106.$$arity = 1);
    
    Opal.def(self, '$take_while', $Array_take_while$107 = function $$take_while() {
      var $iter = $Array_take_while$107.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_take_while$107.$$p = null;
      
      
      if ($iter) $Array_take_while$107.$$p = null;;
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    }, $Array_take_while$107.$$arity = 0);
    
    Opal.def(self, '$to_a', $Array_to_a$108 = function $$to_a() {
      var self = this;

      
      if (self.$$class === Opal.Array) {
        return self;
      }
      else {
        return Opal.Array.$new(self);
      }
    
    }, $Array_to_a$108.$$arity = 0);
    
    Opal.def(self, '$to_ary', $Array_to_ary$109 = function $$to_ary() {
      var self = this;

      return self
    }, $Array_to_ary$109.$$arity = 0);
    
    Opal.def(self, '$to_h', $Array_to_h$110 = function $$to_h() {
      var $iter = $Array_to_h$110.$$p, block = $iter || nil, self = this, array = nil;

      if ($iter) $Array_to_h$110.$$p = null;
      
      
      if ($iter) $Array_to_h$110.$$p = null;;
      array = self;
      if ((block !== nil)) {
        array = $send(array, 'map', [], block.$to_proc())};
      
      var i, len = array.length, ary, key, val, hash = $hash2([], {});

      for (i = 0; i < len; i++) {
        ary = $$($nesting, 'Opal')['$coerce_to?'](array[i], $$($nesting, 'Array'), "to_ary");
        if (!ary.$$is_array) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong element type " + ((ary).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        $hash_put(hash, key, val);
      }

      return hash;
    ;
    }, $Array_to_h$110.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transpose', $Array_transpose$111 = function $$transpose() {
      var $$112, self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []};
      result = [];
      max = nil;
      $send(self, 'each', [], ($$112 = function(row){var self = $$112.$$s == null ? this : $$112.$$s, $$113, $ret_or_5 = nil;

      
        
        if (row == null) {
          row = nil;
        };
        row = (function() {if ($truthy($$($nesting, 'Array')['$==='](row))) {
          return row.$to_a()
        } else {
          return ($coerce_to(row, $$($nesting, 'Array'), 'to_ary')).$to_a()
        }; return nil; })();
        max = (function() {if ($truthy(($ret_or_5 = max))) {
          return $ret_or_5
        } else {
          return row.length;
        }; return nil; })();
        if ($truthy((row.length)['$!='](max))) {
          self.$raise($$($nesting, 'IndexError'), "" + "element size differs (" + (row.length) + " should be " + (max) + ")")};
        return $send((row.length), 'times', [], ($$113 = function(i){var self = $$113.$$s == null ? this : $$113.$$s, entry = nil, $ret_or_6 = nil, $writer = nil;

        
          
          if (i == null) {
            i = nil;
          };
          entry = (function() {if ($truthy(($ret_or_6 = result['$[]'](i)))) {
            return $ret_or_6
          } else {
            
            $writer = [i, []];
            $send(result, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }; return nil; })();
          return entry['$<<'](row.$at(i));}, $$113.$$s = self, $$113.$$arity = 1, $$113));}, $$112.$$s = self, $$112.$$arity = 1, $$112));
      return result;
    }, $Array_transpose$111.$$arity = 0);
    
    Opal.def(self, '$union', $Array_union$114 = function $$union($a) {
      var $post_args, arrays, $$115, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$uniq()], ($$115 = function(a, b){var self = $$115.$$s == null ? this : $$115.$$s;

      
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a['$|'](b);}, $$115.$$s = self, $$115.$$arity = 2, $$115));
    }, $Array_union$114.$$arity = -1);
    
    Opal.def(self, '$uniq', $Array_uniq$116 = function $$uniq() {
      var $iter = $Array_uniq$116.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$116.$$p = null;
      
      
      if ($iter) $Array_uniq$116.$$p = null;;
      
      var hash = $hash2([], {}), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if ($hash_get(hash, item) === undefined) {
            $hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          key = $yield1(block, item);
          if ($hash_get(hash, key) === undefined) {
            $hash_put(hash, key, item);
          }
        }
      }

      return (hash).$values();
    ;
    }, $Array_uniq$116.$$arity = 0);
    
    Opal.def(self, '$uniq!', $Array_uniq$excl$117 = function() {
      var $iter = $Array_uniq$excl$117.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$excl$117.$$p = null;
      
      
      if ($iter) $Array_uniq$excl$117.$$p = null;;
      
      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;

      for (i = 0, length = original_length; i < length; i++) {
        item = self[i];
        key = (block === nil ? item : $yield1(block, item));

        if ($hash_get(hash, key) === undefined) {
          $hash_put(hash, key, item);
          continue;
        }

        self.splice(i, 1);
        length--;
        i--;
      }

      return self.length === original_length ? nil : self;
    ;
    }, $Array_uniq$excl$117.$$arity = 0);
    
    Opal.def(self, '$unshift', $Array_unshift$118 = function $$unshift($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      var selfLength = self.length
      var objectsLength = objects.length
      if (objectsLength == 0) return self;
      var index = selfLength - objectsLength
      for (var i = 0; i < objectsLength; i++) {
        self.push(self[index + i])
      }
      var len = selfLength - 1
      while (len - objectsLength >= 0) {
        self[len] = self[len - objectsLength]
        len--
      }
      for (var j = 0; j < objectsLength; j++) {
        self[j] = objects[j]
      }
      return self;
    ;
    }, $Array_unshift$118.$$arity = -1);
    Opal.alias(self, "prepend", "unshift");
    
    Opal.def(self, '$values_at', $Array_values_at$119 = function $$values_at($a) {
      var $post_args, args, $$120, self = this, out = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      out = [];
      $send(args, 'each', [], ($$120 = function(elem){var self = $$120.$$s == null ? this : $$120.$$s, $$121, finish = nil, start = nil, i = nil;

      
        
        if (elem == null) {
          elem = nil;
        };
        if ($truthy(elem['$is_a?']($$($nesting, 'Range')))) {
          
          finish = $coerce_to(elem.$last(), $$($nesting, 'Integer'), 'to_int');
          start = $coerce_to(elem.$first(), $$($nesting, 'Integer'), 'to_int');
          
          if (start < 0) {
            start = start + self.length;
            return nil;;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']()) {
            finish--;
          }
          if (finish < start) {
            return nil;;
          }
        ;
          return $send(start, 'upto', [finish], ($$121 = function(i){var self = $$121.$$s == null ? this : $$121.$$s;

          
            
            if (i == null) {
              i = nil;
            };
            return out['$<<'](self.$at(i));}, $$121.$$s = self, $$121.$$arity = 1, $$121));
        } else {
          
          i = $coerce_to(elem, $$($nesting, 'Integer'), 'to_int');
          return out['$<<'](self.$at(i));
        };}, $$120.$$s = self, $$120.$$arity = 1, $$120));
      return out;
    }, $Array_values_at$119.$$arity = -1);
    
    Opal.def(self, '$zip', $Array_zip$122 = function $$zip($a) {
      var $iter = $Array_zip$122.$$p, block = $iter || nil, $post_args, others, self = this, $ret_or_7 = nil;

      if ($iter) $Array_zip$122.$$p = null;
      
      
      if ($iter) $Array_zip$122.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_range || o.$$is_enumerator) {
          others[j] = o.$take(size);
          continue;
        }
        others[j] = (function() {if ($truthy(($ret_or_7 = $$($nesting, 'Opal')['$coerce_to?'](o, $$($nesting, 'Array'), "to_ary")))) {
        return $ret_or_7
      } else {
        return $$($nesting, 'Opal')['$coerce_to!'](o, $$($nesting, 'Enumerator'), "to_enum", "each")
      }; return nil; })().$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          block(result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, $Array_zip$122.$$arity = -1);
    Opal.defs(self, '$inherited', $Array_inherited$123 = function $$inherited(klass) {
      var self = this;

      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    }, $Array_inherited$123.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Array_instance_variables$124 = function $$instance_variables() {
      var $$125, $iter = $Array_instance_variables$124.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_instance_variables$124.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      return $send($send2(self, Opal.find_super_dispatcher(self, 'instance_variables', $Array_instance_variables$124, false, true), 'instance_variables', $zuper, $iter), 'reject', [], ($$125 = function(ivar){var self = $$125.$$s == null ? this : $$125.$$s, $ret_or_8 = nil;

      
        
        if (ivar == null) {
          ivar = nil;
        };
        if ($truthy(($ret_or_8 = /^@\d+$/.test(ivar)))) {
          return $ret_or_8
        } else {
          return ivar['$==']("@length")
        };}, $$125.$$s = self, $$125.$$arity = 1, $$125))
    }, $Array_instance_variables$124.$$arity = 0);
    $$($nesting, 'Opal').$pristine(self.$singleton_class(), "allocate");
    $$($nesting, 'Opal').$pristine(self, "copy_instance_variables", "initialize_dup");
    return (Opal.def(self, '$pack', $Array_pack$126 = function $$pack($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, $Array_pack$126.$$arity = -1), nil) && 'pack';
  })($nesting[0], Array, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/hash"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$[]', '$merge!', '$allocate', '$raise', '$coerce_to!', '$each', '$fetch', '$>=', '$>', '$==', '$compare_by_identity', '$lambda?', '$abs', '$arity', '$enum_for', '$size', '$respond_to?', '$class', '$dig', '$except!', '$dup', '$delete', '$new', '$inspect', '$map', '$to_proc', '$flatten', '$eql?', '$default', '$default_proc', '$default_proc=', '$-', '$default=', '$to_h', '$proc']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_$$$1, $Hash_allocate$2, $Hash_try_convert$3, $Hash_initialize$4, $Hash_$eq_eq$5, $Hash_$gt_eq$6, $Hash_$gt$8, $Hash_$lt$9, $Hash_$lt_eq$10, $Hash_$$$11, $Hash_$$$eq$12, $Hash_assoc$13, $Hash_clear$14, $Hash_clone$15, $Hash_compact$16, $Hash_compact$excl$17, $Hash_compare_by_identity$18, $Hash_compare_by_identity$ques$19, $Hash_default$20, $Hash_default$eq$21, $Hash_default_proc$22, $Hash_default_proc$eq$23, $Hash_delete$24, $Hash_delete_if$25, $Hash_dig$27, $Hash_each$28, $Hash_each_key$30, $Hash_each_value$32, $Hash_empty$ques$34, $Hash_except$35, $Hash_except$excl$36, $Hash_fetch$38, $Hash_fetch_values$39, $Hash_flatten$41, $Hash_has_key$ques$42, $Hash_has_value$ques$43, $Hash_hash$44, $Hash_index$45, $Hash_indexes$46, $Hash_inspect$47, $Hash_invert$48, $Hash_keep_if$49, $Hash_keys$51, $Hash_length$52, $Hash_merge$53, $Hash_merge$excl$54, $Hash_rassoc$55, $Hash_rehash$56, $Hash_reject$57, $Hash_reject$excl$59, $Hash_replace$61, $Hash_select$62, $Hash_select$excl$64, $Hash_shift$66, $Hash_slice$67, $Hash_to_a$68, $Hash_to_h$69, $Hash_to_hash$70, $Hash_to_proc$71, $Hash_transform_keys$73, $Hash_transform_keys$excl$75, $Hash_transform_values$77, $Hash_transform_values$excl$79, $Hash_values$81;

    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_hash = true;
    Opal.defs(self, '$[]', $Hash_$$$1 = function($a) {
      var $post_args, argv, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      argv = $post_args;;
      
      var hash, argc = argv.length, i;

      if (argc === 1) {
        hash = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Array'), "to_ary");
        if (argv === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          if (!argv[i].$$is_array) continue;
          switch(argv[i].length) {
          case 1:
            hash.$store(argv[i][0], nil);
            break;
          case 2:
            hash.$store(argv[i][0], argv[i][1]);
            break;
          default:
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid number of elements (" + (argv[i].length) + " for 1..2)")
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, $Hash_$$$1.$$arity = -1);
    Opal.defs(self, '$allocate', $Hash_allocate$2 = function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      Opal.hash_init(hash);

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    }, $Hash_allocate$2.$$arity = 0);
    Opal.defs(self, '$try_convert', $Hash_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Hash'), "to_hash")
    }, $Hash_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$initialize', $Hash_initialize$4 = function $$initialize(defaults) {
      var $iter = $Hash_initialize$4.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_initialize$4.$$p = null;
      
      
      if ($iter) $Hash_initialize$4.$$p = null;;
      ;
      
      if (defaults !== undefined && block !== nil) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, $Hash_initialize$4.$$arity = -1);
    
    Opal.def(self, '$==', $Hash_$eq_eq$5 = function(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.$$keys.length !== other.$$keys.length) {
        return false;
      }

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
          other_value = other.$$smap[key];
        } else {
          value = key.value;
          other_value = Opal.hash_get(other, key.key);
        }

        if (other_value === undefined || !value['$eql?'](other_value)) {
          return false;
        }
      }

      return true;
    
    }, $Hash_$eq_eq$5.$$arity = 1);
    
    Opal.def(self, '$>=', $Hash_$gt_eq$6 = function(other) {
      var $$7, self = this, result = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length < other.$$keys.length) {
        return false
      }
    ;
      result = true;
      $send(other, 'each', [], ($$7 = function(other_key, other_val){var self = $$7.$$s == null ? this : $$7.$$s, val = nil;

      
        
        if (other_key == null) {
          other_key = nil;
        };
        
        if (other_val == null) {
          other_val = nil;
        };
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, $$7.$$s = self, $$7.$$arity = 2, $$7));
      return result;
    }, $Hash_$gt_eq$6.$$arity = 1);
    
    Opal.def(self, '$>', $Hash_$gt$8 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length <= other.$$keys.length) {
        return false
      }
    ;
      return $rb_ge(self, other);
    }, $Hash_$gt$8.$$arity = 1);
    
    Opal.def(self, '$<', $Hash_$lt$9 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_gt(other, self);
    }, $Hash_$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=', $Hash_$lt_eq$10 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_ge(other, self);
    }, $Hash_$lt_eq$10.$$arity = 1);
    
    Opal.def(self, '$[]', $Hash_$$$11 = function(key) {
      var self = this;

      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    }, $Hash_$$$11.$$arity = 1);
    
    Opal.def(self, '$[]=', $Hash_$$$eq$12 = function(key, value) {
      var self = this;

      
      Opal.hash_put(self, key, value);
      return value;
    
    }, $Hash_$$$eq$12.$$arity = 2);
    
    Opal.def(self, '$assoc', $Hash_assoc$13 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          if ((key)['$=='](object)) {
            return [key, self.$$smap[key]];
          }
        } else {
          if ((key.key)['$=='](object)) {
            return [key.key, key.value];
          }
        }
      }

      return nil;
    
    }, $Hash_assoc$13.$$arity = 1);
    
    Opal.def(self, '$clear', $Hash_clear$14 = function $$clear() {
      var self = this;

      
      Opal.hash_init(self);
      return self;
    
    }, $Hash_clear$14.$$arity = 0);
    
    Opal.def(self, '$clone', $Hash_clone$15 = function $$clone() {
      var self = this;

      
      var hash = new self.$$class();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, $Hash_clone$15.$$arity = 0);
    
    Opal.def(self, '$compact', $Hash_compact$16 = function $$compact() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    
    }, $Hash_compact$16.$$arity = 0);
    
    Opal.def(self, '$compact!', $Hash_compact$excl$17 = function() {
      var self = this;

      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    
    }, $Hash_compact$excl$17.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity', $Hash_compare_by_identity$18 = function $$compare_by_identity() {
      var self = this;

      
      var i, ii, key, keys = self.$$keys, identity_hash;

      if (self.$$by_identity) return self;
      if (self.$$keys.length === 0) {
        self.$$by_identity = true
        return self;
      }

      identity_hash = $hash2([], {}).$compare_by_identity();
      for(i = 0, ii = keys.length; i < ii; i++) {
        key = keys[i];
        if (!key.$$is_string) key = key.key;
        Opal.hash_put(identity_hash, key, Opal.hash_get(self, key));
      }

      self.$$by_identity = true;
      self.$$map = identity_hash.$$map;
      self.$$smap = identity_hash.$$smap;
      return self;
    
    }, $Hash_compare_by_identity$18.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity?', $Hash_compare_by_identity$ques$19 = function() {
      var self = this;

      return self.$$by_identity === true;
    }, $Hash_compare_by_identity$ques$19.$$arity = 0);
    
    Opal.def(self, '$default', $Hash_default$20 = function(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, $Hash_default$20.$$arity = -1);
    
    Opal.def(self, '$default=', $Hash_default$eq$21 = function(object) {
      var self = this;

      
      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    }, $Hash_default$eq$21.$$arity = 1);
    
    Opal.def(self, '$default_proc', $Hash_default_proc$22 = function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    }, $Hash_default_proc$22.$$arity = 0);
    
    Opal.def(self, '$default_proc=', $Hash_default_proc$eq$23 = function(default_proc) {
      var self = this;

      
      var proc = default_proc;

      if (proc !== nil) {
        proc = $$($nesting, 'Opal')['$coerce_to!'](proc, $$($nesting, 'Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          self.$raise($$($nesting, 'TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    }, $Hash_default_proc$eq$23.$$arity = 1);
    
    Opal.def(self, '$delete', $Hash_delete$24 = function(key) {
      var $iter = $Hash_delete$24.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_delete$24.$$p = null;
      
      
      if ($iter) $Hash_delete$24.$$p = null;;
      
      var value = Opal.hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    }, $Hash_delete$24.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Hash_delete_if$25 = function $$delete_if() {
      var $iter = $Hash_delete_if$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Hash_delete_if$25.$$p = null;
      
      
      if ($iter) $Hash_delete_if$25.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$26 = function(){var self = $$26.$$s == null ? this : $$26.$$s;

        return self.$size()}, $$26.$$s = self, $$26.$$arity = 0, $$26))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_delete_if$25.$$arity = 0);
    Opal.alias(self, "dup", "clone");
    
    Opal.def(self, '$dig', $Hash_dig$27 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Hash_dig$27.$$arity = -2);
    
    Opal.def(self, '$each', $Hash_each$28 = function $$each() {
      var $iter = $Hash_each$28.$$p, block = $iter || nil, $$29, self = this;

      if ($iter) $Hash_each$28.$$p = null;
      
      
      if ($iter) $Hash_each$28.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$29 = function(){var self = $$29.$$s == null ? this : $$29.$$s;

        return self.$size()}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.yield1(block, [key, value]);
      }

      return self;
    ;
    }, $Hash_each$28.$$arity = 0);
    
    Opal.def(self, '$each_key', $Hash_each_key$30 = function $$each_key() {
      var $iter = $Hash_each_key$30.$$p, block = $iter || nil, $$31, self = this;

      if ($iter) $Hash_each_key$30.$$p = null;
      
      
      if ($iter) $Hash_each_key$30.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_key"], ($$31 = function(){var self = $$31.$$s == null ? this : $$31.$$s;

        return self.$size()}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? key : key.key);
      }

      return self;
    ;
    }, $Hash_each_key$30.$$arity = 0);
    Opal.alias(self, "each_pair", "each");
    
    Opal.def(self, '$each_value', $Hash_each_value$32 = function $$each_value() {
      var $iter = $Hash_each_value$32.$$p, block = $iter || nil, $$33, self = this;

      if ($iter) $Hash_each_value$32.$$p = null;
      
      
      if ($iter) $Hash_each_value$32.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_value"], ($$33 = function(){var self = $$33.$$s == null ? this : $$33.$$s;

        return self.$size()}, $$33.$$s = self, $$33.$$arity = 0, $$33))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? self.$$smap[key] : key.value);
      }

      return self;
    ;
    }, $Hash_each_value$32.$$arity = 0);
    
    Opal.def(self, '$empty?', $Hash_empty$ques$34 = function() {
      var self = this;

      return self.$$keys.length === 0;
    }, $Hash_empty$ques$34.$$arity = 0);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$except', $Hash_except$35 = function $$except($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      return $send(self.$dup(), 'except!', Opal.to_a(keys));
    }, $Hash_except$35.$$arity = -1);
    
    Opal.def(self, '$except!', $Hash_except$excl$36 = function($a) {
      var $post_args, keys, $$37, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      $send(keys, 'each', [], ($$37 = function(key){var self = $$37.$$s == null ? this : $$37.$$s;

      
        
        if (key == null) {
          key = nil;
        };
        return self.$delete(key);}, $$37.$$s = self, $$37.$$arity = 1, $$37));
      return self;
    }, $Hash_except$excl$36.$$arity = -1);
    
    Opal.def(self, '$fetch', $Hash_fetch$38 = function $$fetch(key, defaults) {
      var $iter = $Hash_fetch$38.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_fetch$38.$$p = null;
      
      
      if ($iter) $Hash_fetch$38.$$p = null;;
      ;
      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return self.$raise($$($nesting, 'KeyError').$new("" + "key not found: " + (key.$inspect()), $hash2(["key", "receiver"], {"key": key, "receiver": self})));
    }, $Hash_fetch$38.$$arity = -2);
    
    Opal.def(self, '$fetch_values', $Hash_fetch_values$39 = function $$fetch_values($a) {
      var $iter = $Hash_fetch_values$39.$$p, block = $iter || nil, $post_args, keys, $$40, self = this;

      if ($iter) $Hash_fetch_values$39.$$p = null;
      
      
      if ($iter) $Hash_fetch_values$39.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      return $send(keys, 'map', [], ($$40 = function(key){var self = $$40.$$s == null ? this : $$40.$$s;

      
        
        if (key == null) {
          key = nil;
        };
        return $send(self, 'fetch', [key], block.$to_proc());}, $$40.$$s = self, $$40.$$arity = 1, $$40));
    }, $Hash_fetch_values$39.$$arity = -1);
    
    Opal.def(self, '$flatten', $Hash_flatten$41 = function $$flatten(level) {
      var self = this;

      
      
      if (level == null) {
        level = 1;
      };
      level = $$($nesting, 'Opal')['$coerce_to!'](level, $$($nesting, 'Integer'), "to_int");
      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            continue;
          }

          result = result.concat((value).$flatten(level - 2));
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_flatten$41.$$arity = -1);
    
    Opal.def(self, '$has_key?', $Hash_has_key$ques$42 = function(key) {
      var self = this;

      return Opal.hash_get(self, key) !== undefined;
    }, $Hash_has_key$ques$42.$$arity = 1);
    
    Opal.def(self, '$has_value?', $Hash_has_value$ques$43 = function(value) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {
          return true;
        }
      }

      return false;
    
    }, $Hash_has_value$ques$43.$$arity = 1);
    
    Opal.def(self, '$hash', $Hash_hash$44 = function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          hash_id = self.$object_id(),
          result = ['Hash'],
          key, item;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        if (Opal[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            result.push([key, self.$$smap[key].$hash()]);
          } else {
            result.push([key.key_hash, key.value.$hash()]);
          }
        }

        return result.sort().join();

      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, $Hash_hash$44.$$arity = 0);
    Opal.alias(self, "include?", "has_key?");
    
    Opal.def(self, '$index', $Hash_index$45 = function $$index(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return key;
        }
      }

      return nil;
    
    }, $Hash_index$45.$$arity = 1);
    
    Opal.def(self, '$indexes', $Hash_indexes$46 = function $$indexes($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = Opal.hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_indexes$46.$$arity = -1);
    Opal.alias(self, "indices", "indexes");
    var inspect_ids;
    
    Opal.def(self, '$inspect', $Hash_inspect$47 = function $$inspect() {
      var self = this;

      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];

      try {
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          result.push(key.$inspect() + '=>' + value.$inspect());
        }

        return '{' + result.join(', ') + '}';

      } finally {
        if (top) {
          inspect_ids = undefined;
        }
      }
    
    }, $Hash_inspect$47.$$arity = 0);
    
    Opal.def(self, '$invert', $Hash_invert$48 = function $$invert() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.hash_put(hash, value, key);
      }

      return hash;
    
    }, $Hash_invert$48.$$arity = 0);
    
    Opal.def(self, '$keep_if', $Hash_keep_if$49 = function $$keep_if() {
      var $iter = $Hash_keep_if$49.$$p, block = $iter || nil, $$50, self = this;

      if ($iter) $Hash_keep_if$49.$$p = null;
      
      
      if ($iter) $Hash_keep_if$49.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$50 = function(){var self = $$50.$$s == null ? this : $$50.$$s;

        return self.$size()}, $$50.$$s = self, $$50.$$arity = 0, $$50))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_keep_if$49.$$arity = 0);
    Opal.alias(self, "key", "index");
    Opal.alias(self, "key?", "has_key?");
    
    Opal.def(self, '$keys', $Hash_keys$51 = function $$keys() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(key);
        } else {
          result.push(key.key);
        }
      }

      return result;
    
    }, $Hash_keys$51.$$arity = 0);
    
    Opal.def(self, '$length', $Hash_length$52 = function $$length() {
      var self = this;

      return self.$$keys.length;
    }, $Hash_length$52.$$arity = 0);
    Opal.alias(self, "member?", "has_key?");
    
    Opal.def(self, '$merge', $Hash_merge$53 = function $$merge($a) {
      var $iter = $Hash_merge$53.$$p, block = $iter || nil, $post_args, others, self = this;

      if ($iter) $Hash_merge$53.$$p = null;
      
      
      if ($iter) $Hash_merge$53.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      return $send(self.$dup(), 'merge!', Opal.to_a(others), block.$to_proc());
    }, $Hash_merge$53.$$arity = -1);
    
    Opal.def(self, '$merge!', $Hash_merge$excl$54 = function($a) {
      var $iter = $Hash_merge$excl$54.$$p, block = $iter || nil, $post_args, others, self = this;

      if ($iter) $Hash_merge$excl$54.$$p = null;
      
      
      if ($iter) $Hash_merge$excl$54.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      
      var i, j, other, other_keys, length, key, value, other_value;
      for (i = 0; i < others.length; ++i) {
        other = $$($nesting, 'Opal')['$coerce_to!'](others[i], $$($nesting, 'Hash'), "to_hash");
        other_keys = other.$$keys, length = other_keys.length;

        if (block === nil) {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            Opal.hash_put(self, key, other_value);
          }
        } else {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            value = Opal.hash_get(self, key);

            if (value === undefined) {
              Opal.hash_put(self, key, other_value);
              continue;
            }

            Opal.hash_put(self, key, block(key, value, other_value));
          }
        }
      }

      return self;
    ;
    }, $Hash_merge$excl$54.$$arity = -1);
    
    Opal.def(self, '$rassoc', $Hash_rassoc$55 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return [key, value];
        }
      }

      return nil;
    
    }, $Hash_rassoc$55.$$arity = 1);
    
    Opal.def(self, '$rehash', $Hash_rehash$56 = function $$rehash() {
      var self = this;

      
      Opal.hash_rehash(self);
      return self;
    
    }, $Hash_rehash$56.$$arity = 0);
    
    Opal.def(self, '$reject', $Hash_reject$57 = function $$reject() {
      var $iter = $Hash_reject$57.$$p, block = $iter || nil, $$58, self = this;

      if ($iter) $Hash_reject$57.$$p = null;
      
      
      if ($iter) $Hash_reject$57.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$58 = function(){var self = $$58.$$s == null ? this : $$58.$$s;

        return self.$size()}, $$58.$$s = self, $$58.$$arity = 0, $$58))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_reject$57.$$arity = 0);
    
    Opal.def(self, '$reject!', $Hash_reject$excl$59 = function() {
      var $iter = $Hash_reject$excl$59.$$p, block = $iter || nil, $$60, self = this;

      if ($iter) $Hash_reject$excl$59.$$p = null;
      
      
      if ($iter) $Hash_reject$excl$59.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$60 = function(){var self = $$60.$$s == null ? this : $$60.$$s;

        return self.$size()}, $$60.$$s = self, $$60.$$arity = 0, $$60))
      };
      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    ;
    }, $Hash_reject$excl$59.$$arity = 0);
    
    Opal.def(self, '$replace', $Hash_replace$61 = function $$replace(other) {
      var self = this, $writer = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      Opal.hash_init(self);

      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        Opal.hash_put(self, key, other_value);
      }
    ;
      if ($truthy(other.$default_proc())) {
        
        $writer = [other.$default_proc()];
        $send(self, 'default_proc=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      } else {
        
        $writer = [other.$default()];
        $send(self, 'default=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return self;
    }, $Hash_replace$61.$$arity = 1);
    
    Opal.def(self, '$select', $Hash_select$62 = function $$select() {
      var $iter = $Hash_select$62.$$p, block = $iter || nil, $$63, self = this;

      if ($iter) $Hash_select$62.$$p = null;
      
      
      if ($iter) $Hash_select$62.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$63 = function(){var self = $$63.$$s == null ? this : $$63.$$s;

        return self.$size()}, $$63.$$s = self, $$63.$$arity = 0, $$63))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_select$62.$$arity = 0);
    
    Opal.def(self, '$select!', $Hash_select$excl$64 = function() {
      var $iter = $Hash_select$excl$64.$$p, block = $iter || nil, $$65, self = this;

      if ($iter) $Hash_select$excl$64.$$p = null;
      
      
      if ($iter) $Hash_select$excl$64.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$65 = function(){var self = $$65.$$s == null ? this : $$65.$$s;

        return self.$size()}, $$65.$$s = self, $$65.$$arity = 0, $$65))
      };
      
      var result = nil;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
          result = self;
        }
      }

      return result;
    ;
    }, $Hash_select$excl$64.$$arity = 0);
    Opal.alias(self, "filter", "select");
    Opal.alias(self, "filter!", "select!");
    
    Opal.def(self, '$shift', $Hash_shift$66 = function $$shift() {
      var self = this;

      
      var keys = self.$$keys,
          key;

      if (keys.length > 0) {
        key = keys[0];

        key = key.$$is_string ? key : key.key;

        return [key, Opal.hash_delete(self, key)];
      }

      return self.$default(nil);
    
    }, $Hash_shift$66.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$slice', $Hash_slice$67 = function $$slice($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      
      var result = Opal.hash();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = Opal.hash_get(self, key);

        if (value !== undefined) {
          Opal.hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, $Hash_slice$67.$$arity = -1);
    Opal.alias(self, "store", "[]=");
    
    Opal.def(self, '$to_a', $Hash_to_a$68 = function $$to_a() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push([key, value]);
      }

      return result;
    
    }, $Hash_to_a$68.$$arity = 0);
    
    Opal.def(self, '$to_h', $Hash_to_h$69 = function $$to_h() {
      var $iter = $Hash_to_h$69.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_to_h$69.$$p = null;
      
      
      if ($iter) $Hash_to_h$69.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'map', [], block.$to_proc()).$to_h()};
      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Opal.Hash();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    ;
    }, $Hash_to_h$69.$$arity = 0);
    
    Opal.def(self, '$to_hash', $Hash_to_hash$70 = function $$to_hash() {
      var self = this;

      return self
    }, $Hash_to_hash$70.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Hash_to_proc$71 = function $$to_proc() {
      var $$72, self = this;

      return $send(self, 'proc', [], ($$72 = function(key){var self = $$72.$$s == null ? this : $$72.$$s;

      
        ;
        
        if (key == null) {
          self.$raise($$($nesting, 'ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, $$72.$$s = self, $$72.$$arity = -1, $$72))
    }, $Hash_to_proc$71.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transform_keys', $Hash_transform_keys$73 = function $$transform_keys() {
      var $iter = $Hash_transform_keys$73.$$p, block = $iter || nil, $$74, self = this;

      if ($iter) $Hash_transform_keys$73.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$73.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys"], ($$74 = function(){var self = $$74.$$s == null ? this : $$74.$$s;

        return self.$size()}, $$74.$$s = self, $$74.$$arity = 0, $$74))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        key = Opal.yield1(block, key);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_keys$73.$$arity = 0);
    
    Opal.def(self, '$transform_keys!', $Hash_transform_keys$excl$75 = function() {
      var $iter = $Hash_transform_keys$excl$75.$$p, block = $iter || nil, $$76, self = this;

      if ($iter) $Hash_transform_keys$excl$75.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$excl$75.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys!"], ($$76 = function(){var self = $$76.$$s == null ? this : $$76.$$s;

        return self.$size()}, $$76.$$s = self, $$76.$$arity = 0, $$76))
      };
      
      var keys = Opal.slice.call(self.$$keys),
          i, length = keys.length, key, value, new_key;

      for (i = 0; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        new_key = Opal.yield1(block, key);

        Opal.hash_delete(self, key);
        Opal.hash_put(self, new_key, value);
      }

      return self;
    ;
    }, $Hash_transform_keys$excl$75.$$arity = 0);
    
    Opal.def(self, '$transform_values', $Hash_transform_values$77 = function $$transform_values() {
      var $iter = $Hash_transform_values$77.$$p, block = $iter || nil, $$78, self = this;

      if ($iter) $Hash_transform_values$77.$$p = null;
      
      
      if ($iter) $Hash_transform_values$77.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values"], ($$78 = function(){var self = $$78.$$s == null ? this : $$78.$$s;

        return self.$size()}, $$78.$$s = self, $$78.$$arity = 0, $$78))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_values$77.$$arity = 0);
    
    Opal.def(self, '$transform_values!', $Hash_transform_values$excl$79 = function() {
      var $iter = $Hash_transform_values$excl$79.$$p, block = $iter || nil, $$80, self = this;

      if ($iter) $Hash_transform_values$excl$79.$$p = null;
      
      
      if ($iter) $Hash_transform_values$excl$79.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values!"], ($$80 = function(){var self = $$80.$$s == null ? this : $$80.$$s;

        return self.$size()}, $$80.$$s = self, $$80.$$arity = 0, $$80))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(self, key, value);
      }

      return self;
    ;
    }, $Hash_transform_values$excl$79.$$arity = 0);
    Opal.alias(self, "update", "merge!");
    Opal.alias(self, "value?", "has_value?");
    Opal.alias(self, "values_at", "indexes");
    return (Opal.def(self, '$values', $Hash_values$81 = function $$values() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(self.$$smap[key]);
        } else {
          result.push(key.value);
        }
      }

      return result;
    
    }, $Hash_values$81.$$arity = 0), nil) && 'values';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/number"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send2 = Opal.send2, $send = Opal.send;

  Opal.add_stubs(['$require', '$bridge', '$raise', '$name', '$class', '$Float', '$respond_to?', '$coerce_to!', '$__coerced__', '$===', '$!', '$>', '$**', '$new', '$<', '$to_f', '$==', '$nan?', '$infinite?', '$enum_for', '$+', '$-', '$gcd', '$lcm', '$%', '$/', '$frexp', '$to_i', '$ldexp', '$rationalize', '$*', '$<<', '$to_r', '$truncate', '$-@', '$size', '$<=', '$>=']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting), $Number_coerce$2, $Number___id__$3, $Number_$plus$4, $Number_$minus$5, $Number_$$6, $Number_$slash$7, $Number_$percent$8, $Number_$$9, $Number_$$10, $Number_$$11, $Number_$lt$12, $Number_$lt_eq$13, $Number_$gt$14, $Number_$gt_eq$15, $Number_$lt_eq_gt$16, $Number_$lt$lt$17, $Number_$gt$gt$18, $Number_$$$19, $Number_$plus$$20, $Number_$minus$$21, $Number_$$22, $Number_$$$23, $Number_$eq_eq_eq$24, $Number_$eq_eq$25, $Number_abs$26, $Number_abs2$27, $Number_allbits$ques$28, $Number_anybits$ques$29, $Number_angle$30, $Number_bit_length$31, $Number_ceil$32, $Number_chr$33, $Number_denominator$34, $Number_downto$35, $Number_equal$ques$37, $Number_even$ques$38, $Number_floor$39, $Number_gcd$40, $Number_gcdlcm$41, $Number_integer$ques$42, $Number_is_a$ques$43, $Number_instance_of$ques$44, $Number_lcm$45, $Number_next$46, $Number_nobits$ques$47, $Number_nonzero$ques$48, $Number_numerator$49, $Number_odd$ques$50, $Number_ord$51, $Number_pow$52, $Number_pred$53, $Number_quo$54, $Number_rationalize$55, $Number_remainder$56, $Number_round$57, $Number_times$58, $Number_to_f$60, $Number_to_i$61, $Number_to_r$62, $Number_to_s$63, $Number_truncate$64, $Number_digits$65, $Number_divmod$66, $Number_upto$67, $Number_zero$ques$69, $Number_size$70, $Number_nan$ques$71, $Number_finite$ques$72, $Number_infinite$ques$73, $Number_positive$ques$74, $Number_negative$ques$75;

    
    $$($nesting, 'Opal').$bridge(Number, self);
    Opal.defineProperty(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$coerce', $Number_coerce$2 = function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [self.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
    
    }, $Number_coerce$2.$$arity = 1);
    
    Opal.def(self, '$__id__', $Number___id__$3 = function $$__id__() {
      var self = this;

      return (self * 2) + 1;
    }, $Number___id__$3.$$arity = 0);
    Opal.alias(self, "object_id", "__id__");
    
    Opal.def(self, '$+', $Number_$plus$4 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    }, $Number_$plus$4.$$arity = 1);
    
    Opal.def(self, '$-', $Number_$minus$5 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    }, $Number_$minus$5.$$arity = 1);
    
    Opal.def(self, '$*', $Number_$$6 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    }, $Number_$$6.$$arity = 1);
    
    Opal.def(self, '$/', $Number_$slash$7 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    }, $Number_$slash$7.$$arity = 1);
    Opal.alias(self, "fdiv", "/");
    
    Opal.def(self, '$%', $Number_$percent$8 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    }, $Number_$percent$8.$$arity = 1);
    
    Opal.def(self, '$&', $Number_$$9 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    }, $Number_$$9.$$arity = 1);
    
    Opal.def(self, '$|', $Number_$$10 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    }, $Number_$$10.$$arity = 1);
    
    Opal.def(self, '$^', $Number_$$11 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    }, $Number_$$11.$$arity = 1);
    
    Opal.def(self, '$<', $Number_$lt$12 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    }, $Number_$lt$12.$$arity = 1);
    
    Opal.def(self, '$<=', $Number_$lt_eq$13 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    }, $Number_$lt_eq$13.$$arity = 1);
    
    Opal.def(self, '$>', $Number_$gt$14 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    }, $Number_$gt$14.$$arity = 1);
    
    Opal.def(self, '$>=', $Number_$gt_eq$15 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    }, $Number_$gt_eq$15.$$arity = 1);
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    Opal.def(self, '$<=>', $Number_$lt_eq_gt$16 = function(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Number_$lt_eq_gt$16.$$arity = 1);
    
    Opal.def(self, '$<<', $Number_$lt$lt$17 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    }, $Number_$lt$lt$17.$$arity = 1);
    
    Opal.def(self, '$>>', $Number_$gt$gt$18 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    }, $Number_$gt$gt$18.$$arity = 1);
    
    Opal.def(self, '$[]', $Number_$$$19 = function(bit) {
      var self = this;

      
      bit = $$($nesting, 'Opal')['$coerce_to!'](bit, $$($nesting, 'Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    }, $Number_$$$19.$$arity = 1);
    
    Opal.def(self, '$+@', $Number_$plus$$20 = function() {
      var self = this;

      return +self;
    }, $Number_$plus$$20.$$arity = 0);
    
    Opal.def(self, '$-@', $Number_$minus$$21 = function() {
      var self = this;

      return -self;
    }, $Number_$minus$$21.$$arity = 0);
    
    Opal.def(self, '$~', $Number_$$22 = function() {
      var self = this;

      return ~self;
    }, $Number_$$22.$$arity = 0);
    
    Opal.def(self, '$**', $Number_$$$23 = function(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
        if ($truthy((function() {if ($truthy(($ret_or_1 = $$($nesting, 'Integer')['$==='](self)['$!']()))) {
          return $ret_or_1
        } else {
          return $rb_gt(other, 0)
        }; return nil; })())) {
          return Math.pow(self, other);
        } else {
          return $$($nesting, 'Rational').$new(self, 1)['$**'](other)
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_2 = $rb_lt(self, 0)))) {
        
        if ($truthy(($ret_or_3 = $$($nesting, 'Float')['$==='](other)))) {
          return $ret_or_3
        } else {
          return $$($nesting, 'Rational')['$==='](other)
        };
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return $$($nesting, 'Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    }, $Number_$$$23.$$arity = 1);
    
    Opal.def(self, '$===', $Number_$eq_eq_eq$24 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq_eq$24.$$arity = 1);
    
    Opal.def(self, '$==', $Number_$eq_eq$25 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq$25.$$arity = 1);
    
    Opal.def(self, '$abs', $Number_abs$26 = function $$abs() {
      var self = this;

      return Math.abs(self);
    }, $Number_abs$26.$$arity = 0);
    
    Opal.def(self, '$abs2', $Number_abs2$27 = function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    }, $Number_abs2$27.$$arity = 0);
    
    Opal.def(self, '$allbits?', $Number_allbits$ques$28 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == mask;;
    }, $Number_allbits$ques$28.$$arity = 1);
    
    Opal.def(self, '$anybits?', $Number_anybits$ques$29 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) !== 0;;
    }, $Number_anybits$ques$29.$$arity = 1);
    
    Opal.def(self, '$angle', $Number_angle$30 = function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self};
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    }, $Number_angle$30.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    Opal.alias(self, "phase", "angle");
    
    Opal.def(self, '$bit_length', $Number_bit_length$31 = function $$bit_length() {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
      } else {
        self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    }, $Number_bit_length$31.$$arity = 0);
    
    Opal.def(self, '$ceil', $Number_ceil$32 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_ceil$32.$$arity = -1);
    
    Opal.def(self, '$chr', $Number_chr$33 = function $$chr(encoding) {
      var self = this;

      
      ;
      return Opal.enc(String.fromCharCode(self), encoding || "BINARY");;
    }, $Number_chr$33.$$arity = -1);
    
    Opal.def(self, '$denominator', $Number_denominator$34 = function $$denominator() {
      var $iter = $Number_denominator$34.$$p, $yield = $iter || nil, self = this, $ret_or_4 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_denominator$34.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy((function() {if ($truthy(($ret_or_4 = self['$nan?']()))) {
        return $ret_or_4
      } else {
        return self['$infinite?']()
      }; return nil; })())) {
        return 1
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'denominator', $Number_denominator$34, false, true), 'denominator', $zuper, $iter)
      }
    }, $Number_denominator$34.$$arity = 0);
    
    Opal.def(self, '$downto', $Number_downto$35 = function $$downto(stop) {
      var $iter = $Number_downto$35.$$p, block = $iter || nil, $$36, self = this;

      if ($iter) $Number_downto$35.$$p = null;
      
      
      if ($iter) $Number_downto$35.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["downto", stop], ($$36 = function(){var self = $$36.$$s == null ? this : $$36.$$s;

        
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    }, $Number_downto$35.$$arity = 1);
    Opal.alias(self, "eql?", "==");
    
    Opal.def(self, '$equal?', $Number_equal$ques$37 = function(other) {
      var self = this, $ret_or_5 = nil;

      if ($truthy(($ret_or_5 = self['$=='](other)))) {
        return $ret_or_5
      } else {
        return isNaN(self) && isNaN(other);
      }
    }, $Number_equal$ques$37.$$arity = 1);
    
    Opal.def(self, '$even?', $Number_even$ques$38 = function() {
      var self = this;

      return self % 2 === 0;
    }, $Number_even$ques$38.$$arity = 0);
    
    Opal.def(self, '$floor', $Number_floor$39 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_floor$39.$$arity = -1);
    
    Opal.def(self, '$gcd', $Number_gcd$40 = function $$gcd(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    }, $Number_gcd$40.$$arity = 1);
    
    Opal.def(self, '$gcdlcm', $Number_gcdlcm$41 = function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(other), self.$lcm(other)]
    }, $Number_gcdlcm$41.$$arity = 1);
    
    Opal.def(self, '$integer?', $Number_integer$ques$42 = function() {
      var self = this;

      return self % 1 === 0;
    }, $Number_integer$ques$42.$$arity = 0);
    
    Opal.def(self, '$is_a?', $Number_is_a$ques$43 = function(klass) {
      var $iter = $Number_is_a$ques$43.$$p, $yield = $iter || nil, self = this, $ret_or_6 = nil, $ret_or_7 = nil, $ret_or_8 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_is_a$ques$43.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((function() {if ($truthy(($ret_or_6 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_6
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_7 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_7
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_8 = klass['$==']($$($nesting, 'Float'))))) {
        return $$($nesting, 'Float')['$==='](self)
      } else {
        return $ret_or_8
      }; return nil; })())) {
        return true};
      return $send2(self, Opal.find_super_dispatcher(self, 'is_a?', $Number_is_a$ques$43, false, true), 'is_a?', $zuper, $iter);
    }, $Number_is_a$ques$43.$$arity = 1);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$instance_of?', $Number_instance_of$ques$44 = function(klass) {
      var $iter = $Number_instance_of$ques$44.$$p, $yield = $iter || nil, self = this, $ret_or_9 = nil, $ret_or_10 = nil, $ret_or_11 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_instance_of$ques$44.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((function() {if ($truthy(($ret_or_9 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_9
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_10 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_10
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_11 = klass['$==']($$($nesting, 'Float'))))) {
        return $$($nesting, 'Float')['$==='](self)
      } else {
        return $ret_or_11
      }; return nil; })())) {
        return true};
      return $send2(self, Opal.find_super_dispatcher(self, 'instance_of?', $Number_instance_of$ques$44, false, true), 'instance_of?', $zuper, $iter);
    }, $Number_instance_of$ques$44.$$arity = 1);
    
    Opal.def(self, '$lcm', $Number_lcm$45 = function $$lcm(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    }, $Number_lcm$45.$$arity = 1);
    Opal.alias(self, "magnitude", "abs");
    Opal.alias(self, "modulo", "%");
    
    Opal.def(self, '$next', $Number_next$46 = function $$next() {
      var self = this;

      return self + 1;
    }, $Number_next$46.$$arity = 0);
    
    Opal.def(self, '$nobits?', $Number_nobits$ques$47 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == 0;;
    }, $Number_nobits$ques$47.$$arity = 1);
    
    Opal.def(self, '$nonzero?', $Number_nonzero$ques$48 = function() {
      var self = this;

      return self == 0 ? nil : self;
    }, $Number_nonzero$ques$48.$$arity = 0);
    
    Opal.def(self, '$numerator', $Number_numerator$49 = function $$numerator() {
      var $iter = $Number_numerator$49.$$p, $yield = $iter || nil, self = this, $ret_or_12 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_numerator$49.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy((function() {if ($truthy(($ret_or_12 = self['$nan?']()))) {
        return $ret_or_12
      } else {
        return self['$infinite?']()
      }; return nil; })())) {
        return self
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'numerator', $Number_numerator$49, false, true), 'numerator', $zuper, $iter)
      }
    }, $Number_numerator$49.$$arity = 0);
    
    Opal.def(self, '$odd?', $Number_odd$ques$50 = function() {
      var self = this;

      return self % 2 !== 0;
    }, $Number_odd$ques$50.$$arity = 0);
    
    Opal.def(self, '$ord', $Number_ord$51 = function $$ord() {
      var self = this;

      return self
    }, $Number_ord$51.$$arity = 0);
    
    Opal.def(self, '$pow', $Number_pow$52 = function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$($nesting, 'Integer')['$==='](b))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$($nesting, 'Integer')['$==='](m))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, $Number_pow$52.$$arity = -2);
    
    Opal.def(self, '$pred', $Number_pred$53 = function $$pred() {
      var self = this;

      return self - 1;
    }, $Number_pred$53.$$arity = 0);
    
    Opal.def(self, '$quo', $Number_quo$54 = function $$quo(other) {
      var $iter = $Number_quo$54.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_quo$54.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $send2(self, Opal.find_super_dispatcher(self, 'quo', $Number_quo$54, false, true), 'quo', $zuper, $iter)
      } else {
        return $rb_divide(self, other)
      }
    }, $Number_quo$54.$$arity = 1);
    
    Opal.def(self, '$rationalize', $Number_rationalize$55 = function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $$($nesting, 'Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$($nesting, 'Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, $Number_rationalize$55.$$arity = -1);
    
    Opal.def(self, '$remainder', $Number_remainder$56 = function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    }, $Number_remainder$56.$$arity = 1);
    
    Opal.def(self, '$round', $Number_round$57 = function $$round(ndigits) {
      var $a, $b, self = this, $ret_or_13 = nil, $ret_or_14 = nil, $ret_or_15 = nil, _ = nil, exp = nil;

      
      ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        
        if ($truthy(ndigits == null)) {
          return self};
        if ($truthy((function() {if ($truthy(($ret_or_13 = $$($nesting, 'Float')['$==='](ndigits)))) {
          return ndigits['$infinite?']()
        } else {
          return $ret_or_13
        }; return nil; })())) {
          self.$raise($$($nesting, 'RangeError'), "Infinity")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$($nesting, 'Integer'), 'MIN')))) {
          self.$raise($$($nesting, 'RangeError'), "out of bounds")};
        if ($truthy(ndigits >= 0)) {
          return self};
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(self) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if ($truthy((function() {if ($truthy(($ret_or_14 = self['$nan?']()))) {
          return ndigits == null;
        } else {
          return $ret_or_14
        }; return nil; })())) {
          self.$raise($$($nesting, 'FloatDomainError'), "NaN")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits || 0, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            self.$raise($$($nesting, 'RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            self.$raise($$($nesting, 'FloatDomainError'), "Infinity")}
        } else if (ndigits['$=='](0)) {
          return Math.round(self)
        } else if ($truthy((function() {if ($truthy(($ret_or_15 = self['$nan?']()))) {
          return $ret_or_15
        } else {
          return self['$infinite?']()
        }; return nil; })())) {
          return self};
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$($nesting, 'Float'), 'DIG'), 2), (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_divide(exp, 4)
        } else {
          return $rb_minus($rb_divide(exp, 3), 1)
        }; return nil; })())))) {
          return self};
        if ($truthy($rb_lt(ndigits, (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_plus($rb_divide(exp, 3), 1)
        } else {
          return $rb_divide(exp, 4)
        }; return nil; })()['$-@']()))) {
          return 0};
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, $Number_round$57.$$arity = -1);
    Opal.alias(self, "succ", "next");
    
    Opal.def(self, '$times', $Number_times$58 = function $$times() {
      var $iter = $Number_times$58.$$p, block = $iter || nil, $$59, self = this;

      if ($iter) $Number_times$58.$$p = null;
      
      
      if ($iter) $Number_times$58.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["times"], ($$59 = function(){var self = $$59.$$s == null ? this : $$59.$$s;

        return self}, $$59.$$s = self, $$59.$$arity = 0, $$59))
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_times$58.$$arity = 0);
    
    Opal.def(self, '$to_f', $Number_to_f$60 = function $$to_f() {
      var self = this;

      return self
    }, $Number_to_f$60.$$arity = 0);
    
    Opal.def(self, '$to_i', $Number_to_i$61 = function $$to_i() {
      var self = this;

      return self < 0 ? Math.ceil(self) : Math.floor(self);
    }, $Number_to_i$61.$$arity = 0);
    Opal.alias(self, "to_int", "to_i");
    
    Opal.def(self, '$to_r', $Number_to_r$62 = function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$($nesting, 'Float'), 'RADIX')['$**'](e)).$to_r();
      }
    }, $Number_to_r$62.$$arity = 0);
    
    Opal.def(self, '$to_s', $Number_to_s$63 = function $$to_s(base) {
      var self = this, $ret_or_16 = nil;

      
      
      if (base == null) {
        base = 10;
      };
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy((function() {if ($truthy(($ret_or_16 = $rb_lt(base, 2)))) {
        return $ret_or_16
      } else {
        return $rb_gt(base, 36)
      }; return nil; })())) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      return self.toString(base);;
    }, $Number_to_s$63.$$arity = -1);
    
    Opal.def(self, '$truncate', $Number_truncate$64 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_truncate$64.$$arity = -1);
    Opal.alias(self, "inspect", "to_s");
    
    Opal.def(self, '$digits', $Number_digits$65 = function $$digits(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      if ($rb_lt(self, 0)) {
        self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "out of domain")};
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      
      var value = self, result = [];

      while (value !== 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, $Number_digits$65.$$arity = -1);
    
    Opal.def(self, '$divmod', $Number_divmod$66 = function $$divmod(other) {
      var $iter = $Number_divmod$66.$$p, $yield = $iter || nil, self = this, $ret_or_17 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_divmod$66.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy((function() {if ($truthy(($ret_or_17 = self['$nan?']()))) {
        return $ret_or_17
      } else {
        return other['$nan?']()
      }; return nil; })())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'divmod', $Number_divmod$66, false, true), 'divmod', $zuper, $iter)
      }
    }, $Number_divmod$66.$$arity = 1);
    
    Opal.def(self, '$upto', $Number_upto$67 = function $$upto(stop) {
      var $iter = $Number_upto$67.$$p, block = $iter || nil, $$68, self = this;

      if ($iter) $Number_upto$67.$$p = null;
      
      
      if ($iter) $Number_upto$67.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["upto", stop], ($$68 = function(){var self = $$68.$$s == null ? this : $$68.$$s;

        
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_upto$67.$$arity = 1);
    
    Opal.def(self, '$zero?', $Number_zero$ques$69 = function() {
      var self = this;

      return self == 0;
    }, $Number_zero$ques$69.$$arity = 0);
    
    Opal.def(self, '$size', $Number_size$70 = function $$size() {
      var self = this;

      return 4
    }, $Number_size$70.$$arity = 0);
    
    Opal.def(self, '$nan?', $Number_nan$ques$71 = function() {
      var self = this;

      return isNaN(self);
    }, $Number_nan$ques$71.$$arity = 0);
    
    Opal.def(self, '$finite?', $Number_finite$ques$72 = function() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    }, $Number_finite$ques$72.$$arity = 0);
    
    Opal.def(self, '$infinite?', $Number_infinite$ques$73 = function() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    }, $Number_infinite$ques$73.$$arity = 0);
    
    Opal.def(self, '$positive?', $Number_positive$ques$74 = function() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    }, $Number_positive$ques$74.$$arity = 0);
    return (Opal.def(self, '$negative?', $Number_negative$ques$75 = function() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    }, $Number_negative$ques$75.$$arity = 0), nil) && 'negative?';
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  Opal.const_set($nesting[0], 'Fixnum', $$($nesting, 'Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    self.$$is_integer_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$76, $sqrt$77;

      
      
      Opal.def(self, '$allocate', $allocate$76 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$76.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      return (Opal.def(self, '$sqrt', $sqrt$77 = function $$sqrt(n) {
        var self = this;

        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        
        if (n < 0) {
          self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      }, $sqrt$77.$$arity = 1), nil) && 'sqrt';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'MAX', Math.pow(2, 30) - 1);
    return Opal.const_set($nesting[0], 'MIN', -Math.pow(2, 30));
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$78, $eq_eq_eq$79;

      
      
      Opal.def(self, '$allocate', $allocate$78 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$78.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      return (Opal.def(self, '$===', $eq_eq_eq$79 = function(other) {
        var self = this;

        return !!other.$$is_number;
      }, $eq_eq_eq$79.$$arity = 1), nil) && '===';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'INFINITY', Infinity);
    Opal.const_set($nesting[0], 'MAX', Number.MAX_VALUE);
    Opal.const_set($nesting[0], 'MIN', Number.MIN_VALUE);
    Opal.const_set($nesting[0], 'NAN', NaN);
    Opal.const_set($nesting[0], 'DIG', 15);
    Opal.const_set($nesting[0], 'MANT_DIG', 53);
    Opal.const_set($nesting[0], 'RADIX', 2);
    return Opal.const_set($nesting[0], 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/range"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send2 = Opal.send2, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$attr_reader', '$raise', '$<=>', '$nil?', '$include?', '$!', '$<', '$<=', '$enum_for', '$size', '$upto', '$to_proc', '$respond_to?', '$class', '$succ', '$==', '$===', '$exclude_end?', '$eql?', '$begin', '$end', '$last', '$to_a', '$>', '$-@', '$-', '$to_i', '$coerce_to!', '$ceil', '$/', '$loop', '$+', '$*', '$>=', '$each_with_index', '$%', '$bsearch', '$inspect', '$[]', '$hash']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $Range_initialize$1, $Range_$eq_eq_eq$2, $Range_count$3, $Range_to_a$4, $Range_cover$ques$5, $Range_each$6, $Range_eql$ques$8, $Range_exclude_end$ques$9, $Range_first$10, $Range_last$11, $Range_max$12, $Range_min$13, $Range_size$14, $Range_step$15, $Range_bsearch$19, $Range_to_s$20, $Range_inspect$21, $Range_marshal_load$22, $Range_hash$23;

    self.$$prototype.begin = self.$$prototype.end = self.$$prototype.excl = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    Opal.def(self, '$initialize', $Range_initialize$1 = function $$initialize(first, last, exclude) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      
      
      if (exclude == null) {
        exclude = false;
      };
      if ($truthy(self.begin)) {
        self.$raise($$($nesting, 'NameError'), "'initialize' called twice")};
      if ($truthy((function() {if ($truthy(($ret_or_1 = (function() {if ($truthy(($ret_or_2 = first['$<=>'](last)))) {
        return $ret_or_2
      } else {
        return first['$nil?']()
      }; return nil; })()))) {
        return $ret_or_1
      } else {
        return last['$nil?']()
      }; return nil; })())) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, $Range_initialize$1.$$arity = -3);
    
    Opal.def(self, '$===', $Range_$eq_eq_eq$2 = function(value) {
      var self = this;

      return self['$include?'](value)
    }, $Range_$eq_eq_eq$2.$$arity = 1);
    
    function is_infinite(self) {
      if (self.begin === nil || self.end === nil ||
          self.begin === -Infinity || self.end === Infinity ||
          self.begin === Infinity || self.end === -Infinity) return true;
      return false;
    }
  ;
    
    Opal.def(self, '$count', $Range_count$3 = function $$count() {
      var $iter = $Range_count$3.$$p, block = $iter || nil, self = this, $ret_or_3 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_count$3.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Range_count$3.$$p = null;;
      if ($truthy((function() {if ($truthy(($ret_or_3 = (block !== nil)['$!']()))) {
        return is_infinite(self);
      } else {
        return $ret_or_3
      }; return nil; })())) {
        return $$$($$($nesting, 'Float'), 'INFINITY')};
      return $send2(self, Opal.find_super_dispatcher(self, 'count', $Range_count$3, false, true), 'count', $zuper, $iter);
    }, $Range_count$3.$$arity = 0);
    
    Opal.def(self, '$to_a', $Range_to_a$4 = function $$to_a() {
      var $iter = $Range_to_a$4.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_to_a$4.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy(is_infinite(self))) {
        self.$raise($$($nesting, 'TypeError'), "cannot convert endless range to an array")};
      return $send2(self, Opal.find_super_dispatcher(self, 'to_a', $Range_to_a$4, false, true), 'to_a', $zuper, $iter);
    }, $Range_to_a$4.$$arity = 0);
    
    Opal.def(self, '$cover?', $Range_cover$ques$5 = function(value) {
      var self = this, beg_cmp = nil, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil, end_cmp = nil, $ret_or_7 = nil, $ret_or_8 = nil, $ret_or_9 = nil, $ret_or_10 = nil, $ret_or_11 = nil, $ret_or_12 = nil, $ret_or_13 = nil;

      
      beg_cmp = (function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = self.begin['$nil?']()))) {
        return -1
      } else {
        return $ret_or_6
      }; return nil; })()))) {
        return $ret_or_5
      } else {
        
        return self.begin['$<=>'](value);
      }; return nil; })()))) {
        return $ret_or_4
      } else {
        return false
      }; return nil; })();
      end_cmp = (function() {if ($truthy(($ret_or_7 = (function() {if ($truthy(($ret_or_8 = (function() {if ($truthy(($ret_or_9 = self.end['$nil?']()))) {
        return -1
      } else {
        return $ret_or_9
      }; return nil; })()))) {
        return $ret_or_8
      } else {
        
        return value['$<=>'](self.end);
      }; return nil; })()))) {
        return $ret_or_7
      } else {
        return false
      }; return nil; })();
      if ($truthy(($ret_or_10 = (function() {if ($truthy(($ret_or_11 = (function() {if ($truthy(self.excl)) {
        if ($truthy(($ret_or_12 = end_cmp))) {
          return $rb_lt(end_cmp, 0)
        } else {
          return $ret_or_12
        }
      } else if ($truthy(($ret_or_13 = end_cmp))) {
        return $rb_le(end_cmp, 0)
      } else {
        return $ret_or_13
      }; return nil; })()))) {
        return beg_cmp
      } else {
        return $ret_or_11
      }; return nil; })()))) {
        return $rb_le(beg_cmp, 0)
      } else {
        return $ret_or_10
      };
    }, $Range_cover$ques$5.$$arity = 1);
    
    Opal.def(self, '$each', $Range_each$6 = function $$each() {
      var $iter = $Range_each$6.$$p, block = $iter || nil, $$7, $a, self = this, current = nil, last = nil, $ret_or_14 = nil, $ret_or_15 = nil;

      if ($iter) $Range_each$6.$$p = null;
      
      
      if ($iter) $Range_each$6.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$7 = function(){var self = $$7.$$s == null ? this : $$7.$$s;

        return self.$size()}, $$7.$$s = self, $$7.$$arity = 0, $$7))
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + (function() {if ($truthy(self.excl)) {
        return 0
      } else {
        return 1
      }; return nil; })(); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if ($truthy(current['$respond_to?']("succ"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't iterate from " + (current.$class()))
      };
      while ($truthy((function() {if ($truthy(($ret_or_14 = self.end['$nil?']()))) {
        return $ret_or_14
      } else {
        return $rb_lt(current['$<=>'](last), 0)
      }; return nil; })())) {
        
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if ($truthy((function() {if ($truthy(($ret_or_15 = self.excl['$!']()))) {
        return current['$=='](last)
      } else {
        return $ret_or_15
      }; return nil; })())) {
        Opal.yield1(block, current)};
      return self;
    }, $Range_each$6.$$arity = 0);
    
    Opal.def(self, '$eql?', $Range_eql$ques$8 = function(other) {
      var self = this, $ret_or_16 = nil, $ret_or_17 = nil;

      
      if ($truthy($$($nesting, 'Range')['$==='](other))) {
      } else {
        return false
      };
      if ($truthy(($ret_or_16 = (function() {if ($truthy(($ret_or_17 = self.excl['$==='](other['$exclude_end?']())))) {
        return self.begin['$eql?'](other.$begin())
      } else {
        return $ret_or_17
      }; return nil; })()))) {
        return self.end['$eql?'](other.$end())
      } else {
        return $ret_or_16
      };
    }, $Range_eql$ques$8.$$arity = 1);
    Opal.alias(self, "==", "eql?");
    
    Opal.def(self, '$exclude_end?', $Range_exclude_end$ques$9 = function() {
      var self = this;

      return self.excl
    }, $Range_exclude_end$ques$9.$$arity = 0);
    
    Opal.def(self, '$first', $Range_first$10 = function $$first(n) {
      var $iter = $Range_first$10.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_first$10.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      ;
      if ($truthy(self.begin['$nil?']())) {
        self.$raise($$($nesting, 'RangeError'), "cannot get the minimum of beginless range")};
      if ($truthy(n == null)) {
        return self.begin};
      return $send2(self, Opal.find_super_dispatcher(self, 'first', $Range_first$10, false, true), 'first', $zuper, $iter);
    }, $Range_first$10.$$arity = -1);
    Opal.alias(self, "include?", "cover?");
    
    Opal.def(self, '$last', $Range_last$11 = function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(self.end['$nil?']())) {
        self.$raise($$($nesting, 'RangeError'), "cannot get the maximum of endless range")};
      if ($truthy(n == null)) {
        return self.end};
      return self.$to_a().$last(n);
    }, $Range_last$11.$$arity = -1);
    
    Opal.def(self, '$max', $Range_max$12 = function $$max() {
      var $iter = $Range_max$12.$$p, $yield = $iter || nil, self = this, $ret_or_18 = nil, $ret_or_19 = nil, $ret_or_20 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_max$12.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(self.end['$nil?']())) {
        return self.$raise($$($nesting, 'RangeError'), "cannot get the maximum of endless range")
      } else if (($yield !== nil)) {
        return $send2(self, Opal.find_super_dispatcher(self, 'max', $Range_max$12, false, true), 'max', $zuper, $iter)
      } else if ($truthy((function() {if ($truthy(($ret_or_18 = self.begin['$nil?']()['$!']()))) {
        
        if ($truthy(($ret_or_19 = $rb_gt(self.begin, self.end)))) {
          return $ret_or_19
        } else if ($truthy(($ret_or_20 = self.excl))) {
          return self.begin['$=='](self.end)
        } else {
          return $ret_or_20
        };
      } else {
        return $ret_or_18
      }; return nil; })())) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    }, $Range_max$12.$$arity = 0);
    Opal.alias(self, "member?", "cover?");
    
    Opal.def(self, '$min', $Range_min$13 = function $$min() {
      var $iter = $Range_min$13.$$p, $yield = $iter || nil, self = this, $ret_or_21 = nil, $ret_or_22 = nil, $ret_or_23 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_min$13.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(self.begin['$nil?']())) {
        return self.$raise($$($nesting, 'RangeError'), "cannot get the minimum of beginless range")
      } else if (($yield !== nil)) {
        return $send2(self, Opal.find_super_dispatcher(self, 'min', $Range_min$13, false, true), 'min', $zuper, $iter)
      } else if ($truthy((function() {if ($truthy(($ret_or_21 = self.end['$nil?']()['$!']()))) {
        
        if ($truthy(($ret_or_22 = $rb_gt(self.begin, self.end)))) {
          return $ret_or_22
        } else if ($truthy(($ret_or_23 = self.excl))) {
          return self.begin['$=='](self.end)
        } else {
          return $ret_or_23
        };
      } else {
        return $ret_or_21
      }; return nil; })())) {
        return nil
      } else {
        return self.begin
      }
    }, $Range_min$13.$$arity = 0);
    
    Opal.def(self, '$size', $Range_size$14 = function $$size() {
      var self = this, infinity = nil, $ret_or_24 = nil, $ret_or_25 = nil, $ret_or_26 = nil, $ret_or_27 = nil, range_begin = nil, range_end = nil;

      
      infinity = $$$($$($nesting, 'Float'), 'INFINITY');
      if ($truthy((function() {if ($truthy(($ret_or_24 = (function() {if ($truthy(($ret_or_25 = self.begin['$=='](infinity)))) {
        return self.end['$nil?']()['$!']()
      } else {
        return $ret_or_25
      }; return nil; })()))) {
        return $ret_or_24
      } else {
        
        if ($truthy(($ret_or_26 = self.end['$=='](infinity['$-@']())))) {
          return self.begin['$nil?']()['$!']()
        } else {
          return $ret_or_26
        };
      }; return nil; })())) {
        return 0};
      if ($truthy(is_infinite(self))) {
        return infinity};
      if ($truthy((function() {if ($truthy(($ret_or_27 = $$($nesting, 'Numeric')['$==='](self.begin)))) {
        return $$($nesting, 'Numeric')['$==='](self.end)
      } else {
        return $ret_or_27
      }; return nil; })())) {
      } else {
        return nil
      };
      range_begin = self.begin;
      range_end = self.end;
      if ($truthy(self.excl)) {
        range_end = $rb_minus(range_end, 1)};
      if ($truthy($rb_lt(range_end, range_begin))) {
        return 0};
      return (Math.abs(range_end - range_begin) + 1).$to_i();
    }, $Range_size$14.$$arity = 0);
    
    Opal.def(self, '$step', $Range_step$15 = function $$step(n) {
      var $$16, $$17, $$18, $iter = $Range_step$15.$$p, $yield = $iter || nil, self = this, i = nil;

      if ($iter) $Range_step$15.$$p = null;
      
      
      if (n == null) {
        n = 1;
      };
      
      function coerceStepSize() {
        if (!n.$$is_number) {
          n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int")
        }

        if (n < 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$($nesting, 'Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["step", n], ($$16 = function(){var self = $$16.$$s == null ? this : $$16.$$s;

        
          coerceStepSize();
          return enumeratorSize();
        }, $$16.$$s = self, $$16.$$arity = 0, $$16))
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

        
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              
              Opal.brk(nil, $brk)}
          } else if ($truthy($rb_gt(current, self.end))) {
            
            Opal.brk(nil, $brk)};
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, $$17.$$s = self, $$17.$$brk = $brk, $$17.$$arity = 0, $$17))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], ($$18 = function(value, idx){var self = $$18.$$s == null ? this : $$18.$$s;

        
          
          if (value == null) {
            value = nil;
          };
          
          if (idx == null) {
            idx = nil;
          };
          if (idx['$%'](n)['$=='](0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };}, $$18.$$s = self, $$18.$$arity = 2, $$18));
      };
      return self;
    }, $Range_step$15.$$arity = -1);
    
    Opal.def(self, '$bsearch', $Range_bsearch$19 = function $$bsearch() {
      var $iter = $Range_bsearch$19.$$p, block = $iter || nil, self = this;

      if ($iter) $Range_bsearch$19.$$p = null;
      
      
      if ($iter) $Range_bsearch$19.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      if ($truthy(is_infinite(self) && (self.begin.$$is_number || self.end.$$is_number))) {
        self.$raise($$($nesting, 'NotImplementedError'), "Can't #bsearch an infinite range")};
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    }, $Range_bsearch$19.$$arity = 0);
    
    Opal.def(self, '$to_s', $Range_to_s$20 = function $$to_s() {
      var self = this, $ret_or_28 = nil, $ret_or_29 = nil;

      return "" + ((function() {if ($truthy(($ret_or_28 = self.begin))) {
        return $ret_or_28
      } else {
        return ""
      }; return nil; })()) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + ((function() {if ($truthy(($ret_or_29 = self.end))) {
        return $ret_or_29
      } else {
        return ""
      }; return nil; })())
    }, $Range_to_s$20.$$arity = 0);
    
    Opal.def(self, '$inspect', $Range_inspect$21 = function $$inspect() {
      var self = this, $ret_or_30 = nil, $ret_or_31 = nil;

      return "" + ((function() {if ($truthy(($ret_or_30 = self.begin))) {
        return self.begin.$inspect()
      } else {
        return $ret_or_30
      }; return nil; })()) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + ((function() {if ($truthy(($ret_or_31 = self.end))) {
        return self.end.$inspect()
      } else {
        return $ret_or_31
      }; return nil; })())
    }, $Range_inspect$21.$$arity = 0);
    
    Opal.def(self, '$marshal_load', $Range_marshal_load$22 = function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    }, $Range_marshal_load$22.$$arity = 1);
    return (Opal.def(self, '$hash', $Range_hash$23 = function $$hash() {
      var self = this;

      return [self.begin, self.end, self.excl].$hash()
    }, $Range_hash$23.$$arity = 0), nil) && 'hash';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/proc"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$raise', '$proc', '$call', '$to_proc', '$coerce_to!']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $Proc_new$1, $Proc_call$2, $Proc_$gt$gt$3, $Proc_$lt$lt$5, $Proc_to_proc$7, $Proc_lambda$ques$8, $Proc_arity$9, $Proc_source_location$10, $Proc_binding$11, $Proc_parameters$12, $Proc_curry$13, $Proc_dup$14;

    
    Opal.defineProperty(self.$$prototype, '$$is_proc', true);
    Opal.defineProperty(self.$$prototype, '$$is_lambda', false);
    Opal.defs(self, '$new', $Proc_new$1 = function() {
      var $iter = $Proc_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Proc_new$1.$$p = null;
      
      
      if ($iter) $Proc_new$1.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    }, $Proc_new$1.$$arity = 0);
    
    Opal.def(self, '$call', $Proc_call$2 = function $$call($a) {
      var $iter = $Proc_call$2.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Proc_call$2.$$p = null;
      
      
      if ($iter) $Proc_call$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk;

      if ($brk) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return $brk.$v
          }
          else {
            throw err
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    ;
    }, $Proc_call$2.$$arity = -1);
    Opal.alias(self, "[]", "call");
    Opal.alias(self, "===", "call");
    Opal.alias(self, "yield", "call");
    
    Opal.def(self, '$>>', $Proc_$gt$gt$3 = function(other) {
      var $$4, $iter = $Proc_$gt$gt$3.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Proc_$gt$gt$3.$$p = null;
      return $send(self, 'proc', [], ($$4 = function($a){var self = $$4.$$s == null ? this : $$4.$$s, $iter = $$4.$$p, block = $iter || nil, $post_args, args, out = nil;

      
        
        if ($iter) $$4.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        out = $send(self, 'call', Opal.to_a(args), block.$to_proc());
        return other.$call(out);}, $$4.$$s = self, $$4.$$arity = -1, $$4))
    }, $Proc_$gt$gt$3.$$arity = 1);
    
    Opal.def(self, '$<<', $Proc_$lt$lt$5 = function(other) {
      var $$6, $iter = $Proc_$lt$lt$5.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Proc_$lt$lt$5.$$p = null;
      return $send(self, 'proc', [], ($$6 = function($a){var self = $$6.$$s == null ? this : $$6.$$s, $iter = $$6.$$p, block = $iter || nil, $post_args, args, out = nil;

      
        
        if ($iter) $$6.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        out = $send(other, 'call', Opal.to_a(args), block.$to_proc());
        return self.$call(out);}, $$6.$$s = self, $$6.$$arity = -1, $$6))
    }, $Proc_$lt$lt$5.$$arity = 1);
    
    Opal.def(self, '$to_proc', $Proc_to_proc$7 = function $$to_proc() {
      var self = this;

      return self
    }, $Proc_to_proc$7.$$arity = 0);
    
    Opal.def(self, '$lambda?', $Proc_lambda$ques$8 = function() {
      var self = this;

      return !!self.$$is_lambda;
    }, $Proc_lambda$ques$8.$$arity = 0);
    
    Opal.def(self, '$arity', $Proc_arity$9 = function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else {
        return self.$$arity;
      }
    
    }, $Proc_arity$9.$$arity = 0);
    
    Opal.def(self, '$source_location', $Proc_source_location$10 = function $$source_location() {
      var self = this;

      
      if (self.$$is_curried) { return nil; };
      return nil;
    }, $Proc_source_location$10.$$arity = 0);
    
    Opal.def(self, '$binding', $Proc_binding$11 = function $$binding() {
      var self = this;

      
      if (self.$$is_curried) { self.$raise($$($nesting, 'ArgumentError'), "Can't create Binding") };
      return nil;
    }, $Proc_binding$11.$$arity = 0);
    
    Opal.def(self, '$parameters', $Proc_parameters$12 = function $$parameters() {
      var self = this;

      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (self.$$is_lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    
    }, $Proc_parameters$12.$$arity = 0);
    
    Opal.def(self, '$curry', $Proc_curry$13 = function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $$($nesting, 'Opal')['$coerce_to!'](arity, $$($nesting, 'Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice.call(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice.call(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, $Proc_curry$13.$$arity = -1);
    
    Opal.def(self, '$dup', $Proc_dup$14 = function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    }, $Proc_dup$14.$$arity = 0);
    return Opal.alias(self, "clone", "dup");
  })($nesting[0], Function, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/method"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$attr_reader', '$arity', '$>>', '$<<', '$new', '$class', '$join', '$source_location', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Method');

    var $nesting = [self].concat($parent_nesting), $Method_initialize$1, $Method_arity$2, $Method_parameters$3, $Method_source_location$4, $Method_comments$5, $Method_call$6, $Method_$gt$gt$7, $Method_$lt$lt$8, $Method_unbind$9, $Method_to_proc$10, $Method_inspect$11;

    self.$$prototype.method = self.$$prototype.receiver = self.$$prototype.owner = self.$$prototype.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    Opal.def(self, '$initialize', $Method_initialize$1 = function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    }, $Method_initialize$1.$$arity = 4);
    
    Opal.def(self, '$arity', $Method_arity$2 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $Method_arity$2.$$arity = 0);
    
    Opal.def(self, '$parameters', $Method_parameters$3 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $Method_parameters$3.$$arity = 0);
    
    Opal.def(self, '$source_location', $Method_source_location$4 = function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    }, $Method_source_location$4.$$arity = 0);
    
    Opal.def(self, '$comments', $Method_comments$5 = function $$comments() {
      var self = this, $ret_or_2 = nil;

      if ($truthy(($ret_or_2 = self.method.$$comments))) {
        return $ret_or_2
      } else {
        return []
      }
    }, $Method_comments$5.$$arity = 0);
    
    Opal.def(self, '$call', $Method_call$6 = function $$call($a) {
      var $iter = $Method_call$6.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Method_call$6.$$p = null;
      
      
      if ($iter) $Method_call$6.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, $Method_call$6.$$arity = -1);
    Opal.alias(self, "[]", "call");
    
    Opal.def(self, '$>>', $Method_$gt$gt$7 = function(other) {
      var self = this;

      return self.method['$>>'](other)
    }, $Method_$gt$gt$7.$$arity = 1);
    
    Opal.def(self, '$<<', $Method_$lt$lt$8 = function(other) {
      var self = this;

      return self.method['$<<'](other)
    }, $Method_$lt$lt$8.$$arity = 1);
    
    Opal.def(self, '$unbind', $Method_unbind$9 = function $$unbind() {
      var self = this;

      return $$($nesting, 'UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    }, $Method_unbind$9.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Method_to_proc$10 = function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    }, $Method_to_proc$10.$$arity = 0);
    return (Opal.def(self, '$inspect', $Method_inspect$11 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $Method_inspect$11.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $nesting = [self].concat($parent_nesting), $UnboundMethod_initialize$12, $UnboundMethod_arity$13, $UnboundMethod_parameters$14, $UnboundMethod_source_location$15, $UnboundMethod_comments$16, $UnboundMethod_bind$17, $UnboundMethod_inspect$18;

    self.$$prototype.method = self.$$prototype.owner = self.$$prototype.name = self.$$prototype.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    Opal.def(self, '$initialize', $UnboundMethod_initialize$12 = function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      return (self.name = name);
    }, $UnboundMethod_initialize$12.$$arity = 4);
    
    Opal.def(self, '$arity', $UnboundMethod_arity$13 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $UnboundMethod_arity$13.$$arity = 0);
    
    Opal.def(self, '$parameters', $UnboundMethod_parameters$14 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $UnboundMethod_parameters$14.$$arity = 0);
    
    Opal.def(self, '$source_location', $UnboundMethod_source_location$15 = function $$source_location() {
      var self = this, $ret_or_3 = nil;

      if ($truthy(($ret_or_3 = self.method.$$source_location))) {
        return $ret_or_3
      } else {
        return ["(eval)", 0]
      }
    }, $UnboundMethod_source_location$15.$$arity = 0);
    
    Opal.def(self, '$comments', $UnboundMethod_comments$16 = function $$comments() {
      var self = this, $ret_or_4 = nil;

      if ($truthy(($ret_or_4 = self.method.$$comments))) {
        return $ret_or_4
      } else {
        return []
      }
    }, $UnboundMethod_comments$16.$$arity = 0);
    
    Opal.def(self, '$bind', $UnboundMethod_bind$17 = function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$($nesting, 'Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    }, $UnboundMethod_bind$17.$$arity = 1);
    return (Opal.def(self, '$inspect', $UnboundMethod_inspect$18 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $UnboundMethod_inspect$18.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/variables"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $gvars = Opal.gvars, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new']);
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  Opal.const_set($nesting[0], 'ARGV', []);
  Opal.const_set($nesting[0], 'ARGF', $$($nesting, 'Object').$new());
  Opal.const_set($nesting[0], 'ENV', $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/io"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $module = Opal.module, $gvars = Opal.gvars, $send = Opal.send, $writer = nil;

  Opal.add_stubs(['$attr_accessor', '$size', '$write', '$String', '$chomp', '$getbyte', '$getc', '$raise', '$new', '$write_proc=', '$-', '$extend']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IO');

    var $nesting = [self].concat($parent_nesting), $IO_tty$ques$1, $IO_closed$ques$2, $IO_write$3, $IO_flush$4;

    self.$$prototype.tty = self.$$prototype.closed = nil;
    
    Opal.const_set($nesting[0], 'SEEK_SET', 0);
    Opal.const_set($nesting[0], 'SEEK_CUR', 1);
    Opal.const_set($nesting[0], 'SEEK_END', 2);
    
    Opal.def(self, '$tty?', $IO_tty$ques$1 = function() {
      var self = this;

      return self.tty
    }, $IO_tty$ques$1.$$arity = 0);
    
    Opal.def(self, '$closed?', $IO_closed$ques$2 = function() {
      var self = this;

      return self.closed
    }, $IO_closed$ques$2.$$arity = 0);
    self.$attr_accessor("write_proc");
    
    Opal.def(self, '$write', $IO_write$3 = function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    }, $IO_write$3.$$arity = 1);
    self.$attr_accessor("sync", "tty");
    
    Opal.def(self, '$flush', $IO_flush$4 = function $$flush() {
      var self = this;

      return nil
    }, $IO_flush$4.$$arity = 0);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Writable');

      var $nesting = [self].concat($parent_nesting), $Writable_$lt$lt$5, $Writable_print$6, $Writable_puts$7;

      
      
      Opal.def(self, '$<<', $Writable_$lt$lt$5 = function(string) {
        var self = this;

        
        self.$write(string);
        return self;
      }, $Writable_$lt$lt$5.$$arity = 1);
      
      Opal.def(self, '$print', $Writable_print$6 = function $$print($a) {
        var $post_args, args, self = this;
        if ($gvars[","] == null) $gvars[","] = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        
        for (var i = 0, ii = args.length; i < ii; i++) {
          args[i] = self.$String(args[i])
        }
        self.$write(args.join($gvars[","]));
      ;
        return nil;
      }, $Writable_print$6.$$arity = -1);
      return (Opal.def(self, '$puts', $Writable_puts$7 = function $$puts($a) {
        var $post_args, args, self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        
        for (var i = 0, ii = args.length; i < ii; i++) {
          args[i] = self.$String(args[i]).$chomp()
        }
        self.$write(args.concat([nil]).join($gvars["/"]));
      ;
        return nil;
      }, $Writable_puts$7.$$arity = -1), nil) && 'puts';
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'Readable');

      var $nesting = [self].concat($parent_nesting), $Readable_readbyte$8, $Readable_readchar$9, $Readable_readline$10, $Readable_readpartial$11;

      
      
      Opal.def(self, '$readbyte', $Readable_readbyte$8 = function $$readbyte() {
        var self = this;

        return self.$getbyte()
      }, $Readable_readbyte$8.$$arity = 0);
      
      Opal.def(self, '$readchar', $Readable_readchar$9 = function $$readchar() {
        var self = this;

        return self.$getc()
      }, $Readable_readchar$9.$$arity = 0);
      
      Opal.def(self, '$readline', $Readable_readline$10 = function $$readline(sep) {
        var self = this;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        
        if (sep == null) {
          sep = $gvars["/"];
        };
        return self.$raise($$($nesting, 'NotImplementedError'));
      }, $Readable_readline$10.$$arity = -1);
      return (Opal.def(self, '$readpartial', $Readable_readpartial$11 = function $$readpartial(integer, outbuf) {
        var self = this;

        
        
        if (outbuf == null) {
          outbuf = nil;
        };
        return self.$raise($$($nesting, 'NotImplementedError'));
      }, $Readable_readpartial$11.$$arity = -2), nil) && 'readpartial';
    })($nesting[0], $nesting);
  })($nesting[0], null, $nesting);
  Opal.const_set($nesting[0], 'STDERR', ($gvars.stderr = $$($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDIN', ($gvars.stdin = $$($nesting, 'IO').$new()));
  Opal.const_set($nesting[0], 'STDOUT', ($gvars.stdout = $$($nesting, 'IO').$new()));
  var console = Opal.global.console;
  
  $writer = [typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)}];
  $send($$($nesting, 'STDOUT'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)}];
  $send($$($nesting, 'STDERR'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  $$($nesting, 'STDOUT').$extend($$$($$($nesting, 'IO'), 'Writable'));
  return $$($nesting, 'STDERR').$extend($$$($$($nesting, 'IO'), 'Writable'));
};

/* Generated by Opal 1.2.0 */
Opal.modules["opal/regexp_anchors"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  Opal.add_stubs(['$new']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.const_set($nesting[0], 'REGEXP_START', "^");
    Opal.const_set($nesting[0], 'REGEXP_END', "$");
    Opal.const_set($nesting[0], 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'INLINE_IDENTIFIER_REGEXP', $$($nesting, 'Regexp').$new("" + "[^" + ($$($nesting, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$($nesting, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    Opal.const_set($nesting[0], 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    return Opal.const_set($nesting[0], 'CONST_NAME_REGEXP', $$($nesting, 'Regexp').$new("" + ($$($nesting, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$($nesting, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$($nesting, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["opal/mini"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("corelib/nil");
  self.$require("corelib/boolean");
  self.$require("corelib/string");
  self.$require("corelib/comparable");
  self.$require("corelib/enumerable");
  self.$require("corelib/enumerator");
  self.$require("corelib/array");
  self.$require("corelib/hash");
  self.$require("corelib/number");
  self.$require("corelib/range");
  self.$require("corelib/proc");
  self.$require("corelib/method");
  self.$require("corelib/regexp");
  self.$require("corelib/variables");
  self.$require("corelib/io");
  return self.$require("opal/regexp_anchors");
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/kernel/format"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$==', '$length', '$respond_to?', '$[]', '$coerce_to?', '$nil?', '$to_a', '$raise', '$to_int', '$fetch', '$Integer', '$Float', '$to_ary', '$to_str', '$inspect', '$to_s']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_format$1;

    
    
    Opal.def(self, '$format', $Kernel_format$1 = function $$format(format_string, $a) {
      var $post_args, args, self = this, $ret_or_1 = nil, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_1 = args.$length()['$=='](1)))) {
        return args['$[]'](0)['$respond_to?']("to_ary")
      } else {
        return $ret_or_1
      }; return nil; })())) {
        
        ary = $$($nesting, 'Opal')['$coerce_to?'](args['$[]'](0), $$($nesting, 'Array'), "to_ary");
        if ($truthy(ary['$nil?']())) {
        } else {
          args = ary.$to_a()
        };};
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), "flag after width") }
        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), "width given twice") }
        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { self.$raise($$($nesting, 'ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with numbered")
        case -2: self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with named")
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after unnumbered(" + (pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after named")
        }
        if (num < 1) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid index - " + (num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              self.$raise($$($nesting, 'ArgumentError'), "" + (label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "value given twice - %" + (tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                self.$raise($$($nesting, 'ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  self.$raise($$($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after unnumbered(" + (pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  self.$raise($$($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  self.$raise($$($nesting, 'ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              self.$raise($$($nesting, 'ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = self.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            self.$raise($$($nesting, 'NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode($coerce_to(arg, $$($nesting, 'Integer'), 'to_int'));
            }
            if (str.length !== 1) {
              self.$raise($$($nesting, 'ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            self.$raise($$($nesting, 'ArgumentError'), "" + "malformed format string - %" + (format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        self.$raise($$($nesting, 'ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, $Kernel_format$1.$$arity = -2);
    return Opal.alias(self, "sprintf", "format");
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/string/encoding"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var $$14, $$17, $$20, $$22, $$25, $$27, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $writer = nil;

  Opal.add_stubs(['$require', '$+', '$[]', '$clone', '$initialize', '$new', '$instance_eval', '$to_proc', '$each', '$const_set', '$tr', '$==', '$default_external', '$attr_accessor', '$singleton_class', '$attr_reader', '$raise', '$register', '$length', '$bytes', '$force_encoding', '$dup', '$bytesize', '$enum_for', '$each_byte', '$to_a', '$each_char', '$each_codepoint', '$coerce_to!', '$find', '$<', '$default_external=', '$-']);
  
  self.$require("corelib/string");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Encoding');

    var $nesting = [self].concat($parent_nesting), $Encoding_register$1, $Encoding_find$3, $Encoding_initialize$4, $Encoding_ascii_compatible$ques$5, $Encoding_dummy$ques$6, $Encoding_binary$ques$7, $Encoding_to_s$8, $Encoding_inspect$9, $Encoding_charsize$10, $Encoding_each_char$11, $Encoding_each_byte$12, $Encoding_bytesize$13;

    self.$$prototype.ascii = self.$$prototype.dummy = self.$$prototype.name = nil;
    
    Opal.defs(self, '$register', $Encoding_register$1 = function $$register(name, options) {
      var $iter = $Encoding_register$1.$$p, block = $iter || nil, $$2, self = this, names = nil, $ret_or_1 = nil, ascii = nil, $ret_or_2 = nil, dummy = nil, $ret_or_3 = nil, encoding = nil, register = nil;

      if ($iter) $Encoding_register$1.$$p = null;
      
      
      if ($iter) $Encoding_register$1.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      names = $rb_plus([name], (function() {if ($truthy(($ret_or_1 = options['$[]']("aliases")))) {
        return $ret_or_1
      } else {
        return []
      }; return nil; })());
      ascii = (function() {if ($truthy(($ret_or_2 = options['$[]']("ascii")))) {
        return $ret_or_2
      } else {
        return false
      }; return nil; })();
      dummy = (function() {if ($truthy(($ret_or_3 = options['$[]']("dummy")))) {
        return $ret_or_3
      } else {
        return false
      }; return nil; })();
      if ($truthy(options['$[]']("inherits"))) {
        
        encoding = options['$[]']("inherits").$clone();
        encoding.$initialize(name, names, ascii, dummy);
      } else {
        encoding = self.$new(name, names, ascii, dummy)
      };
      if ((block !== nil)) {
        $send(encoding, 'instance_eval', [], block.$to_proc())};
      register = Opal.encodings;
      return $send(names, 'each', [], ($$2 = function(encoding_name){var self = $$2.$$s == null ? this : $$2.$$s;

      
        
        if (encoding_name == null) {
          encoding_name = nil;
        };
        self.$const_set(encoding_name.$tr("-", "_"), encoding);
        return register[encoding_name] = encoding;}, $$2.$$s = self, $$2.$$arity = 1, $$2));
    }, $Encoding_register$1.$$arity = -2);
    Opal.defs(self, '$find', $Encoding_find$3 = function $$find(name) {
      var self = this;

      
      if (name['$==']("default_external")) {
        return self.$default_external()};
      return Opal.find_encoding(name);;
    }, $Encoding_find$3.$$arity = 1);
    self.$singleton_class().$attr_accessor("default_external");
    self.$attr_reader("name", "names");
    
    Opal.def(self, '$initialize', $Encoding_initialize$4 = function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    }, $Encoding_initialize$4.$$arity = 4);
    
    Opal.def(self, '$ascii_compatible?', $Encoding_ascii_compatible$ques$5 = function() {
      var self = this;

      return self.ascii
    }, $Encoding_ascii_compatible$ques$5.$$arity = 0);
    
    Opal.def(self, '$dummy?', $Encoding_dummy$ques$6 = function() {
      var self = this;

      return self.dummy
    }, $Encoding_dummy$ques$6.$$arity = 0);
    
    Opal.def(self, '$binary?', $Encoding_binary$ques$7 = function() {
      var self = this;

      return false
    }, $Encoding_binary$ques$7.$$arity = 0);
    
    Opal.def(self, '$to_s', $Encoding_to_s$8 = function $$to_s() {
      var self = this;

      return self.name
    }, $Encoding_to_s$8.$$arity = 0);
    
    Opal.def(self, '$inspect', $Encoding_inspect$9 = function $$inspect() {
      var self = this;

      return "" + "#<Encoding:" + (self.name) + ((function() {if ($truthy(self.dummy)) {
        return " (dummy)"
      } else {
        return nil
      }; return nil; })()) + ">"
    }, $Encoding_inspect$9.$$arity = 0);
    
    Opal.def(self, '$charsize', $Encoding_charsize$10 = function $$charsize(string) {
      var self = this;

      
      var len = 0;
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        if (!(charcode >= 0xD800 && charcode <= 0xDBFF)) {
          len++;
        }
      }
      return len;
    
    }, $Encoding_charsize$10.$$arity = 1);
    
    Opal.def(self, '$each_char', $Encoding_each_char$11 = function $$each_char(string) {
      var $iter = $Encoding_each_char$11.$$p, block = $iter || nil, self = this;

      if ($iter) $Encoding_each_char$11.$$p = null;
      
      
      if ($iter) $Encoding_each_char$11.$$p = null;;
      
      var low_surrogate = "";
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        var chr = string.charAt(i);
        if (charcode >= 0xDC00 && charcode <= 0xDFFF) {
          low_surrogate = chr;
          continue;
        }
        else if (charcode >= 0xD800 && charcode <= 0xDBFF) {
          chr = low_surrogate + chr;
        }
        if (string.encoding.name != "UTF-8") {
          chr = new String(chr);
          chr.encoding = string.encoding;
        }
        Opal.yield1(block, chr);
      }
    ;
    }, $Encoding_each_char$11.$$arity = 1);
    
    Opal.def(self, '$each_byte', $Encoding_each_byte$12 = function $$each_byte($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_each_byte$12.$$arity = -1);
    
    Opal.def(self, '$bytesize', $Encoding_bytesize$13 = function $$bytesize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_bytesize$13.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EncodingError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CompatibilityError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'EncodingError'), $nesting);
  })($nesting[0], null, $nesting);
  $send($$($nesting, 'Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], ($$14 = function(){var self = $$14.$$s == null ? this : $$14.$$s, $each_byte$15, $bytesize$16;

  
    
    Opal.def(self, '$each_byte', $each_byte$15 = function $$each_byte(string) {
      var $iter = $each_byte$15.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$15.$$p = null;
      
      
      if ($iter) $each_byte$15.$$p = null;;
      
      // Taken from: https://github.com/feross/buffer/blob/f52dffd9df0445b93c0c9065c2f8f0f46b2c729a/index.js#L1954-L2032
      var units = Infinity
      var codePoint
      var length = string.length
      var leadSurrogate = null

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i)

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue
            }

            // valid lead
            leadSurrogate = codePoint

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) {
              Opal.yield1(block, 0xEF);
              Opal.yield1(block, 0xBF);
              Opal.yield1(block, 0xBD);
            }
            leadSurrogate = codePoint
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) {
            Opal.yield1(block, 0xEF);
            Opal.yield1(block, 0xBF);
            Opal.yield1(block, 0xBD);
          }
        }

        leadSurrogate = null

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          Opal.yield1(block, codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          Opal.yield1(block, codePoint >> 0x6 | 0xC0);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          Opal.yield1(block, codePoint >> 0xC | 0xE0);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          Opal.yield1(block, codePoint >> 0x12 | 0xF0);
          Opal.yield1(block, codePoint >> 0xC & 0x3F | 0x80);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else {
          // Invalid code point
        }
      }
    ;
    }, $each_byte$15.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$16 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$16.$$arity = 1), nil) && 'bytesize';}, $$14.$$s = self, $$14.$$arity = 0, $$14));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16LE"], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s, $each_byte$18, $bytesize$19;

  
    
    Opal.def(self, '$each_byte', $each_byte$18 = function $$each_byte(string) {
      var $iter = $each_byte$18.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$18.$$p = null;
      
      
      if ($iter) $each_byte$18.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$18.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$19 = function $$bytesize(string) {
      var self = this;

      return string.length * 2;
    }, $bytesize$19.$$arity = 1), nil) && 'bytesize';}, $$17.$$s = self, $$17.$$arity = 0, $$17));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16BE", $hash2(["inherits"], {"inherits": $$$($$($nesting, 'Encoding'), 'UTF_16LE')})], ($$20 = function(){var self = $$20.$$s == null ? this : $$20.$$s, $each_byte$21;

  return (Opal.def(self, '$each_byte', $each_byte$21 = function $$each_byte(string) {
      var $iter = $each_byte$21.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$21.$$p = null;
      
      
      if ($iter) $each_byte$21.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$21.$$arity = 1), nil) && 'each_byte'}, $$20.$$s = self, $$20.$$arity = 0, $$20));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-32LE"], ($$22 = function(){var self = $$22.$$s == null ? this : $$22.$$s, $each_byte$23, $bytesize$24;

  
    
    Opal.def(self, '$each_byte', $each_byte$23 = function $$each_byte(string) {
      var $iter = $each_byte$23.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$23.$$p = null;
      
      
      if ($iter) $each_byte$23.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
      }
    ;
    }, $each_byte$23.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$24 = function $$bytesize(string) {
      var self = this;

      return string.length * 4;
    }, $bytesize$24.$$arity = 1), nil) && 'bytesize';}, $$22.$$s = self, $$22.$$arity = 0, $$22));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-32BE", $hash2(["inherits"], {"inherits": $$$($$($nesting, 'Encoding'), 'UTF_32LE')})], ($$25 = function(){var self = $$25.$$s == null ? this : $$25.$$s, $each_byte$26;

  return (Opal.def(self, '$each_byte', $each_byte$26 = function $$each_byte(string) {
      var $iter = $each_byte$26.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$26.$$p = null;
      
      
      if ($iter) $each_byte$26.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$26.$$arity = 1), nil) && 'each_byte'}, $$25.$$s = self, $$25.$$arity = 0, $$25));
  $send($$($nesting, 'Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii"], {"aliases": ["BINARY"], "ascii": true})], ($$27 = function(){var self = $$27.$$s == null ? this : $$27.$$s, $each_char$28, $charsize$29, $each_byte$30, $bytesize$31, $binary$ques$32;

  
    
    Opal.def(self, '$each_char', $each_char$28 = function $$each_char(string) {
      var $iter = $each_char$28.$$p, block = $iter || nil, self = this;

      if ($iter) $each_char$28.$$p = null;
      
      
      if ($iter) $each_char$28.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var chr = new String(string.charAt(i));
        chr.encoding = string.encoding;
        Opal.yield1(block, chr);
      }
    ;
    }, $each_char$28.$$arity = 1);
    
    Opal.def(self, '$charsize', $charsize$29 = function $$charsize(string) {
      var self = this;

      return string.length;
    }, $charsize$29.$$arity = 1);
    
    Opal.def(self, '$each_byte', $each_byte$30 = function $$each_byte(string) {
      var $iter = $each_byte$30.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$30.$$p = null;
      
      
      if ($iter) $each_byte$30.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$30.$$arity = 1);
    
    Opal.def(self, '$bytesize', $bytesize$31 = function $$bytesize(string) {
      var self = this;

      return string.length;
    }, $bytesize$31.$$arity = 1);
    return (Opal.def(self, '$binary?', $binary$ques$32 = function() {
      var self = this;

      return true
    }, $binary$ques$32.$$arity = 0), nil) && 'binary?';}, $$27.$$s = self, $$27.$$arity = 0, $$27));
  $$($nesting, 'Encoding').$register("ISO-8859-1", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ISO8859-1"], "ascii": true, "inherits": $$$($$($nesting, 'Encoding'), 'ASCII_8BIT')}));
  $$($nesting, 'Encoding').$register("US-ASCII", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ASCII"], "ascii": true, "inherits": $$$($$($nesting, 'Encoding'), 'ASCII_8BIT')}));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_b$33, $String_bytesize$34, $String_each_byte$35, $String_bytes$37, $String_each_char$38, $String_chars$40, $String_each_codepoint$41, $String_codepoints$42, $String_encode$43, $String_force_encoding$44, $String_getbyte$45, $String_initialize_copy$46, $String_length$47, $String_valid_encoding$ques$48;

    self.$$prototype.internal_encoding = self.$$prototype.bytes = self.$$prototype.encoding = nil;
    
    self.$attr_reader("encoding");
    self.$attr_reader("internal_encoding");
    Opal.defineProperty(String.prototype, 'bytes', nil);
    Opal.defineProperty(String.prototype, 'encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
    Opal.defineProperty(String.prototype, 'internal_encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
    
    Opal.def(self, '$b', $String_b$33 = function $$b() {
      var self = this;

      return self.$dup().$force_encoding("binary")
    }, $String_b$33.$$arity = 0);
    
    Opal.def(self, '$bytesize', $String_bytesize$34 = function $$bytesize() {
      var self = this;

      return self.internal_encoding.$bytesize(self)
    }, $String_bytesize$34.$$arity = 0);
    
    Opal.def(self, '$each_byte', $String_each_byte$35 = function $$each_byte() {
      var $iter = $String_each_byte$35.$$p, block = $iter || nil, $$36, self = this;

      if ($iter) $String_each_byte$35.$$p = null;
      
      
      if ($iter) $String_each_byte$35.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_byte"], ($$36 = function(){var self = $$36.$$s == null ? this : $$36.$$s;

        return self.$bytesize()}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      $send(self.internal_encoding, 'each_byte', [self], block.$to_proc());
      return self;
    }, $String_each_byte$35.$$arity = 0);
    
    Opal.def(self, '$bytes', $String_bytes$37 = function $$bytes() {
      var self = this, $ret_or_4 = nil;

      
      
      if (typeof self === 'string') {
        return (new String(self)).$each_byte().$to_a();
      }
    ;
      self.bytes = (function() {if ($truthy(($ret_or_4 = self.bytes))) {
        return $ret_or_4
      } else {
        return self.$each_byte().$to_a()
      }; return nil; })();
      return self.bytes.$dup();
    }, $String_bytes$37.$$arity = 0);
    
    Opal.def(self, '$each_char', $String_each_char$38 = function $$each_char() {
      var $iter = $String_each_char$38.$$p, block = $iter || nil, $$39, self = this;

      if ($iter) $String_each_char$38.$$p = null;
      
      
      if ($iter) $String_each_char$38.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_char"], ($$39 = function(){var self = $$39.$$s == null ? this : $$39.$$s;

        return self.$length()}, $$39.$$s = self, $$39.$$arity = 0, $$39))
      };
      $send(self.encoding, 'each_char', [self], block.$to_proc());
      return self;
    }, $String_each_char$38.$$arity = 0);
    
    Opal.def(self, '$chars', $String_chars$40 = function $$chars() {
      var $iter = $String_chars$40.$$p, block = $iter || nil, self = this;

      if ($iter) $String_chars$40.$$p = null;
      
      
      if ($iter) $String_chars$40.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    }, $String_chars$40.$$arity = 0);
    
    Opal.def(self, '$each_codepoint', $String_each_codepoint$41 = function $$each_codepoint() {
      var $iter = $String_each_codepoint$41.$$p, block = $iter || nil, self = this;

      if ($iter) $String_each_codepoint$41.$$p = null;
      
      
      if ($iter) $String_each_codepoint$41.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_codepoint")
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.codePointAt(i));
      }
    ;
      return self;
    }, $String_each_codepoint$41.$$arity = 0);
    
    Opal.def(self, '$codepoints', $String_codepoints$42 = function $$codepoints() {
      var $iter = $String_codepoints$42.$$p, block = $iter || nil, self = this;

      if ($iter) $String_codepoints$42.$$p = null;
      
      
      if ($iter) $String_codepoints$42.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())};
      return self.$each_codepoint().$to_a();
    }, $String_codepoints$42.$$arity = 0);
    
    Opal.def(self, '$encode', $String_encode$43 = function $$encode(encoding) {
      var self = this;

      return Opal.enc(self, encoding);
    }, $String_encode$43.$$arity = 1);
    
    Opal.def(self, '$force_encoding', $String_force_encoding$44 = function $$force_encoding(encoding) {
      var self = this;

      
      var str = self;

      if (encoding === str.encoding) { return str; }

      encoding = $$($nesting, 'Opal')['$coerce_to!'](encoding, $$($nesting, 'String'), "to_s");
      encoding = $$($nesting, 'Encoding').$find(encoding);

      if (encoding === str.encoding) { return str; }

      str = Opal.set_encoding(str, encoding);

      return str;
    
    }, $String_force_encoding$44.$$arity = 1);
    
    Opal.def(self, '$getbyte', $String_getbyte$45 = function $$getbyte(idx) {
      var self = this, string_bytes = nil;

      
      string_bytes = self.$bytes();
      idx = $$($nesting, 'Opal')['$coerce_to!'](idx, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(string_bytes.$length(), idx))) {
        return nil};
      return string_bytes['$[]'](idx);
    }, $String_getbyte$45.$$arity = 1);
    
    Opal.def(self, '$initialize_copy', $String_initialize_copy$46 = function $$initialize_copy(other) {
      var self = this;

      return "" + "\n" + "      self.encoding = other.encoding;\n" + "      self.internal_encoding = other.internal_encoding;\n" + "    "
    }, $String_initialize_copy$46.$$arity = 1);
    
    Opal.def(self, '$length', $String_length$47 = function $$length() {
      var self = this;

      return self.length;
    }, $String_length$47.$$arity = 0);
    Opal.alias(self, "size", "length");
    return (Opal.def(self, '$valid_encoding?', $String_valid_encoding$ques$48 = function() {
      var self = this;

      return true
    }, $String_valid_encoding$ques$48.$$arity = 0), nil) && 'valid_encoding?';
  })($nesting[0], null, $nesting);
  
  $writer = [$$$($$($nesting, 'Encoding'), 'UTF_8')];
  $send($$($nesting, 'Encoding'), 'default_external=', Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/math"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $type_error = Opal.type_error, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$raise', '$Float', '$Integer', '$module_function', '$checked', '$float!', '$===', '$gamma', '$-', '$integer!', '$/', '$infinite?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Math');

    var $nesting = [self].concat($parent_nesting), $Math_checked$1, $Math_float$excl$2, $Math_integer$excl$3, $Math_acos$4, $Math_acosh$5, $Math_asin$6, $Math_asinh$7, $Math_atan$8, $Math_atan2$9, $Math_atanh$10, $Math_cbrt$11, $Math_cos$12, $Math_cosh$13, $Math_erf$14, $Math_erfc$15, $Math_exp$16, $Math_frexp$17, $Math_gamma$18, $Math_hypot$19, $Math_ldexp$20, $Math_lgamma$21, $Math_log$22, $Math_log10$23, $Math_log2$24, $Math_sin$25, $Math_sinh$26, $Math_sqrt$27, $Math_tan$28, $Math_tanh$29;

    
    Opal.const_set($nesting[0], 'E', Math.E);
    Opal.const_set($nesting[0], 'PI', Math.PI);
    Opal.const_set($nesting[0], 'DomainError', $$($nesting, 'Class').$new($$($nesting, 'StandardError')));
    Opal.defs(self, '$checked', $Math_checked$1 = function $$checked(method, $a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        self.$raise($$($nesting, 'DomainError'), "" + "Numerical argument is out of domain - \"" + (method) + "\"");
      }

      return result;
    ;
    }, $Math_checked$1.$$arity = -2);
    Opal.defs(self, '$float!', $Math_float$excl$2 = function(value) {
      var self = this;

      try {
        return self.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return self.$raise($type_error(value, $$($nesting, 'Float')))
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Math_float$excl$2.$$arity = 1);
    Opal.defs(self, '$integer!', $Math_integer$excl$3 = function(value) {
      var self = this;

      try {
        return self.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return self.$raise($type_error(value, $$($nesting, 'Integer')))
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      }
    }, $Math_integer$excl$3.$$arity = 1);
    self.$module_function();
    
    Opal.def(self, '$acos', $Math_acos$4 = function $$acos(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("acos", $$($nesting, 'Math')['$float!'](x))
    }, $Math_acos$4.$$arity = 1);
    if ($truthy((typeof(Math.acosh) !== "undefined"))) {
    } else {
      
      Math.acosh = function(x) {
        return Math.log(x + Math.sqrt(x * x - 1));
      }
    
    };
    
    Opal.def(self, '$acosh', $Math_acosh$5 = function $$acosh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("acosh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_acosh$5.$$arity = 1);
    
    Opal.def(self, '$asin', $Math_asin$6 = function $$asin(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("asin", $$($nesting, 'Math')['$float!'](x))
    }, $Math_asin$6.$$arity = 1);
    if ($truthy((typeof(Math.asinh) !== "undefined"))) {
    } else {
      
      Math.asinh = function(x) {
        return Math.log(x + Math.sqrt(x * x + 1))
      }
    
    };
    
    Opal.def(self, '$asinh', $Math_asinh$7 = function $$asinh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("asinh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_asinh$7.$$arity = 1);
    
    Opal.def(self, '$atan', $Math_atan$8 = function $$atan(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atan", $$($nesting, 'Math')['$float!'](x))
    }, $Math_atan$8.$$arity = 1);
    
    Opal.def(self, '$atan2', $Math_atan2$9 = function $$atan2(y, x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atan2", $$($nesting, 'Math')['$float!'](y), $$($nesting, 'Math')['$float!'](x))
    }, $Math_atan2$9.$$arity = 2);
    if ($truthy((typeof(Math.atanh) !== "undefined"))) {
    } else {
      
      Math.atanh = function(x) {
        return 0.5 * Math.log((1 + x) / (1 - x));
      }
    
    };
    
    Opal.def(self, '$atanh', $Math_atanh$10 = function $$atanh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atanh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_atanh$10.$$arity = 1);
    if ($truthy((typeof(Math.cbrt) !== "undefined"))) {
    } else {
      
      Math.cbrt = function(x) {
        if (x == 0) {
          return 0;
        }

        if (x < 0) {
          return -Math.cbrt(-x);
        }

        var r  = x,
            ex = 0;

        while (r < 0.125) {
          r *= 8;
          ex--;
        }

        while (r > 1.0) {
          r *= 0.125;
          ex++;
        }

        r = (-0.46946116 * r + 1.072302) * r + 0.3812513;

        while (ex < 0) {
          r *= 0.5;
          ex++;
        }

        while (ex > 0) {
          r *= 2;
          ex--;
        }

        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);

        return r;
      }
    
    };
    
    Opal.def(self, '$cbrt', $Math_cbrt$11 = function $$cbrt(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cbrt", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cbrt$11.$$arity = 1);
    
    Opal.def(self, '$cos', $Math_cos$12 = function $$cos(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cos", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cos$12.$$arity = 1);
    if ($truthy((typeof(Math.cosh) !== "undefined"))) {
    } else {
      
      Math.cosh = function(x) {
        return (Math.exp(x) + Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.def(self, '$cosh', $Math_cosh$13 = function $$cosh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cosh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cosh$13.$$arity = 1);
    if ($truthy((typeof(Math.erf) !== "undefined"))) {
    } else {
      
      Opal.defineProperty(Math, 'erf', function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    
    };
    
    Opal.def(self, '$erf', $Math_erf$14 = function $$erf(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("erf", $$($nesting, 'Math')['$float!'](x))
    }, $Math_erf$14.$$arity = 1);
    if ($truthy((typeof(Math.erfc) !== "undefined"))) {
    } else {
      
      Opal.defineProperty(Math, 'erfc', function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      });
    
    };
    
    Opal.def(self, '$erfc', $Math_erfc$15 = function $$erfc(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("erfc", $$($nesting, 'Math')['$float!'](x))
    }, $Math_erfc$15.$$arity = 1);
    
    Opal.def(self, '$exp', $Math_exp$16 = function $$exp(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("exp", $$($nesting, 'Math')['$float!'](x))
    }, $Math_exp$16.$$arity = 1);
    
    Opal.def(self, '$frexp', $Math_frexp$17 = function $$frexp(x) {
      var self = this;

      
      x = $$($nesting, 'Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    }, $Math_frexp$17.$$arity = 1);
    
    Opal.def(self, '$gamma', $Math_gamma$18 = function $$gamma(n) {
      var self = this;

      
      n = $$($nesting, 'Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];


      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        self.$raise($$($nesting, 'DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if ($$($nesting, 'Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * $$($nesting, 'Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    }, $Math_gamma$18.$$arity = 1);
    if ($truthy((typeof(Math.hypot) !== "undefined"))) {
    } else {
      
      Math.hypot = function(x, y) {
        return Math.sqrt(x * x + y * y)
      }
    
    };
    
    Opal.def(self, '$hypot', $Math_hypot$19 = function $$hypot(x, y) {
      var self = this;

      return $$($nesting, 'Math').$checked("hypot", $$($nesting, 'Math')['$float!'](x), $$($nesting, 'Math')['$float!'](y))
    }, $Math_hypot$19.$$arity = 2);
    
    Opal.def(self, '$ldexp', $Math_ldexp$20 = function $$ldexp(mantissa, exponent) {
      var self = this;

      
      mantissa = $$($nesting, 'Math')['$float!'](mantissa);
      exponent = $$($nesting, 'Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        self.$raise($$($nesting, 'RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    }, $Math_ldexp$20.$$arity = 2);
    
    Opal.def(self, '$lgamma', $Math_lgamma$21 = function $$lgamma(n) {
      var self = this;

      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs($$($nesting, 'Math').$gamma(n))), $$($nesting, 'Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    }, $Math_lgamma$21.$$arity = 1);
    
    Opal.def(self, '$log', $Math_log$22 = function $$log(x, base) {
      var self = this;

      
      ;
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($type_error(x, $$($nesting, 'Float')))};
      if ($truthy(base == null)) {
        return $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x))
      } else {
        
        if ($truthy($$($nesting, 'String')['$==='](base))) {
          self.$raise($type_error(base, $$($nesting, 'Float')))};
        return $rb_divide($$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x)), $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](base)));
      };
    }, $Math_log$22.$$arity = -2);
    if ($truthy((typeof(Math.log10) !== "undefined"))) {
    } else {
      
      Math.log10 = function(x) {
        return Math.log(x) / Math.LN10;
      }
    
    };
    
    Opal.def(self, '$log10', $Math_log10$23 = function $$log10(x) {
      var self = this;

      
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($type_error(x, $$($nesting, 'Float')))};
      return $$($nesting, 'Math').$checked("log10", $$($nesting, 'Math')['$float!'](x));
    }, $Math_log10$23.$$arity = 1);
    if ($truthy((typeof(Math.log2) !== "undefined"))) {
    } else {
      
      Math.log2 = function(x) {
        return Math.log(x) / Math.LN2;
      }
    
    };
    
    Opal.def(self, '$log2', $Math_log2$24 = function $$log2(x) {
      var self = this;

      
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($type_error(x, $$($nesting, 'Float')))};
      return $$($nesting, 'Math').$checked("log2", $$($nesting, 'Math')['$float!'](x));
    }, $Math_log2$24.$$arity = 1);
    
    Opal.def(self, '$sin', $Math_sin$25 = function $$sin(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sin", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sin$25.$$arity = 1);
    if ($truthy((typeof(Math.sinh) !== "undefined"))) {
    } else {
      
      Math.sinh = function(x) {
        return (Math.exp(x) - Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.def(self, '$sinh', $Math_sinh$26 = function $$sinh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sinh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sinh$26.$$arity = 1);
    
    Opal.def(self, '$sqrt', $Math_sqrt$27 = function $$sqrt(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sqrt", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sqrt$27.$$arity = 1);
    
    Opal.def(self, '$tan', $Math_tan$28 = function $$tan(x) {
      var self = this;

      
      x = $$($nesting, 'Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return $$$($$($nesting, 'Float'), 'NAN')};
      return $$($nesting, 'Math').$checked("tan", $$($nesting, 'Math')['$float!'](x));
    }, $Math_tan$28.$$arity = 1);
    if ($truthy((typeof(Math.tanh) !== "undefined"))) {
    } else {
      
      Math.tanh = function(x) {
        if (x == Infinity) {
          return 1;
        }
        else if (x == -Infinity) {
          return -1;
        }
        else {
          return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
        }
      }
    
    };
    return (Opal.def(self, '$tanh', $Math_tanh$29 = function $$tanh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("tanh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_tanh$29.$$arity = 1), nil) && 'tanh';
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/complex"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs(['$require', '$===', '$real?', '$raise', '$new', '$*', '$cos', '$sin', '$attr_reader', '$class', '$==', '$real', '$imag', '$Complex', '$-@', '$+', '$__coerced__', '$-', '$nan?', '$/', '$conj', '$abs2', '$quo', '$polar', '$exp', '$log', '$>', '$!=', '$divmod', '$**', '$hypot', '$atan2', '$lcm', '$denominator', '$finite?', '$infinite?', '$numerator', '$abs', '$arg', '$rationalize', '$to_f', '$to_i', '$to_r', '$inspect', '$positive?', '$zero?', '$Rational']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Complex');

    var $nesting = [self].concat($parent_nesting), $Complex_rect$1, $Complex_polar$2, $Complex_initialize$3, $Complex_coerce$4, $Complex_$eq_eq$5, $Complex_$minus$$6, $Complex_$plus$7, $Complex_$minus$8, $Complex_$$9, $Complex_$slash$10, $Complex_$$$11, $Complex_abs$12, $Complex_abs2$13, $Complex_angle$14, $Complex_conj$15, $Complex_denominator$16, $Complex_eql$ques$17, $Complex_fdiv$18, $Complex_finite$ques$19, $Complex_hash$20, $Complex_infinite$ques$21, $Complex_inspect$22, $Complex_numerator$23, $Complex_polar$24, $Complex_rationalize$25, $Complex_real$ques$26, $Complex_rect$27, $Complex_to_f$28, $Complex_to_i$29, $Complex_to_r$30, $Complex_to_s$31;

    self.$$prototype.real = self.$$prototype.imag = nil;
    
    Opal.defs(self, '$rect', $Complex_rect$1 = function $$rect(real, imag) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      
      
      if (imag == null) {
        imag = 0;
      };
      if ($truthy((function() {if ($truthy(($ret_or_1 = (function() {if ($truthy(($ret_or_2 = (function() {if ($truthy(($ret_or_3 = $$($nesting, 'Numeric')['$==='](real)))) {
        return real['$real?']()
      } else {
        return $ret_or_3
      }; return nil; })()))) {
        return $$($nesting, 'Numeric')['$==='](imag)
      } else {
        return $ret_or_2
      }; return nil; })()))) {
        return imag['$real?']()
      } else {
        return $ret_or_1
      }; return nil; })())) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, $Complex_rect$1.$$arity = -2);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return Opal.alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$polar', $Complex_polar$2 = function $$polar(r, theta) {
      var self = this, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil;

      
      
      if (theta == null) {
        theta = 0;
      };
      if ($truthy((function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = $$($nesting, 'Numeric')['$==='](r)))) {
        return r['$real?']()
      } else {
        return $ret_or_6
      }; return nil; })()))) {
        return $$($nesting, 'Numeric')['$==='](theta)
      } else {
        return $ret_or_5
      }; return nil; })()))) {
        return theta['$real?']()
      } else {
        return $ret_or_4
      }; return nil; })())) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not a real")
      };
      return self.$new($rb_times(r, $$($nesting, 'Math').$cos(theta)), $rb_times(r, $$($nesting, 'Math').$sin(theta)));
    }, $Complex_polar$2.$$arity = -2);
    self.$attr_reader("real", "imag");
    
    Opal.def(self, '$initialize', $Complex_initialize$3 = function $$initialize(real, imag) {
      var self = this;

      
      
      if (imag == null) {
        imag = 0;
      };
      self.real = real;
      return (self.imag = imag);
    }, $Complex_initialize$3.$$arity = -2);
    
    Opal.def(self, '$coerce', $Complex_coerce$4 = function $$coerce(other) {
      var self = this, $ret_or_7 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return [other, self]
      } else if ($truthy((function() {if ($truthy(($ret_or_7 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_7
      }; return nil; })())) {
        return [$$($nesting, 'Complex').$new(other, 0), self]
      } else {
        return self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      }
    }, $Complex_coerce$4.$$arity = 1);
    
    Opal.def(self, '$==', $Complex_$eq_eq$5 = function(other) {
      var self = this, $ret_or_8 = nil, $ret_or_9 = nil, $ret_or_10 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        if ($truthy(($ret_or_8 = self.real['$=='](other.$real())))) {
          return self.imag['$=='](other.$imag())
        } else {
          return $ret_or_8
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_9 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_9
      }; return nil; })())) {
        if ($truthy(($ret_or_10 = self.real['$=='](other)))) {
          return self.imag['$=='](0)
        } else {
          return $ret_or_10
        }
      } else {
        return other['$=='](self)
      }
    }, $Complex_$eq_eq$5.$$arity = 1);
    
    Opal.def(self, '$-@', $Complex_$minus$$6 = function() {
      var self = this;

      return self.$Complex(self.real['$-@'](), self.imag['$-@']())
    }, $Complex_$minus$$6.$$arity = 0);
    
    Opal.def(self, '$+', $Complex_$plus$7 = function(other) {
      var self = this, $ret_or_11 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if ($truthy((function() {if ($truthy(($ret_or_11 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_11
      }; return nil; })())) {
        return self.$Complex($rb_plus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("+", other)
      }
    }, $Complex_$plus$7.$$arity = 1);
    
    Opal.def(self, '$-', $Complex_$minus$8 = function(other) {
      var self = this, $ret_or_12 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if ($truthy((function() {if ($truthy(($ret_or_12 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_12
      }; return nil; })())) {
        return self.$Complex($rb_minus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("-", other)
      }
    }, $Complex_$minus$8.$$arity = 1);
    
    Opal.def(self, '$*', $Complex_$$9 = function(other) {
      var self = this, $ret_or_13 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if ($truthy((function() {if ($truthy(($ret_or_13 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_13
      }; return nil; })())) {
        return self.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
      } else {
        return self.$__coerced__("*", other)
      }
    }, $Complex_$$9.$$arity = 1);
    
    Opal.def(self, '$/', $Complex_$slash$10 = function(other) {
      var self = this, $ret_or_14 = nil, $ret_or_15 = nil, $ret_or_16 = nil, $ret_or_17 = nil, $ret_or_18 = nil, $ret_or_19 = nil, $ret_or_20 = nil, $ret_or_21 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        if ($truthy((function() {if ($truthy(($ret_or_14 = (function() {if ($truthy(($ret_or_15 = (function() {if ($truthy(($ret_or_16 = (function() {if ($truthy(($ret_or_17 = $$($nesting, 'Number')['$==='](self.real)))) {
          return self.real['$nan?']()
        } else {
          return $ret_or_17
        }; return nil; })()))) {
          return $ret_or_16
        } else {
          
          if ($truthy(($ret_or_18 = $$($nesting, 'Number')['$==='](self.imag)))) {
            return self.imag['$nan?']()
          } else {
            return $ret_or_18
          };
        }; return nil; })()))) {
          return $ret_or_15
        } else {
          
          if ($truthy(($ret_or_19 = $$($nesting, 'Number')['$==='](other.$real())))) {
            return other.$real()['$nan?']()
          } else {
            return $ret_or_19
          };
        }; return nil; })()))) {
          return $ret_or_14
        } else {
          
          if ($truthy(($ret_or_20 = $$($nesting, 'Number')['$==='](other.$imag())))) {
            return other.$imag()['$nan?']()
          } else {
            return $ret_or_20
          };
        }; return nil; })())) {
          return $$($nesting, 'Complex').$new($$$($$($nesting, 'Float'), 'NAN'), $$$($$($nesting, 'Float'), 'NAN'))
        } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_21 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_21
      }; return nil; })())) {
        return self.$Complex(self.real.$quo(other), self.imag.$quo(other))
      } else {
        return self.$__coerced__("/", other)
      }
    }, $Complex_$slash$10.$$arity = 1);
    
    Opal.def(self, '$**', $Complex_$$$11 = function(other) {
      var $a, $b, $c, $d, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil, $ret_or_22 = nil;

      
      if (other['$=='](0)) {
        return $$($nesting, 'Complex').$new(1, 0)};
      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = $$($nesting, 'Math').$exp($rb_minus($rb_times(ore, $$($nesting, 'Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$($nesting, 'Math').$log(r)));
        return $$($nesting, 'Complex').$polar(nr, ntheta);
      } else if ($truthy($$($nesting, 'Integer')['$==='](other))) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($truthy(n['$!='](0))) {
            
            $c = n.$divmod(2), $b = Opal.to_ary($c), (div = ($b[0] == null ? nil : $b[0])), (mod = ($b[1] == null ? nil : $b[1])), $c;
            while (mod['$=='](0)) {
              
              x = self.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
              $d = n.$divmod(2), $c = Opal.to_ary($d), (div = ($c[0] == null ? nil : $c[0])), (mod = ($c[1] == null ? nil : $c[1])), $d;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
        } else {
          return $rb_divide($$($nesting, 'Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_22 = $$($nesting, 'Float')['$==='](other)))) {
        return $ret_or_22
      } else {
        return $$($nesting, 'Rational')['$==='](other)
      }; return nil; })())) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return $$($nesting, 'Complex').$polar(r['$**'](other), $rb_times(theta, other));
      } else {
        return self.$__coerced__("**", other)
      };
    }, $Complex_$$$11.$$arity = 1);
    
    Opal.def(self, '$abs', $Complex_abs$12 = function $$abs() {
      var self = this;

      return $$($nesting, 'Math').$hypot(self.real, self.imag)
    }, $Complex_abs$12.$$arity = 0);
    
    Opal.def(self, '$abs2', $Complex_abs2$13 = function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    }, $Complex_abs2$13.$$arity = 0);
    
    Opal.def(self, '$angle', $Complex_angle$14 = function $$angle() {
      var self = this;

      return $$($nesting, 'Math').$atan2(self.imag, self.real)
    }, $Complex_angle$14.$$arity = 0);
    Opal.alias(self, "arg", "angle");
    
    Opal.def(self, '$conj', $Complex_conj$15 = function $$conj() {
      var self = this;

      return self.$Complex(self.real, self.imag['$-@']())
    }, $Complex_conj$15.$$arity = 0);
    Opal.alias(self, "conjugate", "conj");
    
    Opal.def(self, '$denominator', $Complex_denominator$16 = function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    }, $Complex_denominator$16.$$arity = 0);
    Opal.alias(self, "divide", "/");
    
    Opal.def(self, '$eql?', $Complex_eql$ques$17 = function(other) {
      var self = this, $ret_or_23 = nil, $ret_or_24 = nil;

      if ($truthy(($ret_or_23 = (function() {if ($truthy(($ret_or_24 = $$($nesting, 'Complex')['$==='](other)))) {
        return self.real.$class()['$=='](self.imag.$class())
      } else {
        return $ret_or_24
      }; return nil; })()))) {
        return self['$=='](other)
      } else {
        return $ret_or_23
      }
    }, $Complex_eql$ques$17.$$arity = 1);
    
    Opal.def(self, '$fdiv', $Complex_fdiv$18 = function $$fdiv(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Numeric')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    }, $Complex_fdiv$18.$$arity = 1);
    
    Opal.def(self, '$finite?', $Complex_finite$ques$19 = function() {
      var self = this, $ret_or_25 = nil;

      if ($truthy(($ret_or_25 = self.real['$finite?']()))) {
        return self.imag['$finite?']()
      } else {
        return $ret_or_25
      }
    }, $Complex_finite$ques$19.$$arity = 0);
    
    Opal.def(self, '$hash', $Complex_hash$20 = function $$hash() {
      var self = this;

      return "" + "Complex:" + (self.real) + ":" + (self.imag)
    }, $Complex_hash$20.$$arity = 0);
    Opal.alias(self, "imaginary", "imag");
    
    Opal.def(self, '$infinite?', $Complex_infinite$ques$21 = function() {
      var self = this, $ret_or_26 = nil;

      if ($truthy(($ret_or_26 = self.real['$infinite?']()))) {
        return $ret_or_26
      } else {
        return self.imag['$infinite?']()
      }
    }, $Complex_infinite$ques$21.$$arity = 0);
    
    Opal.def(self, '$inspect', $Complex_inspect$22 = function $$inspect() {
      var self = this;

      return "" + "(" + (self) + ")"
    }, $Complex_inspect$22.$$arity = 0);
    Opal.alias(self, "magnitude", "abs");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.def(self, '$numerator', $Complex_numerator$23 = function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return self.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    }, $Complex_numerator$23.$$arity = 0);
    Opal.alias(self, "phase", "arg");
    
    Opal.def(self, '$polar', $Complex_polar$24 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, $Complex_polar$24.$$arity = 0);
    
    Opal.udef(self, '$' + "positive?");;
    Opal.alias(self, "quo", "/");
    
    Opal.def(self, '$rationalize', $Complex_rationalize$25 = function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy(self.imag['$!='](0))) {
        self.$raise($$($nesting, 'RangeError'), "" + "can't' convert " + (self) + " into Rational")};
      return self.$real().$rationalize(eps);
    }, $Complex_rationalize$25.$$arity = -1);
    
    Opal.def(self, '$real?', $Complex_real$ques$26 = function() {
      var self = this;

      return false
    }, $Complex_real$ques$26.$$arity = 0);
    
    Opal.def(self, '$rect', $Complex_rect$27 = function $$rect() {
      var self = this;

      return [self.real, self.imag]
    }, $Complex_rect$27.$$arity = 0);
    Opal.alias(self, "rectangular", "rect");
    
    Opal.udef(self, '$' + "step");;
    
    Opal.def(self, '$to_f', $Complex_to_f$28 = function $$to_f() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Float")
      };
      return self.real.$to_f();
    }, $Complex_to_f$28.$$arity = 0);
    
    Opal.def(self, '$to_i', $Complex_to_i$29 = function $$to_i() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Integer")
      };
      return self.real.$to_i();
    }, $Complex_to_i$29.$$arity = 0);
    
    Opal.def(self, '$to_r', $Complex_to_r$30 = function $$to_r() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Rational")
      };
      return self.real.$to_r();
    }, $Complex_to_r$30.$$arity = 0);
    
    Opal.def(self, '$to_s', $Complex_to_s$31 = function $$to_s() {
      var self = this, result = nil, $ret_or_27 = nil, $ret_or_28 = nil, $ret_or_29 = nil, $ret_or_30 = nil, $ret_or_31 = nil;

      
      result = self.real.$inspect();
      result = $rb_plus(result, (function() {if ($truthy((function() {if ($truthy(($ret_or_27 = (function() {if ($truthy(($ret_or_28 = (function() {if ($truthy(($ret_or_29 = $$($nesting, 'Number')['$==='](self.imag)))) {
        return self.imag['$nan?']()
      } else {
        return $ret_or_29
      }; return nil; })()))) {
        return $ret_or_28
      } else {
        return self.imag['$positive?']()
      }; return nil; })()))) {
        return $ret_or_27
      } else {
        return self.imag['$zero?']()
      }; return nil; })())) {
        return "+"
      } else {
        return "-"
      }; return nil; })());
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if ($truthy((function() {if ($truthy(($ret_or_30 = $$($nesting, 'Number')['$==='](self.imag)))) {
        
        if ($truthy(($ret_or_31 = self.imag['$nan?']()))) {
          return $ret_or_31
        } else {
          return self.imag['$infinite?']()
        };
      } else {
        return $ret_or_30
      }; return nil; })())) {
        result = $rb_plus(result, "*")};
      return $rb_plus(result, "i");
    }, $Complex_to_s$31.$$arity = 0);
    return Opal.const_set($nesting[0], 'I', self.$new(0, 1));
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Complex$32;

    return (Opal.def(self, '$Complex', $Kernel_Complex$32 = function $$Complex(real, imag) {
      var self = this;

      
      
      if (imag == null) {
        imag = nil;
      };
      if ($truthy(imag)) {
        return $$($nesting, 'Complex').$new(real, imag)
      } else {
        return $$($nesting, 'Complex').$new(real, 0)
      };
    }, $Kernel_Complex$32.$$arity = -2), nil) && 'Complex'
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_c$33;

    return (Opal.def(self, '$to_c', $String_to_c$33 = function $$to_c() {
      var self = this;

      
      var str = self,
          re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
          match = str.match(re),
          real, imag, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      // handles both floats and rationals
      function cutNumber() {
        if (isFloat()) {
          var numerator = parseFloat(cutFloat());

          if (str[0] === '/') {
            // rational real part
            str = str.slice(1);

            if (isFloat()) {
              var denominator = parseFloat(cutFloat());
              return self.$Rational(numerator, denominator);
            } else {
              // reverting '/'
              str = '/' + str;
              return numerator;
            }
          } else {
            // float real part, no denominator
            return numerator;
          }
        } else {
          return null;
        }
      }

      real = cutNumber();

      if (!real) {
        if (str[0] === 'i') {
          // i => Complex(0, 1)
          return self.$Complex(0, 1);
        }
        if (str[0] === '-' && str[1] === 'i') {
          // -i => Complex(0, -1)
          return self.$Complex(0, -1);
        }
        if (str[0] === '+' && str[1] === 'i') {
          // +i => Complex(0, 1)
          return self.$Complex(0, 1);
        }
        // anything => Complex(0, 0)
        return self.$Complex(0, 0);
      }

      imag = cutNumber();
      if (!imag) {
        if (str[0] === 'i') {
          // 3i => Complex(0, 3)
          return self.$Complex(0, real);
        } else {
          // 3 => Complex(3, 0)
          return self.$Complex(real, 0);
        }
      } else {
        // 3+2i => Complex(3, 2)
        return self.$Complex(real, imag);
      }
    
    }, $String_to_c$33.$$arity = 0), nil) && 'to_c'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/rational"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $module = Opal.module;

  Opal.add_stubs(['$require', '$to_i', '$==', '$raise', '$<', '$-@', '$new', '$gcd', '$/', '$nil?', '$===', '$reduce', '$to_r', '$equal?', '$!', '$coerce_to!', '$to_f', '$numerator', '$denominator', '$<=>', '$-', '$*', '$__coerced__', '$+', '$Rational', '$>', '$**', '$abs', '$ceil', '$with_precision', '$floor', '$<=', '$truncate', '$send', '$convert']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Rational');

    var $nesting = [self].concat($parent_nesting), $Rational_reduce$1, $Rational_convert$2, $Rational_initialize$3, $Rational_numerator$4, $Rational_denominator$5, $Rational_coerce$6, $Rational_$eq_eq$7, $Rational_$lt_eq_gt$8, $Rational_$plus$9, $Rational_$minus$10, $Rational_$$11, $Rational_$slash$12, $Rational_$$$13, $Rational_abs$14, $Rational_ceil$15, $Rational_floor$16, $Rational_hash$17, $Rational_inspect$18, $Rational_rationalize$19, $Rational_round$20, $Rational_to_f$21, $Rational_to_i$22, $Rational_to_r$23, $Rational_to_s$24, $Rational_truncate$25, $Rational_with_precision$26;

    self.$$prototype.num = self.$$prototype.den = nil;
    
    Opal.defs(self, '$reduce', $Rational_reduce$1 = function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if (den['$=='](0)) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if (den['$=='](1)) {
        return self.$new(num, den)};
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    }, $Rational_reduce$1.$$arity = 2);
    Opal.defs(self, '$convert', $Rational_convert$2 = function $$convert(num, den) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil, $ret_or_7 = nil, $ret_or_8 = nil;

      
      if ($truthy((function() {if ($truthy(($ret_or_1 = num['$nil?']()))) {
        return $ret_or_1
      } else {
        return den['$nil?']()
      }; return nil; })())) {
        self.$raise($$($nesting, 'TypeError'), "cannot convert nil into Rational")};
      if ($truthy((function() {if ($truthy(($ret_or_2 = $$($nesting, 'Integer')['$==='](num)))) {
        return $$($nesting, 'Integer')['$==='](den)
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return self.$reduce(num, den)};
      if ($truthy((function() {if ($truthy(($ret_or_3 = (function() {if ($truthy(($ret_or_4 = $$($nesting, 'Float')['$==='](num)))) {
        return $ret_or_4
      } else {
        return $$($nesting, 'String')['$==='](num)
      }; return nil; })()))) {
        return $ret_or_3
      } else {
        return $$($nesting, 'Complex')['$==='](num)
      }; return nil; })())) {
        num = num.$to_r()};
      if ($truthy((function() {if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = $$($nesting, 'Float')['$==='](den)))) {
        return $ret_or_6
      } else {
        return $$($nesting, 'String')['$==='](den)
      }; return nil; })()))) {
        return $ret_or_5
      } else {
        return $$($nesting, 'Complex')['$==='](den)
      }; return nil; })())) {
        den = den.$to_r()};
      if ($truthy((function() {if ($truthy(($ret_or_7 = den['$equal?'](1)))) {
        return $$($nesting, 'Integer')['$==='](num)['$!']()
      } else {
        return $ret_or_7
      }; return nil; })())) {
        return $$($nesting, 'Opal')['$coerce_to!'](num, $$($nesting, 'Rational'), "to_r")
      } else if ($truthy((function() {if ($truthy(($ret_or_8 = $$($nesting, 'Numeric')['$==='](num)))) {
        return $$($nesting, 'Numeric')['$==='](den)
      } else {
        return $ret_or_8
      }; return nil; })())) {
        return $rb_divide(num, den)
      } else {
        return self.$reduce(num, den)
      };
    }, $Rational_convert$2.$$arity = 2);
    
    Opal.def(self, '$initialize', $Rational_initialize$3 = function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      return (self.den = den);
    }, $Rational_initialize$3.$$arity = 2);
    
    Opal.def(self, '$numerator', $Rational_numerator$4 = function $$numerator() {
      var self = this;

      return self.num
    }, $Rational_numerator$4.$$arity = 0);
    
    Opal.def(self, '$denominator', $Rational_denominator$5 = function $$denominator() {
      var self = this;

      return self.den
    }, $Rational_denominator$5.$$arity = 0);
    
    Opal.def(self, '$coerce', $Rational_coerce$6 = function $$coerce(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return [other, self]}
      else if ($$($nesting, 'Integer')['$===']($case)) {return [other.$to_r(), self]}
      else if ($$($nesting, 'Float')['$===']($case)) {return [other, self.$to_f()]}
      else { return nil }})()
    }, $Rational_coerce$6.$$arity = 1);
    
    Opal.def(self, '$==', $Rational_$eq_eq$7 = function(other) {
      var self = this, $case = nil, $ret_or_9 = nil, $ret_or_10 = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {if ($truthy(($ret_or_9 = self.num['$=='](other.$numerator())))) {
        return self.den['$=='](other.$denominator())
      } else {
        return $ret_or_9
      }}
      else if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy(($ret_or_10 = self.num['$=='](other)))) {
        return self.den['$=='](1)
      } else {
        return $ret_or_10
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$=='](other)}
      else {return other['$=='](self)}})()
    }, $Rational_$eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Rational_$lt_eq_gt$8 = function(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)}
      else if ($$($nesting, 'Integer')['$===']($case)) {return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$<=>'](other)}
      else {return self.$__coerced__("<=>", other)}})()
    }, $Rational_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$+', $Rational_$plus$9 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_plus(self.$to_f(), other)}
      else {return self.$__coerced__("+", other)}})()
    }, $Rational_$plus$9.$$arity = 1);
    
    Opal.def(self, '$-', $Rational_$minus$10 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_minus(self.$to_f(), other)}
      else {return self.$__coerced__("-", other)}})()
    }, $Rational_$minus$10.$$arity = 1);
    
    Opal.def(self, '$*', $Rational_$$11 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$numerator());
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_times(self.num, other), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_times(self.$to_f(), other)}
      else {return self.$__coerced__("*", other)}})()
    }, $Rational_$$11.$$arity = 1);
    
    Opal.def(self, '$/', $Rational_$slash$12 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$denominator());
      den = $rb_times(self.den, other.$numerator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {if (other['$=='](0)) {
        return $rb_divide(self.$to_f(), 0.0)
      } else {
        return self.$Rational(self.num, $rb_times(self.den, other))
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_divide(self.$to_f(), other)}
      else {return self.$__coerced__("/", other)}})()
    }, $Rational_$slash$12.$$arity = 1);
    
    Opal.def(self, '$**', $Rational_$$$13 = function(other) {
      var self = this, $case = nil, $ret_or_11 = nil, $ret_or_12 = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy((function() {if ($truthy(($ret_or_11 = self['$=='](0)))) {
        return $rb_lt(other, 0)
      } else {
        return $ret_or_11
      }; return nil; })())) {
        return $$$($$($nesting, 'Float'), 'INFINITY')
      } else if ($truthy($rb_gt(other, 0))) {
        return self.$Rational(self.num['$**'](other), self.den['$**'](other))
      } else if ($truthy($rb_lt(other, 0))) {
        return self.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
      } else {
        return self.$Rational(1, 1)
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$**'](other)}
      else if ($$($nesting, 'Rational')['$===']($case)) {if (other['$=='](0)) {
        return self.$Rational(1, 1)
      } else if (other.$denominator()['$=='](1)) {
        if ($truthy($rb_lt(other, 0))) {
          return self.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
        } else {
          return self.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_12 = self['$=='](0)))) {
        return $rb_lt(other, 0)
      } else {
        return $ret_or_12
      }; return nil; })())) {
        return self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      } else {
        return self.$to_f()['$**'](other)
      }}
      else {return self.$__coerced__("**", other)}})()
    }, $Rational_$$$13.$$arity = 1);
    
    Opal.def(self, '$abs', $Rational_abs$14 = function $$abs() {
      var self = this;

      return self.$Rational(self.num.$abs(), self.den.$abs())
    }, $Rational_abs$14.$$arity = 0);
    
    Opal.def(self, '$ceil', $Rational_ceil$15 = function $$ceil(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
      } else {
        return self.$with_precision("ceil", precision)
      };
    }, $Rational_ceil$15.$$arity = -1);
    Opal.alias(self, "divide", "/");
    
    Opal.def(self, '$floor', $Rational_floor$16 = function $$floor(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
      } else {
        return self.$with_precision("floor", precision)
      };
    }, $Rational_floor$16.$$arity = -1);
    
    Opal.def(self, '$hash', $Rational_hash$17 = function $$hash() {
      var self = this;

      return "" + "Rational:" + (self.num) + ":" + (self.den)
    }, $Rational_hash$17.$$arity = 0);
    
    Opal.def(self, '$inspect', $Rational_inspect$18 = function $$inspect() {
      var self = this;

      return "" + "(" + (self) + ")"
    }, $Rational_inspect$18.$$arity = 0);
    Opal.alias(self, "quo", "/");
    
    Opal.def(self, '$rationalize', $Rational_rationalize$19 = function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return self.$Rational(c * p1 + p0, c * q1 + q0);
    ;
    }, $Rational_rationalize$19.$$arity = -1);
    
    Opal.def(self, '$round', $Rational_round$20 = function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
      } else {
        return self.$with_precision("round", precision)
      };
      if (self.num['$=='](0)) {
        return 0};
      if (self.den['$=='](1)) {
        return self.num};
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
      } else {
        return approx
      };
    }, $Rational_round$20.$$arity = -1);
    
    Opal.def(self, '$to_f', $Rational_to_f$21 = function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    }, $Rational_to_f$21.$$arity = 0);
    
    Opal.def(self, '$to_i', $Rational_to_i$22 = function $$to_i() {
      var self = this;

      return self.$truncate()
    }, $Rational_to_i$22.$$arity = 0);
    
    Opal.def(self, '$to_r', $Rational_to_r$23 = function $$to_r() {
      var self = this;

      return self
    }, $Rational_to_r$23.$$arity = 0);
    
    Opal.def(self, '$to_s', $Rational_to_s$24 = function $$to_s() {
      var self = this;

      return "" + (self.num) + "/" + (self.den)
    }, $Rational_to_s$24.$$arity = 0);
    
    Opal.def(self, '$truncate', $Rational_truncate$25 = function $$truncate(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
        } else {
          return self.$floor()
        }
      } else {
        return self.$with_precision("truncate", precision)
      };
    }, $Rational_truncate$25.$$arity = -1);
    return (Opal.def(self, '$with_precision', $Rational_with_precision$26 = function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if ($truthy($$($nesting, 'Integer')['$==='](precision))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
      } else {
        return self.$Rational(s.$send(method), p)
      };
    }, $Rational_with_precision$26.$$arity = 2), nil) && 'with_precision';
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Rational$27;

    return (Opal.def(self, '$Rational', $Kernel_Rational$27 = function $$Rational(numerator, denominator) {
      var self = this;

      
      
      if (denominator == null) {
        denominator = 1;
      };
      return $$($nesting, 'Rational').$convert(numerator, denominator);
    }, $Kernel_Rational$27.$$arity = -2), nil) && 'Rational'
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_r$28;

    return (Opal.def(self, '$to_r', $String_to_r$28 = function $$to_r() {
      var self = this;

      
      var str = self.trimLeft(),
          re = /^[+-]?[\d_]+(\.[\d_]+)?/,
          match = str.match(re),
          numerator, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      if (isFloat()) {
        numerator = parseFloat(cutFloat());

        if (str[0] === '/') {
          // rational real part
          str = str.slice(1);

          if (isFloat()) {
            denominator = parseFloat(cutFloat());
            return self.$Rational(numerator, denominator);
          } else {
            return self.$Rational(numerator, 1);
          }
        } else {
          return self.$Rational(numerator, 1);
        }
      } else {
        return self.$Rational(0, 1);
      }
    
    }, $String_to_r$28.$$arity = 0), nil) && 'to_r'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/time"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $range = Opal.range;

  Opal.add_stubs(['$require', '$include', '$===', '$raise', '$coerce_to!', '$respond_to?', '$to_str', '$to_i', '$new', '$<=>', '$to_f', '$nil?', '$>', '$<', '$strftime', '$year', '$month', '$day', '$+', '$round', '$/', '$-', '$copy_instance_variables', '$initialize_dup', '$is_a?', '$zero?', '$wday', '$utc?', '$mon', '$yday', '$hour', '$min', '$sec', '$rjust', '$ljust', '$zone', '$to_s', '$[]', '$cweek_cyear', '$isdst', '$<=', '$!=', '$==', '$ceil']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_at$1, $Time_new$2, $Time_local$3, $Time_gm$4, $Time_now$5, $Time_$plus$6, $Time_$minus$7, $Time_$lt_eq_gt$8, $Time_$eq_eq$9, $Time_asctime$10, $Time_day$11, $Time_yday$12, $Time_isdst$13, $Time_dup$14, $Time_eql$ques$15, $Time_friday$ques$16, $Time_hash$17, $Time_hour$18, $Time_inspect$19, $Time_min$20, $Time_mon$21, $Time_monday$ques$22, $Time_saturday$ques$23, $Time_sec$24, $Time_succ$25, $Time_usec$26, $Time_zone$27, $Time_getgm$28, $Time_gmtime$29, $Time_gmt$ques$30, $Time_gmt_offset$31, $Time_strftime$32, $Time_sunday$ques$33, $Time_thursday$ques$34, $Time_to_a$35, $Time_to_f$36, $Time_to_i$37, $Time_tuesday$ques$38, $Time_wday$39, $Time_wednesday$ques$40, $Time_year$41, $Time_cweek_cyear$42;

    
    self.$include($$($nesting, 'Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    Opal.defs(self, '$at', $Time_at$1 = function $$at(seconds, frac) {
      var self = this;

      
      ;
      
      var result;

      if ($$($nesting, 'Time')['$==='](seconds)) {
        if (frac !== undefined) {
          self.$raise($$($nesting, 'TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.is_utc = seconds.is_utc;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = $$($nesting, 'Opal')['$coerce_to!'](seconds, $$($nesting, 'Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = $$($nesting, 'Opal')['$coerce_to!'](frac, $$($nesting, 'Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    ;
    }, $Time_at$1.$$arity = -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $$($nesting, 'Opal')['$coerce_to!'](year, $$($nesting, 'Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = $$($nesting, 'Opal')['$coerce_to!'](month, $$($nesting, 'Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "month out of range: " + (month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $$($nesting, 'Opal')['$coerce_to!'](day, $$($nesting, 'Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "day out of range: " + (day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $$($nesting, 'Opal')['$coerce_to!'](hour, $$($nesting, 'Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "hour out of range: " + (hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $$($nesting, 'Opal')['$coerce_to!'](min, $$($nesting, 'Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "min out of range: " + (min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $$($nesting, 'Opal')['$coerce_to!'](sec, $$($nesting, 'Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "sec out of range: " + (sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    Opal.defs(self, '$new', $Time_new$2 = function(year, month, day, hour, min, sec, utc_offset) {
      var self = this;

      
      ;
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (utc_offset == null) {
        utc_offset = nil;
      };
      
      var args, result;

      if (year === undefined) {
        return new Date();
      }

      if (utc_offset !== nil) {
        self.$raise($$($nesting, 'ArgumentError'), "Opal does not support explicitly specifying UTC offset for Time")
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, $Time_new$2.$$arity = -1);
    Opal.defs(self, '$local', $Time_local$3 = function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (millisecond == null) {
        millisecond = nil;
      };
      
      if (_dummy1 == null) {
        _dummy1 = nil;
      };
      
      if (_dummy2 == null) {
        _dummy2 = nil;
      };
      
      if (_dummy3 == null) {
        _dummy3 = nil;
      };
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, $Time_local$3.$$arity = -2);
    Opal.defs(self, '$gm', $Time_gm$4 = function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (millisecond == null) {
        millisecond = nil;
      };
      
      if (_dummy1 == null) {
        _dummy1 = nil;
      };
      
      if (_dummy2 == null) {
        _dummy2 = nil;
      };
      
      if (_dummy3 == null) {
        _dummy3 = nil;
      };
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.is_utc = true;
      return result;
    ;
    }, $Time_gm$4.$$arity = -2);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      
      Opal.alias(self, "mktime", "local");
      return Opal.alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$now', $Time_now$5 = function $$now() {
      var self = this;

      return self.$new()
    }, $Time_now$5.$$arity = 0);
    
    Opal.def(self, '$+', $Time_$plus$6 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        self.$raise($$($nesting, 'TypeError'), "time + time?")};
      
      if (!other.$$is_number) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, $Time_$plus$6.$$arity = 1);
    
    Opal.def(self, '$-', $Time_$minus$7 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        return (self.getTime() - other.getTime()) / 1000};
      
      if (!other.$$is_number) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, $Time_$minus$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Time_$lt_eq_gt$8 = function(other) {
      var self = this, r = nil;

      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        return self.$to_f()['$<=>'](other.$to_f())
      } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
        } else {
          return 0
        };
      }
    }, $Time_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$==', $Time_$eq_eq$9 = function(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $$($nesting, 'Time')['$==='](other)))) {
        return self.$to_f() === other.$to_f()
      } else {
        return $ret_or_1
      }
    }, $Time_$eq_eq$9.$$arity = 1);
    
    Opal.def(self, '$asctime', $Time_asctime$10 = function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    }, $Time_asctime$10.$$arity = 0);
    Opal.alias(self, "ctime", "asctime");
    
    Opal.def(self, '$day', $Time_day$11 = function $$day() {
      var self = this;

      return self.is_utc ? self.getUTCDate() : self.getDate();
    }, $Time_day$11.$$arity = 0);
    
    Opal.def(self, '$yday', $Time_yday$12 = function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = $$($nesting, 'Time').$new(self.$year()).$to_i();
      start_of_day = $$($nesting, 'Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    }, $Time_yday$12.$$arity = 0);
    
    Opal.def(self, '$isdst', $Time_isdst$13 = function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    }, $Time_isdst$13.$$arity = 0);
    Opal.alias(self, "dst?", "isdst");
    
    Opal.def(self, '$dup', $Time_dup$14 = function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, $Time_dup$14.$$arity = 0);
    
    Opal.def(self, '$eql?', $Time_eql$ques$15 = function(other) {
      var self = this, $ret_or_2 = nil;

      if ($truthy(($ret_or_2 = other['$is_a?']($$($nesting, 'Time'))))) {
        return self['$<=>'](other)['$zero?']()
      } else {
        return $ret_or_2
      }
    }, $Time_eql$ques$15.$$arity = 1);
    
    Opal.def(self, '$friday?', $Time_friday$ques$16 = function() {
      var self = this;

      return self.$wday() == 5
    }, $Time_friday$ques$16.$$arity = 0);
    
    Opal.def(self, '$hash', $Time_hash$17 = function $$hash() {
      var self = this;

      return 'Time:' + self.getTime();
    }, $Time_hash$17.$$arity = 0);
    
    Opal.def(self, '$hour', $Time_hour$18 = function $$hour() {
      var self = this;

      return self.is_utc ? self.getUTCHours() : self.getHours();
    }, $Time_hour$18.$$arity = 0);
    
    Opal.def(self, '$inspect', $Time_inspect$19 = function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
      } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    }, $Time_inspect$19.$$arity = 0);
    Opal.alias(self, "mday", "day");
    
    Opal.def(self, '$min', $Time_min$20 = function $$min() {
      var self = this;

      return self.is_utc ? self.getUTCMinutes() : self.getMinutes();
    }, $Time_min$20.$$arity = 0);
    
    Opal.def(self, '$mon', $Time_mon$21 = function $$mon() {
      var self = this;

      return (self.is_utc ? self.getUTCMonth() : self.getMonth()) + 1;
    }, $Time_mon$21.$$arity = 0);
    
    Opal.def(self, '$monday?', $Time_monday$ques$22 = function() {
      var self = this;

      return self.$wday() == 1
    }, $Time_monday$ques$22.$$arity = 0);
    Opal.alias(self, "month", "mon");
    
    Opal.def(self, '$saturday?', $Time_saturday$ques$23 = function() {
      var self = this;

      return self.$wday() == 6
    }, $Time_saturday$ques$23.$$arity = 0);
    
    Opal.def(self, '$sec', $Time_sec$24 = function $$sec() {
      var self = this;

      return self.is_utc ? self.getUTCSeconds() : self.getSeconds();
    }, $Time_sec$24.$$arity = 0);
    
    Opal.def(self, '$succ', $Time_succ$25 = function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.is_utc = self.is_utc;
      return result;
    
    }, $Time_succ$25.$$arity = 0);
    
    Opal.def(self, '$usec', $Time_usec$26 = function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000;
    }, $Time_usec$26.$$arity = 0);
    
    Opal.def(self, '$zone', $Time_zone$27 = function $$zone() {
      var self = this;

      
      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    }, $Time_zone$27.$$arity = 0);
    
    Opal.def(self, '$getgm', $Time_getgm$28 = function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.is_utc = true;
      return result;
    
    }, $Time_getgm$28.$$arity = 0);
    Opal.alias(self, "getutc", "getgm");
    
    Opal.def(self, '$gmtime', $Time_gmtime$29 = function $$gmtime() {
      var self = this;

      
      self.is_utc = true;
      return self;
    
    }, $Time_gmtime$29.$$arity = 0);
    Opal.alias(self, "utc", "gmtime");
    
    Opal.def(self, '$gmt?', $Time_gmt$ques$30 = function() {
      var self = this;

      return self.is_utc === true;
    }, $Time_gmt$ques$30.$$arity = 0);
    
    Opal.def(self, '$gmt_offset', $Time_gmt_offset$31 = function $$gmt_offset() {
      var self = this;

      return self.is_utc ? 0 : -self.getTimezoneOffset() * 60;
    }, $Time_gmt_offset$31.$$arity = 0);
    
    Opal.def(self, '$strftime', $Time_strftime$32 = function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "",
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = self.getTimezoneOffset(),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    }, $Time_strftime$32.$$arity = 1);
    
    Opal.def(self, '$sunday?', $Time_sunday$ques$33 = function() {
      var self = this;

      return self.$wday() == 0
    }, $Time_sunday$ques$33.$$arity = 0);
    
    Opal.def(self, '$thursday?', $Time_thursday$ques$34 = function() {
      var self = this;

      return self.$wday() == 4
    }, $Time_thursday$ques$34.$$arity = 0);
    
    Opal.def(self, '$to_a', $Time_to_a$35 = function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    }, $Time_to_a$35.$$arity = 0);
    
    Opal.def(self, '$to_f', $Time_to_f$36 = function $$to_f() {
      var self = this;

      return self.getTime() / 1000;
    }, $Time_to_f$36.$$arity = 0);
    
    Opal.def(self, '$to_i', $Time_to_i$37 = function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10);
    }, $Time_to_i$37.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$tuesday?', $Time_tuesday$ques$38 = function() {
      var self = this;

      return self.$wday() == 2
    }, $Time_tuesday$ques$38.$$arity = 0);
    Opal.alias(self, "tv_sec", "to_i");
    Opal.alias(self, "tv_usec", "usec");
    Opal.alias(self, "utc?", "gmt?");
    Opal.alias(self, "gmtoff", "gmt_offset");
    Opal.alias(self, "utc_offset", "gmt_offset");
    
    Opal.def(self, '$wday', $Time_wday$39 = function $$wday() {
      var self = this;

      return self.is_utc ? self.getUTCDay() : self.getDay();
    }, $Time_wday$39.$$arity = 0);
    
    Opal.def(self, '$wednesday?', $Time_wednesday$ques$40 = function() {
      var self = this;

      return self.$wday() == 3
    }, $Time_wednesday$ques$40.$$arity = 0);
    
    Opal.def(self, '$year', $Time_year$41 = function $$year() {
      var self = this;

      return self.is_utc ? self.getUTCFullYear() : self.getFullYear();
    }, $Time_year$41.$$arity = 0);
    return (Opal.def(self, '$cweek_cyear', $Time_cweek_cyear$42 = function $$cweek_cyear() {
      var self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, $ret_or_3 = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil, $ret_or_4 = nil;

      
      jan01 = $$($nesting, 'Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if ($truthy((function() {if ($truthy(($ret_or_3 = $rb_le(jan01_wday, 4)))) {
        return jan01_wday['$!='](0)
      } else {
        return $ret_or_3
      }; return nil; })())) {
        offset = $rb_minus(jan01_wday, 1)
      } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if (offset['$=='](-8)) {
          offset = -1};
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return $$($nesting, 'Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if (week['$=='](53)) {
        
        dec31 = $$($nesting, 'Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if ($truthy((function() {if ($truthy(($ret_or_4 = $rb_le(dec31_wday, 3)))) {
          return dec31_wday['$!='](0)
        } else {
          return $ret_or_4
        }; return nil; })())) {
          
          week = 1;
          year = $rb_plus(year, 1);};};
      return [week, year];
    }, $Time_cweek_cyear$42.$$arity = 0), nil) && 'cweek_cyear';
  })($nesting[0], Date, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/struct"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$const_name!', '$unshift', '$map', '$coerce_to!', '$new', '$each', '$define_struct_attribute', '$allocate', '$initialize', '$alias_method', '$module_eval', '$to_proc', '$const_set', '$==', '$raise', '$<<', '$members', '$define_method', '$instance_eval', '$class', '$last', '$>', '$length', '$-', '$keys', '$any?', '$join', '$[]', '$[]=', '$each_with_index', '$hash', '$===', '$<', '$-@', '$size', '$>=', '$include?', '$to_sym', '$instance_of?', '$__id__', '$eql?', '$enum_for', '$name', '$+', '$each_pair', '$inspect', '$to_h', '$args', '$each_with_object', '$flatten', '$to_a', '$respond_to?', '$dig']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $Struct_new$1, $Struct_define_struct_attribute$6, $Struct_members$9, $Struct_inherited$10, $Struct_initialize$12, $Struct_initialize_copy$15, $Struct_members$16, $Struct_hash$17, $Struct_$$$18, $Struct_$$$eq$19, $Struct_$eq_eq$20, $Struct_eql$ques$21, $Struct_each$22, $Struct_each_pair$25, $Struct_length$28, $Struct_to_a$29, $Struct_inspect$31, $Struct_to_h$33, $Struct_values_at$35, $Struct_dig$37;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defs(self, '$new', $Struct_new$1 = function(const_name, $a, $b) {
      var $iter = $Struct_new$1.$$p, block = $iter || nil, $post_args, $kwargs, args, keyword_init, $$2, $$3, self = this, klass = nil;

      if ($iter) $Struct_new$1.$$p = null;
      
      
      if ($iter) $Struct_new$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      args = $post_args;;
      
      keyword_init = $kwargs.$$smap["keyword_init"];
      if (keyword_init == null) {
        keyword_init = false
      };
      if ($truthy(const_name)) {
        
        try {
          const_name = $$($nesting, 'Opal')['$const_name!'](const_name)
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'TypeError'), $$($nesting, 'NameError')])) {
            try {
              
              args.$unshift(const_name);
              const_name = nil;
            } finally { Opal.pop_exception() }
          } else { throw $err; }
        };};
      $send(args, 'map', [], ($$2 = function(arg){var self = $$2.$$s == null ? this : $$2.$$s;

      
        
        if (arg == null) {
          arg = nil;
        };
        return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'String'), "to_str");}, $$2.$$s = self, $$2.$$arity = 1, $$2));
      klass = $send($$($nesting, 'Class'), 'new', [self], ($$3 = function(){var self = $$3.$$s == null ? this : $$3.$$s, $$4;

      
        $send(args, 'each', [], ($$4 = function(arg){var self = $$4.$$s == null ? this : $$4.$$s;

        
          
          if (arg == null) {
            arg = nil;
          };
          return self.$define_struct_attribute(arg);}, $$4.$$s = self, $$4.$$arity = 1, $$4));
        return (function(self, $parent_nesting) {
          var $nesting = [self].concat($parent_nesting), $new$5;

          
          
          Opal.def(self, '$new', $new$5 = function($a) {
            var $post_args, args, self = this, instance = nil;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', Opal.to_a(args));
            return instance;
          }, $new$5.$$arity = -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, $$3.$$s = self, $$3.$$arity = 0, $$3));
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())};
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$($nesting, 'Struct').$const_set(const_name, klass)};
      return klass;
    }, $Struct_new$1.$$arity = -2);
    Opal.defs(self, '$define_struct_attribute', $Struct_define_struct_attribute$6 = function $$define_struct_attribute(name) {
      var $$7, $$8, self = this;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "you cannot define attributes to the Struct class")};
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], ($$7 = function(){var self = $$7.$$s == null ? this : $$7.$$s;

      return self.$$data[name];}, $$7.$$s = self, $$7.$$arity = 0, $$7));
      return $send(self, 'define_method', ["" + (name) + "="], ($$8 = function(value){var self = $$8.$$s == null ? this : $$8.$$s;

      
        
        if (value == null) {
          value = nil;
        };
        return self.$$data[name] = value;;}, $$8.$$s = self, $$8.$$arity = 1, $$8));
    }, $Struct_define_struct_attribute$6.$$arity = 1);
    Opal.defs(self, '$members', $Struct_members$9 = function $$members() {
      var self = this, $ret_or_1 = nil;
      if (self.members == null) self.members = nil;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "the Struct class has no members")};
      return (self.members = (function() {if ($truthy(($ret_or_1 = self.members))) {
        return $ret_or_1
      } else {
        return []
      }; return nil; })());
    }, $Struct_members$9.$$arity = 0);
    Opal.defs(self, '$inherited', $Struct_inherited$10 = function $$inherited(klass) {
      var $$11, self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], ($$11 = function(){var self = $$11.$$s == null ? this : $$11.$$s;

      return (self.members = members)}, $$11.$$s = self, $$11.$$arity = 0, $$11));
    }, $Struct_inherited$10.$$arity = 1);
    
    Opal.def(self, '$initialize', $Struct_initialize$12 = function $$initialize($a) {
      var $post_args, args, $$13, $$14, self = this, kwargs = nil, $ret_or_2 = nil, $ret_or_3 = nil, extra = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = (function() {if ($truthy(($ret_or_2 = args.$last()))) {
          return $ret_or_2
        } else {
          return $hash2([], {})
        }; return nil; })();
        if ($truthy((function() {if ($truthy(($ret_or_3 = $rb_gt(args.$length(), 1)))) {
          return $ret_or_3
        } else {
          return (args.length === 1 && !kwargs.$$is_hash);
        }; return nil; })())) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (given " + (args.$length()) + ", expected 0)")};
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "unknown keywords: " + (extra.$join(", ")))};
        return $send(self.$class().$members(), 'each', [], ($$13 = function(name){var self = $$13.$$s == null ? this : $$13.$$s, $writer = nil;

        
          
          if (name == null) {
            name = nil;
          };
          $writer = [name, kwargs['$[]'](name)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$13.$$s = self, $$13.$$arity = 1, $$13));
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          self.$raise($$($nesting, 'ArgumentError'), "struct size differs")};
        return $send(self.$class().$members(), 'each_with_index', [], ($$14 = function(name, index){var self = $$14.$$s == null ? this : $$14.$$s, $writer = nil;

        
          
          if (name == null) {
            name = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          $writer = [name, args['$[]'](index)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$14.$$s = self, $$14.$$arity = 2, $$14));
      };
    }, $Struct_initialize$12.$$arity = -1);
    
    Opal.def(self, '$initialize_copy', $Struct_initialize_copy$15 = function $$initialize_copy(from) {
      var self = this;

      
      self.$$data = {}
      var keys = Object.keys(from.$$data), i, max, name;
      for (i = 0, max = keys.length; i < max; i++) {
        name = keys[i];
        self.$$data[name] = from.$$data[name];
      }
    
    }, $Struct_initialize_copy$15.$$arity = 1);
    
    Opal.def(self, '$members', $Struct_members$16 = function $$members() {
      var self = this;

      return self.$class().$members()
    }, $Struct_members$16.$$arity = 0);
    
    Opal.def(self, '$hash', $Struct_hash$17 = function $$hash() {
      var self = this;

      return $$($nesting, 'Hash').$new(self.$$data).$hash()
    }, $Struct_hash$17.$$arity = 0);
    
    Opal.def(self, '$[]', $Struct_$$$18 = function(name) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name];;
    }, $Struct_$$$18.$$arity = 1);
    
    Opal.def(self, '$[]=', $Struct_$$$eq$19 = function(name, value) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        if ($truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
        } else {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name] = value;;
    }, $Struct_$$$eq$19.$$arity = 2);
    
    Opal.def(self, '$==', $Struct_$eq_eq$20 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_$eq_eq$20.$$arity = 1);
    
    Opal.def(self, '$eql?', $Struct_eql$ques$21 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_eql$ques$21.$$arity = 1);
    
    Opal.def(self, '$each', $Struct_each$22 = function $$each() {
      var $$23, $$24, $iter = $Struct_each$22.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each$22.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$23 = function(){var self = $$23.$$s == null ? this : $$23.$$s;

        return self.$size()}, $$23.$$s = self, $$23.$$arity = 0, $$23))
      };
      $send(self.$class().$members(), 'each', [], ($$24 = function(name){var self = $$24.$$s == null ? this : $$24.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, self['$[]'](name));;}, $$24.$$s = self, $$24.$$arity = 1, $$24));
      return self;
    }, $Struct_each$22.$$arity = 0);
    
    Opal.def(self, '$each_pair', $Struct_each_pair$25 = function $$each_pair() {
      var $$26, $$27, $iter = $Struct_each_pair$25.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each_pair$25.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_pair"], ($$26 = function(){var self = $$26.$$s == null ? this : $$26.$$s;

        return self.$size()}, $$26.$$s = self, $$26.$$arity = 0, $$26))
      };
      $send(self.$class().$members(), 'each', [], ($$27 = function(name){var self = $$27.$$s == null ? this : $$27.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, $$27.$$s = self, $$27.$$arity = 1, $$27));
      return self;
    }, $Struct_each_pair$25.$$arity = 0);
    
    Opal.def(self, '$length', $Struct_length$28 = function $$length() {
      var self = this;

      return self.$class().$members().$length()
    }, $Struct_length$28.$$arity = 0);
    Opal.alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $Struct_to_a$29 = function $$to_a() {
      var $$30, self = this;

      return $send(self.$class().$members(), 'map', [], ($$30 = function(name){var self = $$30.$$s == null ? this : $$30.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        return self['$[]'](name);}, $$30.$$s = self, $$30.$$arity = 1, $$30))
    }, $Struct_to_a$29.$$arity = 0);
    Opal.alias(self, "values", "to_a");
    
    Opal.def(self, '$inspect', $Struct_inspect$31 = function $$inspect() {
      var $$32, self = this, result = nil, $ret_or_4 = nil;

      
      result = "#<struct ";
      if ($truthy((function() {if ($truthy(($ret_or_4 = $$($nesting, 'Struct')['$==='](self)))) {
        return self.$class().$name()
      } else {
        return $ret_or_4
      }; return nil; })())) {
        result = $rb_plus(result, "" + (self.$class()) + " ")};
      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], ($$32 = function(name, value){var self = $$32.$$s == null ? this : $$32.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        return "" + (name) + "=" + (value.$inspect());}, $$32.$$s = self, $$32.$$arity = 2, $$32)).$join(", "));
      result = $rb_plus(result, ">");
      return result;
    }, $Struct_inspect$31.$$arity = 0);
    Opal.alias(self, "to_s", "inspect");
    
    Opal.def(self, '$to_h', $Struct_to_h$33 = function $$to_h() {
      var $iter = $Struct_to_h$33.$$p, block = $iter || nil, $$34, self = this;

      if ($iter) $Struct_to_h$33.$$p = null;
      
      
      if ($iter) $Struct_to_h$33.$$p = null;;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', Opal.to_a(self.$args()))};
      return $send(self.$class().$members(), 'each_with_object', [$hash2([], {})], ($$34 = function(name, h){var self = $$34.$$s == null ? this : $$34.$$s, $writer = nil;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (h == null) {
          h = nil;
        };
        $writer = [name, self['$[]'](name)];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $$34.$$s = self, $$34.$$arity = 2, $$34));
    }, $Struct_to_h$33.$$arity = 0);
    
    Opal.def(self, '$values_at', $Struct_values_at$35 = function $$values_at($a) {
      var $post_args, args, $$36, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      args = $send(args, 'map', [], ($$36 = function(arg){var self = $$36.$$s == null ? this : $$36.$$s;

      
        
        if (arg == null) {
          arg = nil;
        };
        return arg.$$is_range ? arg.$to_a() : arg;}, $$36.$$s = self, $$36.$$arity = 1, $$36)).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, $Struct_values_at$35.$$arity = -1);
    return (Opal.def(self, '$dig', $Struct_dig$37 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = (function() {if ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key))) {
        return self.$$data[key] || nil;
      } else {
        return nil
      }; return nil; })();
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Struct_dig$37.$$arity = -2), nil) && 'dig';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/main"] = function(Opal) {
  var $to_s$1, $include$2, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$include']);
  
  Opal.defs(self, '$to_s', $to_s$1 = function $$to_s() {
    var self = this;

    return "main"
  }, $to_s$1.$$arity = 0);
  return (Opal.defs(self, '$include', $include$2 = function $$include(mod) {
    var self = this;

    return $$($nesting, 'Object').$include(mod)
  }, $include$2.$$arity = 1), nil) && 'include';
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/dir"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$[]']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $chdir$1, $pwd$2, $home$3;

      
      
      Opal.def(self, '$chdir', $chdir$1 = function $$chdir(dir) {
        var $iter = $chdir$1.$$p, $yield = $iter || nil, self = this, prev_cwd = nil;

        if ($iter) $chdir$1.$$p = null;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      }, $chdir$1.$$arity = 1);
      
      Opal.def(self, '$pwd', $pwd$2 = function $$pwd() {
        var self = this;

        return Opal.current_dir || '.';
      }, $pwd$2.$$arity = 0);
      Opal.alias(self, "getwd", "pwd");
      return (Opal.def(self, '$home', $home$3 = function $$home() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$($nesting, 'ENV')['$[]']("HOME")))) {
          return $ret_or_1
        } else {
          return "."
        }
      }, $home$3.$$arity = 0), nil) && 'home';
    })(Opal.get_singleton_class(self), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/file"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $klass = Opal.klass, $range = Opal.range, $send = Opal.send;

  Opal.add_stubs(['$respond_to?', '$to_path', '$pwd', '$split', '$sub', '$+', '$unshift', '$join', '$home', '$raise', '$start_with?', '$absolute_path', '$coerce_to!', '$basename', '$empty?', '$rindex', '$[]', '$nil?', '$==', '$-', '$length', '$gsub', '$find', '$=~', '$map', '$each_with_index', '$flatten', '$reject', '$to_proc', '$end_with?']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    Opal.const_set($nesting[0], 'Separator', Opal.const_set($nesting[0], 'SEPARATOR', "/"));
    Opal.const_set($nesting[0], 'ALT_SEPARATOR', nil);
    Opal.const_set($nesting[0], 'PATH_SEPARATOR', ":");
    Opal.const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $absolute_path$1, $expand_path$2, $dirname$3, $basename$4, $extname$5, $exist$ques$6, $directory$ques$7, $join$9, $split$12;

      
      
      Opal.def(self, '$absolute_path', $absolute_path$1 = function $$absolute_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = (function() {if ($truthy(path['$respond_to?']("to_path"))) {
          return path.$to_path()
        } else {
          return path
        }; return nil; })();
        basedir = (function() {if ($truthy(($ret_or_1 = basedir))) {
          return $ret_or_1
        } else {
          return $$($nesting, 'Dir').$pwd()
        }; return nil; })();
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split(Opal.regexp(["[", sep_chars, "]"]));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split(Opal.regexp(["[", sep_chars, "]"])), path.$split(Opal.regexp(["[", sep_chars, "]"])));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)};
        return new_path;
      }, $absolute_path$1.$$arity = -2);
      
      Opal.def(self, '$expand_path', $expand_path$2 = function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$($nesting, 'Dir').$home();
          if ($truthy(home)) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          if ($truthy(home['$start_with?'](leading_sep))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = Opal.regexp(["^\\~(?:", sep, "|$)"]);
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)};};
        return self.$absolute_path(path, basedir);
      }, $expand_path$2.$$arity = -2);
      Opal.alias(self, "realpath", "expand_path");
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $$($nesting, 'Opal')['$coerce_to!'](path, $$($nesting, 'String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$($nesting, 'ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$($nesting, 'SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$($nesting, 'SEPARATOR'), $$($nesting, 'ALT_SEPARATOR')));
        }
      }
    ;
      
      Opal.def(self, '$dirname', $dirname$3 = function $$dirname(path) {
        var self = this, sep_chars = nil;

        
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("" + "^[" + (sep_chars) + "]"));

        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("" + "[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          return absolute ? '/' : '.';
        }

        return path;
      ;
      }, $dirname$3.$$arity = 1);
      
      Opal.def(self, '$basename', $basename$4 = function $$basename(name, suffix) {
        var self = this, sep_chars = nil;

        
        
        if (suffix == null) {
          suffix = nil;
        };
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $$($nesting, 'Opal')['$coerce_to!'](suffix, $$($nesting, 'String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("" + "(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("" + "^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, $basename$4.$$arity = -2);
      
      Opal.def(self, '$extname', $extname$5 = function $$extname(path) {
        var self = this, filename = nil, last_dot_idx = nil, $ret_or_2 = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""};
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if ($truthy((function() {if ($truthy(($ret_or_2 = last_dot_idx['$nil?']()))) {
          return $ret_or_2
        } else {
          return $rb_plus(last_dot_idx, 1)['$==']($rb_minus(filename.$length(), 1))
        }; return nil; })())) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, $extname$5.$$arity = 1);
      
      Opal.def(self, '$exist?', $exist$ques$6 = function(path) {
        var self = this;

        return Opal.modules[path] != null
      }, $exist$ques$6.$$arity = 1);
      Opal.alias(self, "exists?", "exist?");
      
      Opal.def(self, '$directory?', $directory$ques$7 = function(path) {
        var $$8, self = this, files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub(Opal.regexp(["(^.", $$($nesting, 'SEPARATOR'), "+|", $$($nesting, 'SEPARATOR'), "+$)"]));
        file = $send(files, 'find', [], ($$8 = function(f){var self = $$8.$$s == null ? this : $$8.$$s;

        
          
          if (f == null) {
            f = nil;
          };
          return f['$=~'](Opal.regexp(["^", path]));}, $$8.$$s = self, $$8.$$arity = 1, $$8));
        return file;
      }, $directory$ques$7.$$arity = 1);
      
      Opal.def(self, '$join', $join$9 = function $$join($a) {
        var $post_args, paths, $$10, $$11, self = this, result = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        paths = $post_args;;
        if ($truthy(paths['$empty?']())) {
          return ""};
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], ($$10 = function(item, index){var self = $$10.$$s == null ? this : $$10.$$s, $ret_or_3 = nil, $ret_or_4 = nil;

        
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          if ($truthy((function() {if ($truthy(($ret_or_3 = index['$=='](0)))) {
            return item['$empty?']()
          } else {
            return $ret_or_3
          }; return nil; })())) {
            return $$($nesting, 'SEPARATOR')
          } else if ($truthy((function() {if ($truthy(($ret_or_4 = paths.$length()['$==']($rb_plus(index, 1))))) {
            return item['$empty?']()
          } else {
            return $ret_or_4
          }; return nil; })())) {
            return $$($nesting, 'SEPARATOR')
          } else {
            return item
          };}, $$10.$$s = self, $$10.$$arity = 2, $$10));
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], ($$11 = function(item, index){var self = $$11.$$s == null ? this : $$11.$$s, next_item = nil, $ret_or_5 = nil, $ret_or_6 = nil;

        
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if ($truthy((function() {if ($truthy(($ret_or_5 = item['$end_with?']($$($nesting, 'SEPARATOR'))))) {
              return next_item['$start_with?']($$($nesting, 'SEPARATOR'))
            } else {
              return $ret_or_5
            }; return nil; })())) {
              item = item.$sub(Opal.regexp([$$($nesting, 'SEPARATOR'), "+$"]), "")};
            return (result = (function() {if ($truthy((function() {if ($truthy(($ret_or_6 = item['$end_with?']($$($nesting, 'SEPARATOR'))))) {
              return $ret_or_6
            } else {
              return next_item['$start_with?']($$($nesting, 'SEPARATOR'))
            }; return nil; })())) {
              return "" + (result) + (item)
            } else {
              return "" + (result) + (item) + ($$($nesting, 'SEPARATOR'))
            }; return nil; })());
          };}, $$11.$$s = self, $$11.$$arity = 2, $$11));
        return result;
      }, $join$9.$$arity = -1);
      return (Opal.def(self, '$split', $split$12 = function $$split(path) {
        var self = this;

        return path.$split($$($nesting, 'SEPARATOR'))
      }, $split$12.$$arity = 1), nil) && 'split';
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], $$($nesting, 'IO'), $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/process"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$const_set', '$size', '$<<', '$__register_clock__', '$to_f', '$now', '$new', '$[]', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Process');

    var $nesting = [self].concat($parent_nesting), $Process___register_clock__$1, $Process_pid$2, $Process_times$3, $Process_clock_gettime$4, monotonic = nil;

    
    self.__clocks__ = [];
    Opal.defs(self, '$__register_clock__', $Process___register_clock__$1 = function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    }, $Process___register_clock__$1.$$arity = 2);
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)};
    Opal.defs(self, '$pid', $Process_pid$2 = function $$pid() {
      var self = this;

      return 0
    }, $Process_pid$2.$$arity = 0);
    Opal.defs(self, '$times', $Process_times$3 = function $$times() {
      var self = this, t = nil;

      
      t = $$($nesting, 'Time').$now().$to_f();
      return $$$($$($nesting, 'Benchmark'), 'Tms').$new(t, t, t, t, t);
    }, $Process_times$3.$$arity = 0);
    return (Opal.defs(self, '$clock_gettime', $Process_clock_gettime$4 = function $$clock_gettime(clock_id, unit) {
      var self = this, $ret_or_1 = nil, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      
      if (unit == null) {
        unit = "float_second";
      };
      if ($truthy(($ret_or_1 = (clock = self.__clocks__['$[]'](clock_id))))) {
        $ret_or_1
      } else {
        self.$raise($$$($$($nesting, 'Errno'), 'EINVAL'), "" + "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id)))
      };
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: self.$raise($$($nesting, 'ArgumentError'), "" + "unexpected unit: " + (unit))
      }
    ;
    }, $Process_clock_gettime$4.$$arity = -2), nil) && 'clock_gettime';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Signal');

    var $nesting = [self].concat($parent_nesting), $Signal_trap$5;

    return (Opal.defs(self, '$trap', $Signal_trap$5 = function $$trap($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Signal_trap$5.$$arity = -1), nil) && 'trap'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'GC');

    var $nesting = [self].concat($parent_nesting), $GC_start$6;

    return (Opal.defs(self, '$start', $GC_start$6 = function $$start() {
      var self = this;

      return nil
    }, $GC_start$6.$$arity = 0), nil) && 'start'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/random/formatter"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $module = Opal.module, $send = Opal.send, $range = Opal.range;

  Opal.add_stubs(['$_verify_count', '$bytes', '$encode', '$strict_encode64', '$random_bytes', '$urlsafe_encode64', '$split', '$hex', '$[]=', '$-', '$[]', '$map', '$to_proc', '$join', '$times', '$<<', '$|', '$ord', '$/', '$abs', '$random_float', '$raise', '$coerce_to!', '$flatten', '$new', '$random_number', '$length', '$include', '$extend']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $Formatter_hex$1, $Formatter_random_bytes$2, $Formatter_base64$3, $Formatter_urlsafe_base64$4, $Formatter_uuid$5, $Formatter_random_float$6, $Formatter_random_number$8, $Formatter_alphanumeric$9;

      
      
      Opal.def(self, '$hex', $Formatter_hex$1 = function $$hex(count) {
        var self = this;

        
        
        if (count == null) {
          count = nil;
        };
        count = $$($nesting, 'Random').$_verify_count(count);
        
        var bytes = self.$bytes(count);
        var out = "";
        for (var i = 0; i < count; i++) {
          out += bytes.charCodeAt(i).toString(16).padStart(2, '0');
        }
        return (out).$encode("US-ASCII");
      ;
      }, $Formatter_hex$1.$$arity = -1);
      
      Opal.def(self, '$random_bytes', $Formatter_random_bytes$2 = function $$random_bytes(count) {
        var self = this;

        
        
        if (count == null) {
          count = nil;
        };
        return self.$bytes(count);
      }, $Formatter_random_bytes$2.$$arity = -1);
      
      Opal.def(self, '$base64', $Formatter_base64$3 = function $$base64(count) {
        var self = this;

        
        
        if (count == null) {
          count = nil;
        };
        return $$($nesting, 'Base64').$strict_encode64(self.$random_bytes(count)).$encode("US-ASCII");
      }, $Formatter_base64$3.$$arity = -1);
      
      Opal.def(self, '$urlsafe_base64', $Formatter_urlsafe_base64$4 = function $$urlsafe_base64(count, padding) {
        var self = this;

        
        
        if (count == null) {
          count = nil;
        };
        
        if (padding == null) {
          padding = false;
        };
        return $$($nesting, 'Base64').$urlsafe_encode64(self.$random_bytes(count), padding).$encode("US-ASCII");
      }, $Formatter_urlsafe_base64$4.$$arity = -1);
      
      Opal.def(self, '$uuid', $Formatter_uuid$5 = function $$uuid() {
        var self = this, str = nil, $writer = nil;

        
        str = self.$hex(16).$split("");
        
        $writer = [12, "4"];
        $send(str, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [16, (parseInt(str['$[]'](16), 16) & 3 | 8).toString(16)];
        $send(str, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        str = [str['$[]']($range(0, 8, true)), str['$[]']($range(8, 12, true)), str['$[]']($range(12, 16, true)), str['$[]']($range(16, 20, true)), str['$[]']($range(20, 32, true))];
        str = $send(str, 'map', [], "join".$to_proc());
        return str.$join("-");
      }, $Formatter_uuid$5.$$arity = 0);
      
      Opal.def(self, '$random_float', $Formatter_random_float$6 = function $$random_float() {
        var $$7, self = this, bs = nil, num = nil;

        
        bs = self.$bytes(4);
        num = 0;
        $send((4), 'times', [], ($$7 = function(i){var self = $$7.$$s == null ? this : $$7.$$s;

        
          
          if (i == null) {
            i = nil;
          };
          num = num['$<<'](8);
          return (num = num['$|'](bs['$[]'](i).$ord()));}, $$7.$$s = self, $$7.$$arity = 1, $$7));
        return $rb_divide(num.$abs(), 2147483647);
      }, $Formatter_random_float$6.$$arity = 0);
      
      Opal.def(self, '$random_number', $Formatter_random_number$8 = function $$random_number(limit) {
        var self = this;

        
        ;
        
        function randomFloat() {
          return self.$random_float();
        }

        function randomInt(max) {
          return Math.floor(randomFloat() * max);
        }

        function randomRange() {
          var min = limit.begin,
              max = limit.end;

          if (min === nil || max === nil) {
            return nil;
          }

          var length = max - min;

          if (length < 0) {
            return nil;
          }

          if (length === 0) {
            return min;
          }

          if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
            length++;
          }

          return randomInt(length) + min;
        }

        if (limit == null) {
          return randomFloat();
        } else if (limit.$$is_range) {
          return randomRange();
        } else if (limit.$$is_number) {
          if (limit <= 0) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
          }

          if (limit % 1 === 0) {
            // integer
            return randomInt(limit);
          } else {
            return randomFloat() * limit;
          }
        } else {
          limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");

          if (limit <= 0) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
          }

          return randomInt(limit);
        }
      ;
      }, $Formatter_random_number$8.$$arity = -1);
      return (Opal.def(self, '$alphanumeric', $Formatter_alphanumeric$9 = function $$alphanumeric(count) {
        var $$10, self = this, map = nil;

        
        
        if (count == null) {
          count = nil;
        };
        count = $$($nesting, 'Random').$_verify_count(count);
        map = $send([$range("0", "9", false), $range("a", "z", false), $range("A", "Z", false)], 'map', [], "to_a".$to_proc()).$flatten();
        return $send($$($nesting, 'Array'), 'new', [count], ($$10 = function(i){var self = $$10.$$s == null ? this : $$10.$$s;

        
          
          if (i == null) {
            i = nil;
          };
          return map['$[]'](self.$random_number(map.$length()));}, $$10.$$s = self, $$10.$$arity = 1, $$10)).$join();
      }, $Formatter_alphanumeric$9.$$arity = -1), nil) && 'alphanumeric';
    })($nesting[0], $nesting);
    self.$include($$$($$($nesting, 'Random'), 'Formatter'));
    return self.$extend($$$($$($nesting, 'Random'), 'Formatter'));
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/random"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$to_int', '$raise', '$new_seed', '$coerce_to!', '$reseed', '$rand', '$seed', '$bytes', '$===', '$==', '$state', '$_verify_count', '$encode', '$join', '$new', '$chr', '$random_number', '$random_float', '$const_defined?', '$const_set']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting), $Random__verify_count$1, $Random_initialize$2, $Random_reseed$3, $Random_new_seed$4, $Random_rand$5, $Random_srand$6, $Random_urandom$7, $Random_$eq_eq$8, $Random_bytes$9, $Random_bytes$11, $Random_rand$12, $Random_random_float$13, $Random_random_float$14, $Random_generator$eq$15;

    
    self.$attr_reader("seed", "state");
    Opal.defs(self, '$_verify_count', $Random__verify_count$1 = function $$_verify_count(count) {
      var self = this;

      
      if ($falsy(count)) count = 16;
      if (typeof count !== "number") count = (count).$to_int();
      if (count < 0) self.$raise($$($nesting, 'ArgumentError'), "negative string size (or size too big)");
      count = Math.floor(count);
      return count;
    
    }, $Random__verify_count$1.$$arity = 1);
    
    Opal.def(self, '$initialize', $Random_initialize$2 = function $$initialize(seed) {
      var self = this;

      
      
      if (seed == null) {
        seed = $$($nesting, 'Random').$new_seed();
      };
      seed = $$($nesting, 'Opal')['$coerce_to!'](seed, $$($nesting, 'Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, $Random_initialize$2.$$arity = -1);
    
    Opal.def(self, '$reseed', $Random_reseed$3 = function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = Opal.$$rand.reseed(seed);;
    }, $Random_reseed$3.$$arity = 1);
    Opal.defs(self, '$new_seed', $Random_new_seed$4 = function $$new_seed() {
      var self = this;

      return Opal.$$rand.new_seed();
    }, $Random_new_seed$4.$$arity = 0);
    Opal.defs(self, '$rand', $Random_rand$5 = function $$rand(limit) {
      var self = this;

      
      ;
      return $$($nesting, 'DEFAULT').$rand(limit);
    }, $Random_rand$5.$$arity = -1);
    Opal.defs(self, '$srand', $Random_srand$6 = function $$srand(n) {
      var self = this, previous_seed = nil;

      
      
      if (n == null) {
        n = $$($nesting, 'Random').$new_seed();
      };
      n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      previous_seed = $$($nesting, 'DEFAULT').$seed();
      $$($nesting, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, $Random_srand$6.$$arity = -1);
    Opal.defs(self, '$urandom', $Random_urandom$7 = function $$urandom(size) {
      var self = this;

      return $$$('::', 'SecureRandom').$bytes(size)
    }, $Random_urandom$7.$$arity = 1);
    
    Opal.def(self, '$==', $Random_$eq_eq$8 = function(other) {
      var self = this, $ret_or_1 = nil;

      
      if ($truthy($$($nesting, 'Random')['$==='](other))) {
      } else {
        return false
      };
      if ($truthy(($ret_or_1 = self.$seed()['$=='](other.$seed())))) {
        return self.$state()['$=='](other.$state())
      } else {
        return $ret_or_1
      };
    }, $Random_$eq_eq$8.$$arity = 1);
    
    Opal.def(self, '$bytes', $Random_bytes$9 = function $$bytes(length) {
      var $$10, self = this;

      
      length = $$($nesting, 'Random').$_verify_count(length);
      return $send($$($nesting, 'Array'), 'new', [length], ($$10 = function(){var self = $$10.$$s == null ? this : $$10.$$s;

      return self.$rand(255).$chr()}, $$10.$$s = self, $$10.$$arity = 0, $$10)).$join().$encode("ASCII-8BIT");
    }, $Random_bytes$9.$$arity = 1);
    Opal.defs(self, '$bytes', $Random_bytes$11 = function $$bytes(length) {
      var self = this;

      return $$($nesting, 'DEFAULT').$bytes(length)
    }, $Random_bytes$11.$$arity = 1);
    
    Opal.def(self, '$rand', $Random_rand$12 = function $$rand(limit) {
      var self = this;

      
      ;
      return self.$random_number(limit);
    }, $Random_rand$12.$$arity = -1);
    
    Opal.def(self, '$random_float', $Random_random_float$13 = function $$random_float() {
      var self = this;

      
      self.state++;
      return Opal.$$rand.rand(self.$rng);
    
    }, $Random_random_float$13.$$arity = 0);
    Opal.defs(self, '$random_float', $Random_random_float$14 = function $$random_float() {
      var self = this;

      return $$($nesting, 'DEFAULT').$random_float()
    }, $Random_random_float$14.$$arity = 0);
    return (Opal.defs(self, '$generator=', $Random_generator$eq$15 = function(generator) {
      var self = this;

      
      Opal.$$rand = generator;
      if ($truthy(self['$const_defined?']("DEFAULT"))) {
        return $$($nesting, 'DEFAULT').$reseed()
      } else {
        return self.$const_set("DEFAULT", self.$new(self.$new_seed()))
      };
    }, $Random_generator$eq$15.$$arity = 1), nil) && 'generator=';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, mersenne_twister = nil;

  Opal.add_stubs(['$generator=', '$-']);
  
  mersenne_twister = (function() {
  /* Period parameters */
  var N = 624;
  var M = 397;
  var MATRIX_A = 0x9908b0df;      /* constant vector a */
  var UMASK = 0x80000000;         /* most significant w-r bits */
  var LMASK = 0x7fffffff;         /* least significant r bits */
  var MIXBITS = function(u,v) { return ( ((u) & UMASK) | ((v) & LMASK) ); };
  var TWIST = function(u,v) { return (MIXBITS((u),(v)) >>> 1) ^ ((v & 0x1) ? MATRIX_A : 0x0); };

  function init(s) {
    var mt = {left: 0, next: N, state: new Array(N)};
    init_genrand(mt, s);
    return mt;
  }

  /* initializes mt[N] with a seed */
  function init_genrand(mt, s) {
    var j, i;
    mt.state[0] = s >>> 0;
    for (j=1; j<N; j++) {
      mt.state[j] = (1812433253 * ((mt.state[j-1] ^ (mt.state[j-1] >> 30) >>> 0)) + j);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array state[].                     */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      mt.state[j] &= 0xffffffff;  /* for >32 bit machines */
    }
    mt.left = 1;
    mt.next = N;
  }

  /* generate N words at one time */
  function next_state(mt) {
    var p = 0, _p = mt.state;
    var j;

    mt.left = N;
    mt.next = 0;

    for (j=N-M+1; --j; p++)
      _p[p] = _p[p+(M)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    for (j=M; --j; p++)
      _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[0]);
  }

  /* generates a random number on [0,0xffffffff]-interval */
  function genrand_int32(mt) {
    /* mt must be initialized */
    var y;

    if (--mt.left <= 0) next_state(mt);
    y = mt.state[mt.next++];

    /* Tempering */
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);

    return y >>> 0;
  }

  function int_pair_to_real_exclusive(a, b) {
    a >>>= 5;
    b >>>= 6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  // generates a random number on [0,1) with 53-bit resolution
  function genrand_real(mt) {
    /* mt must be initialized */
    var a = genrand_int32(mt), b = genrand_int32(mt);
    return int_pair_to_real_exclusive(a, b);
  }

  return { genrand_real: genrand_real, init: init };
})();
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting), $writer = nil;

    
    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    Opal.const_set($nesting[0], 'MERSENNE_TWISTER_GENERATOR', {
    new_seed: function() { return Math.round(Math.random() * MAX_INT); },
    reseed: function(seed) { return mersenne_twister.init(seed); },
    rand: function(mt) { return mersenne_twister.genrand_real(mt); }
  });
    
    $writer = [$$($nesting, 'MERSENNE_TWISTER_GENERATOR')];
    $send(self, 'generator=', Opal.to_a($writer));
    return $writer[$rb_minus($writer["length"], 1)];;
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.2.0 */
Opal.modules["corelib/unsupported"] = function(Opal) {
  var $public$35, $private$36, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $module = Opal.module;

  Opal.add_stubs(['$raise', '$warn', '$%']);
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $$($nesting, 'Kernel').$raise($$($nesting, 'NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_$lt$lt$1, $String_capitalize$excl$2, $String_chomp$excl$3, $String_chop$excl$4, $String_downcase$excl$5, $String_gsub$excl$6, $String_lstrip$excl$7, $String_next$excl$8, $String_reverse$excl$9, $String_slice$excl$10, $String_squeeze$excl$11, $String_strip$excl$12, $String_sub$excl$13, $String_succ$excl$14, $String_swapcase$excl$15, $String_tr$excl$16, $String_tr_s$excl$17, $String_upcase$excl$18, $String_prepend$19, $String_$$$eq$20, $String_clear$21, $String_encode$excl$22, $String_unicode_normalize$excl$23;

    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    
    Opal.def(self, '$<<', $String_$lt$lt$1 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("<<"));
    }, $String_$lt$lt$1.$$arity = -1);
    
    Opal.def(self, '$capitalize!', $String_capitalize$excl$2 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("capitalize!"));
    }, $String_capitalize$excl$2.$$arity = -1);
    
    Opal.def(self, '$chomp!', $String_chomp$excl$3 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chomp!"));
    }, $String_chomp$excl$3.$$arity = -1);
    
    Opal.def(self, '$chop!', $String_chop$excl$4 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chop!"));
    }, $String_chop$excl$4.$$arity = -1);
    
    Opal.def(self, '$downcase!', $String_downcase$excl$5 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("downcase!"));
    }, $String_downcase$excl$5.$$arity = -1);
    
    Opal.def(self, '$gsub!', $String_gsub$excl$6 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("gsub!"));
    }, $String_gsub$excl$6.$$arity = -1);
    
    Opal.def(self, '$lstrip!', $String_lstrip$excl$7 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("lstrip!"));
    }, $String_lstrip$excl$7.$$arity = -1);
    
    Opal.def(self, '$next!', $String_next$excl$8 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("next!"));
    }, $String_next$excl$8.$$arity = -1);
    
    Opal.def(self, '$reverse!', $String_reverse$excl$9 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("reverse!"));
    }, $String_reverse$excl$9.$$arity = -1);
    
    Opal.def(self, '$slice!', $String_slice$excl$10 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("slice!"));
    }, $String_slice$excl$10.$$arity = -1);
    
    Opal.def(self, '$squeeze!', $String_squeeze$excl$11 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("squeeze!"));
    }, $String_squeeze$excl$11.$$arity = -1);
    
    Opal.def(self, '$strip!', $String_strip$excl$12 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("strip!"));
    }, $String_strip$excl$12.$$arity = -1);
    
    Opal.def(self, '$sub!', $String_sub$excl$13 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("sub!"));
    }, $String_sub$excl$13.$$arity = -1);
    
    Opal.def(self, '$succ!', $String_succ$excl$14 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("succ!"));
    }, $String_succ$excl$14.$$arity = -1);
    
    Opal.def(self, '$swapcase!', $String_swapcase$excl$15 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("swapcase!"));
    }, $String_swapcase$excl$15.$$arity = -1);
    
    Opal.def(self, '$tr!', $String_tr$excl$16 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr!"));
    }, $String_tr$excl$16.$$arity = -1);
    
    Opal.def(self, '$tr_s!', $String_tr_s$excl$17 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr_s!"));
    }, $String_tr_s$excl$17.$$arity = -1);
    
    Opal.def(self, '$upcase!', $String_upcase$excl$18 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("upcase!"));
    }, $String_upcase$excl$18.$$arity = -1);
    
    Opal.def(self, '$prepend', $String_prepend$19 = function $$prepend($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("prepend"));
    }, $String_prepend$19.$$arity = -1);
    
    Opal.def(self, '$[]=', $String_$$$eq$20 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("[]="));
    }, $String_$$$eq$20.$$arity = -1);
    
    Opal.def(self, '$clear', $String_clear$21 = function $$clear($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("clear"));
    }, $String_clear$21.$$arity = -1);
    
    Opal.def(self, '$encode!', $String_encode$excl$22 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("encode!"));
    }, $String_encode$excl$22.$$arity = -1);
    return (Opal.def(self, '$unicode_normalize!', $String_unicode_normalize$excl$23 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("unicode_normalize!"));
    }, $String_unicode_normalize$excl$23.$$arity = -1), nil) && 'unicode_normalize!';
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_freeze$24, $Kernel_frozen$ques$25;

    
    var ERROR = "Object freezing is not supported by Opal";
    
    Opal.def(self, '$freeze', $Kernel_freeze$24 = function $$freeze() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_freeze$24.$$arity = 0);
    return (Opal.def(self, '$frozen?', $Kernel_frozen$ques$25 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_frozen$ques$25.$$arity = 0), nil) && 'frozen?';
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_taint$26, $Kernel_untaint$27, $Kernel_tainted$ques$28;

    
    var ERROR = "Object tainting is not supported by Opal";
    
    Opal.def(self, '$taint', $Kernel_taint$26 = function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_taint$26.$$arity = 0);
    
    Opal.def(self, '$untaint', $Kernel_untaint$27 = function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_untaint$27.$$arity = 0);
    return (Opal.def(self, '$tainted?', $Kernel_tainted$ques$28 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_tainted$ques$28.$$arity = 0), nil) && 'tainted?';
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_public$29, $Module_private_class_method$30, $Module_private_method_defined$ques$31, $Module_private_constant$32;

    
    
    Opal.def(self, '$public', $Module_public$29 = function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = false;
      }

      return nil;
    ;
    }, $Module_public$29.$$arity = -1);
    Opal.alias(self, "private", "public");
    Opal.alias(self, "protected", "public");
    Opal.alias(self, "nesting", "public");
    
    Opal.def(self, '$private_class_method', $Module_private_class_method$30 = function $$private_class_method($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self;
    }, $Module_private_class_method$30.$$arity = -1);
    Opal.alias(self, "public_class_method", "private_class_method");
    
    Opal.def(self, '$private_method_defined?', $Module_private_method_defined$ques$31 = function(obj) {
      var self = this;

      return false
    }, $Module_private_method_defined$ques$31.$$arity = 1);
    
    Opal.def(self, '$private_constant', $Module_private_constant$32 = function $$private_constant($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_private_constant$32.$$arity = -1);
    Opal.alias(self, "protected_method_defined?", "private_method_defined?");
    Opal.alias(self, "public_instance_methods", "instance_methods");
    Opal.alias(self, "public_instance_method", "instance_method");
    return Opal.alias(self, "public_method_defined?", "method_defined?");
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_private_methods$33;

    
    
    Opal.def(self, '$private_methods', $Kernel_private_methods$33 = function $$private_methods($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return [];
    }, $Kernel_private_methods$33.$$arity = -1);
    return Opal.alias(self, "private_instance_methods", "private_methods");
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_eval$34;

    return (Opal.def(self, '$eval', $Kernel_eval$34 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), "" + "To use Kernel#eval, you must first require 'opal-parser'. " + ("" + "See https://github.com/opal/opal/blob/" + ($$($nesting, 'RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, $Kernel_eval$34.$$arity = -1), nil) && 'eval'
  })($nesting[0], $nesting);
  Opal.defs(self, '$public', $public$35 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $public$35.$$arity = -1);
  return (Opal.defs(self, '$private', $private$36 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $private$36.$$arity = -1), nil) && 'private';
};

/* Generated by Opal 1.2.0 */
(function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("opal/mini");
  self.$require("corelib/kernel/format");
  self.$require("corelib/string/encoding");
  self.$require("corelib/math");
  self.$require("corelib/complex");
  self.$require("corelib/rational");
  self.$require("corelib/time");
  self.$require("corelib/struct");
  self.$require("corelib/io");
  self.$require("corelib/main");
  self.$require("corelib/dir");
  self.$require("corelib/file");
  self.$require("corelib/process");
  self.$require("corelib/random/formatter");
  self.$require("corelib/random");
  self.$require("corelib/random/mersenne_twister");
  return self.$require("corelib/unsupported");
})(Opal);

/* Generated by Opal 1.2.0 */
Opal.modules["ostruct"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $range = Opal.range, $send2 = Opal.send2;

  Opal.add_stubs(['$each_pair', '$new_ostruct_member', '$[]=', '$-', '$[]', '$to_sym', '$>', '$length', '$raise', '$new', '$end_with?', '$!=', '$chomp', '$to_s', '$key?', '$enum_for', '$is_a?', '$==', '$instance_variable_get', '$===', '$eql?', '$dup', '$to_n', '$hash', '$attr_reader', '$__send__', '$singleton_class', '$delete', '$respond_to?', '$define_singleton_method', '$__id__', '$class', '$any?', '$+', '$join', '$map', '$inspect']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'OpenStruct');

    var $nesting = [self].concat($parent_nesting), $OpenStruct_initialize$1, $OpenStruct_$$$3, $OpenStruct_$$$eq$4, $OpenStruct_method_missing$5, $OpenStruct_respond_to_missing$ques$6, $OpenStruct_each_pair$7, $OpenStruct_$eq_eq$9, $OpenStruct_$eq_eq_eq$10, $OpenStruct_eql$ques$11, $OpenStruct_to_h$12, $OpenStruct_to_n$13, $OpenStruct_hash$14, $OpenStruct_delete_field$15, $OpenStruct_new_ostruct_member$16, $OpenStruct_inspect$19;

    self.$$prototype.table = nil;
    
    
    Opal.def(self, '$initialize', $OpenStruct_initialize$1 = function $$initialize(hash) {
      var $$2, self = this;

      
      
      if (hash == null) {
        hash = nil;
      };
      self.table = $hash2([], {});
      if ($truthy(hash)) {
        return $send(hash, 'each_pair', [], ($$2 = function(key, value){var self = $$2.$$s == null ? this : $$2.$$s, $writer = nil;
          if (self.table == null) self.table = nil;

        
          
          if (key == null) {
            key = nil;
          };
          
          if (value == null) {
            value = nil;
          };
          $writer = [self.$new_ostruct_member(key), value];
          $send(self.table, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$2.$$s = self, $$2.$$arity = 2, $$2))
      } else {
        return nil
      };
    }, $OpenStruct_initialize$1.$$arity = -1);
    
    Opal.def(self, '$[]', $OpenStruct_$$$3 = function(name) {
      var self = this;

      return self.table['$[]'](name.$to_sym())
    }, $OpenStruct_$$$3.$$arity = 1);
    
    Opal.def(self, '$[]=', $OpenStruct_$$$eq$4 = function(name, value) {
      var self = this, $writer = nil;

      
      $writer = [self.$new_ostruct_member(name), value];
      $send(self.table, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];
    }, $OpenStruct_$$$eq$4.$$arity = 2);
    
    Opal.def(self, '$method_missing', $OpenStruct_method_missing$5 = function $$method_missing(name, $a) {
      var $post_args, args, self = this, $writer = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      if ($truthy($rb_gt(args.$length(), 2))) {
        self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `" + (name) + "' for #<OpenStruct>", name))};
      if ($truthy(name['$end_with?']("="))) {
        
        if ($truthy(args.$length()['$!='](1))) {
          self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1)")};
        
        $writer = [self.$new_ostruct_member(name['$[]']($range(0, -2, false))), args['$[]'](0)];
        $send(self.table, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];;
      } else {
        return self.table['$[]'](name.$to_sym())
      };
    }, $OpenStruct_method_missing$5.$$arity = -2);
    
    Opal.def(self, '$respond_to_missing?', $OpenStruct_respond_to_missing$ques$6 = function(mid, include_private) {
      var $a, $iter = $OpenStruct_respond_to_missing$ques$6.$$p, $yield = $iter || nil, self = this, mname = nil, $ret_or_1 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $OpenStruct_respond_to_missing$ques$6.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if (include_private == null) {
        include_private = false;
      };
      mname = mid.$to_s().$chomp("=").$to_sym();
      if ($truthy(($ret_or_1 = ($a = self.table, ($a === nil || $a == null) ? nil : $send($a, 'key?', [mname]))))) {
        return $ret_or_1
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'respond_to_missing?', $OpenStruct_respond_to_missing$ques$6, false, true), 'respond_to_missing?', $zuper, $iter)
      };
    }, $OpenStruct_respond_to_missing$ques$6.$$arity = -2);
    
    Opal.def(self, '$each_pair', $OpenStruct_each_pair$7 = function $$each_pair() {
      var $$8, $iter = $OpenStruct_each_pair$7.$$p, $yield = $iter || nil, self = this;

      if ($iter) $OpenStruct_each_pair$7.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return self.$enum_for("each_pair")
      };
      return $send(self.table, 'each_pair', [], ($$8 = function(pair){var self = $$8.$$s == null ? this : $$8.$$s;

      
        
        if (pair == null) {
          pair = nil;
        };
        return Opal.yield1($yield, pair);;}, $$8.$$s = self, $$8.$$arity = 1, $$8));
    }, $OpenStruct_each_pair$7.$$arity = 0);
    
    Opal.def(self, '$==', $OpenStruct_$eq_eq$9 = function(other) {
      var self = this;

      
      if ($truthy(other['$is_a?']($$($nesting, 'OpenStruct')))) {
      } else {
        return false
      };
      return self.table['$=='](other.$instance_variable_get("@table"));
    }, $OpenStruct_$eq_eq$9.$$arity = 1);
    
    Opal.def(self, '$===', $OpenStruct_$eq_eq_eq$10 = function(other) {
      var self = this;

      
      if ($truthy(other['$is_a?']($$($nesting, 'OpenStruct')))) {
      } else {
        return false
      };
      return self.table['$==='](other.$instance_variable_get("@table"));
    }, $OpenStruct_$eq_eq_eq$10.$$arity = 1);
    
    Opal.def(self, '$eql?', $OpenStruct_eql$ques$11 = function(other) {
      var self = this;

      
      if ($truthy(other['$is_a?']($$($nesting, 'OpenStruct')))) {
      } else {
        return false
      };
      return self.table['$eql?'](other.$instance_variable_get("@table"));
    }, $OpenStruct_eql$ques$11.$$arity = 1);
    
    Opal.def(self, '$to_h', $OpenStruct_to_h$12 = function $$to_h() {
      var self = this;

      return self.table.$dup()
    }, $OpenStruct_to_h$12.$$arity = 0);
    
    Opal.def(self, '$to_n', $OpenStruct_to_n$13 = function $$to_n() {
      var self = this;

      return self.table.$to_n()
    }, $OpenStruct_to_n$13.$$arity = 0);
    
    Opal.def(self, '$hash', $OpenStruct_hash$14 = function $$hash() {
      var self = this;

      return self.table.$hash()
    }, $OpenStruct_hash$14.$$arity = 0);
    self.$attr_reader("table");
    
    Opal.def(self, '$delete_field', $OpenStruct_delete_field$15 = function $$delete_field(name) {
      var self = this, sym = nil;

      
      sym = name.$to_sym();
      
      try {
        self.$singleton_class().$__send__("remove_method", sym, "" + (sym) + "=")
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'NameError')])) {
          try {
            nil
          } finally { Opal.pop_exception() }
        } else { throw $err; }
      };;
      return self.table.$delete(sym);
    }, $OpenStruct_delete_field$15.$$arity = 1);
    
    Opal.def(self, '$new_ostruct_member', $OpenStruct_new_ostruct_member$16 = function $$new_ostruct_member(name) {
      var $$17, $$18, self = this;

      
      name = name.$to_sym();
      if ($truthy(self['$respond_to?'](name))) {
      } else {
        
        $send(self, 'define_singleton_method', [name], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s;
          if (self.table == null) self.table = nil;

        return self.table['$[]'](name)}, $$17.$$s = self, $$17.$$arity = 0, $$17));
        $send(self, 'define_singleton_method', ["" + (name) + "="], ($$18 = function(x){var self = $$18.$$s == null ? this : $$18.$$s, $writer = nil;
          if (self.table == null) self.table = nil;

        
          
          if (x == null) {
            x = nil;
          };
          $writer = [name, x];
          $send(self.table, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$18.$$s = self, $$18.$$arity = 1, $$18));
      };
      return name;
    }, $OpenStruct_new_ostruct_member$16.$$arity = 1);
    var ostruct_ids;;
    
    Opal.def(self, '$inspect', $OpenStruct_inspect$19 = function $$inspect() {
      var $$20, self = this, result = nil;

      
      
      var top = (ostruct_ids === undefined),
          ostruct_id = self.$__id__();
    ;
      
      return (function() { try {
      
      result = "" + "#<" + (self.$class());
      
        if (top) {
          ostruct_ids = {};
        }
        if (ostruct_ids.hasOwnProperty(ostruct_id)) {
          return result + ' ...>';
        }
        ostruct_ids[ostruct_id] = true;
      ;
      if ($truthy(self.table['$any?']())) {
        result = $rb_plus(result, " ")};
      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], ($$20 = function(name, value){var self = $$20.$$s == null ? this : $$20.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        return "" + (name) + "=" + (value.$inspect());}, $$20.$$s = self, $$20.$$arity = 2, $$20)).$join(", "));
      result = $rb_plus(result, ">");
      return result;
      } finally {
        
        if (top) {
          ostruct_ids = undefined;
        }
      
      }; })();;
    }, $OpenStruct_inspect$19.$$arity = 0);
    return Opal.alias(self, "to_s", "inspect");
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.2.0 */
Opal.modules["native"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module, $truthy = Opal.truthy, $send = Opal.send, $hash2 = Opal.hash2, $range = Opal.range, $klass = Opal.klass, $send2 = Opal.send2, $gvars = Opal.gvars;

  Opal.add_stubs(['$try_convert', '$native?', '$respond_to?', '$to_n', '$raise', '$inspect', '$Native', '$proc', '$map!', '$end_with?', '$define_method', '$[]', '$convert', '$call', '$to_proc', '$new', '$each', '$native_reader', '$native_writer', '$extend', '$warn', '$include', '$is_a?', '$map', '$to_a', '$_Array', '$method_missing', '$bind', '$instance_method', '$slice', '$-', '$length', '$[]=', '$enum_for', '$===', '$>=', '$<<', '$each_pair', '$_initialize', '$name', '$native_module']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Native');

    var $nesting = [self].concat($parent_nesting), $Native_is_a$ques$1, $Native_try_convert$2, $Native_convert$3, $Native_call$4, $Native_proc$5, $Native_included$22;

    
    Opal.defs(self, '$is_a?', $Native_is_a$ques$1 = function(object, klass) {
      var self = this;

      
      try {
        return object instanceof self.$try_convert(klass);
      }
      catch (e) {
        return false;
      }
    
    }, $Native_is_a$ques$1.$$arity = 2);
    Opal.defs(self, '$try_convert', $Native_try_convert$2 = function $$try_convert(value, default$) {
      var self = this;

      
      
      if (default$ == null) {
        default$ = nil;
      };
      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        return default$;
      }
    ;
    }, $Native_try_convert$2.$$arity = -2);
    Opal.defs(self, '$convert', $Native_convert$3 = function $$convert(value) {
      var self = this;

      
      if (self['$native?'](value)) {
        return value;
      }
      else if (value['$respond_to?']("to_n")) {
        return value.$to_n();
      }
      else {
        self.$raise($$($nesting, 'ArgumentError'), "" + (value.$inspect()) + " isn't native");
      }
    
    }, $Native_convert$3.$$arity = 1);
    Opal.defs(self, '$call', $Native_call$4 = function $$call(obj, key, $a) {
      var $iter = $Native_call$4.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Native_call$4.$$p = null;
      
      
      if ($iter) $Native_call$4.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 2, arguments.length);
      
      args = $post_args;;
      
      var prop = obj[key];

      if (prop instanceof Function) {
        var converted = new Array(args.length);

        for (var i = 0, l = args.length; i < l; i++) {
          var item = args[i],
              conv = self.$try_convert(item);

          converted[i] = conv === nil ? item : conv;
        }

        if (block !== nil) {
          converted.push(block);
        }

        return self.$Native(prop.apply(obj, converted));
      }
      else {
        return self.$Native(prop);
      }
    ;
    }, $Native_call$4.$$arity = -3);
    Opal.defs(self, '$proc', $Native_proc$5 = function $$proc() {
      var $iter = $Native_proc$5.$$p, block = $iter || nil, $$6, self = this;

      if ($iter) $Native_proc$5.$$p = null;
      
      
      if ($iter) $Native_proc$5.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'LocalJumpError'), "no block given")
      };
      return $send($$$('::', 'Kernel'), 'proc', [], ($$6 = function($a){var self = $$6.$$s == null ? this : $$6.$$s, $post_args, args, $$7, instance = nil;

      
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        $send(args, 'map!', [], ($$7 = function(arg){var self = $$7.$$s == null ? this : $$7.$$s;

        
          
          if (arg == null) {
            arg = nil;
          };
          return self.$Native(arg);}, $$7.$$s = self, $$7.$$arity = 1, $$7));
        instance = self.$Native(this);
        
        // if global is current scope, run the block in the scope it was defined
        if (this === Opal.global) {
          return block.apply(self, args);
        }

        var self_ = block.$$s;
        block.$$s = null;

        try {
          return block.apply(instance, args);
        }
        finally {
          block.$$s = self_;
        }
      ;}, $$6.$$s = self, $$6.$$arity = -1, $$6));
    }, $Native_proc$5.$$arity = 0);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Helpers');

      var $nesting = [self].concat($parent_nesting), $Helpers_alias_native$8, $Helpers_native_reader$12, $Helpers_native_writer$15, $Helpers_native_accessor$18;

      
      
      Opal.def(self, '$alias_native', $Helpers_alias_native$8 = function $$alias_native(new$, $a, $b) {
        var $post_args, $kwargs, old, as, $$9, $$10, $$11, $iter = $Helpers_alias_native$8.$$p, $yield = $iter || nil, self = this;

        if ($iter) $Helpers_alias_native$8.$$p = null;
        
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        $kwargs = Opal.extract_kwargs($post_args);
        
        if ($kwargs == null) {
          $kwargs = $hash2([], {});
        } else if (!$kwargs.$$is_hash) {
          throw Opal.ArgumentError.$new('expected kwargs');
        };
        
        if ($post_args.length > 0) {
          old = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (old == null) {
          old = new$;
        };
        
        as = $kwargs.$$smap["as"];
        if (as == null) {
          as = nil
        };
        if ($truthy(old['$end_with?']("="))) {
          return $send(self, 'define_method', [new$], ($$9 = function(value){var self = $$9.$$s == null ? this : $$9.$$s;
            if (self["native"] == null) self["native"] = nil;

          
            
            if (value == null) {
              value = nil;
            };
            self["native"][old['$[]']($range(0, -2, false))] = $$($nesting, 'Native').$convert(value);
            return value;}, $$9.$$s = self, $$9.$$arity = 1, $$9))
        } else if ($truthy(as)) {
          return $send(self, 'define_method', [new$], ($$10 = function($c){var self = $$10.$$s == null ? this : $$10.$$s, $iter = $$10.$$p, block = $iter || nil, $post_args, args, value = nil;
            if (self["native"] == null) self["native"] = nil;

          
            
            if ($iter) $$10.$$p = null;;
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            value = $send($$($nesting, 'Native'), 'call', [self["native"], old].concat(Opal.to_a(args)), block.$to_proc());
            if ($truthy(value)) {
              return as.$new(value.$to_n())
            } else {
              return nil
            };}, $$10.$$s = self, $$10.$$arity = -1, $$10))
        } else {
          return $send(self, 'define_method', [new$], ($$11 = function($c){var self = $$11.$$s == null ? this : $$11.$$s, $iter = $$11.$$p, block = $iter || nil, $post_args, args;
            if (self["native"] == null) self["native"] = nil;

          
            
            if ($iter) $$11.$$p = null;;
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            return $send($$($nesting, 'Native'), 'call', [self["native"], old].concat(Opal.to_a(args)), block.$to_proc());}, $$11.$$s = self, $$11.$$arity = -1, $$11))
        };
      }, $Helpers_alias_native$8.$$arity = -2);
      
      Opal.def(self, '$native_reader', $Helpers_native_reader$12 = function $$native_reader($a) {
        var $post_args, names, $$13, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        names = $post_args;;
        return $send(names, 'each', [], ($$13 = function(name){var self = $$13.$$s == null ? this : $$13.$$s, $$14;

        
          
          if (name == null) {
            name = nil;
          };
          return $send(self, 'define_method', [name], ($$14 = function(){var self = $$14.$$s == null ? this : $$14.$$s;
            if (self["native"] == null) self["native"] = nil;

          return self.$Native(self["native"][name])}, $$14.$$s = self, $$14.$$arity = 0, $$14));}, $$13.$$s = self, $$13.$$arity = 1, $$13));
      }, $Helpers_native_reader$12.$$arity = -1);
      
      Opal.def(self, '$native_writer', $Helpers_native_writer$15 = function $$native_writer($a) {
        var $post_args, names, $$16, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        names = $post_args;;
        return $send(names, 'each', [], ($$16 = function(name){var self = $$16.$$s == null ? this : $$16.$$s, $$17;

        
          
          if (name == null) {
            name = nil;
          };
          return $send(self, 'define_method', ["" + (name) + "="], ($$17 = function(value){var self = $$17.$$s == null ? this : $$17.$$s;
            if (self["native"] == null) self["native"] = nil;

          
            
            if (value == null) {
              value = nil;
            };
            return self.$Native(self["native"][name] = value);}, $$17.$$s = self, $$17.$$arity = 1, $$17));}, $$16.$$s = self, $$16.$$arity = 1, $$16));
      }, $Helpers_native_writer$15.$$arity = -1);
      return (Opal.def(self, '$native_accessor', $Helpers_native_accessor$18 = function $$native_accessor($a) {
        var $post_args, names, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        names = $post_args;;
        $send(self, 'native_reader', Opal.to_a(names));
        return $send(self, 'native_writer', Opal.to_a(names));
      }, $Helpers_native_accessor$18.$$arity = -1), nil) && 'native_accessor';
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Wrapper');

      var $nesting = [self].concat($parent_nesting), $Wrapper_initialize$19, $Wrapper_to_n$20, $Wrapper_included$21;

      
      
      Opal.def(self, '$initialize', $Wrapper_initialize$19 = function $$initialize(native$) {
        var self = this;

        
        if ($truthy($$$('::', 'Kernel')['$native?'](native$))) {
        } else {
          $$$('::', 'Kernel').$raise($$($nesting, 'ArgumentError'), "" + (native$.$inspect()) + " isn't native")
        };
        return (self["native"] = native$);
      }, $Wrapper_initialize$19.$$arity = 1);
      
      Opal.def(self, '$to_n', $Wrapper_to_n$20 = function $$to_n() {
        var self = this;
        if (self["native"] == null) self["native"] = nil;

        return self["native"]
      }, $Wrapper_to_n$20.$$arity = 0);
      return (Opal.defs(self, '$included', $Wrapper_included$21 = function $$included(klass) {
        var self = this;

        return klass.$extend($$($nesting, 'Helpers'))
      }, $Wrapper_included$21.$$arity = 1), nil) && 'included';
    })($nesting[0], $nesting);
    return (Opal.defs(self, '$included', $Native_included$22 = function $$included(base) {
      var self = this;

      
      self.$warn("Including ::Native is deprecated. Please include Native::Wrapper instead.");
      return base.$include($$($nesting, 'Wrapper'));
    }, $Native_included$22.$$arity = 1), nil) && 'included';
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_native$ques$23, $Kernel_Native$24, $Kernel_Array$27;

    
    
    Opal.def(self, '$native?', $Kernel_native$ques$23 = function(value) {
      var self = this;

      return value == null || !value.$$class;
    }, $Kernel_native$ques$23.$$arity = 1);
    
    Opal.def(self, '$Native', $Kernel_Native$24 = function $$Native(obj) {
      var $$25, $$26, $iter = $Kernel_Native$24.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Kernel_Native$24.$$p = null;
      if ($truthy(obj == null)) {
        return nil
      } else if ($truthy(self['$native?'](obj))) {
        return $$$($$($nesting, 'Native'), 'Object').$new(obj)
      } else if ($truthy(obj['$is_a?']($$($nesting, 'Array')))) {
        return $send(obj, 'map', [], ($$25 = function(o){var self = $$25.$$s == null ? this : $$25.$$s;

        
          
          if (o == null) {
            o = nil;
          };
          return self.$Native(o);}, $$25.$$s = self, $$25.$$arity = 1, $$25))
      } else if ($truthy(obj['$is_a?']($$($nesting, 'Proc')))) {
        return $send(self, 'proc', [], ($$26 = function($a){var self = $$26.$$s == null ? this : $$26.$$s, $iter = $$26.$$p, block = $iter || nil, $post_args, args;

        
          
          if ($iter) $$26.$$p = null;;
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return self.$Native($send(obj, 'call', Opal.to_a(args), block.$to_proc()));}, $$26.$$s = self, $$26.$$arity = -1, $$26))
      } else {
        return obj
      }
    }, $Kernel_Native$24.$$arity = 1);
    Opal.alias(self, "_Array", "Array");
    return (Opal.def(self, '$Array', $Kernel_Array$27 = function $$Array(object, $a) {
      var $iter = $Kernel_Array$27.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_Array$27.$$p = null;
      
      
      if ($iter) $Kernel_Array$27.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      if ($truthy(self['$native?'](object))) {
        return $send($$$($$($nesting, 'Native'), 'Array'), 'new', [object].concat(Opal.to_a(args)), block.$to_proc()).$to_a()};
      return self.$_Array(object);
    }, $Kernel_Array$27.$$arity = -2), nil) && 'Array';
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting), $Object_$eq_eq$28, $Object_has_key$ques$29, $Object_each$30, $Object_$$$31, $Object_$$$eq$32, $Object_merge$excl$33, $Object_respond_to$ques$34, $Object_respond_to_missing$ques$35, $Object_method_missing$36, $Object_nil$ques$37, $Object_is_a$ques$38, $Object_instance_of$ques$39, $Object_class$40, $Object_to_a$41, $Object_inspect$42;

    self.$$prototype["native"] = nil;
    
    self.$include($$$($$$('::', 'Native'), 'Wrapper'));
    
    Opal.def(self, '$==', $Object_$eq_eq$28 = function(other) {
      var self = this;

      return self["native"] === $$$('::', 'Native').$try_convert(other)
    }, $Object_$eq_eq$28.$$arity = 1);
    
    Opal.def(self, '$has_key?', $Object_has_key$ques$29 = function(name) {
      var self = this;

      return Opal.hasOwnProperty.call(self["native"], name)
    }, $Object_has_key$ques$29.$$arity = 1);
    Opal.alias(self, "key?", "has_key?");
    Opal.alias(self, "include?", "has_key?");
    Opal.alias(self, "member?", "has_key?");
    
    Opal.def(self, '$each', $Object_each$30 = function $$each($a) {
      var $post_args, args, $iter = $Object_each$30.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Object_each$30.$$p = null;
      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if (($yield !== nil)) {
        
        
        for (var key in self["native"]) {
          Opal.yieldX($yield, [key, self["native"][key]])
        }
      ;
        return self;
      } else {
        return $send(self, 'method_missing', ["each"].concat(Opal.to_a(args)))
      };
    }, $Object_each$30.$$arity = -1);
    
    Opal.def(self, '$[]', $Object_$$$31 = function(key) {
      var self = this;

      
      var prop = self["native"][key];

      if (prop instanceof Function) {
        return prop;
      }
      else {
        return $$$('::', 'Native').$call(self["native"], key)
      }
    
    }, $Object_$$$31.$$arity = 1);
    
    Opal.def(self, '$[]=', $Object_$$$eq$32 = function(key, value) {
      var self = this, native$ = nil;

      
      native$ = $$$('::', 'Native').$try_convert(value);
      if ($truthy(native$ === nil)) {
        return self["native"][key] = value
      } else {
        return self["native"][key] = native$
      };
    }, $Object_$$$eq$32.$$arity = 2);
    
    Opal.def(self, '$merge!', $Object_merge$excl$33 = function(other) {
      var self = this;

      
      
      other = $$$('::', 'Native').$convert(other);

      for (var prop in other) {
        self["native"][prop] = other[prop];
      }
    ;
      return self;
    }, $Object_merge$excl$33.$$arity = 1);
    
    Opal.def(self, '$respond_to?', $Object_respond_to$ques$34 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return $$$('::', 'Kernel').$instance_method("respond_to?").$bind(self).$call(name, include_all);
    }, $Object_respond_to$ques$34.$$arity = -2);
    
    Opal.def(self, '$respond_to_missing?', $Object_respond_to_missing$ques$35 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return Opal.hasOwnProperty.call(self["native"], name);
    }, $Object_respond_to_missing$ques$35.$$arity = -2);
    
    Opal.def(self, '$method_missing', $Object_method_missing$36 = function $$method_missing(mid, $a) {
      var $iter = $Object_method_missing$36.$$p, block = $iter || nil, $post_args, args, self = this, $writer = nil;

      if ($iter) $Object_method_missing$36.$$p = null;
      
      
      if ($iter) $Object_method_missing$36.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      if (mid.charAt(mid.length - 1) === '=') {
        return (($writer = [mid.$slice(0, $rb_minus(mid.$length(), 1)), args['$[]'](0)]), $send(self, '[]=', Opal.to_a($writer)), $writer[$rb_minus($writer["length"], 1)]);
      }
      else {
        return $send($$$('::', 'Native'), 'call', [self["native"], mid].concat(Opal.to_a(args)), block.$to_proc());
      }
    ;
    }, $Object_method_missing$36.$$arity = -2);
    
    Opal.def(self, '$nil?', $Object_nil$ques$37 = function() {
      var self = this;

      return false
    }, $Object_nil$ques$37.$$arity = 0);
    
    Opal.def(self, '$is_a?', $Object_is_a$ques$38 = function(klass) {
      var self = this;

      return Opal.is_a(self, klass);
    }, $Object_is_a$ques$38.$$arity = 1);
    Opal.alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$instance_of?', $Object_instance_of$ques$39 = function(klass) {
      var self = this;

      return self.$$class === klass;
    }, $Object_instance_of$ques$39.$$arity = 1);
    
    Opal.def(self, '$class', $Object_class$40 = function() {
      var self = this;

      return self.$$class;
    }, $Object_class$40.$$arity = 0);
    
    Opal.def(self, '$to_a', $Object_to_a$41 = function $$to_a(options) {
      var $iter = $Object_to_a$41.$$p, block = $iter || nil, self = this;

      if ($iter) $Object_to_a$41.$$p = null;
      
      
      if ($iter) $Object_to_a$41.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      return $send($$$($$$('::', 'Native'), 'Array'), 'new', [self["native"], options], block.$to_proc()).$to_a();
    }, $Object_to_a$41.$$arity = -1);
    return (Opal.def(self, '$inspect', $Object_inspect$42 = function $$inspect() {
      var self = this;

      return "" + "#<Native:" + (String(self["native"])) + ">"
    }, $Object_inspect$42.$$arity = 0), nil) && 'inspect';
  })($$($nesting, 'Native'), $$($nesting, 'BasicObject'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_initialize$43, $Array_each$44, $Array_$$$45, $Array_$$$eq$46, $Array_last$47, $Array_length$48, $Array_inspect$49;

    self.$$prototype.named = self.$$prototype["native"] = self.$$prototype.get = self.$$prototype.block = self.$$prototype.set = self.$$prototype.length = nil;
    
    self.$include($$$($$($nesting, 'Native'), 'Wrapper'));
    self.$include($$($nesting, 'Enumerable'));
    
    Opal.def(self, '$initialize', $Array_initialize$43 = function $$initialize(native$, options) {
      var $iter = $Array_initialize$43.$$p, block = $iter || nil, self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      if ($iter) $Array_initialize$43.$$p = null;
      
      
      if ($iter) $Array_initialize$43.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $Array_initialize$43, false, true), 'initialize', [native$], null);
      self.get = (function() {if ($truthy(($ret_or_1 = options['$[]']("get")))) {
        return $ret_or_1
      } else {
        return options['$[]']("access")
      }; return nil; })();
      self.named = options['$[]']("named");
      self.set = (function() {if ($truthy(($ret_or_2 = options['$[]']("set")))) {
        return $ret_or_2
      } else {
        return options['$[]']("access")
      }; return nil; })();
      self.length = (function() {if ($truthy(($ret_or_3 = options['$[]']("length")))) {
        return $ret_or_3
      } else {
        return "length"
      }; return nil; })();
      self.block = block;
      if ($truthy(self.$length() == null)) {
        return self.$raise($$($nesting, 'ArgumentError'), "no length found on the array-like object")
      } else {
        return nil
      };
    }, $Array_initialize$43.$$arity = -2);
    
    Opal.def(self, '$each', $Array_each$44 = function $$each() {
      var $iter = $Array_each$44.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_each$44.$$p = null;
      
      
      if ($iter) $Array_each$44.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("each")
      };
      
      for (var i = 0, length = self.$length(); i < length; i++) {
        Opal.yield1(block, self['$[]'](i));
      }
    ;
      return self;
    }, $Array_each$44.$$arity = 0);
    
    Opal.def(self, '$[]', $Array_$$$45 = function(index) {
      var self = this, result = nil, $case = nil;

      
      result = (function() {$case = index;
      if ($$($nesting, 'String')['$===']($case) || $$($nesting, 'Symbol')['$===']($case)) {if ($truthy(self.named)) {
        return self["native"][self.named](index)
      } else {
        return self["native"][index]
      }}
      else if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy(self.get)) {
        return self["native"][self.get](index)
      } else {
        return self["native"][index]
      }}
      else { return nil }})();
      if ($truthy(result)) {
        if ($truthy(self.block)) {
          return self.block.$call(result)
        } else {
          return self.$Native(result)
        }
      } else {
        return nil
      };
    }, $Array_$$$45.$$arity = 1);
    
    Opal.def(self, '$[]=', $Array_$$$eq$46 = function(index, value) {
      var self = this;

      if ($truthy(self.set)) {
        return self["native"][self.set](index, $$($nesting, 'Native').$convert(value))
      } else {
        return self["native"][index] = $$($nesting, 'Native').$convert(value)
      }
    }, $Array_$$$eq$46.$$arity = 2);
    
    Opal.def(self, '$last', $Array_last$47 = function $$last(count) {
      var $a, self = this, index = nil, result = nil;

      
      
      if (count == null) {
        count = nil;
      };
      if ($truthy(count)) {
        
        index = $rb_minus(self.$length(), 1);
        result = [];
        while ($truthy($rb_ge(index, 0))) {
          
          result['$<<'](self['$[]'](index));
          index = $rb_minus(index, 1);
        };
        return result;
      } else {
        return self['$[]']($rb_minus(self.$length(), 1))
      };
    }, $Array_last$47.$$arity = -1);
    
    Opal.def(self, '$length', $Array_length$48 = function $$length() {
      var self = this;

      return self["native"][self.length]
    }, $Array_length$48.$$arity = 0);
    Opal.alias(self, "to_ary", "to_a");
    return (Opal.def(self, '$inspect', $Array_inspect$49 = function $$inspect() {
      var self = this;

      return self.$to_a().$inspect()
    }, $Array_inspect$49.$$arity = 0), nil) && 'inspect';
  })($$($nesting, 'Native'), null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_to_n$50;

    return (Opal.def(self, '$to_n', $Numeric_to_n$50 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $Numeric_to_n$50.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $Proc_to_n$51;

    return (Opal.def(self, '$to_n', $Proc_to_n$51 = function $$to_n() {
      var self = this;

      return self
    }, $Proc_to_n$51.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_n$52;

    return (Opal.def(self, '$to_n', $String_to_n$52 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $String_to_n$52.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $Regexp_to_n$53;

    return (Opal.def(self, '$to_n', $Regexp_to_n$53 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $Regexp_to_n$53.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $MatchData_to_n$54;

    self.$$prototype.matches = nil;
    return (Opal.def(self, '$to_n', $MatchData_to_n$54 = function $$to_n() {
      var self = this;

      return self.matches
    }, $MatchData_to_n$54.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $Struct_to_n$55;

    return (Opal.def(self, '$to_n', $Struct_to_n$55 = function $$to_n() {
      var $$56, self = this, result = nil;

      
      result = {};
      $send(self, 'each_pair', [], ($$56 = function(name, value){var self = $$56.$$s == null ? this : $$56.$$s;

      
        
        if (name == null) {
          name = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        return result[name] = $$($nesting, 'Native').$try_convert(value, value);}, $$56.$$s = self, $$56.$$arity = 2, $$56));
      return result;
    }, $Struct_to_n$55.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_to_n$57;

    return (Opal.def(self, '$to_n', $Array_to_n$57 = function $$to_n() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var obj = self[i];

        result.push($$($nesting, 'Native').$try_convert(obj, obj));
      }

      return result;
    
    }, $Array_to_n$57.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean_to_n$58;

    return (Opal.def(self, '$to_n', $Boolean_to_n$58 = function $$to_n() {
      var self = this;

      return self.valueOf();
    }, $Boolean_to_n$58.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_to_n$59;

    return (Opal.def(self, '$to_n', $Time_to_n$59 = function $$to_n() {
      var self = this;

      return self
    }, $Time_to_n$59.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_to_n$60;

    return (Opal.def(self, '$to_n', $NilClass_to_n$60 = function $$to_n() {
      var self = this;

      return null;
    }, $NilClass_to_n$60.$$arity = 0), nil) && 'to_n'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_initialize$61, $Hash_to_n$62;

    
    Opal.alias(self, "_initialize", "initialize");
    
    Opal.def(self, '$initialize', $Hash_initialize$61 = function $$initialize(defaults) {
      var $iter = $Hash_initialize$61.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_initialize$61.$$p = null;
      
      
      if ($iter) $Hash_initialize$61.$$p = null;;
      ;
      
      if (defaults != null &&
           (defaults.constructor === undefined ||
             defaults.constructor === Object)) {
        var smap = self.$$smap,
            keys = self.$$keys,
            key, value;

        for (key in defaults) {
          value = defaults[key];

          if (value &&
               (value.constructor === undefined ||
                 value.constructor === Object)) {
            smap[key] = $$($nesting, 'Hash').$new(value);
          } else if (value && value.$$is_array) {
            value = value.map(function(item) {
              if (item &&
                   (item.constructor === undefined ||
                     item.constructor === Object)) {
                return $$($nesting, 'Hash').$new(item);
              }

              return self.$Native(item);
            });
            smap[key] = value
          } else {
            smap[key] = self.$Native(value);
          }

          keys.push(key);
        }

        return self;
      }

      return $send(self, '_initialize', [defaults], block.$to_proc());
    ;
    }, $Hash_initialize$61.$$arity = -1);
    return (Opal.def(self, '$to_n', $Hash_to_n$62 = function $$to_n() {
      var self = this;

      
      var result = {},
          keys = self.$$keys,
          smap = self.$$smap,
          key, value;

      for (var i = 0, length = keys.length; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = smap[key];
        } else {
          key = key.key;
          value = key.value;
        }

        result[key] = $$($nesting, 'Native').$try_convert(value, value);
      }

      return result;
    
    }, $Hash_to_n$62.$$arity = 0), nil) && 'to_n';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_native_module$63;

    return (Opal.def(self, '$native_module', $Module_native_module$63 = function $$native_module() {
      var self = this;

      return Opal.global[self.$name()] = self
    }, $Module_native_module$63.$$arity = 0), nil) && 'native_module'
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $Class_native_alias$64, $Class_native_class$65;

    
    
    Opal.def(self, '$native_alias', $Class_native_alias$64 = function $$native_alias(new_jsid, existing_mid) {
      var self = this;

      
      var aliased = self.prototype['$' + existing_mid];
      if (!aliased) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (existing_mid) + "' for class `" + (self.$inspect()) + "'", existing_mid));
      }
      self.prototype[new_jsid] = aliased;
    
    }, $Class_native_alias$64.$$arity = 2);
    return (Opal.def(self, '$native_class', $Class_native_class$65 = function $$native_class() {
      var self = this;

      
      self.$native_module();
      return self["new"] = self.$new;;
    }, $Class_native_class$65.$$arity = 0), nil) && 'native_class';
  })($nesting[0], null, $nesting);
  return ($gvars.$ = ($gvars.global = self.$Native(Opal.global)));
};

/* Generated by Opal 1.2.0 */
(function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var $$1, $$2, $update$3, $$6, $$7, $$8, $$9, $$10, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $range = Opal.range, $send = Opal.send, $hash2 = Opal.hash2, $gvars = Opal.gvars, $truthy = Opal.truthy, death_year = nil, personality = nil, alignment = nil, face = nil, colour = nil, occupation = nil, all_selections = nil, total_selections_count = nil, stats_table = nil, $writer = nil, slider_container = nil, the_slider = nil, minus_btn = nil, plus_btn = nil, btn = nil;
  if ($gvars.$ == null) $gvars.$ = nil;

  Opal.add_stubs(['$require', '$to_a', '$map', '$reduce', '$values', '$length', '$-', '$each', '$keys', '$to_i', '$/', '$[]', '$divmod', '$[]=', '$innerHTML=', '$getElementById', '$backgroundColor=', '$style', '$backgroundImage=', '$join', '$capitalize', '$split', '$addEventListener', '$update', '$value', '$>', '$value=', '$<', '$+', '$each_key', '$innerHTML', '$p']);
  
  self.$require("ostruct");
  self.$require("native");
  death_year = $range(1800, 2020, false).$to_a();
  personality = ["Spirited", "Haunting", "Transparent"];
  alignment = ["Lawful good", "Neutral good", "Chaotic good", "Lawful neutral", "True neutral", "Chaotic neutral", "Lawful evil", "Neutral evil", "Chaotic evil"];
  face = $send($range(1, 7, false), 'map', [], ($$1 = function(i){var self = $$1.$$s == null ? this : $$1.$$s;

  
    
    if (i == null) {
      i = nil;
    };
    return "" + "#" + (i);}, $$1.$$s = self, $$1.$$arity = 1, $$1));
  colour = ["#FFC996", "#FF8474", "#9F5F80", "#583D72"];
  occupation = ["Unemployed", "Student", "Librarian", "Musician", "Gamer", "Customer Service", "McDonald's"];
  all_selections = $hash2(["death_year", "personality", "alignment", "face", "colour", "occupation"], {"death_year": death_year, "personality": personality, "alignment": alignment, "face": face, "colour": colour, "occupation": occupation});
  total_selections_count = $send(all_selections.$values(), 'map', [], ($$2 = function(x){var self = $$2.$$s == null ? this : $$2.$$s;

  
    
    if (x == null) {
      x = nil;
    };
    return x.$length();}, $$2.$$s = self, $$2.$$arity = 1, $$2)).$reduce("*");
  
  Opal.def(self, '$update', $update$3 = function $$update(num, total_selections_count, all_selections) {
    var $$4, $$5, self = this, result = nil, i = nil, k = nil, q = nil, r = nil, $writer = nil;
    if ($gvars.$ == null) $gvars.$ = nil;

    
    num = $rb_minus(num, 1);
    result = $hash2([], {});
    i = total_selections_count;
    
    ;
    ;
    ;
    ;
    ;
    $send(all_selections.$keys(), 'each', [], ($$4 = function($for_tmp1){var self = $$4.$$s == null ? this : $$4.$$s, $a, $b, $writer = nil;

    
      
      if ($for_tmp1 == null) {
        $for_tmp1 = nil;
      };
      k = $for_tmp1;
      i = $rb_divide(i, all_selections['$[]'](k).$length()).$to_i();
      $b = num.$divmod(i), $a = Opal.to_ary($b), (q = ($a[0] == null ? nil : $a[0])), (r = ($a[1] == null ? nil : $a[1])), $b;
      num = r;
      
      $writer = [k, all_selections['$[]'](k)['$[]'](q)];
      $send(result, '[]=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];;}, $$4.$$s = self, $$4.$$arity = 1, $$4));;
    $send(result, 'each', [], ($$5 = function(k, v){var self = $$5.$$s == null ? this : $$5.$$s, $writer = nil;
      if ($gvars.$ == null) $gvars.$ = nil;

    
      
      if (k == null) {
        k = nil;
      };
      
      if (v == null) {
        v = nil;
      };
      $writer = ["" + (v)];
      $send($gvars.$['$[]']("document").$getElementById("" + (k) + "Col"), 'innerHTML=', Opal.to_a($writer));
      return $writer[$rb_minus($writer["length"], 1)];}, $$5.$$s = self, $$5.$$arity = 2, $$5));
    
    $writer = [result['$[]']("colour")];
    $send($gvars.$['$[]']("document").$getElementById("characterContainer").$style(), 'backgroundColor=', Opal.to_a($writer));
    $writer[$rb_minus($writer["length"], 1)];;
    
    $writer = ["" + "url('img/ghost" + (result['$[]']("face")['$[]']($range(1, -1, false))) + ".png')"];
    $send($gvars.$['$[]']("document").$getElementById("characterContainer").$style(), 'backgroundImage=', Opal.to_a($writer));
    return $writer[$rb_minus($writer["length"], 1)];;
  }, $update$3.$$arity = 3);
  stats_table = $gvars.$['$[]']("document").$getElementById("statsTable");
  
  $writer = [$send(all_selections.$keys(), 'map', [], ($$6 = function(k){var self = $$6.$$s == null ? this : $$6.$$s;

  
    
    if (k == null) {
      k = nil;
    };
    return "" + "<tr><td>" + (k.$split("_").$join(" ").$capitalize()) + "</td><td class='statsResult' id='" + (k) + "Col'></td></tr>";}, $$6.$$s = self, $$6.$$arity = 1, $$6)).$join("")];
  $send(stats_table, 'innerHTML=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  slider_container = $gvars.$['$[]']("document").$getElementById("sliderContainer");
  
  $writer = ["" + "\n" + "  <button id='minusBtn' class='buttonClass'>-</button>\n" + "  <input type='range' min='1' max='" + (total_selections_count) + "' value='0' class='sliderClass' id='slider'>\n" + "  <button id='plusBtn' class='buttonClass'>+</button>\n"];
  $send(slider_container, 'innerHTML=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  the_slider = $gvars.$['$[]']("document").$getElementById("slider");
  $send(the_slider, 'addEventListener', ["input"], ($$7 = function(event){var self = $$7.$$s == null ? this : $$7.$$s;

  
    
    if (event == null) {
      event = nil;
    };
    return self.$update(the_slider.$value().$to_i(), total_selections_count, all_selections);}, $$7.$$s = self, $$7.$$arity = 1, $$7));
  minus_btn = $gvars.$['$[]']("document").$getElementById("minusBtn");
  $send(minus_btn, 'addEventListener', ["click"], ($$8 = function(event){var self = $$8.$$s == null ? this : $$8.$$s, slider_value = nil;
    if ($gvars.$ == null) $gvars.$ = nil;

  
    
    if (event == null) {
      event = nil;
    };
    slider_value = $gvars.$['$[]']("document").$getElementById("slider").$value().$to_i();
    if ($truthy($rb_gt(slider_value, 1))) {
      
      
      $writer = [$rb_minus(slider_value, 1)];
      $send($gvars.$['$[]']("document").$getElementById("slider"), 'value=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return self.$update($rb_minus(slider_value, 1), total_selections_count, all_selections);
    } else {
      return nil
    };}, $$8.$$s = self, $$8.$$arity = 1, $$8));
  plus_btn = $gvars.$['$[]']("document").$getElementById("plusBtn");
  $send(plus_btn, 'addEventListener', ["click"], ($$9 = function(event){var self = $$9.$$s == null ? this : $$9.$$s, slider_value = nil;
    if ($gvars.$ == null) $gvars.$ = nil;

  
    
    if (event == null) {
      event = nil;
    };
    slider_value = $gvars.$['$[]']("document").$getElementById("slider").$value().$to_i();
    if ($truthy($rb_lt(slider_value, total_selections_count))) {
      
      
      $writer = [$rb_plus(slider_value, 1)];
      $send($gvars.$['$[]']("document").$getElementById("slider"), 'value=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return self.$update($rb_plus(slider_value, 1), total_selections_count, all_selections);
    } else {
      return nil
    };}, $$9.$$s = self, $$9.$$arity = 1, $$9));
  btn = $gvars.$['$[]']("document").$getElementById("createBtn");
  $send(btn, 'addEventListener', ["click"], ($$10 = function(event){var self = $$10.$$s == null ? this : $$10.$$s, $$11, result = nil, txt = nil;
    if ($gvars.$ == null) $gvars.$ = nil;

  
    
    if (event == null) {
      event = nil;
    };
    result = $send(all_selections.$each_key(), 'map', [], ($$11 = function(k){var self = $$11.$$s == null ? this : $$11.$$s, v = nil;
      if ($gvars.$ == null) $gvars.$ = nil;

    
      
      if (k == null) {
        k = nil;
      };
      v = $gvars.$['$[]']("document").$getElementById("" + (k) + "Col").$innerHTML();
      return "" + (k.$split("_").$join(" ").$capitalize()) + ": " + (v);}, $$11.$$s = self, $$11.$$arity = 1, $$11)).$to_a().$join("; ");
    txt = $gvars.$['$[]']("document").$getElementById("createdContainer").$innerHTML();
    
    $writer = ["" + "Created: " + (result) + "<br />" + (txt)];
    $send($gvars.$['$[]']("document").$getElementById("createdContainer"), 'innerHTML=', Opal.to_a($writer));
    return $writer[$rb_minus($writer["length"], 1)];;}, $$10.$$s = self, $$10.$$arity = 1, $$10));
  self.$update(1, total_selections_count, all_selections);
  return self.$p("Successfully initialized");
})(Opal);

/* Generated by Opal 1.2.0 */
(function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$exit']);
  return $$($nesting, 'Kernel').$exit()
})(Opal);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGdsb2JhbF9vYmplY3QpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gQG5vdGVcbiAgLy8gICBBIGZldyBjb252ZW50aW9ucyBmb3IgdGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmaWxlOlxuICAvLyAgIDEuIEFsd2F5cyB1c2UgXCIvL1wiIChpbiBjb250cmFzdCB3aXRoIFwiLyoqL1wiKVxuICAvLyAgIDIuIFRoZSBzeW50YXggdXNlZCBpcyBZYXJkb2MgKHlhcmRvYy5vcmcpLCB3aGljaCBpcyBpbnRlbmRlZCBmb3IgUnVieSAoc2UgYmVsb3cpXG4gIC8vICAgMy4gYEBwYXJhbWAgYW5kIGBAcmV0dXJuYCB0eXBlcyBzaG91bGQgYmUgcHJlY2VkZWQgYnkgYEpTLmAgd2hlbiByZWZlcnJpbmcgdG9cbiAgLy8gICAgICBKYXZhU2NyaXB0IGNvbnN0cnVjdG9ycyAoZS5nLiBgSlMuRnVuY3Rpb25gKSBvdGhlcndpc2UgUnVieSBpcyBhc3N1bWVkLlxuICAvLyAgIDQuIGBuaWxgIGFuZCBgbnVsbGAgYmVpbmcgdW5hbWJpZ3VvdXMgcmVmZXIgdG8gdGhlIHJlc3BlY3RpdmVcbiAgLy8gICAgICBvYmplY3RzL3ZhbHVlcyBpbiBSdWJ5IGFuZCBKYXZhU2NyaXB0XG4gIC8vICAgNS4gVGhpcyBpcyBzdGlsbCBXSVAgOikgc28gcGxlYXNlIGdpdmUgZmVlZGJhY2sgYW5kIHN1Z2dlc3Rpb25zIG9uIGhvd1xuICAvLyAgICAgIHRvIGltcHJvdmUgb3IgZm9yIGFsdGVybmF0aXZlIHNvbHV0aW9uc1xuICAvL1xuICAvLyAgIFRoZSB3YXkgdGhlIGNvZGUgaXMgZGlnZXN0ZWQgYmVmb3JlIGdvaW5nIHRocm91Z2ggWWFyZG9jIGlzIGEgc2VjcmV0IGtlcHRcbiAgLy8gICBpbiB0aGUgZG9jcyByZXBvIChodHRwczovL2dpdGh1Yi5jb20vb3BhbC9kb2NzL3RyZWUvbWFzdGVyKS5cblxuICB2YXIgY29uc29sZTtcblxuICAvLyBEZXRlY3QgdGhlIGdsb2JhbCBvYmplY3RcbiAgaWYgKHR5cGVvZihnbG9iYWxUaGlzKSAhPT0gJ3VuZGVmaW5lZCcpIHsgZ2xvYmFsX29iamVjdCA9IGdsb2JhbFRoaXM7IH1cbiAgZWxzZSBpZiAodHlwZW9mKGdsb2JhbCkgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSBnbG9iYWw7IH1cbiAgZWxzZSBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSB3aW5kb3c7IH1cblxuICAvLyBTZXR1cCBhIGR1bW15IGNvbnNvbGUgb2JqZWN0IGlmIG1pc3NpbmdcbiAgaWYgKHR5cGVvZihnbG9iYWxfb2JqZWN0LmNvbnNvbGUpID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnNvbGUgPSBnbG9iYWxfb2JqZWN0LmNvbnNvbGU7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsX29iamVjdC5jb25zb2xlID09IG51bGwpIHtcbiAgICBjb25zb2xlID0gZ2xvYmFsX29iamVjdC5jb25zb2xlID0ge307XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZSA9IHt9O1xuICB9XG5cbiAgaWYgKCEoJ2xvZycgaW4gY29uc29sZSkpIHsgY29uc29sZS5sb2cgPSBmdW5jdGlvbiAoKSB7fTsgfVxuICBpZiAoISgnd2FybicgaW4gY29uc29sZSkpIHsgY29uc29sZS53YXJuID0gY29uc29sZS5sb2c7IH1cblxuICBpZiAodHlwZW9mKGdsb2JhbF9vYmplY3QuT3BhbCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS53YXJuKCdPcGFsIGFscmVhZHkgbG9hZGVkLiBMb2FkaW5nIHR3aWNlIGNhbiBjYXVzZSB0cm91YmxlcywgcGxlYXNlIGZpeCB5b3VyIHNldHVwLicpO1xuICAgIHJldHVybiBnbG9iYWxfb2JqZWN0Lk9wYWw7XG4gIH1cblxuICB2YXIgbmlsO1xuXG4gIC8vIFRoZSBhY3R1YWwgY2xhc3MgZm9yIEJhc2ljT2JqZWN0XG4gIHZhciBCYXNpY09iamVjdDtcblxuICAvLyBUaGUgYWN0dWFsIE9iamVjdCBjbGFzcy5cbiAgLy8gVGhlIGxlYWRpbmcgdW5kZXJzY29yZSBpcyB0byBhdm9pZCBjb25mdXNpb24gd2l0aCB3aW5kb3cuT2JqZWN0KClcbiAgdmFyIF9PYmplY3Q7XG5cbiAgLy8gVGhlIGFjdHVhbCBNb2R1bGUgY2xhc3NcbiAgdmFyIE1vZHVsZTtcblxuICAvLyBUaGUgYWN0dWFsIENsYXNzIGNsYXNzXG4gIHZhciBDbGFzcztcblxuICAvLyBUaGUgT3BhbCBvYmplY3QgdGhhdCBpcyBleHBvc2VkIGdsb2JhbGx5XG4gIHZhciBPcGFsID0gZ2xvYmFsX29iamVjdC5PcGFsID0ge307XG5cbiAgLy8gVGhpcyBpcyBhIHVzZWZ1bCByZWZlcmVuY2UgdG8gZ2xvYmFsIG9iamVjdCBpbnNpZGUgcnVieSBmaWxlc1xuICBPcGFsLmdsb2JhbCA9IGdsb2JhbF9vYmplY3Q7XG4gIGdsb2JhbF9vYmplY3QuT3BhbCA9IE9wYWw7XG5cbiAgLy8gQ29uZmlndXJlIHJ1bnRpbWUgYmVoYXZpb3Igd2l0aCByZWdhcmRzIHRvIHJlcXVpcmUgYW5kIHVuc3VwcG9ydGVkIGZlYXR1cmVzXG4gIE9wYWwuY29uZmlnID0ge1xuICAgIG1pc3NpbmdfcmVxdWlyZV9zZXZlcml0eTogJ2Vycm9yJywgICAgICAgIC8vIGVycm9yLCB3YXJuaW5nLCBpZ25vcmVcbiAgICB1bnN1cHBvcnRlZF9mZWF0dXJlc19zZXZlcml0eTogJ3dhcm5pbmcnLCAvLyBlcnJvciwgd2FybmluZywgaWdub3JlXG4gICAgZW5hYmxlX3N0YWNrX3RyYWNlOiB0cnVlICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSwgZmFsc2VcbiAgfTtcblxuICAvLyBNaW5pZnkgY29tbW9uIGZ1bmN0aW9uIGNhbGxzXG4gIHZhciAkaGFzX293biAgID0gT2JqZWN0Lmhhc093blByb3BlcnR5O1xuICB2YXIgJGJpbmQgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuICB2YXIgJHNldF9wcm90byA9IE9iamVjdC5zZXRQcm90b3R5cGVPZjtcbiAgdmFyICRzbGljZSAgICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIHZhciAkc3BsaWNlICAgID0gQXJyYXkucHJvdG90eXBlLnNwbGljZTtcblxuICAvLyBOaWwgb2JqZWN0IGlkIGlzIGFsd2F5cyA0XG4gIHZhciBuaWxfaWQgPSA0O1xuXG4gIC8vIEdlbmVyYXRlcyBldmVuIHNlcXVlbnRpYWwgbnVtYmVycyBncmVhdGVyIHRoYW4gNFxuICAvLyAobmlsX2lkKSB0byBzZXJ2ZSBhcyB1bmlxdWUgaWRzIGZvciBydWJ5IG9iamVjdHNcbiAgdmFyIHVuaXF1ZV9pZCA9IG5pbF9pZDtcblxuICAvLyBSZXR1cm4gbmV4dCB1bmlxdWUgaWRcbiAgT3BhbC51aWQgPSBmdW5jdGlvbigpIHtcbiAgICB1bmlxdWVfaWQgKz0gMjtcbiAgICByZXR1cm4gdW5pcXVlX2lkO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIG9yIGFzc2lnbiB0aGUgaWQgb2YgYW4gb2JqZWN0XG4gIE9wYWwuaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLiQkaXNfbnVtYmVyKSByZXR1cm4gKG9iaiAqIDIpKzE7XG4gICAgaWYgKG9iai4kJGlkICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBvYmouJCRpZDtcbiAgICB9XG4gICAgJGRlZmluZVByb3BlcnR5KG9iaiwgJyQkaWQnLCBPcGFsLnVpZCgpKTtcbiAgICByZXR1cm4gb2JqLiQkaWQ7XG4gIH07XG5cbiAgLy8gR2xvYmFscyB0YWJsZVxuICBPcGFsLmd2YXJzID0ge307XG5cbiAgLy8gRXhpdCBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgcmVwbGFjZWQgYnkgcGxhdGZvcm0gc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cbiAgLy8gKFNlZSBub2RlanMgYW5kIGNocm9tZSBmb3IgZXhhbXBsZXMpXG4gIE9wYWwuZXhpdCA9IGZ1bmN0aW9uKHN0YXR1cykgeyBpZiAoT3BhbC5ndmFycy5ERUJVRykgY29uc29sZS5sb2coJ0V4aXRlZCB3aXRoIHN0YXR1cyAnK3N0YXR1cyk7IH07XG5cbiAgLy8ga2VlcHMgdHJhY2sgb2YgZXhjZXB0aW9ucyBmb3IgJCFcbiAgT3BhbC5leGNlcHRpb25zID0gW107XG5cbiAgLy8gQHByaXZhdGVcbiAgLy8gUG9wcyBhbiBleGNlcHRpb24gZnJvbSB0aGUgc3RhY2sgYW5kIHVwZGF0ZXMgYCQhYC5cbiAgT3BhbC5wb3BfZXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgT3BhbC5ndmFyc1tcIiFcIl0gPSBPcGFsLmV4Y2VwdGlvbnMucG9wKCkgfHwgbmlsO1xuICB9O1xuXG4gIC8vIEluc3BlY3QgYW55IGtpbmQgb2Ygb2JqZWN0LCBpbmNsdWRpbmcgbm9uIFJ1Ynkgb25lc1xuICBPcGFsLmluc3BlY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9iai4kJGNsYXNzKSB7XG4gICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIG9iai4kaW5zcGVjdCgpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBpbml0aWFsVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mKG9iamVjdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3I6XG4gICAgICAvLyAgIHMgPSBcInN0cmluZ1wiXG4gICAgICAvLyAgIGRlZiBzLm07IGVuZFxuICAgICAgLy8gU3RyaW5nIGNsYXNzIGlzIHRoZSBvbmx5IGNsYXNzIHRoYXQ6XG4gICAgICAvLyArIGNvbXBpbGVzIHRvIEpTIHByaW1pdGl2ZVxuICAgICAgLy8gKyBhbGxvd3MgbWV0aG9kIGRlZmluaXRpb24gZGlyZWN0bHkgb24gaW5zdGFuY2VzXG4gICAgICAvLyBudW1iZXJzLCB0cnVlLCBmYWxzZSBhbmQgbnVsbCBkbyBub3Qgc3VwcG9ydCBpdC5cbiAgICAgIG9iamVjdFtuYW1lXSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICB2YWx1ZTogaW5pdGlhbFZhbHVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgT3BhbC5kZWZpbmVQcm9wZXJ0eSA9ICRkZWZpbmVQcm9wZXJ0eTtcblxuICBPcGFsLnNsaWNlID0gJHNsaWNlO1xuXG5cbiAgLy8gSGVscGVyc1xuICAvLyAtLS0tLVxuXG4gIE9wYWwudHJ1dGh5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuICh2YWwgIT09IG5pbCAmJiB2YWwgIT0gbnVsbCAmJiAoIXZhbC4kJGlzX2Jvb2xlYW4gfHwgdmFsID09IHRydWUpKTtcbiAgfTtcblxuICBPcGFsLmZhbHN5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuICh2YWwgPT09IG5pbCB8fCB2YWwgPT0gbnVsbCB8fCAodmFsLiQkaXNfYm9vbGVhbiAmJiB2YWwgPT0gZmFsc2UpKVxuICB9O1xuXG4gIE9wYWwudHlwZV9lcnJvciA9IGZ1bmN0aW9uKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0LiQkY2xhc3M7XG5cbiAgICBpZiAoY29lcmNlZCAmJiBtZXRob2QpIHtcbiAgICAgIGNvZXJjZWQgPSBjb2VyY2VkLiQkY2xhc3M7XG4gICAgICByZXR1cm4gT3BhbC5UeXBlRXJyb3IuJG5ldyhcbiAgICAgICAgXCJjYW4ndCBjb252ZXJ0IFwiICsgb2JqZWN0ICsgXCIgaW50byBcIiArIHR5cGUgK1xuICAgICAgICBcIiAoXCIgKyBvYmplY3QgKyBcIiNcIiArIG1ldGhvZCArIFwiIGdpdmVzIFwiICsgY29lcmNlZCArIFwiKVwiXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLlR5cGVFcnJvci4kbmV3KFxuICAgICAgICBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgXCIgKyBvYmplY3QgKyBcIiBpbnRvIFwiICsgdHlwZVxuICAgICAgKVxuICAgIH1cbiAgfTtcblxuICBPcGFsLmNvZXJjZV90byA9IGZ1bmN0aW9uKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBhcmdzKSB7XG4gICAgaWYgKHR5cGVbJyQ9PT0nXShvYmplY3QpKSByZXR1cm4gb2JqZWN0O1xuXG4gICAgaWYgKCFvYmplY3RbJyRyZXNwb25kX3RvPyddKG1ldGhvZCkpIHtcbiAgICAgIHRocm93IE9wYWwudHlwZV9lcnJvcihvYmplY3QsIHR5cGUpO1xuICAgIH1cblxuICAgIGlmIChhcmdzID09IG51bGwpIGFyZ3MgPSBbXTtcbiAgICByZXR1cm4gT3BhbC5zZW5kKG9iamVjdCwgbWV0aG9kLCBhcmdzKTtcbiAgfVxuXG4gIE9wYWwucmVzcG9uZF90byA9IGZ1bmN0aW9uKG9iaiwganNpZCwgaW5jbHVkZV9hbGwpIHtcbiAgICBpZiAob2JqID09IG51bGwgfHwgIW9iai4kJGNsYXNzKSByZXR1cm4gZmFsc2U7XG4gICAgaW5jbHVkZV9hbGwgPSAhIWluY2x1ZGVfYWxsO1xuICAgIHZhciBib2R5ID0gb2JqW2pzaWRdO1xuXG4gICAgaWYgKG9ialsnJHJlc3BvbmRfdG8/J10uJCRwcmlzdGluZSkge1xuICAgICAgaWYgKG9ialsnJHJlc3BvbmRfdG9fbWlzc2luZz8nXS4kJHByaXN0aW5lKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5zZW5kKG9iaiwgb2JqWyckcmVzcG9uZF90b19taXNzaW5nPyddLCBbanNpZC5zdWJzdHIoMSksIGluY2x1ZGVfYWxsXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLnNlbmQob2JqLCBvYmpbJyRyZXNwb25kX3RvPyddLCBbanNpZC5zdWJzdHIoMSksIGluY2x1ZGVfYWxsXSk7XG4gICAgfVxuICB9XG5cblxuICAvLyBDb25zdGFudHNcbiAgLy8gLS0tLS0tLS0tXG4gIC8vXG4gIC8vIEZvciBmdXR1cmUgcmVmZXJlbmNlOlxuICAvLyAtIFRoZSBSYWlscyBhdXRvbG9hZGluZyBndWlkZSAoaHR0cDovL2d1aWRlcy5ydWJ5b25yYWlscy5vcmcvdjUuMC9hdXRvbG9hZGluZ19hbmRfcmVsb2FkaW5nX2NvbnN0YW50cy5odG1sKVxuICAvLyAtIEBDb25yYWRJcndpbidzIDIwMTIgcG9zdCBvbiDigJxFdmVyeXRoaW5nIHlvdSBldmVyIHdhbnRlZCB0byBrbm93IGFib3V0IGNvbnN0YW50IGxvb2t1cCBpbiBSdWJ54oCdIChodHRwOi8vY2lydy5pbi9ibG9nL2NvbnN0YW50LWxvb2t1cC5odG1sKVxuICAvL1xuICAvLyBMZWdlbmQgb2YgTVJJIGNvbmNlcHRzL25hbWVzOlxuICAvLyAtIGNvbnN0YW50IHJlZmVyZW5jZSAoY3JlZik6IHRoZSBtb2R1bGUvY2xhc3MgdGhhdCBhY3RzIGFzIGEgbmFtZXNwYWNlXG4gIC8vIC0gbmVzdGluZzogdGhlIG5hbWVzcGFjZXMgd3JhcHBpbmcgdGhlIGN1cnJlbnQgc2NvcGUsIGUuZy4gbmVzdGluZyBpbnNpZGVcbiAgLy8gICAgICAgICAgICBgbW9kdWxlIEE7IG1vZHVsZSBCOjpDOyBlbmQ7IGVuZGAgaXMgYFtCOjpDLCBBXWBcblxuICAvLyBHZXQgdGhlIGNvbnN0YW50IGluIHRoZSBzY29wZSBvZiB0aGUgY3VycmVudCBjcmVmXG4gIGZ1bmN0aW9uIGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoY3JlZikgcmV0dXJuIGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIG5lc3RpbmcgYXJyYXkgbG9va2luZyBmb3IgdGhlIGNvbnN0YW50XG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9uZXN0aW5nKG5lc3RpbmcsIG5hbWUpIHtcbiAgICB2YXIgaSwgaWksIGNvbnN0YW50O1xuXG4gICAgaWYgKG5lc3RpbmcubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAvLyBJZiB0aGUgbmVzdGluZyBpcyBub3QgZW1wdHkgdGhlIGNvbnN0YW50IGlzIGxvb2tlZCB1cCBpbiBpdHMgZWxlbWVudHNcbiAgICAvLyBhbmQgaW4gb3JkZXIuIFRoZSBhbmNlc3RvcnMgb2YgdGhvc2UgZWxlbWVudHMgYXJlIGlnbm9yZWQuXG4gICAgZm9yIChpID0gMCwgaWkgPSBuZXN0aW5nLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0YW50ID0gbmVzdGluZ1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgaWYgKGNvbnN0YW50ICE9IG51bGwpIHJldHVybiBjb25zdGFudDtcbiAgICB9XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSBhbmNlc3RvcnMgY2hhaW4gbG9va2luZyBmb3IgdGhlIGNvbnN0YW50XG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoY3JlZiwgbmFtZSkge1xuICAgIHZhciBpLCBpaSwgYW5jZXN0b3JzO1xuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMoY3JlZik7XG5cbiAgICBmb3IgKGkgPSAwLCBpaSA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBpZiAoYW5jZXN0b3JzW2ldLiQkY29uc3QgJiYgJGhhc19vd24uY2FsbChhbmNlc3RvcnNbaV0uJCRjb25zdCwgbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yc1tpXS4kJGNvbnN0W25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgT2JqZWN0J3MgYW5jZXN0b3JzIGNoYWluIGxvb2tpbmcgZm9yIHRoZSBjb25zdGFudCxcbiAgLy8gYnV0IG9ubHkgaWYgY3JlZiBpcyBtaXNzaW5nIG9yIGEgbW9kdWxlLlxuICBmdW5jdGlvbiBjb25zdF9sb29rdXBfT2JqZWN0KGNyZWYsIG5hbWUpIHtcbiAgICBpZiAoY3JlZiA9PSBudWxsIHx8IGNyZWYuJCRpc19tb2R1bGUpIHtcbiAgICAgIHJldHVybiBjb25zdF9sb29rdXBfYW5jZXN0b3JzKF9PYmplY3QsIG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGwgY29uc3RfbWlzc2luZyBpZiBub3RoaW5nIGVsc2Ugd29ya2VkXG4gIGZ1bmN0aW9uIGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgaWYgKCFza2lwX21pc3NpbmcpIHtcbiAgICAgIHJldHVybiAoY3JlZiB8fCBfT2JqZWN0KS4kY29uc3RfbWlzc2luZyhuYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQganVzdCBpbiB0aGUgY3VycmVudCBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYFxuICBPcGFsLmNvbnN0X2dldF9sb2NhbCA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoY3JlZiA9PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAoY3JlZiA9PT0gJzo6JykgY3JlZiA9IF9PYmplY3Q7XG5cbiAgICBpZiAoIWNyZWYuJCRpc19tb2R1bGUgJiYgIWNyZWYuJCRpc19jbGFzcykge1xuICAgICAgdGhyb3cgbmV3IE9wYWwuVHlwZUVycm9yKGNyZWYudG9TdHJpbmcoKSArIFwiIGlzIG5vdCBhIGNsYXNzL21vZHVsZVwiKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBjb25zdF9nZXRfbmFtZShjcmVmLCBuYW1lKTsgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXN1bHQgPSBjb25zdF9taXNzaW5nKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZyk7IGlmIChyZXN1bHQgIT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQgcmVsYXRpdmUgdG8gYSBjcmVmIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGVcbiAgLy8gY29uc3RhbnQgaXMgcHJlZml4ZWQgYnkgYDo6YCkuXG4gIE9wYWwuY29uc3RfZ2V0X3F1YWxpZmllZCA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUsIHNraXBfbWlzc2luZykge1xuICAgIHZhciByZXN1bHQsIGNhY2hlLCBjYWNoZWQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcblxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcblxuICAgIGlmIChjcmVmID09PSAnOjonKSBjcmVmID0gX09iamVjdDtcblxuICAgIGlmICghY3JlZi4kJGlzX21vZHVsZSAmJiAhY3JlZi4kJGlzX2NsYXNzKSB7XG4gICAgICB0aHJvdyBuZXcgT3BhbC5UeXBlRXJyb3IoY3JlZi50b1N0cmluZygpICsgXCIgaXMgbm90IGEgY2xhc3MvbW9kdWxlXCIpO1xuICAgIH1cblxuICAgIGlmICgoY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShjcmVmLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBjcmVmLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSkgICAgICAhPSBudWxsKTtcbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgfTtcblxuICAvLyBJbml0aWFsaXplIHRoZSB0b3AgbGV2ZWwgY29uc3RhbnQgY2FjaGUgZ2VuZXJhdGlvbiBjb3VudGVyXG4gIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiA9IDE7XG5cbiAgLy8gTG9vayBmb3IgdGhlIGNvbnN0YW50IGluIHRoZSBvcGVuIHVzaW5nIHRoZSBjdXJyZW50IG5lc3RpbmcgYW5kIHRoZSBuZWFyZXN0XG4gIC8vIGNyZWYgYW5jZXN0b3JzIG9yIGNhbGwgYCNjb25zdF9taXNzaW5nYCAod2hlbiB0aGUgY29uc3RhbnQgaGFzIG5vIDo6IHByZWZpeCkuXG4gIE9wYWwuY29uc3RfZ2V0X3JlbGF0aXZlID0gZnVuY3Rpb24obmVzdGluZywgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgdmFyIGNyZWYgPSBuZXN0aW5nWzBdLCByZXN1bHQsIGN1cnJlbnRfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbiwgY2FjaGUsIGNhY2hlZDtcblxuICAgIGlmICgoY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGUpID09IG51bGwpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShuZXN0aW5nLCAnJCRjb25zdF9jYWNoZScsIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgY2FjaGUgPSBuZXN0aW5nLiQkY29uc3RfY2FjaGU7XG4gICAgfVxuICAgIGNhY2hlZCA9IGNhY2hlW25hbWVdO1xuXG4gICAgaWYgKGNhY2hlZCA9PSBudWxsIHx8IGNhY2hlZFswXSAhPT0gY3VycmVudF92ZXJzaW9uKSB7XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpKSAgICAgICAgICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX25lc3RpbmcobmVzdGluZywgbmFtZSkpICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpKSAgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9PYmplY3QoY3JlZiwgbmFtZSkpICAgICAgICAgIT0gbnVsbCk7XG5cbiAgICAgIGNhY2hlW25hbWVdID0gW2N1cnJlbnRfdmVyc2lvbiwgcmVzdWx0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY2FjaGVkWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgIT0gbnVsbCA/IHJlc3VsdCA6IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTtcbiAgfTtcblxuICAvLyBSZWdpc3RlciB0aGUgY29uc3RhbnQgb24gYSBjcmVmIGFuZCBvcHBvcnR1bmlzdGljYWxseSBzZXQgdGhlIG5hbWUgb2ZcbiAgLy8gdW5uYW1lZCBjbGFzc2VzL21vZHVsZXMuXG4gIE9wYWwuY29uc3Rfc2V0ID0gZnVuY3Rpb24oY3JlZiwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoY3JlZiA9PSBudWxsIHx8IGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKHZhbHVlLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgIGlmICh2YWx1ZS4kJG5hbWUgPT0gbnVsbCB8fCB2YWx1ZS4kJG5hbWUgPT09IG5pbCkgdmFsdWUuJCRuYW1lID0gbmFtZTtcbiAgICAgIGlmICh2YWx1ZS4kJGJhc2VfbW9kdWxlID09IG51bGwpIHZhbHVlLiQkYmFzZV9tb2R1bGUgPSBjcmVmO1xuICAgIH1cblxuICAgIGNyZWYuJCRjb25zdCA9IChjcmVmLiQkY29uc3QgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgY3JlZi4kJGNvbnN0W25hbWVdID0gdmFsdWU7XG5cbiAgICAvLyBBZGQgYSBzaG9ydCBoZWxwZXIgdG8gbmF2aWdhdGUgY29uc3RhbnRzIG1hbnVhbGx5LlxuICAgIC8vIEBleGFtcGxlXG4gICAgLy8gICBPcGFsLiQkLlJlZ2V4cC4kJC5JR05PUkVDQVNFXG4gICAgY3JlZi4kJCA9IGNyZWYuJCRjb25zdDtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuXG4gICAgLy8gRXhwb3NlIHRvcCBsZXZlbCBjb25zdGFudHMgb250byB0aGUgT3BhbCBvYmplY3RcbiAgICBpZiAoY3JlZiA9PT0gX09iamVjdCkgT3BhbFtuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gTmFtZSBuZXcgY2xhc3MgZGlyZWN0bHkgb250byBjdXJyZW50IHNjb3BlIChPcGFsLkZvby5CYXogPSBrbGFzcylcbiAgICAkZGVmaW5lUHJvcGVydHkoY3JlZiwgbmFtZSwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIEdldCBhbGwgdGhlIGNvbnN0YW50cyByZWFjaGFibGUgZnJvbSBhIGdpdmVuIGNyZWYsIGJ5IGRlZmF1bHQgd2lsbCBpbmNsdWRlXG4gIC8vIGluaGVyaXRlZCBjb25zdGFudHMuXG4gIE9wYWwuY29uc3RhbnRzID0gZnVuY3Rpb24oY3JlZiwgaW5oZXJpdCkge1xuICAgIGlmIChpbmhlcml0ID09IG51bGwpIGluaGVyaXQgPSB0cnVlO1xuXG4gICAgdmFyIG1vZHVsZSwgbW9kdWxlcyA9IFtjcmVmXSwgaSwgaWksIGNvbnN0YW50cyA9IHt9LCBjb25zdGFudDtcblxuICAgIGlmIChpbmhlcml0KSBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoT3BhbC5hbmNlc3RvcnMoY3JlZikpO1xuICAgIGlmIChpbmhlcml0ICYmIGNyZWYuJCRpc19tb2R1bGUpIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChbT3BhbC5PYmplY3RdKS5jb25jYXQoT3BhbC5hbmNlc3RvcnMoT3BhbC5PYmplY3QpKTtcblxuICAgIGZvciAoaSA9IDAsIGlpID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBtb2R1bGUgPSBtb2R1bGVzW2ldO1xuXG4gICAgICAvLyBEbyBub3Qgc2hvdyBPYmplY3RzIGNvbnN0YW50cyB1bmxlc3Mgd2UncmUgcXVlcnlpbmcgT2JqZWN0IGl0c2VsZlxuICAgICAgaWYgKGNyZWYgIT09IF9PYmplY3QgJiYgbW9kdWxlID09IF9PYmplY3QpIGJyZWFrO1xuXG4gICAgICBmb3IgKGNvbnN0YW50IGluIG1vZHVsZS4kJGNvbnN0KSB7XG4gICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhjb25zdGFudHMpO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBhIGNvbnN0YW50IGZyb20gYSBjcmVmLlxuICBPcGFsLmNvbnN0X3JlbW92ZSA9IGZ1bmN0aW9uKGNyZWYsIG5hbWUpIHtcbiAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcblxuICAgIGlmIChjcmVmLiQkY29uc3RbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgdmFyIG9sZCA9IGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgICAgIGRlbGV0ZSBjcmVmLiQkY29uc3RbbmFtZV07XG4gICAgICByZXR1cm4gb2xkO1xuICAgIH1cblxuICAgIGlmIChjcmVmLiQkYXV0b2xvYWQgIT0gbnVsbCAmJiBjcmVmLiQkYXV0b2xvYWRbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgZGVsZXRlIGNyZWYuJCRhdXRvbG9hZFtuYW1lXTtcbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuXG4gICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcImNvbnN0YW50IFwiK2NyZWYrXCI6OlwiK2NyZWYuJG5hbWUoKStcIiBub3QgZGVmaW5lZFwiKTtcbiAgfTtcblxuICAvLyBTZXR1cCBzb21lIHNob3J0Y3V0cyB0byByZWR1Y2UgY29tcGlsZWQgc2l6ZVxuICBPcGFsLiQkID0gT3BhbC5jb25zdF9nZXRfcmVsYXRpdmU7XG4gIE9wYWwuJCQkID0gT3BhbC5jb25zdF9nZXRfcXVhbGlmaWVkO1xuXG5cbiAgLy8gTW9kdWxlcyAmIENsYXNzZXNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBBIGBjbGFzcyBGb287IGVuZGAgZXhwcmVzc2lvbiBpbiBydWJ5IGlzIGNvbXBpbGVkIHRvIGNhbGwgdGhpcyBydW50aW1lXG4gIC8vIG1ldGhvZCB3aGljaCBlaXRoZXIgcmV0dXJucyBhbiBleGlzdGluZyBjbGFzcyBvZiB0aGUgZ2l2ZW4gbmFtZSwgb3IgY3JlYXRlc1xuICAvLyBhIG5ldyBjbGFzcyBpbiB0aGUgZ2l2ZW4gYGJhc2VgIHNjb3BlLlxuICAvL1xuICAvLyBJZiBhIGNvbnN0YW50IHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3RzLCB0aGVuIHdlIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0XG4gIC8vIGl0IGlzIGEgY2xhc3MgYW5kIGFsc28gdGhhdCB0aGUgc3VwZXJjbGFzc2VzIG1hdGNoLiBJZiBlaXRoZXIgb2YgdGhlc2VcbiAgLy8gZmFpbCwgdGhlbiB3ZSByYWlzZSBhIGBUeXBlRXJyb3JgLiBOb3RlLCBgc3VwZXJjbGFzc2AgbWF5IGJlIG51bGwgaWYgb25lXG4gIC8vIHdhcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBydWJ5IGNvZGUuXG4gIC8vXG4gIC8vIFdlIHBhc3MgYSBjb25zdHJ1Y3RvciB0byB0aGlzIG1ldGhvZCBvZiB0aGUgZm9ybSBgZnVuY3Rpb24gQ2xhc3NOYW1lKCkge31gXG4gIC8vIHNpbXBseSBzbyB0aGF0IGNsYXNzZXMgc2hvdyB1cCB3aXRoIG5pY2VseSBmb3JtYXR0ZWQgbmFtZXMgaW5zaWRlIGRlYnVnZ2Vyc1xuICAvLyBpbiB0aGUgd2ViIGJyb3dzZXIgKG9yIG5vZGUvc3Byb2NrZXRzKS5cbiAgLy9cbiAgLy8gVGhlIGBzY29wZWAgaXMgdGhlIGN1cnJlbnQgYHNlbGZgIHZhbHVlIHdoZXJlIHRoZSBjbGFzcyBpcyBiZWluZyBjcmVhdGVkXG4gIC8vIGZyb20uIFdlIHVzZSB0aGlzIHRvIGdldCB0aGUgc2NvcGUgZm9yIHdoZXJlIHRoZSBjbGFzcyBzaG91bGQgYmUgY3JlYXRlZC5cbiAgLy8gSWYgYHNjb3BlYCBpcyBhbiBvYmplY3QgKG5vdCBhIGNsYXNzL21vZHVsZSksIHdlIHNpbXBsZSBnZXQgaXRzIGNsYXNzIGFuZFxuICAvLyB1c2UgdGhhdCBhcyB0aGUgc2NvcGUgaW5zdGVhZC5cbiAgLy9cbiAgLy8gQHBhcmFtIHNjb3BlICAgICAgICBbT2JqZWN0XSB3aGVyZSB0aGUgY2xhc3MgaXMgYmVpbmcgY3JlYXRlZFxuICAvLyBAcGFyYW0gc3VwZXJjbGFzcyAgW0NsYXNzLG51bGxdIHN1cGVyY2xhc3Mgb2YgdGhlIG5ldyBjbGFzcyAobWF5IGJlIG51bGwpXG4gIC8vIEBwYXJhbSBpZCAgICAgICAgICBbU3RyaW5nXSB0aGUgbmFtZSBvZiB0aGUgY2xhc3MgdG8gYmUgY3JlYXRlZFxuICAvLyBAcGFyYW0gY29uc3RydWN0b3IgW0pTLkZ1bmN0aW9uXSBmdW5jdGlvbiB0byB1c2UgYXMgY29uc3RydWN0b3JcbiAgLy9cbiAgLy8gQHJldHVybiBuZXcgW0NsYXNzXSAgb3IgZXhpc3RpbmcgcnVieSBjbGFzc1xuICAvL1xuICBPcGFsLmFsbG9jYXRlX2NsYXNzID0gZnVuY3Rpb24obmFtZSwgc3VwZXJjbGFzcykge1xuICAgIHZhciBrbGFzcywgY29uc3RydWN0b3I7XG5cbiAgICBpZiAoc3VwZXJjbGFzcyAhPSBudWxsICYmIHN1cGVyY2xhc3MuJCRicmlkZ2UpIHtcbiAgICAgIC8vIEluaGVyaXRhbmNlIGZyb20gYnJpZGdlZCBjbGFzc2VzIHJlcXVpcmVzXG4gICAgICAvLyBjYWxsaW5nIG9yaWdpbmFsIEpTIGNvbnN0cnVjdG9yc1xuICAgICAgY29uc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgc2VsZiA9IG5ldyAoJGJpbmQuYXBwbHkoc3VwZXJjbGFzcy4kJGNvbnN0cnVjdG9yLCBbbnVsbF0uY29uY2F0KGFyZ3MpKSkoKTtcblxuICAgICAgICAvLyBhbmQgcmVwbGFjaW5nIGEgX19wcm90b19fIG1hbnVhbGx5XG4gICAgICAgICRzZXRfcHJvdG8oc2VsZiwga2xhc3MuJCRwcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RydWN0b3IgPSBmdW5jdGlvbigpe307XG4gICAgfVxuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ2Rpc3BsYXlOYW1lJywgJzo6JytuYW1lKTtcbiAgICB9XG5cbiAgICBrbGFzcyA9IGNvbnN0cnVjdG9yO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRuYW1lJywgbmFtZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRjb25zdHJ1Y3RvcicsIGNvbnN0cnVjdG9yKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJHByb3RvdHlwZScsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRjb25zdCcsIHt9KTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGlzX2NsYXNzJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRpc19hX21vZHVsZScsIHRydWUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkc3VwZXInLCBzdXBlcmNsYXNzKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGN2YXJzJywge30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkb3duX2luY2x1ZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRvd25fcHJlcGVuZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRhbmNlc3RvcnMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbicsIG51bGwpO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLiQkcHJvdG90eXBlLCAnJCRjbGFzcycsIGtsYXNzKTtcblxuICAgIC8vIEJ5IGRlZmF1bHQgaWYgdGhlcmUgYXJlIG5vIHNpbmdsZXRvbiBjbGFzcyBtZXRob2RzXG4gICAgLy8gX19wcm90b19fIGlzIENsYXNzLnByb3RvdHlwZVxuICAgIC8vIExhdGVyIHNpbmdsZXRvbiBtZXRob2RzIGdlbmVyYXRlIGEgc2luZ2xldG9uX2NsYXNzXG4gICAgLy8gYW5kIGluamVjdCBpdCBpbnRvIGFuY2VzdG9ycyBjaGFpblxuICAgIGlmIChPcGFsLkNsYXNzKSB7XG4gICAgICAkc2V0X3Byb3RvKGtsYXNzLCBPcGFsLkNsYXNzLnByb3RvdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHN1cGVyY2xhc3MgIT0gbnVsbCkge1xuICAgICAgJHNldF9wcm90byhrbGFzcy4kJHByb3RvdHlwZSwgc3VwZXJjbGFzcy4kJHByb3RvdHlwZSk7XG5cbiAgICAgIGlmIChzdXBlcmNsYXNzLiQkbWV0YSkge1xuICAgICAgICAvLyBJZiBzdXBlcmNsYXNzIGhhcyBtZXRhY2xhc3MgdGhlbiB3ZSBoYXZlIGV4cGxpY2l0ZWx5IGluaGVyaXQgaXQuXG4gICAgICAgIE9wYWwuYnVpbGRfY2xhc3Nfc2luZ2xldG9uX2NsYXNzKGtsYXNzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cblxuICBmdW5jdGlvbiBmaW5kX2V4aXN0aW5nX2NsYXNzKHNjb3BlLCBuYW1lKSB7XG4gICAgLy8gVHJ5IHRvIGZpbmQgdGhlIGNsYXNzIGluIHRoZSBjdXJyZW50IHNjb3BlXG4gICAgdmFyIGtsYXNzID0gY29uc3RfZ2V0X25hbWUoc2NvcGUsIG5hbWUpO1xuXG4gICAgLy8gSWYgdGhlIGNsYXNzIGV4aXN0cyBpbiB0aGUgc2NvcGUsIHRoZW4gd2UgbXVzdCB1c2UgdGhhdFxuICAgIGlmIChrbGFzcykge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBleGlzdGluZyBjb25zdGFudCBpcyBhIGNsYXNzLCBvciByYWlzZSBlcnJvclxuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcobmFtZSArIFwiIGlzIG5vdCBhIGNsYXNzXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5zdXJlU3VwZXJjbGFzc01hdGNoKGtsYXNzLCBzdXBlcmNsYXNzKSB7XG4gICAgaWYgKGtsYXNzLiQkc3VwZXIgIT09IHN1cGVyY2xhc3MpIHtcbiAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG1pc21hdGNoIGZvciBjbGFzcyBcIiArIGtsYXNzLiQkbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgT3BhbC5rbGFzcyA9IGZ1bmN0aW9uKHNjb3BlLCBzdXBlcmNsYXNzLCBuYW1lKSB7XG4gICAgdmFyIGJyaWRnZWQ7XG5cbiAgICBpZiAoc2NvcGUgPT0gbnVsbCB8fCBzY29wZSA9PSAnOjonKSB7XG4gICAgICAvLyBHbG9iYWwgc2NvcGVcbiAgICAgIHNjb3BlID0gX09iamVjdDtcbiAgICB9IGVsc2UgaWYgKCFzY29wZS4kJGlzX2NsYXNzICYmICFzY29wZS4kJGlzX21vZHVsZSkge1xuICAgICAgLy8gU2NvcGUgaXMgYW4gb2JqZWN0LCB1c2UgaXRzIGNsYXNzXG4gICAgICBzY29wZSA9IHNjb3BlLiQkY2xhc3M7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHN1cGVyY2xhc3MgaXMgbm90IGFuIE9wYWwtZ2VuZXJhdGVkIGNsYXNzIHRoZW4gd2UncmUgYnJpZGdpbmcgYSBuYXRpdmUgSlMgY2xhc3NcbiAgICBpZiAoXG4gICAgICBzdXBlcmNsYXNzICE9IG51bGwgJiYgKCFzdXBlcmNsYXNzLmhhc093blByb3BlcnR5IHx8IChcbiAgICAgICAgc3VwZXJjbGFzcy5oYXNPd25Qcm9wZXJ0eSAmJiAhc3VwZXJjbGFzcy5oYXNPd25Qcm9wZXJ0eSgnJCRpc19jbGFzcycpXG4gICAgICApKVxuICAgICkge1xuICAgICAgaWYgKHN1cGVyY2xhc3MuY29uc3RydWN0b3IgJiYgc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5uYW1lID09IFwiRnVuY3Rpb25cIikge1xuICAgICAgICBicmlkZ2VkID0gc3VwZXJjbGFzcztcbiAgICAgICAgc3VwZXJjbGFzcyA9IF9PYmplY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwic3VwZXJjbGFzcyBtdXN0IGJlIGEgQ2xhc3MgKFwiICsgKFxuICAgICAgICAgIChzdXBlcmNsYXNzLmNvbnN0cnVjdG9yICYmIChzdXBlcmNsYXNzLmNvbnN0cnVjdG9yLm5hbWUgfHwgc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci4kJG5hbWUpKSB8fFxuICAgICAgICAgIHR5cGVvZihzdXBlcmNsYXNzKVxuICAgICAgICApICsgXCIgZ2l2ZW4pXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrbGFzcyA9IGZpbmRfZXhpc3RpbmdfY2xhc3Moc2NvcGUsIG5hbWUpO1xuXG4gICAgaWYgKGtsYXNzKSB7XG4gICAgICBpZiAoc3VwZXJjbGFzcykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgZXhpc3RpbmcgY2xhc3MgaGFzIHNhbWUgc3VwZXJjbGFzc1xuICAgICAgICBlbnN1cmVTdXBlcmNsYXNzTWF0Y2goa2xhc3MsIHN1cGVyY2xhc3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIC8vIENsYXNzIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBhIG5ldyBvbmUgd2l0aCBnaXZlbiBzdXBlcmNsYXNzLi4uXG5cbiAgICAvLyBOb3Qgc3BlY2lmeWluZyBhIHN1cGVyY2xhc3MgbWVhbnMgd2UgY2FuIGFzc3VtZSBpdCB0byBiZSBPYmplY3RcbiAgICBpZiAoc3VwZXJjbGFzcyA9PSBudWxsKSB7XG4gICAgICBzdXBlcmNsYXNzID0gX09iamVjdDtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIGNsYXNzIG9iamVjdCAoaW5zdGFuY2Ugb2YgQ2xhc3MpXG4gICAga2xhc3MgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG5hbWUsIHN1cGVyY2xhc3MpO1xuICAgIE9wYWwuY29uc3Rfc2V0KHNjb3BlLCBuYW1lLCBrbGFzcyk7XG5cbiAgICAvLyBDYWxsIC5pbmhlcml0ZWQoKSBob29rIHdpdGggbmV3IGNsYXNzIG9uIHRoZSBzdXBlcmNsYXNzXG4gICAgaWYgKHN1cGVyY2xhc3MuJGluaGVyaXRlZCkge1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAoYnJpZGdlZCkge1xuICAgICAgT3BhbC5icmlkZ2UoYnJpZGdlZCwga2xhc3MpO1xuICAgIH1cblxuICAgIHJldHVybiBrbGFzcztcbiAgfTtcblxuICAvLyBEZWZpbmUgbmV3IG1vZHVsZSAob3IgcmV0dXJuIGV4aXN0aW5nIG1vZHVsZSkuIFRoZSBnaXZlbiBgc2NvcGVgIGlzIGJhc2ljYWxseVxuICAvLyB0aGUgY3VycmVudCBgc2VsZmAgdmFsdWUgdGhlIGBtb2R1bGVgIHN0YXRlbWVudCB3YXMgZGVmaW5lZCBpbi4gSWYgdGhpcyBpc1xuICAvLyBhIHJ1YnkgbW9kdWxlIG9yIGNsYXNzLCB0aGVuIGl0IGlzIHVzZWQsIG90aGVyd2lzZSBpZiB0aGUgc2NvcGUgaXMgYSBydWJ5XG4gIC8vIG9iamVjdCB0aGVuIHRoYXQgb2JqZWN0cyByZWFsIHJ1YnkgY2xhc3MgaXMgdXNlZCAoZS5nLiBpZiB0aGUgc2NvcGUgaXMgdGhlXG4gIC8vIG1haW4gb2JqZWN0LCB0aGVuIHRoZSB0b3AgbGV2ZWwgYE9iamVjdGAgY2xhc3MgaXMgdXNlZCBhcyB0aGUgc2NvcGUpLlxuICAvL1xuICAvLyBJZiBhIG1vZHVsZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpcyBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIHNjb3BlLCB0aGVuIHRoYXRcbiAgLy8gaW5zdGFuY2UgaXMganVzdCByZXR1cm5lZC5cbiAgLy9cbiAgLy8gSWYgdGhlcmUgaXMgYSBjbGFzcyBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGUgc2NvcGUsIHRoZW4gYW4gZXJyb3IgaXNcbiAgLy8gZ2VuZXJhdGVkIGluc3RlYWQgKGNhbm5vdCBoYXZlIGEgY2xhc3MgYW5kIG1vZHVsZSBvZiBzYW1lIG5hbWUgaW4gc2FtZSBzY29wZSkuXG4gIC8vXG4gIC8vIE90aGVyd2lzZSwgYSBuZXcgbW9kdWxlIGlzIGNyZWF0ZWQgaW4gdGhlIHNjb3BlIHdpdGggdGhlIGdpdmVuIG5hbWUsIGFuZCB0aGF0XG4gIC8vIG5ldyBpbnN0YW5jZSBpcyByZXR1cm5lZCBiYWNrICh0byBiZSByZWZlcmVuY2VkIGF0IHJ1bnRpbWUpLlxuICAvL1xuICAvLyBAcGFyYW0gIHNjb3BlIFtNb2R1bGUsIENsYXNzXSBjbGFzcyBvciBtb2R1bGUgdGhpcyBkZWZpbml0aW9uIGlzIGluc2lkZVxuICAvLyBAcGFyYW0gIGlkICAgW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG5ldyAob3IgZXhpc3RpbmcpIG1vZHVsZVxuICAvL1xuICAvLyBAcmV0dXJuIFtNb2R1bGVdXG4gIE9wYWwuYWxsb2NhdGVfbW9kdWxlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCl7fTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCBuYW1lKycuJCRjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIHZhciBtb2R1bGUgPSBjb25zdHJ1Y3RvcjtcblxuICAgIGlmIChuYW1lKVxuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCBuYW1lKycuY29uc3RydWN0b3InKTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJG5hbWUnLCBuYW1lKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRwcm90b3R5cGUnLCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGNvbnN0Jywge30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGlzX21vZHVsZScsIHRydWUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkY3ZhcnMnLCB7fSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkaWNsYXNzZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkb3duX2luY2x1ZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkb3duX3ByZXBlbmRlZF9tb2R1bGVzJywgW10pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGFuY2VzdG9ycycsIFttb2R1bGVdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbicsIG51bGwpO1xuXG4gICAgJHNldF9wcm90byhtb2R1bGUsIE9wYWwuTW9kdWxlLnByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4gbW9kdWxlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZpbmRfZXhpc3RpbmdfbW9kdWxlKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZSA9IGNvbnN0X2dldF9uYW1lKHNjb3BlLCBuYW1lKTtcbiAgICBpZiAobW9kdWxlID09IG51bGwgJiYgc2NvcGUgPT09IF9PYmplY3QpIG1vZHVsZSA9IGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoX09iamVjdCwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICBpZiAoIW1vZHVsZS4kJGlzX21vZHVsZSAmJiBtb2R1bGUgIT09IF9PYmplY3QpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhuYW1lICsgXCIgaXMgbm90IGEgbW9kdWxlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH1cblxuICBPcGFsLm1vZHVsZSA9IGZ1bmN0aW9uKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZTtcblxuICAgIGlmIChzY29wZSA9PSBudWxsIHx8IHNjb3BlID09ICc6OicpIHtcbiAgICAgIC8vIEdsb2JhbCBzY29wZVxuICAgICAgc2NvcGUgPSBfT2JqZWN0O1xuICAgIH0gZWxzZSBpZiAoIXNjb3BlLiQkaXNfY2xhc3MgJiYgIXNjb3BlLiQkaXNfbW9kdWxlKSB7XG4gICAgICAvLyBTY29wZSBpcyBhbiBvYmplY3QsIHVzZSBpdHMgY2xhc3NcbiAgICAgIHNjb3BlID0gc2NvcGUuJCRjbGFzcztcbiAgICB9XG5cbiAgICBtb2R1bGUgPSBmaW5kX2V4aXN0aW5nX21vZHVsZShzY29wZSwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICByZXR1cm4gbW9kdWxlO1xuICAgIH1cblxuICAgIC8vIE1vZHVsZSBkb2VzbnQgZXhpc3QsIGNyZWF0ZSBhIG5ldyBvbmUuLi5cbiAgICBtb2R1bGUgPSBPcGFsLmFsbG9jYXRlX21vZHVsZShuYW1lKTtcbiAgICBPcGFsLmNvbnN0X3NldChzY29wZSwgbmFtZSwgbW9kdWxlKTtcblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIHRoZSBwYXNzZWQgb2JqZWN0LlxuICAvL1xuICAvLyBJZiB0aGUgZ2l2ZW4gb2JqZWN0IGFscmVkeSBoYXMgYSBzaW5nbGV0b24gY2xhc3MsIHRoZW4gaXQgd2lsbCBiZSBzdG9yZWQgb25cbiAgLy8gdGhlIG9iamVjdCBhcyB0aGUgYCQkbWV0YWAgcHJvcGVydHkuIElmIHRoaXMgZXhpc3RzLCB0aGVuIGl0IGlzIHNpbXBseVxuICAvLyByZXR1cm5lZCBiYWNrLlxuICAvL1xuICAvLyBPdGhlcndpc2UsIGEgbmV3IHNpbmdsZXRvbiBvYmplY3QgZm9yIHRoZSBjbGFzcyBvciBvYmplY3QgaXMgY3JlYXRlZCwgc2V0IG9uXG4gIC8vIHRoZSBvYmplY3QgYXQgYCQkbWV0YWAgZm9yIGZ1dHVyZSB1c2UsIGFuZCB0aGVuIHJldHVybmVkLlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIHRoZSBydWJ5IG9iamVjdFxuICAvLyBAcmV0dXJuIFtDbGFzc10gdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3Igb2JqZWN0XG4gIE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuJCRtZXRhKSB7XG4gICAgICByZXR1cm4gb2JqZWN0LiQkbWV0YTtcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX2NsYXNzJykpIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX2NsYXNzX3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xuICAgIH0gZWxzZSBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX21vZHVsZScpKSB7XG4gICAgICByZXR1cm4gT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldG9uX2NsYXNzKG9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQnVpbGQgdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3IgYW4gZXhpc3RpbmcgY2xhc3MuIENsYXNzIG9iamVjdCBhcmUgYnVpbHRcbiAgLy8gd2l0aCB0aGVpciBzaW5nbGV0b24gY2xhc3MgYWxyZWFkeSBpbiB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBpbmhlcml0aW5nXG4gIC8vIGZyb20gdGhlaXIgc3VwZXJjbGFzcyBvYmplY3QgKHVwIHRvIGBDbGFzc2AgaXRzZWxmKS5cbiAgLy9cbiAgLy8gTk9URTogQWN0dWFsbHkgaW4gTVJJIGEgY2xhc3MnIHNpbmdsZXRvbiBjbGFzcyBpbmhlcml0cyBmcm9tIGl0c1xuICAvLyBzdXBlcmNsYXNzJyBzaW5nbGV0b24gY2xhc3Mgd2hpY2ggaW4gdHVybiBpbmhlcml0cyBmcm9tIENsYXNzLlxuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgW0NsYXNzXVxuICAvLyBAcmV0dXJuIFtDbGFzc11cbiAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihrbGFzcykge1xuICAgIHZhciBzdXBlcmNsYXNzLCBtZXRhO1xuXG4gICAgaWYgKGtsYXNzLiQkbWV0YSkge1xuICAgICAgcmV0dXJuIGtsYXNzLiQkbWV0YTtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2luZ2xldG9uX2NsYXNzIHN1cGVyY2xhc3MgaXMgdGhlIHNpbmdsZXRvbl9jbGFzcyBvZiBpdHMgc3VwZXJjbGFzcztcbiAgICAvLyBidXQgQmFzaWNPYmplY3QgaGFzIG5vIHN1cGVyY2xhc3MgKGl0cyBgJCRzdXBlcmAgaXMgbnVsbCksIHRodXMgd2VcbiAgICAvLyBmYWxsYmFjayBvbiBgQ2xhc3NgLlxuICAgIHN1cGVyY2xhc3MgPSBrbGFzcyA9PT0gQmFzaWNPYmplY3QgPyBDbGFzcyA6IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhrbGFzcy4kJHN1cGVyKTtcblxuICAgIG1ldGEgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG51bGwsIHN1cGVyY2xhc3MsIGZ1bmN0aW9uKCl7fSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkobWV0YSwgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1ldGEsICckJHNpbmdsZXRvbl9vZicsIGtsYXNzKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG1ldGEnLCBtZXRhKTtcbiAgICAkc2V0X3Byb3RvKGtsYXNzLCBtZXRhLiQkcHJvdG90eXBlKTtcbiAgICAvLyBSZXN0b3JpbmcgQ2xhc3NOYW1lLmNsYXNzXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRjbGFzcycsIE9wYWwuQ2xhc3MpO1xuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH07XG5cbiAgT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldG9uX2NsYXNzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgaWYgKG1vZC4kJG1ldGEpIHtcbiAgICAgIHJldHVybiBtb2QuJCRtZXRhO1xuICAgIH1cblxuICAgIHZhciBtZXRhID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhudWxsLCBPcGFsLk1vZHVsZSwgZnVuY3Rpb24oKXt9KTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShtZXRhLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobWV0YSwgJyQkc2luZ2xldG9uX29mJywgbW9kKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kLCAnJCRtZXRhJywgbWV0YSk7XG4gICAgJHNldF9wcm90byhtb2QsIG1ldGEuJCRwcm90b3R5cGUpO1xuICAgIC8vIFJlc3RvcmluZyBNb2R1bGVOYW1lLmNsYXNzXG4gICAgJGRlZmluZVByb3BlcnR5KG1vZCwgJyQkY2xhc3MnLCBPcGFsLk1vZHVsZSk7XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfTtcblxuICAvLyBCdWlsZCB0aGUgc2luZ2xldG9uIGNsYXNzIGZvciBhIFJ1YnkgKG5vbiBjbGFzcykgT2JqZWN0LlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdXG4gIC8vIEByZXR1cm4gW0NsYXNzXVxuICBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgc3VwZXJjbGFzcyA9IG9iamVjdC4kJGNsYXNzLFxuICAgICAgICBrbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MobmlsLCBzdXBlcmNsYXNzLCBmdW5jdGlvbigpe30pO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJHNpbmdsZXRvbl9vZicsIG9iamVjdCk7XG5cbiAgICBkZWxldGUga2xhc3MuJCRwcm90b3R5cGUuJCRjbGFzcztcblxuICAgICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsICckJG1ldGEnLCBrbGFzcyk7XG5cbiAgICAkc2V0X3Byb3RvKG9iamVjdCwgb2JqZWN0LiQkbWV0YS4kJHByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cbiAgT3BhbC5pc19tZXRob2QgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIChwcm9wWzBdID09PSAnJCcgJiYgcHJvcFsxXSAhPT0gJyQnKTtcbiAgfTtcblxuICBPcGFsLmluc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgZXhjbHVkZSA9IFtdLCByZXN1bHRzID0gW10sIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcbiAgICAgICAgICBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxsID0gcHJvcHMubGVuZ3RoOyBqIDwgbGw7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSksXG4gICAgICAgICAgICAgIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgICAgaWYgKG1ldGhvZC4kJHN0dWIgJiYgZXhjbHVkZS5pbmRleE9mKG1ldGhvZF9uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGV4Y2x1ZGUucHVzaChtZXRob2RfbmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFtZXRob2QuJCRzdHViICYmIHJlc3VsdHMuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xICYmIGV4Y2x1ZGUuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobWV0aG9kX25hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICBwcm90byA9IG1vZC4kJHByb3RvdHlwZTtcblxuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgIGlmICghbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG1ldGhvZF9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMoT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iaikpO1xuICB9O1xuXG4gIE9wYWwub3duX21ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyhPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSk7XG4gIH07XG5cbiAgT3BhbC5yZWNlaXZlcl9tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG1vZCA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopO1xuICAgIHZhciBzaW5nbGV0b25fbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kKTtcbiAgICB2YXIgaW5zdGFuY2VfbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kLiQkc3VwZXIpO1xuICAgIHJldHVybiBzaW5nbGV0b25fbWV0aG9kcy5jb25jYXQoaW5zdGFuY2VfbWV0aG9kcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgcGFpcnMgb2YgbmFtZXMvdmFsdWVzXG4gIC8vIGZvciBhbGwgY2xhc3MgdmFyaWFibGVzIGRlZmluZWQgaW4gcHJvdmlkZWQgK21vZHVsZStcbiAgLy8gYW5kIGl0cyBhbmNlc3RvcnMuXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV1cbiAgLy8gQHJldHVybiBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGZvciAodmFyIGN2YXIgaW4gYW5jZXN0b3IuJCRjdmFycykge1xuICAgICAgICByZXN1bHRbY3Zhcl0gPSBhbmNlc3Rvci4kJGN2YXJzW2N2YXJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgdG8gK3ZhbHVlK1xuICAvLyBpbiBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIC8vIEBwYXJhbSB2YWx1ZSBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldCA9IGZ1bmN0aW9uKG1vZHVsZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMobW9kdWxlKSxcbiAgICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGlmICgkaGFzX293bi5jYWxsKGFuY2VzdG9yLiQkY3ZhcnMsIG5hbWUpKSB7XG4gICAgICAgIGFuY2VzdG9yLiQkY3ZhcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS4kJGN2YXJzW25hbWVdID0gdmFsdWU7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gR2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgZnJvbSBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIE9wYWwuY2xhc3NfdmFyaWFibGVfZ2V0ID0gZnVuY3Rpb24obW9kdWxlLCBuYW1lLCB0b2xlcmFudCkge1xuICAgIGlmICgkaGFzX293bi5jYWxsKG1vZHVsZS4kJGN2YXJzLCBuYW1lKSlcbiAgICAgIHJldHVybiBtb2R1bGUuJCRjdmFyc1tuYW1lXTtcblxuICAgIHZhciBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xuXG4gICAgICBpZiAoJGhhc19vd24uY2FsbChhbmNlc3Rvci4kJGN2YXJzLCBuYW1lKSkge1xuICAgICAgICByZXR1cm4gYW5jZXN0b3IuJCRjdmFyc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRvbGVyYW50KVxuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldygndW5pbml0aWFsaXplZCBjbGFzcyB2YXJpYWJsZSAnK25hbWUrJyBpbiAnK21vZHVsZS4kbmFtZSgpKTtcblxuICAgIHJldHVybiBuaWw7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Jvb3QocHJvdG8pIHtcbiAgICByZXR1cm4gcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkcm9vdCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX2luY2x1ZGVkX21vZHVsZXMobW9kdWxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBtb2QsIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZS4kJHByb3RvdHlwZSk7XG5cbiAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRjbGFzcycpKSB7XG4gICAgICAgIC8vIHN1cGVyY2xhc3NcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtb2QgPSBwcm90b1RvTW9kdWxlKHByb3RvKTtcbiAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobW9kKTtcbiAgICAgIH1cbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX3ByZXBlbmRlZF9tb2R1bGVzKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xuXG4gICAgaWYgKG1vZHVsZS4kJHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgICAgaWYgKHByb3RvID09PSBtb2R1bGUuJCRwcm90b3R5cGUuJCRkZWZpbmVfbWV0aG9kc19vbikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kID0gcHJvdG9Ub01vZHVsZShwcm90byk7XG4gICAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4gIC8vIFRoZSBhY3R1YWwgaW5jbHVzaW9uIG9mIGEgbW9kdWxlIGludG8gYSBjbGFzcy5cbiAgLy9cbiAgLy8gIyMgQ2xhc3MgYCQkcGFyZW50YCBhbmQgYGljbGFzc2BcbiAgLy9cbiAgLy8gVG8gaGFuZGxlIGBzdXBlcmAgY2FsbHMsIGV2ZXJ5IGNsYXNzIGhhcyBhIGAkJHBhcmVudGAuIFRoaXMgcGFyZW50IGlzXG4gIC8vIHVzZWQgdG8gcmVzb2x2ZSB0aGUgbmV4dCBjbGFzcyBmb3IgYSBzdXBlciBjYWxsLiBBIG5vcm1hbCBjbGFzcyB3b3VsZFxuICAvLyBoYXZlIHRoaXMgcG9pbnQgdG8gaXRzIHN1cGVyY2xhc3MuIEhvd2V2ZXIsIGlmIGEgY2xhc3MgaW5jbHVkZXMgYSBtb2R1bGVcbiAgLy8gdGhlbiB0aGlzIHdvdWxkIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlIG1vZHVsZS4gVGhlIG1vZHVsZSB3b3VsZFxuICAvLyBhbHNvIGhhdmUgdG8gdGhlbiBwb2ludCBpdHMgYCQkcGFyZW50YCB0byB0aGUgYWN0dWFsIHN1cGVyY2xhc3MuIFdlXG4gIC8vIGNhbm5vdCBtb2RpZnkgbW9kdWxlcyBsaWtlIHRoaXMsIGJlY2F1c2UgaXQgbWlnaHQgYmUgaW5jbHVkZWQgaW4gbW9yZVxuICAvLyB0aGVuIG9uZSBjbGFzcy4gVG8gZml4IHRoaXMsIHdlIGFjdHVhbGx5IGluc2VydCBhbiBgaWNsYXNzYCBhcyB0aGUgY2xhc3MnXG4gIC8vIGAkJHBhcmVudGAgd2hpY2ggY2FuIHRoZW4gcG9pbnQgdG8gdGhlIHN1cGVyY2xhc3MuIFRoZSBgaWNsYXNzYCBhY3RzIGFzXG4gIC8vIGEgcHJveHkgdG8gdGhlIGFjdHVhbCBtb2R1bGUsIHNvIHRoZSBgc3VwZXJgIGNoYWluIGNhbiB0aGVuIHNlYXJjaCBpdCBmb3JcbiAgLy8gdGhlIHJlcXVpcmVkIG1ldGhvZC5cbiAgLy9cbiAgLy8gQHBhcmFtIG1vZHVsZSBbTW9kdWxlXSB0aGUgbW9kdWxlIHRvIGluY2x1ZGVcbiAgLy8gQHBhcmFtIGluY2x1ZGVyIFtNb2R1bGVdIHRoZSB0YXJnZXQgY2xhc3MgdG8gaW5jbHVkZSBtb2R1bGUgaW50b1xuICAvLyBAcmV0dXJuIFtudWxsXVxuICBPcGFsLmFwcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgaW5jbHVkZXIpIHtcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKGluY2x1ZGVyKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdjeWNsaWMgaW5jbHVkZSBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtb2R1bGVfYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBtb2R1bGVfYW5jZXN0b3JzW2ldLCBpY2xhc3MgPSBjcmVhdGVfaWNsYXNzKGFuY2VzdG9yKTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsICckJGluY2x1ZGVkJywgdHJ1ZSk7XG4gICAgICBpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XG4gICAgfVxuICAgIHZhciBpbmNsdWRlcl9hbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhpbmNsdWRlciksXG4gICAgICAgIGNoYWluID0gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpLFxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlcixcbiAgICAgICAgZW5kX2NoYWluX29uO1xuXG4gICAgaWYgKGluY2x1ZGVyX2FuY2VzdG9ycy5pbmRleE9mKG1vZHVsZSkgPT09IC0xKSB7XG4gICAgICAvLyBmaXJzdCB0aW1lIGluY2x1ZGVcblxuICAgICAgLy8gaW5jbHVkZXIgLT4gY2hhaW4uZmlyc3QgLT4gLi4uY2hhaW4uLi4gLT4gY2hhaW4ubGFzdCAtPiBpbmNsdWRlci5wYXJlbnRcbiAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XG4gICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5jbHVkZXIuJCRwcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgbW9kdWxlIGhhcyBiZWVuIGFscmVhZHkgaW5jbHVkZWQsXG4gICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHB1dCBpdCBpbnRvIHRoZSBhbmNlc3RvcnMgY2hhaW4gYWdhaW4sXG4gICAgICAvLyBidXQgdGhpcyBtb2R1bGUgbWF5IGhhdmUgbmV3IGluY2x1ZGVkIG1vZHVsZXMuXG4gICAgICAvLyBJZiBpdCdzIHRydWUgd2UgbmVlZCB0byBjb3B5IHRoZW0uXG4gICAgICAvL1xuICAgICAgLy8gVGhlIHNpbXBsZXN0IHdheSBpcyB0byByZXBsYWNlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICBgbW9kdWxlYCBpY2xhc3MgKGhhcyBhICQkcm9vdCBmbGFnKVxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIC4uLnByZXZpb3MgY2hhaW4gb2YgbW9kdWxlLmluY2x1ZGVkX21vZHVsZXMgLi4uXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICBcIm5leHQgYW5jZXN0b3JcIiAoaGFzIGEgJCRyb290IGZsYWcgb3IgaXMgYSByZWFsIGNsYXNzKVxuICAgICAgLy9cbiAgICAgIC8vIHRvXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAgYG1vZHVsZWAgaWNsYXNzIChoYXMgYSAkJHJvb3QgZmxhZylcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAuLi5yZWdlbmVyYXRlZCBjaGFpbiBvZiBtb2R1bGUuaW5jbHVkZWRfbW9kdWxlc1xuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIFwibmV4dCBhbmNlc3RvclwiIChoYXMgYSAkJHJvb3QgZmxhZyBvciBpcyBhIHJlYWwgY2xhc3MpXG4gICAgICAvL1xuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBhcmUgbm8gaW50ZXJtZWRpYXRlIGNsYXNzZXMgYmV0d2VlbiBgcGFyZW50YCBhbmQgYG5leHQgYW5jZXN0b3JgLlxuICAgICAgLy8gSXQgZG9lc24ndCBicmVhayBhbnkgcHJvdG90eXBlcyBvZiBvdGhlciBvYmplY3RzIGFzIHdlIGRvbid0IGNoYW5nZSBjbGFzcyByZWZlcmVuY2VzLlxuXG4gICAgICB2YXIgcGFyZW50ID0gaW5jbHVkZXIuJCRwcm90b3R5cGUsIG1vZHVsZV9pY2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcblxuICAgICAgd2hpbGUgKG1vZHVsZV9pY2xhc3MgIT0gbnVsbCkge1xuICAgICAgICBpZiAobW9kdWxlX2ljbGFzcy4kJG1vZHVsZSA9PT0gbW9kdWxlICYmIGlzUm9vdChtb2R1bGVfaWNsYXNzKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gbW9kdWxlX2ljbGFzcztcbiAgICAgICAgbW9kdWxlX2ljbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGVfaWNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZHVsZV9pY2xhc3MpIHtcbiAgICAgICAgLy8gbW9kdWxlIGhhcyBiZWVuIGRpcmVjdGx5IGluY2x1ZGVkXG4gICAgICAgIHZhciBuZXh0X2FuY2VzdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZV9pY2xhc3MpO1xuXG4gICAgICAgIC8vIHNraXAgbm9uLXJvb3QgaWNsYXNzZXMgKHRoYXQgd2VyZSByZWN1cnNpdmVseSBpbmNsdWRlZClcbiAgICAgICAgd2hpbGUgKG5leHRfYW5jZXN0b3IuaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgIWlzUm9vdChuZXh0X2FuY2VzdG9yKSkge1xuICAgICAgICAgIG5leHRfYW5jZXN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV4dF9hbmNlc3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlciA9IHBhcmVudDtcbiAgICAgICAgZW5kX2NoYWluX29uID0gbmV4dF9hbmNlc3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vZHVsZSBoYXMgbm90IGJlZW4gZGlyZWN0bHkgaW5jbHVkZWQgYnV0IHdhcyBpbiBhbmNlc3RvciBjaGFpbiBiZWNhdXNlIGl0IHdhcyBpbmNsdWRlZCBieSBhbm90aGVyIG1vZHVsZVxuICAgICAgICAvLyBpbmNsdWRlIGl0IGRpcmVjdGx5XG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbmNsdWRlci4kJHByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgJHNldF9wcm90byhzdGFydF9jaGFpbl9hZnRlciwgY2hhaW4uZmlyc3QpO1xuICAgICRzZXRfcHJvdG8oY2hhaW4ubGFzdCwgZW5kX2NoYWluX29uKTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIG93bl9pbmNsdWRlZF9tb2R1bGVzIGNhY2hlXG4gICAgaW5jbHVkZXIuJCRvd25faW5jbHVkZWRfbW9kdWxlcyA9IG93bl9pbmNsdWRlZF9tb2R1bGVzKGluY2x1ZGVyKTtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICB9O1xuXG4gIE9wYWwucHJlcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgcHJlcGVuZGVyKSB7XG4gICAgLy8gSGVyZSB3ZSBjaGFuZ2UgdGhlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXG4gICAgLy9cbiAgICAvLyAgIHByZXBlbmRlclxuICAgIC8vICAgICAgfFxuICAgIC8vICAgIHBhcmVudFxuICAgIC8vXG4gICAgLy8gdG86XG4gICAgLy9cbiAgICAvLyBkdW1teShwcmVwZW5kZXIpXG4gICAgLy8gICAgICB8XG4gICAgLy8gIGljbGFzcyhtb2R1bGUpXG4gICAgLy8gICAgICB8XG4gICAgLy8gaWNsYXNzKHByZXBlbmRlcilcbiAgICAvLyAgICAgIHxcbiAgICAvLyAgICBwYXJlbnRcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKHByZXBlbmRlcikgIT09IC0xKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldygnY3ljbGljIHByZXBlbmQgZGV0ZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbW9kdWxlX2FuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gbW9kdWxlX2FuY2VzdG9yc1tpXSwgaWNsYXNzID0gY3JlYXRlX2ljbGFzcyhhbmNlc3Rvcik7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRwcmVwZW5kZWQnLCB0cnVlKTtcbiAgICAgIGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhaW4gPSBjaGFpbl9pY2xhc3NlcyhpY2xhc3NlcyksXG4gICAgICAgIGR1bW15X3ByZXBlbmRlciA9IHByZXBlbmRlci4kJHByb3RvdHlwZSxcbiAgICAgICAgcHJldmlvdXNfcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGR1bW15X3ByZXBlbmRlciksXG4gICAgICAgIHByZXBlbmRlcl9pY2xhc3MsXG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyLFxuICAgICAgICBlbmRfY2hhaW5fb247XG5cbiAgICBpZiAoZHVtbXlfcHJlcGVuZGVyLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIC8vIFRoZSBtb2R1bGUgYWxyZWFkeSBoYXMgc29tZSBwcmVwZW5kZWQgbW9kdWxlc1xuICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIHRvIG1ha2UgaXQgXCJkdW1teVwiXG4gICAgICBwcmVwZW5kZXJfaWNsYXNzID0gZHVtbXlfcHJlcGVuZGVyLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1ha2luZyB0aGUgbW9kdWxlIFwiZHVtbXlcIlxuICAgICAgcHJlcGVuZGVyX2ljbGFzcyA9IGNyZWF0ZV9kdW1teV9pY2xhc3MocHJlcGVuZGVyKTtcbiAgICAgIGZsdXNoX21ldGhvZHNfaW4ocHJlcGVuZGVyKTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShkdW1teV9wcmVwZW5kZXIsICckJGR1bW15JywgdHJ1ZSk7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoZHVtbXlfcHJlcGVuZGVyLCAnJCRkZWZpbmVfbWV0aG9kc19vbicsIHByZXBlbmRlcl9pY2xhc3MpO1xuXG4gICAgICAvLyBDb252ZXJ0aW5nXG4gICAgICAvLyAgIGR1bW15KHByZXBlbmRlcikgLT4gcHJldmlvdXNfcGFyZW50XG4gICAgICAvLyB0b1xuICAgICAgLy8gICBkdW1teShwcmVwZW5kZXIpIC0+IGljbGFzcyhwcmVwZW5kZXIpIC0+IHByZXZpb3VzX3BhcmVudFxuICAgICAgJHNldF9wcm90byhkdW1teV9wcmVwZW5kZXIsIHByZXBlbmRlcl9pY2xhc3MpO1xuICAgICAgJHNldF9wcm90byhwcmVwZW5kZXJfaWNsYXNzLCBwcmV2aW91c19wYXJlbnQpO1xuICAgIH1cblxuICAgIHZhciBwcmVwZW5kZXJfYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMocHJlcGVuZGVyKTtcblxuICAgIGlmIChwcmVwZW5kZXJfYW5jZXN0b3JzLmluZGV4T2YobW9kdWxlKSA9PT0gLTEpIHtcbiAgICAgIC8vIGZpcnN0IHRpbWUgcHJlcGVuZFxuXG4gICAgICBzdGFydF9jaGFpbl9hZnRlciA9IGR1bW15X3ByZXBlbmRlcjtcblxuICAgICAgLy8gbmV4dCAkJHJvb3Qgb3IgcHJlcGVuZGVyX2ljbGFzcyBvciBub24tJCRpY2xhc3NcbiAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihkdW1teV9wcmVwZW5kZXIpO1xuICAgICAgd2hpbGUgKGVuZF9jaGFpbl9vbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBlbmRfY2hhaW5fb24uaGFzT3duUHJvcGVydHkoJyQkcm9vdCcpIHx8XG4gICAgICAgICAgZW5kX2NoYWluX29uID09PSBwcmVwZW5kZXJfaWNsYXNzIHx8XG4gICAgICAgICAgIWVuZF9jaGFpbl9vbi5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKVxuICAgICAgICApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihlbmRfY2hhaW5fb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFwiUHJlcGVuZGluZyBhIG1vZHVsZSBtdWx0aXBsZSB0aW1lcyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cblxuICAgICRzZXRfcHJvdG8oc3RhcnRfY2hhaW5fYWZ0ZXIsIGNoYWluLmZpcnN0KTtcbiAgICAkc2V0X3Byb3RvKGNoYWluLmxhc3QsIGVuZF9jaGFpbl9vbik7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBvd25fcHJlcGVuZGVkX21vZHVsZXMgY2FjaGVcbiAgICBwcmVwZW5kZXIuJCRvd25fcHJlcGVuZGVkX21vZHVsZXMgPSBvd25fcHJlcGVuZGVkX21vZHVsZXMocHJlcGVuZGVyKTtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZsdXNoX21ldGhvZHNfaW4obW9kdWxlKSB7XG4gICAgdmFyIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlLFxuICAgICAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgZGVsZXRlIHByb3RvW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZV9pY2xhc3MobW9kdWxlKSB7XG4gICAgdmFyIGljbGFzcyA9IGNyZWF0ZV9kdW1teV9pY2xhc3MobW9kdWxlKTtcblxuICAgIGlmIChtb2R1bGUuJCRpc19tb2R1bGUpIHtcbiAgICAgIG1vZHVsZS4kJGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWNsYXNzO1xuICB9XG5cbiAgLy8gRHVtbXkgaWNsYXNzIGRvZXNuJ3QgcmVjZWl2ZSB1cGRhdGVzIHdoZW4gdGhlIG1vZHVsZSBnZXRzIGEgbmV3IG1ldGhvZC5cbiAgZnVuY3Rpb24gY3JlYXRlX2R1bW15X2ljbGFzcyhtb2R1bGUpIHtcbiAgICB2YXIgaWNsYXNzID0ge30sXG4gICAgICAgIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlO1xuXG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIHByb3RvID0gcHJvdG8uJCRkZWZpbmVfbWV0aG9kc19vbjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsIHByb3AsIHByb3RvW3Byb3BdKTtcbiAgICB9XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRpY2xhc3MnLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRtb2R1bGUnLCBtb2R1bGUpO1xuXG4gICAgcmV0dXJuIGljbGFzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYWluX2ljbGFzc2VzKGljbGFzc2VzKSB7XG4gICAgdmFyIGxlbmd0aCA9IGljbGFzc2VzLmxlbmd0aCwgZmlyc3QgPSBpY2xhc3Nlc1swXTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShmaXJzdCwgJyQkcm9vdCcsIHRydWUpO1xuXG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHsgZmlyc3Q6IGZpcnN0LCBsYXN0OiBmaXJzdCB9O1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91cyA9IGZpcnN0O1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpY2xhc3Nlc1tpXTtcbiAgICAgICRzZXRfcHJvdG8ocHJldmlvdXMsIGN1cnJlbnQpO1xuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH1cblxuXG4gICAgcmV0dXJuIHsgZmlyc3Q6IGljbGFzc2VzWzBdLCBsYXN0OiBpY2xhc3Nlc1tsZW5ndGggLSAxXSB9O1xuICB9XG5cbiAgLy8gRm9yIHBlcmZvcm1hbmNlLCBzb21lIGNvcmUgUnVieSBjbGFzc2VzIGFyZSB0b2xsLWZyZWUgYnJpZGdlZCB0byB0aGVpclxuICAvLyBuYXRpdmUgSmF2YVNjcmlwdCBjb3VudGVycGFydHMgKGUuZy4gYSBSdWJ5IEFycmF5IGlzIGEgSmF2YVNjcmlwdCBBcnJheSkuXG4gIC8vXG4gIC8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2V0dXAgYSBuYXRpdmUgY29uc3RydWN0b3IgKGUuZy4gQXJyYXkpLCB0byBoYXZlXG4gIC8vIGl0cyBwcm90b3R5cGUgYWN0IGxpa2UgYSBub3JtYWwgUnVieSBjbGFzcy4gRmlyc3RseSwgYSBuZXcgUnVieSBjbGFzcyBpc1xuICAvLyBjcmVhdGVkIHVzaW5nIHRoZSBuYXRpdmUgY29uc3RydWN0b3Igc28gdGhhdCBpdHMgcHJvdG90eXBlIGlzIHNldCBhcyB0aGVcbiAgLy8gdGFyZ2V0IGZvciB0aGUgbmV3IGNsYXNzLiBOb3RlOiBhbGwgYnJpZGdlZCBjbGFzc2VzIGFyZSBzZXQgdG8gaW5oZXJpdFxuICAvLyBmcm9tIE9iamVjdC5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gICAgT3BhbC5icmlkZ2Uoc2VsZiwgRnVuY3Rpb24pO1xuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgICAgICAgW0NsYXNzXSB0aGUgUnVieSBjbGFzcyB0byBicmlkZ2VcbiAgLy8gQHBhcmFtIGNvbnN0cnVjdG9yIFtKUy5GdW5jdGlvbl0gbmF0aXZlIEphdmFTY3JpcHQgY29uc3RydWN0b3IgdG8gdXNlXG4gIC8vIEByZXR1cm4gW0NsYXNzXSByZXR1cm5zIHRoZSBwYXNzZWQgUnVieSBjbGFzc1xuICAvL1xuICBPcGFsLmJyaWRnZSA9IGZ1bmN0aW9uKG5hdGl2ZV9rbGFzcywga2xhc3MpIHtcbiAgICBpZiAobmF0aXZlX2tsYXNzLmhhc093blByb3BlcnR5KCckJGJyaWRnZScpKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcImFscmVhZHkgYnJpZGdlZFwiKTtcbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3RvciBpcyBhIEpTIGZ1bmN0aW9uIHdpdGggYSBwcm90b3R5cGUgY2hhaW4gbGlrZTpcbiAgICAvLyAtIGNvbnN0cnVjdG9yXG4gICAgLy8gICAtIHN1cGVyXG4gICAgLy9cbiAgICAvLyBXaGF0IHdlIG5lZWQgdG8gZG8gaXMgdG8gaW5qZWN0IG91ciBjbGFzcyAod2l0aCBpdHMgcHJvdG90eXBlIGNoYWluKVxuICAgIC8vIGJldHdlZW4gY29uc3RydWN0b3IgYW5kIHN1cGVyLiBGb3IgZXhhbXBsZSwgYWZ0ZXIgaW5qZWN0aW5nIDo6T2JqZWN0XG4gICAgLy8gaW50byBKUyBTdHJpbmcgd2UgZ2V0OlxuICAgIC8vXG4gICAgLy8gLSBjb25zdHJ1Y3RvciAod2luZG93LlN0cmluZylcbiAgICAvLyAgIC0gT3BhbC5PYmplY3RcbiAgICAvLyAgICAgLSBPcGFsLktlcm5lbFxuICAgIC8vICAgICAgIC0gT3BhbC5CYXNpY09iamVjdFxuICAgIC8vICAgICAgICAgLSBzdXBlciAod2luZG93Lk9iamVjdClcbiAgICAvLyAgICAgICAgICAgLSBudWxsXG4gICAgLy9cbiAgICAkZGVmaW5lUHJvcGVydHkobmF0aXZlX2tsYXNzLCAnJCRicmlkZ2UnLCBrbGFzcyk7XG4gICAgJHNldF9wcm90byhuYXRpdmVfa2xhc3MucHJvdG90eXBlLCAoa2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdCkuJCRwcm90b3R5cGUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkcHJvdG90eXBlJywgbmF0aXZlX2tsYXNzLnByb3RvdHlwZSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MuJCRwcm90b3R5cGUsICckJGNsYXNzJywga2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkY29uc3RydWN0b3InLCBuYXRpdmVfa2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkYnJpZGdlJywgdHJ1ZSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHJvdG9Ub01vZHVsZShwcm90bykge1xuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkbW9kdWxlO1xuICAgIH0gZWxzZSBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkY2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3duX2FuY2VzdG9ycyhtb2R1bGUpIHtcbiAgICByZXR1cm4gbW9kdWxlLiQkb3duX3ByZXBlbmRlZF9tb2R1bGVzLmNvbmNhdChbbW9kdWxlXSkuY29uY2F0KG1vZHVsZS4kJG93bl9pbmNsdWRlZF9tb2R1bGVzKTtcbiAgfVxuXG4gIC8vIFRoZSBBcnJheSBvZiBhbmNlc3RvcnMgZm9yIGEgZ2l2ZW4gbW9kdWxlL2NsYXNzXG4gIE9wYWwuYW5jZXN0b3JzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgaWYgKCFtb2R1bGUpIHsgcmV0dXJuIFtdOyB9XG5cbiAgICBpZiAobW9kdWxlLiQkYW5jZXN0b3JzX2NhY2hlX3ZlcnNpb24gPT09IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbikge1xuICAgICAgcmV0dXJuIG1vZHVsZS4kJGFuY2VzdG9ycztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW10sIGksIG1vZHMsIGxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIG1vZHMgPSBvd25fYW5jZXN0b3JzKG1vZHVsZSksIGxlbmd0aCA9IG1vZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKG1vZHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChtb2R1bGUuJCRzdXBlcikge1xuICAgICAgZm9yIChpID0gMCwgbW9kcyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZS4kJHN1cGVyKSwgbGVuZ3RoID0gbW9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChtb2RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcbiAgICBtb2R1bGUuJCRhbmNlc3RvcnMgPSByZXN1bHQ7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIE9wYWwuaW5jbHVkZWRfbW9kdWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kID0gbnVsbCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIGZvciAoOyBwcm90byAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pOyBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpIHtcbiAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgaWYgKG1vZCAmJiBtb2QuJCRpc19tb2R1bGUgJiYgcHJvdG8uJCRpY2xhc3MgJiYgcHJvdG8uJCRpbmNsdWRlZCkge1xuICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblxuICAvLyBNZXRob2QgTWlzc2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE1ldGhvZHMgc3R1YnMgYXJlIHVzZWQgdG8gZmFjaWxpdGF0ZSBtZXRob2RfbWlzc2luZyBpbiBvcGFsLiBBIHN0dWIgaXMgYVxuICAvLyBwbGFjZWhvbGRlciBmdW5jdGlvbiB3aGljaCBqdXN0IGNhbGxzIGBtZXRob2RfbWlzc2luZ2Agb24gdGhlIHJlY2VpdmVyLlxuICAvLyBJZiBubyBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBhY3R1YWxseSBkZWZpbmVkIG9uIGFuIG9iamVjdCwgdGhlbiBpdFxuICAvLyBpcyBvYnZpb3VzIHRvIHNheSB0aGF0IHRoZSBzdHViIHdpbGwgYmUgY2FsbGVkIGluc3RlYWQsIGFuZCB0aGVuIGluIHR1cm5cbiAgLy8gbWV0aG9kX21pc3Npbmcgd2lsbCBiZSBjYWxsZWQuXG4gIC8vXG4gIC8vIFdoZW4gYSBmaWxlIGluIHJ1YnkgZ2V0cyBjb21waWxlZCB0byBqYXZhc2NyaXB0LCBpdCBpbmNsdWRlcyBhIGNhbGwgdG9cbiAgLy8gdGhpcyBmdW5jdGlvbiB3aGljaCBhZGRzIHN0dWJzIGZvciBldmVyeSBtZXRob2QgbmFtZSBpbiB0aGUgY29tcGlsZWQgZmlsZS5cbiAgLy8gSXQgc2hvdWxkIHRoZW4gYmUgc2FmZSB0byBhc3N1bWUgdGhhdCBtZXRob2RfbWlzc2luZyB3aWxsIHdvcmsgZm9yIGFueVxuICAvLyBtZXRob2QgY2FsbCBkZXRlY3RlZC5cbiAgLy9cbiAgLy8gTWV0aG9kIHN0dWJzIGFyZSBhZGRlZCB0byB0aGUgQmFzaWNPYmplY3QgcHJvdG90eXBlLCB3aGljaCBldmVyeSBvdGhlclxuICAvLyBydWJ5IG9iamVjdCBpbmhlcml0cywgc28gYWxsIG9iamVjdHMgc2hvdWxkIGhhbmRsZSBtZXRob2QgbWlzc2luZy4gQSBzdHViXG4gIC8vIGlzIG9ubHkgYWRkZWQgaWYgdGhlIGdpdmVuIHByb3BlcnR5IG5hbWUgKG1ldGhvZCBuYW1lKSBpcyBub3QgYWxyZWFkeVxuICAvLyBkZWZpbmVkLlxuICAvL1xuICAvLyBOb3RlOiBhbGwgcnVieSBtZXRob2RzIGhhdmUgYSBgJGAgcHJlZml4IGluIGphdmFzY3JpcHQsIHNvIGFsbCBzdHVicyB3aWxsXG4gIC8vIGhhdmUgdGhpcyBwcmVmaXggYXMgd2VsbCAodG8gbWFrZSB0aGlzIG1ldGhvZCBtb3JlIHBlcmZvcm1hbnQpLlxuICAvL1xuICAvLyAgICBPcGFsLmFkZF9zdHVicyhbXCIkZm9vXCIsIFwiJGJhclwiLCBcIiRiYXo9XCJdKTtcbiAgLy9cbiAgLy8gQWxsIHN0dWIgZnVuY3Rpb25zIHdpbGwgaGF2ZSBhIHByaXZhdGUgYCQkc3R1YmAgcHJvcGVydHkgc2V0IHRvIHRydWUgc29cbiAgLy8gdGhhdCBvdGhlciBpbnRlcm5hbCBtZXRob2RzIGNhbiBkZXRlY3QgaWYgYSBtZXRob2QgaXMganVzdCBhIHN0dWIgb3Igbm90LlxuICAvLyBgS2VybmVsI3Jlc3BvbmRfdG8/YCB1c2VzIHRoaXMgcHJvcGVydHkgdG8gZGV0ZWN0IGEgbWV0aG9kcyBwcmVzZW5jZS5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0dWJzIFtBcnJheV0gYW4gYXJyYXkgb2YgbWV0aG9kIHN0dWJzIHRvIGFkZFxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuYWRkX3N0dWJzID0gZnVuY3Rpb24oc3R1YnMpIHtcbiAgICB2YXIgcHJvdG8gPSBPcGFsLkJhc2ljT2JqZWN0LiQkcHJvdG90eXBlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0dWJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3R1YiA9IHN0dWJzW2ldLCBleGlzdGluZ19tZXRob2QgPSBwcm90b1tzdHViXTtcblxuICAgICAgaWYgKGV4aXN0aW5nX21ldGhvZCA9PSBudWxsIHx8IGV4aXN0aW5nX21ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgT3BhbC5hZGRfc3R1Yl9mb3IocHJvdG8sIHN0dWIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYSBtZXRob2RfbWlzc2luZyBzdHViIGZ1bmN0aW9uIHRvIHRoZSBnaXZlbiBwcm90b3R5cGUgZm9yIHRoZVxuICAvLyBnaXZlbiBuYW1lLlxuICAvL1xuICAvLyBAcGFyYW0gcHJvdG90eXBlIFtQcm90b3R5cGVdIHRoZSB0YXJnZXQgcHJvdG90eXBlXG4gIC8vIEBwYXJhbSBzdHViIFtTdHJpbmddIHN0dWIgbmFtZSB0byBhZGQgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5hZGRfc3R1Yl9mb3IgPSBmdW5jdGlvbihwcm90b3R5cGUsIHN0dWIpIHtcbiAgICB2YXIgbWV0aG9kX21pc3Npbmdfc3R1YiA9IE9wYWwuc3R1Yl9mb3Ioc3R1Yik7XG4gICAgJGRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgc3R1YiwgbWV0aG9kX21pc3Npbmdfc3R1Yik7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgdGhlIG1ldGhvZF9taXNzaW5nIHN0dWIgZm9yIGEgZ2l2ZW4gbWV0aG9kIG5hbWUuXG4gIC8vXG4gIC8vIEBwYXJhbSBtZXRob2RfbmFtZSBbU3RyaW5nXSBUaGUganMtbmFtZSBvZiB0aGUgbWV0aG9kIHRvIHN0dWIgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5zdHViX2ZvciA9IGZ1bmN0aW9uKG1ldGhvZF9uYW1lKSB7XG5cbiAgICBmdW5jdGlvbiBtZXRob2RfbWlzc2luZ19zdHViKCkge1xuICAgICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXG4gICAgICAvLyBDb3B5IGFueSBnaXZlbiBibG9jayBvbnRvIHRoZSBtZXRob2RfbWlzc2luZyBkaXNwYXRjaGVyXG4gICAgICB0aGlzLiRtZXRob2RfbWlzc2luZy4kJHAgPSBtZXRob2RfbWlzc2luZ19zdHViLiQkcDtcblxuICAgICAgLy8gU2V0IGJsb2NrIHByb3BlcnR5IHRvIG51bGwgcmVhZHkgZm9yIHRoZSBuZXh0IGNhbGwgKHN0b3AgZmFsc2UtcG9zaXRpdmVzKVxuICAgICAgbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHAgPSBudWxsO1xuXG4gICAgICAvLyBjYWxsIG1ldGhvZCBtaXNzaW5nIHdpdGggY29ycmVjdCBhcmdzIChyZW1vdmUgJyQnIHByZWZpeCBvbiBtZXRob2QgbmFtZSlcbiAgICAgIHZhciBhcmdzX2FyeSA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmd1bWVudHNbaV07IH1cblxuICAgICAgcmV0dXJuIHRoaXMuJG1ldGhvZF9taXNzaW5nLmFwcGx5KHRoaXMsIFttZXRob2RfbmFtZS5zbGljZSgxKV0uY29uY2F0KGFyZ3NfYXJ5KSk7XG4gICAgfVxuXG4gICAgbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHN0dWIgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG1ldGhvZF9taXNzaW5nX3N0dWI7XG4gIH07XG5cblxuICAvLyBNZXRob2RzXG4gIC8vIC0tLS0tLS1cblxuICAvLyBBcml0eSBjb3VudCBlcnJvciBkaXNwYXRjaGVyIGZvciBtZXRob2RzXG4gIC8vXG4gIC8vIEBwYXJhbSBhY3R1YWwgW0ZpeG51bV0gbnVtYmVyIG9mIGFyZ3VtZW50cyBnaXZlbiB0byBtZXRob2RcbiAgLy8gQHBhcmFtIGV4cGVjdGVkIFtGaXhudW1dIGV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHBhcmFtIG9iamVjdCBbT2JqZWN0XSBvd25lciBvZiB0aGUgbWV0aG9kICttZXRoK1xuICAvLyBAcGFyYW0gbWV0aCBbU3RyaW5nXSBtZXRob2QgbmFtZSB0aGF0IGdvdCB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzXG4gIC8vIEByYWlzZSBbQXJndW1lbnRFcnJvcl1cbiAgT3BhbC5hYyA9IGZ1bmN0aW9uKGFjdHVhbCwgZXhwZWN0ZWQsIG9iamVjdCwgbWV0aCkge1xuICAgIHZhciBpbnNwZWN0ID0gJyc7XG4gICAgaWYgKG9iamVjdC4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICBpbnNwZWN0ICs9IG9iamVjdC4kJG5hbWUgKyAnLic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaW5zcGVjdCArPSBvYmplY3QuJCRjbGFzcy4kJG5hbWUgKyAnIyc7XG4gICAgfVxuICAgIGluc3BlY3QgKz0gbWV0aDtcblxuICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdbJyArIGluc3BlY3QgKyAnXSB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzKCcgKyBhY3R1YWwgKyAnIGZvciAnICsgZXhwZWN0ZWQgKyAnKScpO1xuICB9O1xuXG4gIC8vIEFyaXR5IGNvdW50IGVycm9yIGRpc3BhdGNoZXIgZm9yIGJsb2Nrc1xuICAvL1xuICAvLyBAcGFyYW0gYWN0dWFsIFtGaXhudW1dIG51bWJlciBvZiBhcmd1bWVudHMgZ2l2ZW4gdG8gYmxvY2tcbiAgLy8gQHBhcmFtIGV4cGVjdGVkIFtGaXhudW1dIGV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHNcbiAgLy8gQHBhcmFtIGNvbnRleHQgW09iamVjdF0gY29udGV4dCBvZiB0aGUgYmxvY2sgZGVmaW5pdGlvblxuICAvLyBAcmFpc2UgW0FyZ3VtZW50RXJyb3JdXG4gIE9wYWwuYmxvY2tfYWMgPSBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBjb250ZXh0KSB7XG4gICAgdmFyIGluc3BlY3QgPSBcImBibG9jayBpbiBcIiArIGNvbnRleHQgKyBcIidcIjtcblxuICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KGluc3BlY3QgKyAnOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgnICsgYWN0dWFsICsgJyBmb3IgJyArIGV4cGVjdGVkICsgJyknKTtcbiAgfTtcblxuICAvLyBTdXBlciBkaXNwYXRjaGVyXG4gIE9wYWwuZmluZF9zdXBlcl9kaXNwYXRjaGVyID0gZnVuY3Rpb24ob2JqLCBtaWQsIGN1cnJlbnRfZnVuYywgZGVmY2hlY2ssIGFsbG93X3N0dWJzKSB7XG4gICAgdmFyIGpzaWQgPSAnJCcgKyBtaWQsIGFuY2VzdG9ycywgc3VwZXJfbWV0aG9kO1xuXG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSgnJCRtZXRhJykpIHtcbiAgICAgIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG9iai4kJG1ldGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvYmouJCRjbGFzcyk7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRfaW5kZXggPSBhbmNlc3RvcnMuaW5kZXhPZihjdXJyZW50X2Z1bmMuJCRvd25lcik7XG5cbiAgICBmb3IgKHZhciBpID0gY3VycmVudF9pbmRleCArIDE7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcbiAgICAgICAgICBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eShqc2lkKSkge1xuICAgICAgICBzdXBlcl9tZXRob2QgPSBwcm90b1tqc2lkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkZWZjaGVjayAmJiBzdXBlcl9tZXRob2QgJiYgc3VwZXJfbWV0aG9kLiQkc3R1YiAmJiBvYmouJG1ldGhvZF9taXNzaW5nLiQkcHJpc3RpbmUpIHtcbiAgICAgIC8vIG1ldGhvZF9taXNzaW5nIGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgZGVmaW5lZFxuICAgICAgdGhyb3cgT3BhbC5Ob01ldGhvZEVycm9yLiRuZXcoJ3N1cGVyOiBubyBzdXBlcmNsYXNzIG1ldGhvZCBgJyttaWQrXCInIGZvciBcIitvYmosIG1pZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChzdXBlcl9tZXRob2QuJCRzdHViICYmICFhbGxvd19zdHVicykgPyBudWxsIDogc3VwZXJfbWV0aG9kO1xuICB9O1xuXG4gIC8vIEl0ZXIgZGlzcGF0Y2hlciBmb3Igc3VwZXIgaW4gYSBibG9ja1xuICBPcGFsLmZpbmRfaXRlcl9zdXBlcl9kaXNwYXRjaGVyID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBpbXBsaWNpdCkge1xuICAgIHZhciBjYWxsX2pzaWQgPSBqc2lkO1xuXG4gICAgaWYgKCFjdXJyZW50X2Z1bmMpIHtcbiAgICAgIHRocm93IE9wYWwuUnVudGltZUVycm9yLiRuZXcoXCJzdXBlciBjYWxsZWQgb3V0c2lkZSBvZiBtZXRob2RcIik7XG4gICAgfVxuXG4gICAgaWYgKGltcGxpY2l0ICYmIGN1cnJlbnRfZnVuYy4kJGRlZmluZV9tZXRoKSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFwiaW1wbGljaXQgYXJndW1lbnQgcGFzc2luZyBvZiBzdXBlciBmcm9tIG1ldGhvZCBkZWZpbmVkIGJ5IGRlZmluZV9tZXRob2QoKSBpcyBub3Qgc3VwcG9ydGVkLiBTcGVjaWZ5IGFsbCBhcmd1bWVudHMgZXhwbGljaXRseVwiKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudF9mdW5jLiQkZGVmKSB7XG4gICAgICBjYWxsX2pzaWQgPSBjdXJyZW50X2Z1bmMuJCRqc2lkO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLmZpbmRfc3VwZXJfZGlzcGF0Y2hlcihvYmosIGNhbGxfanNpZCwgY3VycmVudF9mdW5jLCBkZWZjaGVjayk7XG4gIH07XG5cbiAgLy8gVXNlZCB0byByZXR1cm4gYXMgYW4gZXhwcmVzc2lvbi4gU29tZXRpbWVzLCB3ZSBjYW4ndCBzaW1wbHkgcmV0dXJuIGZyb21cbiAgLy8gYSBqYXZhc2NyaXB0IGZ1bmN0aW9uIGFzIGlmIHdlIHdlcmUgYSBtZXRob2QsIGFzIHRoZSByZXR1cm4gaXMgdXNlZCBhc1xuICAvLyBhbiBleHByZXNzaW9uLCBvciBldmVuIGluc2lkZSBhIGJsb2NrIHdoaWNoIG11c3QgXCJyZXR1cm5cIiB0byB0aGUgb3V0ZXJcbiAgLy8gbWV0aG9kLiBUaGlzIGhlbHBlciBzaW1wbHkgdGhyb3dzIGFuIGVycm9yIHdoaWNoIGlzIHRoZW4gY2F1Z2h0IGJ5IHRoZVxuICAvLyBtZXRob2QuIFRoaXMgYXBwcm9hY2ggaXMgZXhwZW5zaXZlLCBzbyBpdCBpcyBvbmx5IHVzZWQgd2hlbiBhYnNvbHV0ZWx5XG4gIC8vIG5lZWRlZC5cbiAgLy9cbiAgT3BhbC5yZXQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICBPcGFsLnJldHVybmVyLiR2ID0gdmFsO1xuICAgIHRocm93IE9wYWwucmV0dXJuZXI7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBicmVhayBvdXQgb2YgYSBibG9jay5cbiAgT3BhbC5icmsgPSBmdW5jdGlvbih2YWwsIGJyZWFrZXIpIHtcbiAgICBicmVha2VyLiR2ID0gdmFsO1xuICAgIHRocm93IGJyZWFrZXI7XG4gIH07XG5cbiAgLy8gQnVpbGRzIGEgbmV3IHVuaXF1ZSBicmVha2VyLCB0aGlzIGlzIHRvIGF2b2lkIG11bHRpcGxlIG5lc3RlZCBicmVha3MgdG8gZ2V0XG4gIC8vIGluIHRoZSB3YXkgb2YgZWFjaCBvdGhlci5cbiAgT3BhbC5uZXdfYnJrID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcigndW5leHBlY3RlZCBicmVhaycpO1xuICB9O1xuXG4gIC8vIGhhbmRsZXMgeWllbGQgY2FsbHMgZm9yIDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZDEgPSBmdW5jdGlvbihibG9jaywgYXJnKSB7XG4gICAgaWYgKHR5cGVvZihibG9jaykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgT3BhbC5Mb2NhbEp1bXBFcnJvci4kbmV3KFwibm8gYmxvY2sgZ2l2ZW5cIik7XG4gICAgfVxuXG4gICAgdmFyIGhhc19tbGhzID0gYmxvY2suJCRoYXNfdG9wX2xldmVsX21saHNfYXJnLFxuICAgICAgICBoYXNfdHJhaWxpbmdfY29tbWEgPSBibG9jay4kJGhhc190cmFpbGluZ19jb21tYV9pbl9hcmdzO1xuXG4gICAgaWYgKGJsb2NrLmxlbmd0aCA+IDEgfHwgKChoYXNfbWxocyB8fCBoYXNfdHJhaWxpbmdfY29tbWEpICYmIGJsb2NrLmxlbmd0aCA9PT0gMSkpIHtcbiAgICAgIGFyZyA9IE9wYWwudG9fYXJ5KGFyZyk7XG4gICAgfVxuXG4gICAgaWYgKChibG9jay5sZW5ndGggPiAxIHx8IChoYXNfdHJhaWxpbmdfY29tbWEgJiYgYmxvY2subGVuZ3RoID09PSAxKSkgJiYgYXJnLiQkaXNfYXJyYXkpIHtcbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBibG9jayhhcmcpO1xuICAgIH1cbiAgfTtcblxuICAvLyBoYW5kbGVzIHlpZWxkIGZvciA+IDEgeWllbGRlZCBhcmdcbiAgT3BhbC55aWVsZFggPSBmdW5jdGlvbihibG9jaywgYXJncykge1xuICAgIGlmICh0eXBlb2YoYmxvY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IE9wYWwuTG9jYWxKdW1wRXJyb3IuJG5ldyhcIm5vIGJsb2NrIGdpdmVuXCIpO1xuICAgIH1cblxuICAgIGlmIChibG9jay5sZW5ndGggPiAxICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoYXJnc1swXS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzWzBdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFyZ3MuJCRpc19hcnJheSkge1xuICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGwgPSBhcmdzX2FyeS5sZW5ndGg7IGkgPCBsOyBpKyspIHsgYXJnc19hcnlbaV0gPSBhcmdzW2ldOyB9XG5cbiAgICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzX2FyeSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9O1xuXG4gIC8vIEZpbmRzIHRoZSBjb3JyZXNwb25kaW5nIGV4Y2VwdGlvbiBtYXRjaCBpbiBjYW5kaWRhdGVzLiAgRWFjaCBjYW5kaWRhdGUgY2FuXG4gIC8vIGJlIGEgdmFsdWUsIG9yIGFuIGFycmF5IG9mIHZhbHVlcy4gIFJldHVybnMgbnVsbCBpZiBub3QgZm91bmQuXG4gIE9wYWwucmVzY3VlID0gZnVuY3Rpb24oZXhjZXB0aW9uLCBjYW5kaWRhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYW5kaWRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcblxuICAgICAgaWYgKGNhbmRpZGF0ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBPcGFsLnJlc2N1ZShleGNlcHRpb24sIGNhbmRpZGF0ZSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZSA9PT0gT3BhbC5KUy5FcnJvcikge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoY2FuZGlkYXRlWyckPT09J10oZXhjZXB0aW9uKSkge1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIE9wYWwuaXNfYSA9IGZ1bmN0aW9uKG9iamVjdCwga2xhc3MpIHtcbiAgICBpZiAoa2xhc3MgIT0gbnVsbCAmJiBvYmplY3QuJCRtZXRhID09PSBrbGFzcyB8fCBvYmplY3QuJCRjbGFzcyA9PT0ga2xhc3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvYmplY3QuJCRpc19udW1iZXIgJiYga2xhc3MuJCRpc19udW1iZXJfY2xhc3MpIHtcbiAgICAgIHJldHVybiAoa2xhc3MuJCRpc19pbnRlZ2VyX2NsYXNzKSA/IChvYmplY3QgJSAxKSA9PT0gMCA6IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGksIGxlbmd0aCwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMob2JqZWN0LiQkaXNfY2xhc3MgPyBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KSA6IChvYmplY3QuJCRtZXRhIHx8IG9iamVjdC4kJGNsYXNzKSk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhbmNlc3RvcnNbaV0gPT09IGtsYXNzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBIZWxwZXJzIGZvciBleHRyYWN0aW5nIGt3c3BsYXRzXG4gIC8vIFVzZWQgZm9yOiB7ICoqaCB9XG4gIE9wYWwudG9faGFzaCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLiQkaXNfaGFzaCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2hhc2gnLCB0cnVlKSkge1xuICAgICAgdmFyIGhhc2ggPSB2YWx1ZS4kdG9faGFzaCgpO1xuICAgICAgaWYgKGhhc2guJCRpc19oYXNoKSB7XG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXG4gICAgICAgICAgXCIgdG8gSGFzaCAoXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIjdG9faGFzaCBnaXZlcyBcIiArIGhhc2guJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiBcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiBpbnRvIEhhc2hcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIEhlbHBlcnMgZm9yIGltcGxlbWVudGluZyBtdWx0aXBsZSBhc3NpZ25tZW50XG4gIC8vIE91ciBjb2RlIGZvciBleHRyYWN0aW5nIHRoZSB2YWx1ZXMgYW5kIGFzc2lnbmluZyB0aGVtIG9ubHkgd29ya3MgaWYgdGhlXG4gIC8vIHJldHVybiB2YWx1ZSBpcyBhIEpTIGFycmF5LlxuICAvLyBTbyBpZiB3ZSBnZXQgYW4gQXJyYXkgc3ViY2xhc3MsIGV4dHJhY3QgdGhlIHdyYXBwZWQgSlMgYXJyYXkgZnJvbSBpdFxuXG4gIC8vIFVzZWQgZm9yOiBhLCBiID0gc29tZXRoaW5nIChubyBzcGxhdClcbiAgT3BhbC50b19hcnkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlWyckcmVzcG9uZF90bz8nXSgndG9fYXJ5JywgdHJ1ZSkpIHtcbiAgICAgIHZhciBhcnkgPSB2YWx1ZS4kdG9fYXJ5KCk7XG4gICAgICBpZiAoYXJ5ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcnkuJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gYXJ5O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXG4gICAgICAgICAgXCIgdG8gQXJyYXkgKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2FyeSBnaXZlcyBcIiArIGFyeS4kJGNsYXNzICsgXCIpXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgIH1cbiAgfTtcblxuICAvLyBVc2VkIGZvcjogYSwgYiA9ICpzb21ldGhpbmcgKHdpdGggc3BsYXQpXG4gIE9wYWwudG9fYSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpIHtcbiAgICAgIC8vIEEgc3BsYXR0ZWQgYXJyYXkgbXVzdCBiZSBjb3BpZWRcbiAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2EnLCB0cnVlKSkge1xuICAgICAgdmFyIGFyeSA9IHZhbHVlLiR0b19hKCk7XG4gICAgICBpZiAoYXJ5ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcnkuJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gYXJ5O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJDYW4ndCBjb252ZXJ0IFwiICsgdmFsdWUuJCRjbGFzcyArXG4gICAgICAgICAgXCIgdG8gQXJyYXkgKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2EgZ2l2ZXMgXCIgKyBhcnkuJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCBmb3IgZXh0cmFjdGluZyBrZXl3b3JkIGFyZ3VtZW50cyBmcm9tIGFyZ3VtZW50cyBwYXNzZWQgdG9cbiAgLy8gSlMgZnVuY3Rpb24uIElmIHByb3ZpZGVkICthcmd1bWVudHMrIGxpc3QgZG9lc24ndCBoYXZlIGEgSGFzaFxuICAvLyBhcyBhIGxhc3QgaXRlbSwgcmV0dXJucyBhIGJsYW5rIEhhc2guXG4gIC8vXG4gIC8vIEBwYXJhbSBwYXJhbWV0ZXJzIFtBcnJheV1cbiAgLy8gQHJldHVybiBbSGFzaF1cbiAgLy9cbiAgT3BhbC5leHRyYWN0X2t3YXJncyA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICB2YXIga3dhcmdzID0gcGFyYW1ldGVyc1twYXJhbWV0ZXJzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChrd2FyZ3MgIT0gbnVsbCAmJiBPcGFsLnJlc3BvbmRfdG8oa3dhcmdzLCAnJHRvX2hhc2gnLCB0cnVlKSkge1xuICAgICAgJHNwbGljZS5jYWxsKHBhcmFtZXRlcnMsIHBhcmFtZXRlcnMubGVuZ3RoIC0gMSwgMSk7XG4gICAgICByZXR1cm4ga3dhcmdzLiR0b19oYXNoKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIE9wYWwuaGFzaDIoW10sIHt9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCB0byBnZXQgYSBsaXN0IG9mIHJlc3Qga2V5d29yZCBhcmd1bWVudHMuIE1ldGhvZCB0YWtlcyB0aGUgZ2l2ZW5cbiAgLy8ga2V5d29yZCBhcmdzLCBpLmUuIHRoZSBoYXNoIGxpdGVyYWwgcGFzc2VkIHRvIHRoZSBtZXRob2QgY29udGFpbmluZyBhbGxcbiAgLy8ga2V5d29yZCBhcmd1ZW1udHMgcGFzc2VkIHRvIG1ldGhvZCwgYXMgd2VsbCBhcyB0aGUgdXNlZCBhcmdzIHdoaWNoIGFyZVxuICAvLyB0aGUgbmFtZXMgb2YgcmVxdWlyZWQgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cyBkZWZpbmVkLiBUaGlzIG1ldGhvZCB0aGVuXG4gIC8vIGp1c3QgcmV0dXJucyBhbGwga2V5L3ZhbHVlIHBhaXJzIHdoaWNoIGhhdmUgbm90IGJlZW4gdXNlZCwgaW4gYSBuZXdcbiAgLy8gaGFzaCBsaXRlcmFsLlxuICAvL1xuICAvLyBAcGFyYW0gZ2l2ZW5fYXJncyBbSGFzaF0gYWxsIGt3YXJncyBnaXZlbiB0byBtZXRob2RcbiAgLy8gQHBhcmFtIHVzZWRfYXJncyBbT2JqZWN0PFN0cmluZzogdHJ1ZT5dIGFsbCBrZXlzIHVzZWQgYXMgbmFtZWQga3dhcmdzXG4gIC8vIEByZXR1cm4gW0hhc2hdXG4gIC8vXG4gIE9wYWwua3dyZXN0YXJncyA9IGZ1bmN0aW9uKGdpdmVuX2FyZ3MsIHVzZWRfYXJncykge1xuICAgIHZhciBrZXlzICAgICAgPSBbXSxcbiAgICAgICAgbWFwICAgICAgID0ge30sXG4gICAgICAgIGtleSAgICAgICAgICAgLFxuICAgICAgICBnaXZlbl9tYXAgPSBnaXZlbl9hcmdzLiQkc21hcDtcblxuICAgIGZvciAoa2V5IGluIGdpdmVuX21hcCkge1xuICAgICAgaWYgKCF1c2VkX2FyZ3Nba2V5XSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgbWFwW2tleV0gPSBnaXZlbl9tYXBba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5oYXNoMihrZXlzLCBtYXApO1xuICB9O1xuXG4gIC8vIENhbGxzIHBhc3NlZCBtZXRob2Qgb24gYSBydWJ5IG9iamVjdCB3aXRoIGFyZ3VtZW50cyBhbmQgYmxvY2s6XG4gIC8vXG4gIC8vIENhbiB0YWtlIGEgbWV0aG9kIG9yIGEgbWV0aG9kIG5hbWUuXG4gIC8vXG4gIC8vIDEuIFdoZW4gbWV0aG9kIG5hbWUgZ2V0cyBwYXNzZWQgaXQgaW52b2tlcyBpdCBieSBpdHMgbmFtZVxuICAvLyAgICBhbmQgY2FsbHMgJ21ldGhvZF9taXNzaW5nJyB3aGVuIG9iamVjdCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2QuXG4gIC8vICAgIFVzZWQgaW50ZXJuYWxseSBieSBPcGFsIHRvIGludm9rZSBtZXRob2QgdGhhdCB0YWtlcyBhIGJsb2NrIG9yIGEgc3BsYXQuXG4gIC8vIDIuIFdoZW4gbWV0aG9kIChpLmUuIG1ldGhvZCBib2R5KSBnZXRzIHBhc3NlZCwgaXQgZG9lc24ndCB0cmlnZ2VyICdtZXRob2RfbWlzc2luZydcbiAgLy8gICAgYmVjYXVzZSBpdCBkb2Vzbid0IGtub3cgdGhlIG5hbWUgb2YgdGhlIGFjdHVhbCBtZXRob2QuXG4gIC8vICAgIFVzZWQgaW50ZXJuYWxseSBieSBPcGFsIHRvIGludm9rZSAnc3VwZXInLlxuICAvL1xuICAvLyBAZXhhbXBsZVxuICAvLyAgIHZhciBteV9hcnJheSA9IFsxLCAyLCAzLCA0XVxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgJ2xlbmd0aCcpICAgICAgICAgICAgICAgICAgICAjID0+IDRcbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksIG15X2FycmF5LiRsZW5ndGgpICAgICAgICAgICAgIyA9PiA0XG4gIC8vXG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCAncmV2ZXJzZSEnKSAgICAgICAgICAgICAgICAgICMgPT4gWzQsIDMsIDIsIDFdXG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCBteV9hcnJheVsnJHJldmVyc2UhJ10nKSAgICAgICMgPT4gWzQsIDMsIDIsIDFdXG4gIC8vXG4gIC8vIEBwYXJhbSByZWN2IFtPYmplY3RdIHJ1Ynkgb2JqZWN0XG4gIC8vIEBwYXJhbSBtZXRob2QgW0Z1bmN0aW9uLCBTdHJpbmddIG1ldGhvZCBib2R5IG9yIG5hbWUgb2YgdGhlIG1ldGhvZFxuICAvLyBAcGFyYW0gYXJncyBbQXJyYXldIGFyZ3VtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBtZXRob2QgY2FsbFxuICAvLyBAcGFyYW0gYmxvY2sgW0Z1bmN0aW9uXSBydWJ5IGJsb2NrXG4gIC8vIEByZXR1cm4gW09iamVjdF0gcmV0dXJuaW5nIHZhbHVlIG9mIHRoZSBtZXRob2QgY2FsbFxuICBPcGFsLnNlbmQgPSBmdW5jdGlvbihyZWN2LCBtZXRob2QsIGFyZ3MsIGJsb2NrKSB7XG4gICAgdmFyIGJvZHk7XG5cbiAgICBpZiAodHlwZW9mKG1ldGhvZCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJvZHkgPSBtZXRob2Q7XG4gICAgICBtZXRob2QgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mKG1ldGhvZCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBib2R5ID0gcmVjdlsnJCcrbWV0aG9kXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIlBhc3NlZCBtZXRob2Qgc2hvdWxkIGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wYWwuc2VuZDIocmVjdiwgYm9keSwgbWV0aG9kLCBhcmdzLCBibG9jayk7XG4gIH07XG5cbiAgT3BhbC5zZW5kMiA9IGZ1bmN0aW9uKHJlY3YsIGJvZHksIG1ldGhvZCwgYXJncywgYmxvY2spIHtcbiAgICBpZiAoYm9keSA9PSBudWxsICYmIG1ldGhvZCAhPSBudWxsICYmIHJlY3YuJG1ldGhvZF9taXNzaW5nKSB7XG4gICAgICBib2R5ID0gcmVjdi4kbWV0aG9kX21pc3Npbmc7XG4gICAgICBhcmdzID0gW21ldGhvZF0uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIGJvZHkuJCRwID0gYmxvY2s7XG4gICAgcmV0dXJuIGJvZHkuYXBwbHkocmVjdiwgYXJncyk7XG4gIH07XG5cbiAgT3BhbC5sYW1iZGEgPSBmdW5jdGlvbihibG9jaykge1xuICAgIGJsb2NrLiQkaXNfbGFtYmRhID0gdHJ1ZTtcbiAgICByZXR1cm4gYmxvY2s7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBkZWZpbmUgbWV0aG9kcyBvbiBhbiBvYmplY3QuIFRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kLCB1c2VkIGJ5IHRoZVxuICAvLyBjb21waWxlZCBzb3VyY2UgdG8gZGVmaW5lIG1ldGhvZHMgb24gc3BlY2lhbCBjYXNlIG9iamVjdHMgd2hlbiB0aGUgY29tcGlsZXJcbiAgLy8gY2FuIG5vdCBkZXRlcm1pbmUgdGhlIGRlc3RpbmF0aW9uIG9iamVjdCwgb3IgdGhlIG9iamVjdCBpcyBhIE1vZHVsZVxuICAvLyBpbnN0YW5jZS4gVGhpcyBjYW4gZ2V0IGNhbGxlZCBieSBgTW9kdWxlI2RlZmluZV9tZXRob2RgIGFzIHdlbGwuXG4gIC8vXG4gIC8vICMjIE1vZHVsZXNcbiAgLy9cbiAgLy8gQW55IG1ldGhvZCBkZWZpbmVkIG9uIGEgbW9kdWxlIHdpbGwgY29tZSB0aHJvdWdoIHRoaXMgcnVudGltZSBoZWxwZXIuXG4gIC8vIFRoZSBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG1vZHVsZSBib2R5LCBhbmQgdGhlIG93bmVyIG9mIHRoZSBtZXRob2QgaXNcbiAgLy8gc2V0IHRvIGJlIHRoZSBtb2R1bGUgaXRzZWxmLiBUaGlzIGlzIHVzZWQgbGF0ZXIgd2hlbiBjaG9vc2luZyB3aGljaFxuICAvLyBtZXRob2Qgc2hvdWxkIHNob3cgb24gYSBjbGFzcyBpZiBtb3JlIHRoYW4gMSBpbmNsdWRlZCBtb2R1bGVzIGRlZmluZVxuICAvLyB0aGUgc2FtZSBtZXRob2QuIEZpbmFsbHksIGlmIHRoZSBtb2R1bGUgaXMgaW4gYG1vZHVsZV9mdW5jdGlvbmAgbW9kZSxcbiAgLy8gdGhlbiB0aGUgbWV0aG9kIGlzIGFsc28gZGVmaW5lZCBvbnRvIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAvL1xuICAvLyAjIyBDbGFzc2VzXG4gIC8vXG4gIC8vIFRoaXMgaGVscGVyIHdpbGwgb25seSBiZSBjYWxsZWQgZm9yIGNsYXNzZXMgd2hlbiBhIG1ldGhvZCBpcyBiZWluZ1xuICAvLyBkZWZpbmVkIGluZGlyZWN0bHk7IGVpdGhlciB0aHJvdWdoIGBNb2R1bGUjZGVmaW5lX21ldGhvZGAsIG9yIGJ5IGFcbiAgLy8gbGl0ZXJhbCBgZGVmYCBtZXRob2QgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBvciBgY2xhc3NfZXZhbGAgYm9keS4gSW5cbiAgLy8gZWl0aGVyIGNhc2UsIHRoZSBtZXRob2QgaXMgc2ltcGx5IGFkZGVkIHRvIHRoZSBjbGFzcycgcHJvdG90eXBlLiBBIHNwZWNpYWxcbiAgLy8gZXhjZXB0aW9uIGV4aXN0cyBmb3IgYEJhc2ljT2JqZWN0YCBhbmQgYE9iamVjdGAuIFRoZXNlIHR3byBjbGFzc2VzIGFyZVxuICAvLyBzcGVjaWFsIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbiB0b2xsLWZyZWUgYnJpZGdlZCBjbGFzc2VzLiBJbiBlYWNoIG9mXG4gIC8vIHRoZXNlIHR3byBjYXNlcywgZXh0cmEgd29yayBpcyByZXF1aXJlZCB0byBkZWZpbmUgdGhlIG1ldGhvZHMgb24gdG9sbC1mcmVlXG4gIC8vIGJyaWRnZWQgY2xhc3MnIHByb3RvdHlwZXMgYXMgd2VsbC5cbiAgLy9cbiAgLy8gIyMgT2JqZWN0c1xuICAvL1xuICAvLyBJZiBhIHNpbXBsZSBydWJ5IG9iamVjdCBpcyB0aGUgb2JqZWN0LCB0aGVuIHRoZSBtZXRob2QgaXMgc2ltcGx5IGp1c3RcbiAgLy8gZGVmaW5lZCBvbiB0aGUgb2JqZWN0IGFzIGEgc2luZ2xldG9uIG1ldGhvZC4gVGhpcyB3b3VsZCBiZSB0aGUgY2FzZSB3aGVuXG4gIC8vIGEgbWV0aG9kIGlzIGRlZmluZWQgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBibG9jay5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iaiAgW09iamVjdCwgQ2xhc3NdIHRoZSBhY3R1YWwgb2JqIHRvIGRlZmluZSBtZXRob2QgZm9yXG4gIC8vIEBwYXJhbSBqc2lkIFtTdHJpbmddIHRoZSBKYXZhU2NyaXB0IGZyaWVuZGx5IG1ldGhvZCBuYW1lIChlLmcuICckZm9vJylcbiAgLy8gQHBhcmFtIGJvZHkgW0pTLkZ1bmN0aW9uXSB0aGUgbGl0ZXJhbCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHVzZWQgYXMgbWV0aG9kXG4gIC8vIEByZXR1cm4gW251bGxdXG4gIC8vXG4gIE9wYWwuZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBib2R5KSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIG1ldGhvZCBkZWZpbml0aW9uIGluIHRoZVxuICAgIC8vIHRvcC1sZXZlbCBuYW1lc3BhY2VcbiAgICBpZiAob2JqID09PSBPcGFsLnRvcCkge1xuICAgICAgT3BhbC5kZWZuKE9wYWwuT2JqZWN0LCBqc2lkLCBib2R5KVxuICAgIH1cbiAgICAvLyBpZiBpbnN0YW5jZV9ldmFsIGlzIGludm9rZWQgb24gYSBtb2R1bGUvY2xhc3MsIGl0IHNldHMgaW5zdF9ldmFsX21vZFxuICAgIGVsc2UgaWYgKCFvYmouJCRldmFsICYmIG9iai4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICBPcGFsLmRlZm4ob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBPcGFsLmRlZnMob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVmaW5lIG1ldGhvZCBvbiBhIG1vZHVsZSBvciBjbGFzcyAoc2VlIE9wYWwuZGVmKS5cbiAgT3BhbC5kZWZuID0gZnVuY3Rpb24obW9kdWxlLCBqc2lkLCBib2R5KSB7XG4gICAgYm9keS5kaXNwbGF5TmFtZSA9IGpzaWQ7XG4gICAgYm9keS4kJG93bmVyID0gbW9kdWxlO1xuXG4gICAgdmFyIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlO1xuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuICAgICRkZWZpbmVQcm9wZXJ0eShwcm90bywganNpZCwgYm9keSk7XG5cbiAgICBpZiAobW9kdWxlLiQkaXNfbW9kdWxlKSB7XG4gICAgICBpZiAobW9kdWxlLiQkbW9kdWxlX2Z1bmN0aW9uKSB7XG4gICAgICAgIE9wYWwuZGVmcyhtb2R1bGUsIGpzaWQsIGJvZHkpXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpY2xhc3NlcyA9IG1vZHVsZS4kJGljbGFzc2VzLCBsZW5ndGggPSBpY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWNsYXNzID0gaWNsYXNzZXNbaV07XG4gICAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsIGpzaWQsIGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaW5nbGV0b25fb2YgPSBtb2R1bGUuJCRzaW5nbGV0b25fb2Y7XG4gICAgaWYgKG1vZHVsZS4kbWV0aG9kX2FkZGVkICYmICFtb2R1bGUuJG1ldGhvZF9hZGRlZC4kJHN0dWIgJiYgIXNpbmdsZXRvbl9vZikge1xuICAgICAgbW9kdWxlLiRtZXRob2RfYWRkZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaW5nbGV0b25fb2YgJiYgc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkICYmICFzaW5nbGV0b25fb2YuJHNpbmdsZXRvbl9tZXRob2RfYWRkZWQuJCRzdHViKSB7XG4gICAgICBzaW5nbGV0b25fb2YuJHNpbmdsZXRvbl9tZXRob2RfYWRkZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEZWZpbmUgYSBzaW5nbGV0b24gbWV0aG9kIG9uIHRoZSBnaXZlbiBvYmplY3QgKHNlZSBPcGFsLmRlZikuXG4gIE9wYWwuZGVmcyA9IGZ1bmN0aW9uKG9iaiwganNpZCwgYm9keSkge1xuICAgIGlmIChvYmouJCRpc19zdHJpbmcgfHwgb2JqLiQkaXNfbnVtYmVyKSB7XG4gICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiY2FuJ3QgZGVmaW5lIHNpbmdsZXRvblwiKTtcbiAgICB9XG4gICAgT3BhbC5kZWZuKE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopLCBqc2lkLCBib2R5KVxuICB9O1xuXG4gIC8vIENhbGxlZCBmcm9tICNyZW1vdmVfbWV0aG9kLlxuICBPcGFsLnJkZWYgPSBmdW5jdGlvbihvYmosIGpzaWQpIHtcbiAgICBpZiAoISRoYXNfb3duLmNhbGwob2JqLiQkcHJvdG90eXBlLCBqc2lkKSkge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb2JqLiQkcHJvdG90eXBlW2pzaWRdO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkICYmICFvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF9yZW1vdmVkICYmICFvYmouJG1ldGhvZF9yZW1vdmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJG1ldGhvZF9yZW1vdmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGZyb20gI3VuZGVmX21ldGhvZC5cbiAgT3BhbC51ZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkKSB7XG4gICAgaWYgKCFvYmouJCRwcm90b3R5cGVbanNpZF0gfHwgb2JqLiQkcHJvdG90eXBlW2pzaWRdLiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBPcGFsLmFkZF9zdHViX2ZvcihvYmouJCRwcm90b3R5cGUsIGpzaWQpO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQuJCRzdHViKSB7XG4gICAgICAgIG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kbWV0aG9kX3VuZGVmaW5lZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiRtZXRob2RfdW5kZWZpbmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfbWV0aG9kX2JvZHkoYm9keSkge1xuICAgIHJldHVybiAodHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViKTtcbiAgfVxuXG4gIE9wYWwuYWxpYXMgPSBmdW5jdGlvbihvYmosIG5hbWUsIG9sZCkge1xuICAgIHZhciBpZCAgICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBvbGRfaWQgPSAnJCcgKyBvbGQsXG4gICAgICAgIGJvZHkgICA9IG9iai4kJHByb3RvdHlwZVsnJCcgKyBvbGRdLFxuICAgICAgICBhbGlhcztcblxuICAgIC8vIFdoZW4gcnVubmluZyBpbnNpZGUgI2luc3RhbmNlX2V2YWwgdGhlIGFsaWFzIHJlZmVycyB0byBjbGFzcyBtZXRob2RzLlxuICAgIGlmIChvYmouJCRldmFsKSB7XG4gICAgICByZXR1cm4gT3BhbC5hbGlhcyhPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwgbmFtZSwgb2xkKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBvYmouJCRzdXBlcjtcblxuICAgICAgd2hpbGUgKHR5cGVvZihib2R5KSAhPT0gXCJmdW5jdGlvblwiICYmIGFuY2VzdG9yKSB7XG4gICAgICAgIGJvZHkgICAgID0gYW5jZXN0b3Jbb2xkX2lkXTtcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci4kJHN1cGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpICYmIG9iai4kJGlzX21vZHVsZSkge1xuICAgICAgICAvLyB0cnkgdG8gbG9vayBpbnRvIE9iamVjdFxuICAgICAgICBib2R5ID0gT3BhbC5PYmplY3QuJCRwcm90b3R5cGVbb2xkX2lkXVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGBcIiArIG9sZCArIFwiJyBmb3IgY2xhc3MgYFwiICsgb2JqLiRuYW1lKCkgKyBcIidcIilcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYm9keSBpcyBpdHNlbGYgYW4gYWxpYXMgdXNlIHRoZSBvcmlnaW5hbCBib2R5XG4gICAgLy8gdG8ga2VlcCB0aGUgbWF4IGRlcHRoIGF0IDEuXG4gICAgaWYgKGJvZHkuJCRhbGlhc19vZikgYm9keSA9IGJvZHkuJCRhbGlhc19vZjtcblxuICAgIC8vIFdlIG5lZWQgYSB3cmFwcGVyIGJlY2F1c2Ugb3RoZXJ3aXNlIHByb3BlcnRpZXNcbiAgICAvLyB3b3VsZCBiZSBvdmVyd3JpdHRlbiBvbiB0aGUgb3JpZ2luYWwgYm9keS5cbiAgICBhbGlhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJsb2NrID0gYWxpYXMuJCRwLCBhcmdzLCBpLCBpaTtcblxuICAgICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcihpID0gMCwgaWkgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT0gbnVsbCkgeyBhbGlhcy4kJHAgPSBudWxsIH1cblxuICAgICAgcmV0dXJuIE9wYWwuc2VuZCh0aGlzLCBib2R5LCBhcmdzLCBibG9jayk7XG4gICAgfTtcblxuICAgIC8vIEFzc2lnbiB0aGUgJ2xlbmd0aCcgdmFsdWUgd2l0aCBkZWZpbmVQcm9wZXJ0eSBiZWNhdXNlXG4gICAgLy8gaW4gc3RyaWN0IG1vZGUgdGhlIHByb3BlcnR5IGlzIG5vdCB3cml0YWJsZS5cbiAgICAvLyBJdCBkb2Vzbid0IHdvcmsgaW4gb2xkZXIgYnJvd3NlcnMgKGxpa2UgQ2hyb21lIDM4KSwgd2hlcmVcbiAgICAvLyBhbiBleGNlcHRpb24gaXMgdGhyb3duIGJyZWFraW5nIE9wYWwgYWx0b2dldGhlci5cbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFsaWFzLCAnbGVuZ3RoJywgeyB2YWx1ZTogYm9keS5sZW5ndGggfSk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIFRyeSB0byBtYWtlIHRoZSBicm93c2VyIHBpY2sgdGhlIHJpZ2h0IG5hbWVcbiAgICBhbGlhcy5kaXNwbGF5TmFtZSAgICAgICA9IG5hbWU7XG5cbiAgICBhbGlhcy4kJGFyaXR5ICAgICAgICAgICA9IGJvZHkuJCRhcml0eTtcbiAgICBhbGlhcy4kJHBhcmFtZXRlcnMgICAgICA9IGJvZHkuJCRwYXJhbWV0ZXJzO1xuICAgIGFsaWFzLiQkc291cmNlX2xvY2F0aW9uID0gYm9keS4kJHNvdXJjZV9sb2NhdGlvbjtcbiAgICBhbGlhcy4kJGFsaWFzX29mICAgICAgICA9IGJvZHk7XG4gICAgYWxpYXMuJCRhbGlhc19uYW1lICAgICAgPSBuYW1lO1xuXG4gICAgT3BhbC5kZWZuKG9iaiwgaWQsIGFsaWFzKTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgT3BhbC5hbGlhc19uYXRpdmUgPSBmdW5jdGlvbihvYmosIG5hbWUsIG5hdGl2ZV9uYW1lKSB7XG4gICAgdmFyIGlkICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBib2R5ID0gb2JqLiQkcHJvdG90eXBlW25hdGl2ZV9uYW1lXTtcblxuICAgIGlmICh0eXBlb2YoYm9keSkgIT09IFwiZnVuY3Rpb25cIiB8fCBib2R5LiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcInVuZGVmaW5lZCBuYXRpdmUgbWV0aG9kIGBcIiArIG5hdGl2ZV9uYW1lICsgXCInIGZvciBjbGFzcyBgXCIgKyBvYmouJG5hbWUoKSArIFwiJ1wiKVxuICAgIH1cblxuICAgIE9wYWwuZGVmbihvYmosIGlkLCBib2R5KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cblxuICAvLyBIYXNoZXNcbiAgLy8gLS0tLS0tXG5cbiAgT3BhbC5oYXNoX2luaXQgPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgaGFzaC4kJHNtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IFtdO1xuICB9O1xuXG4gIE9wYWwuaGFzaF9jbG9uZSA9IGZ1bmN0aW9uKGZyb21faGFzaCwgdG9faGFzaCkge1xuICAgIHRvX2hhc2guJCRub25lID0gZnJvbV9oYXNoLiQkbm9uZTtcbiAgICB0b19oYXNoLiQkcHJvYyA9IGZyb21faGFzaC4kJHByb2M7XG5cbiAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IGZyb21faGFzaC4kJGtleXMsIHNtYXAgPSBmcm9tX2hhc2guJCRzbWFwLCBsZW4gPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHZhbHVlID0gc21hcFtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICB9XG5cbiAgICAgIE9wYWwuaGFzaF9wdXQodG9faGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9wdXQgPSBmdW5jdGlvbihoYXNoLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIGhhc2guJCRrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICAgIGhhc2guJCRzbWFwW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5X2hhc2gsIGJ1Y2tldCwgbGFzdF9idWNrZXQ7XG4gICAga2V5X2hhc2ggPSBoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKTtcblxuICAgIGlmICghJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIGJ1Y2tldCA9IHtrZXk6IGtleSwga2V5X2hhc2g6IGtleV9oYXNoLCB2YWx1ZTogdmFsdWV9O1xuICAgICAgaGFzaC4kJGtleXMucHVzaChidWNrZXQpO1xuICAgICAgaGFzaC4kJG1hcFtrZXlfaGFzaF0gPSBidWNrZXQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG5cbiAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICBpZiAoa2V5ID09PSBidWNrZXQua2V5IHx8IGtleVsnJGVxbD8nXShidWNrZXQua2V5KSkge1xuICAgICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnVja2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGFzdF9idWNrZXQgPSBidWNrZXQ7XG4gICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICB9XG5cbiAgICBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgIGJ1Y2tldCA9IHtrZXk6IGtleSwga2V5X2hhc2g6IGtleV9oYXNoLCB2YWx1ZTogdmFsdWV9O1xuICAgICAgaGFzaC4kJGtleXMucHVzaChidWNrZXQpO1xuICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGJ1Y2tldDtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX2dldCA9IGZ1bmN0aW9uKGhhc2gsIGtleSkge1xuICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgIGlmICgkaGFzX293bi5jYWxsKGhhc2guJCRzbWFwLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCwgYnVja2V0O1xuICAgIGtleV9oYXNoID0gaGFzaC4kJGJ5X2lkZW50aXR5ID8gT3BhbC5pZChrZXkpIDoga2V5LiRoYXNoKCk7XG5cbiAgICBpZiAoJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdO1xuXG4gICAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGJ1Y2tldC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX2RlbGV0ZSA9IGZ1bmN0aW9uKGhhc2gsIGtleSkge1xuICAgIHZhciBpLCBrZXlzID0gaGFzaC4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCB2YWx1ZTtcblxuICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSBrZXkgPSBrZXkudmFsdWVPZigpO1xuXG4gICAgICBpZiAoISRoYXNfb3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGtleXNbaV0gPT09IGtleSkge1xuICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gaGFzaC4kJHNtYXBba2V5XTtcbiAgICAgIGRlbGV0ZSBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCA9IGtleS4kaGFzaCgpO1xuXG4gICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBidWNrZXQgPSBoYXNoLiQkbWFwW2tleV9oYXNoXSwgbGFzdF9idWNrZXQ7XG5cbiAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICBpZiAoa2V5ID09PSBidWNrZXQua2V5IHx8IGtleVsnJGVxbD8nXShidWNrZXQua2V5KSkge1xuICAgICAgICB2YWx1ZSA9IGJ1Y2tldC52YWx1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoa2V5c1tpXSA9PT0gYnVja2V0KSB7XG4gICAgICAgICAgICBrZXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0X2J1Y2tldCAmJiBidWNrZXQubmV4dCkge1xuICAgICAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBidWNrZXQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXN0X2J1Y2tldCkge1xuICAgICAgICAgIGRlbGV0ZSBsYXN0X2J1Y2tldC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgaGFzaC4kJG1hcFtrZXlfaGFzaF0gPSBidWNrZXQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgaGFzaC4kJG1hcFtrZXlfaGFzaF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBsYXN0X2J1Y2tldCA9IGJ1Y2tldDtcbiAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2hfcmVoYXNoID0gZnVuY3Rpb24oaGFzaCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBoYXNoLiQka2V5cy5sZW5ndGgsIGtleV9oYXNoLCBidWNrZXQsIGxhc3RfYnVja2V0OyBpIDwgbGVuZ3RoOyBpKyspIHtcblxuICAgICAgaWYgKGhhc2guJCRrZXlzW2ldLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBrZXlfaGFzaCA9IGhhc2guJCRrZXlzW2ldLmtleS4kaGFzaCgpO1xuXG4gICAgICBpZiAoa2V5X2hhc2ggPT09IGhhc2guJCRrZXlzW2ldLmtleV9oYXNoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBidWNrZXQgPSBoYXNoLiQkbWFwW2hhc2guJCRrZXlzW2ldLmtleV9oYXNoXTtcbiAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAoYnVja2V0KSB7XG4gICAgICAgIGlmIChidWNrZXQgPT09IGhhc2guJCRrZXlzW2ldKSB7XG4gICAgICAgICAgaWYgKGxhc3RfYnVja2V0ICYmIGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgICBsYXN0X2J1Y2tldC5uZXh0ID0gYnVja2V0Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICAgICAgICBkZWxldGUgbGFzdF9idWNrZXQubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICAgIGhhc2guJCRtYXBbaGFzaC4kJGtleXNbaV0ua2V5X2hhc2hdID0gYnVja2V0Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGhhc2guJCRtYXBbaGFzaC4kJGtleXNbaV0ua2V5X2hhc2hdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsYXN0X2J1Y2tldCA9IGJ1Y2tldDtcbiAgICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGhhc2guJCRrZXlzW2ldLmtleV9oYXNoID0ga2V5X2hhc2g7XG5cbiAgICAgIGlmICghJGhhc19vd24uY2FsbChoYXNoLiQkbWFwLCBrZXlfaGFzaCkpIHtcbiAgICAgICAgaGFzaC4kJG1hcFtrZXlfaGFzaF0gPSBoYXNoLiQka2V5c1tpXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdO1xuICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgICAgaWYgKGJ1Y2tldCA9PT0gaGFzaC4kJGtleXNbaV0pIHtcbiAgICAgICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsYXN0X2J1Y2tldCA9IGJ1Y2tldDtcbiAgICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXN0X2J1Y2tldCkge1xuICAgICAgICBsYXN0X2J1Y2tldC5uZXh0ID0gaGFzaC4kJGtleXNbaV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmd1bWVudHNfbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncywgaGFzaCwgaSwgbGVuZ3RoLCBrZXksIHZhbHVlO1xuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdLiQkaXNfaGFzaCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICB9XG5cbiAgICBoYXNoID0gbmV3IE9wYWwuSGFzaCgpO1xuICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdLiQkaXNfYXJyYXkpIHtcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcmdzW2ldLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KFwidmFsdWUgbm90IG9mIGxlbmd0aCAyOiBcIiArIGFyZ3NbaV0uJGluc3BlY3QoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSBhcmdzW2ldWzBdO1xuICAgICAgICB2YWx1ZSA9IGFyZ3NbaV1bMV07XG5cbiAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggPT09IDEpIHtcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IgKGtleSBpbiBhcmdzKSB7XG4gICAgICAgIGlmICgkaGFzX293bi5jYWxsKGFyZ3MsIGtleSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGFyZ3Nba2V5XTtcblxuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50c19sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcIm9kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoXCIpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHNfbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzW2kgKyAxXTtcblxuICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBBIGZhc3RlciBIYXNoIGNyZWF0b3IgZm9yIGhhc2hlcyB0aGF0IGp1c3QgdXNlIHN5bWJvbHMgYW5kXG4gIC8vIHN0cmluZ3MgYXMga2V5cy4gVGhlIG1hcCBhbmQga2V5cyBhcnJheSBjYW4gYmUgY29uc3RydWN0ZWQgYXRcbiAgLy8gY29tcGlsZSB0aW1lLCBzbyB0aGV5IGFyZSBqdXN0IGFkZGVkIGhlcmUgYnkgdGhlIGNvbnN0cnVjdG9yXG4gIC8vIGZ1bmN0aW9uLlxuICAvL1xuICBPcGFsLmhhc2gyID0gZnVuY3Rpb24oa2V5cywgc21hcCkge1xuICAgIHZhciBoYXNoID0gbmV3IE9wYWwuSGFzaCgpO1xuXG4gICAgaGFzaC4kJHNtYXAgPSBzbWFwO1xuICAgIGhhc2guJCRtYXAgID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBoYXNoLiQka2V5cyA9IGtleXM7XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgcmFuZ2UgaW5zdGFuY2Ugd2l0aCBmaXJzdCBhbmQgbGFzdCB2YWx1ZXMsIGFuZCB3aGV0aGVyIHRoZVxuICAvLyByYW5nZSBleGNsdWRlcyB0aGUgbGFzdCB2YWx1ZS5cbiAgLy9cbiAgT3BhbC5yYW5nZSA9IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCBleGMpIHtcbiAgICB2YXIgcmFuZ2UgICAgICAgICA9IG5ldyBPcGFsLlJhbmdlKCk7XG4gICAgICAgIHJhbmdlLmJlZ2luICAgPSBmaXJzdDtcbiAgICAgICAgcmFuZ2UuZW5kICAgICA9IGxhc3Q7XG4gICAgICAgIHJhbmdlLmV4Y2wgICAgPSBleGM7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBpdmFyIG5hbWUgZm9yIGEgZ2l2ZW4gbmFtZS5cbiAgLy8gTW9zdGx5IGFkZHMgYSB0cmFpbGluZyAkIHRvIHJlc2VydmVkIG5hbWVzLlxuICAvL1xuICBPcGFsLml2YXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG4gICAgICAgIG5hbWUgPT09IFwiY29uc3RydWN0b3JcIiB8fFxuICAgICAgICBuYW1lID09PSBcImRpc3BsYXlOYW1lXCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJfX2NvdW50X19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fbm9TdWNoTWV0aG9kX19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fcGFyZW50X19cIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8XG5cbiAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICBuYW1lID09PSBcImhhc093blByb3BlcnR5XCIgfHxcbiAgICAgICAgbmFtZSA9PT0gXCJ2YWx1ZU9mXCJcbiAgICAgICApXG4gICAge1xuICAgICAgcmV0dXJuIG5hbWUgKyBcIiRcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcblxuXG4gIC8vIFJlZ2V4cHNcbiAgLy8gLS0tLS0tLVxuXG4gIC8vIEVzY2FwZSBSZWdleHAgc3BlY2lhbCBjaGFycyBsZXR0aW5nIHRoZSByZXN1bHRpbmcgc3RyaW5nIGJlIHVzZWQgdG8gYnVpbGRcbiAgLy8gYSBuZXcgUmVnZXhwLlxuICAvL1xuICBPcGFsLmVzY2FwZV9yZWdleHAgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLVtcXF1cXC97fSgpKis/Ll4kXFxcXHwgXSkvZywgJ1xcXFwkMScpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxuXS9nLCAnXFxcXG4nKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xccl0vZywgJ1xcXFxyJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXGZdL2csICdcXFxcZicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx0XS9nLCAnXFxcXHQnKTtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBnbG9iYWwgUmVnZXhwIGZyb20gYSBSZWdFeHAgb2JqZWN0IGFuZCBjYWNoZSB0aGUgcmVzdWx0XG4gIC8vIG9uIHRoZSBvYmplY3QgaXRzZWxmICgkJGcgYXR0cmlidXRlKS5cbiAgLy9cbiAgT3BhbC5nbG9iYWxfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIGlmIChwYXR0ZXJuLmdsb2JhbCkge1xuICAgICAgcmV0dXJuIHBhdHRlcm47IC8vIFJlZ0V4cCBhbHJlYWR5IGhhcyB0aGUgZ2xvYmFsIGZsYWdcbiAgICB9XG4gICAgaWYgKHBhdHRlcm4uJCRnID09IG51bGwpIHtcbiAgICAgIHBhdHRlcm4uJCRnID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgKHBhdHRlcm4ubXVsdGlsaW5lID8gJ2dtJyA6ICdnJykgKyAocGF0dGVybi5pZ25vcmVDYXNlID8gJ2knIDogJycpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybi4kJGcubGFzdEluZGV4ID0gbnVsbDsgLy8gcmVzZXQgbGFzdEluZGV4IHByb3BlcnR5XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuLiQkZztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBnbG9iYWwgbXVsdGlsaW5lIFJlZ2V4cCBmcm9tIGEgUmVnRXhwIG9iamVjdCBhbmQgY2FjaGUgdGhlIHJlc3VsdFxuICAvLyBvbiB0aGUgb2JqZWN0IGl0c2VsZiAoJCRnbSBvciAkJGcgYXR0cmlidXRlKS5cbiAgLy9cbiAgT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cCA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChwYXR0ZXJuLm11bHRpbGluZSkge1xuICAgICAgaWYgKHBhdHRlcm4uZ2xvYmFsKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuOyAvLyBSZWdFeHAgYWxyZWFkeSBoYXMgdGhlIGdsb2JhbCBhbmQgbXVsdGlsaW5lIGZsYWdcbiAgICAgIH1cbiAgICAgIC8vIHdlIGFyZSB1c2luZyB0aGUgJCRnIGF0dHJpYnV0ZSBiZWNhdXNlIHRoZSBSZWdleHAgaXMgYWxyZWFkeSBtdWx0aWxpbmVcbiAgICAgIGlmIChwYXR0ZXJuLiQkZyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IHBhdHRlcm4uJCRnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGcgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAnZ20nICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXR0ZXJuLiQkZ20gIT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGdtO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBwYXR0ZXJuLiQkZ20gPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAnZ20nICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSk7XG4gICAgfVxuICAgIHJlc3VsdC5sYXN0SW5kZXggPSBudWxsOyAvLyByZXNldCBsYXN0SW5kZXggcHJvcGVydHlcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbWJpbmUgbXVsdGlwbGUgcmVnZXhwIHBhcnRzIHRvZ2V0aGVyXG4gIE9wYWwucmVnZXhwID0gZnVuY3Rpb24ocGFydHMsIGZsYWdzKSB7XG4gICAgdmFyIHBhcnQ7XG4gICAgdmFyIGlnbm9yZUNhc2UgPSB0eXBlb2YgZmxhZ3MgIT09ICd1bmRlZmluZWQnICYmIGZsYWdzICYmIGZsYWdzLmluZGV4T2YoJ2knKSA+PSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgaWYgKHBhcnQuaWdub3JlQ2FzZSAhPT0gaWdub3JlQ2FzZSlcbiAgICAgICAgICBPcGFsLktlcm5lbC4kd2FybihcbiAgICAgICAgICAgIFwiaWdub3JlIGNhc2UgZG9lc24ndCBtYXRjaCBmb3IgXCIgKyBwYXJ0LnNvdXJjZS4kaW5zcGVjdCgpLFxuICAgICAgICAgICAgT3BhbC5oYXNoKHt1cGxldmVsOiAxfSlcbiAgICAgICAgICApXG5cbiAgICAgICAgcGFydCA9IHBhcnQuc291cmNlO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQgPT09ICcnKSBwYXJ0ID0gJyg/OicgKyBwYXJ0ICsgJyknO1xuICAgICAgcGFydHNbaV0gPSBwYXJ0O1xuICAgIH1cblxuICAgIGlmIChmbGFncykge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGFydHMuam9pbignJyksIGZsYWdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGFydHMuam9pbignJykpO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXF1aXJlIHN5c3RlbVxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIE9wYWwubW9kdWxlcyAgICAgICAgID0ge307XG4gIE9wYWwubG9hZGVkX2ZlYXR1cmVzID0gWydjb3JlbGliL3J1bnRpbWUnXTtcbiAgT3BhbC5jdXJyZW50X2RpciAgICAgPSAnLic7XG4gIE9wYWwucmVxdWlyZV90YWJsZSAgID0geydjb3JlbGliL3J1bnRpbWUnOiB0cnVlfTtcblxuICBPcGFsLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICB2YXIgcGFydHMsIHBhcnQsIG5ld19wYXJ0cyA9IFtdLCBTRVBBUkFUT1IgPSAnLyc7XG5cbiAgICBpZiAoT3BhbC5jdXJyZW50X2RpciAhPT0gJy4nKSB7XG4gICAgICBwYXRoID0gT3BhbC5jdXJyZW50X2Rpci5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyBwYXRoO1xuICAgIH1cblxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC5cXC8vLCAnJyk7XG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwuKHJifG9wYWx8anMpJC8sICcnKTtcbiAgICBwYXJ0cyA9IHBhdGguc3BsaXQoU0VQQVJBVE9SKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0ID09PSAnJykgY29udGludWU7XG4gICAgICAocGFydCA9PT0gJy4uJykgPyBuZXdfcGFydHMucG9wKCkgOiBuZXdfcGFydHMucHVzaChwYXJ0KVxuICAgIH1cblxuICAgIHJldHVybiBuZXdfcGFydHMuam9pbihTRVBBUkFUT1IpO1xuICB9O1xuXG4gIE9wYWwubG9hZGVkID0gZnVuY3Rpb24ocGF0aHMpIHtcbiAgICB2YXIgaSwgbCwgcGF0aDtcblxuICAgIGZvciAoaSA9IDAsIGwgPSBwYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoc1tpXSk7XG5cbiAgICAgIGlmIChPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIE9wYWwubG9hZGVkX2ZlYXR1cmVzLnB1c2gocGF0aCk7XG4gICAgICBPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0gPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBPcGFsLmxvYWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGgpO1xuXG4gICAgT3BhbC5sb2FkZWQoW3BhdGhdKTtcblxuICAgIHZhciBtb2R1bGUgPSBPcGFsLm1vZHVsZXNbcGF0aF07XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICBtb2R1bGUoT3BhbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNldmVyaXR5ID0gT3BhbC5jb25maWcubWlzc2luZ19yZXF1aXJlX3NldmVyaXR5O1xuICAgICAgdmFyIG1lc3NhZ2UgID0gJ2Nhbm5vdCBsb2FkIHN1Y2ggZmlsZSAtLSAnICsgcGF0aDtcblxuICAgICAgaWYgKHNldmVyaXR5ID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgaWYgKE9wYWwuTG9hZEVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgT3BhbC5Mb2FkRXJyb3IuJG5ldyhtZXNzYWdlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG1lc3NhZ2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2V2ZXJpdHkgPT09IFwid2FybmluZ1wiKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogTG9hZEVycm9yOiAnICsgbWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgT3BhbC5yZXF1aXJlID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcblxuICAgIGlmIChPcGFsLnJlcXVpcmVfdGFibGVbcGF0aF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5sb2FkKHBhdGgpO1xuICB9O1xuXG5cbiAgLy8gU3RyaW5nc1xuICAvLyAtLS0tLS0tXG5cbiAgT3BhbC5lbmNvZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIFNldHMgdGhlIGVuY29kaW5nIG9uIGEgc3RyaW5nLCB3aWxsIHRyZWF0IHN0cmluZyBsaXRlcmFscyBhcyBmcm96ZW4gc3RyaW5nc1xuICAvLyByYWlzaW5nIGEgRnJvemVuRXJyb3IuXG4gIC8vXG4gIC8vIEBwYXJhbSBzdHIgW1N0cmluZ10gdGhlIHN0cmluZyBvbiB3aGljaCB0aGUgZW5jb2Rpbmcgc2hvdWxkIGJlIHNldFxuICAvLyBAcGFyYW0gbmFtZSBbU3RyaW5nXSB0aGUgY2Fub25pY2FsIG5hbWUgb2YgdGhlIGVuY29kaW5nXG4gIC8vIEBwYXJhbSB0eXBlIFtTdHJpbmddIHBvc3NpYmxlIHZhbHVlcyBhcmUgZWl0aGVyIGBcImVuY29kaW5nXCJgLCBgXCJpbnRlcm5hbF9lbmNvZGluZ1wiYCwgb3IgYHVuZGVmaW5lZFxuICBPcGFsLnNldF9lbmNvZGluZyA9IGZ1bmN0aW9uKHN0ciwgbmFtZSwgdHlwZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJ1bmRlZmluZWRcIikgdHlwZSA9IFwiZW5jb2RpbmdcIjtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyLiQkZnJvemVuID09PSB0cnVlKVxuICAgICAgdGhyb3cgT3BhbC5Gcm96ZW5FcnJvci4kbmV3KFwiY2FuJ3QgbW9kaWZ5IGZyb3plbiBTdHJpbmdcIik7XG5cbiAgICB2YXIgZW5jb2RpbmcgPSBPcGFsLmZpbmRfZW5jb2RpbmcobmFtZSk7XG5cbiAgICBpZiAoZW5jb2RpbmcgPT09IHN0clt0eXBlXSkgeyByZXR1cm4gc3RyOyB9XG5cbiAgICBzdHJbdHlwZV0gPSBlbmNvZGluZztcblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLy8gRmV0Y2hlcyB0aGUgZW5jb2RpbmcgZm9yIHRoZSBnaXZlbiBuYW1lIG9yIHJhaXNlcyBBcmd1bWVudEVycm9yLlxuICBPcGFsLmZpbmRfZW5jb2RpbmcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHJlZ2lzdGVyID0gT3BhbC5lbmNvZGluZ3M7XG4gICAgdmFyIGVuY29kaW5nID0gcmVnaXN0ZXJbbmFtZV0gfHwgcmVnaXN0ZXJbbmFtZS50b1VwcGVyQ2FzZSgpXTtcbiAgICBpZiAoIWVuY29kaW5nKSB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcInVua25vd24gZW5jb2RpbmcgbmFtZSAtIFwiICsgbmFtZSk7XG4gICAgcmV0dXJuIGVuY29kaW5nO1xuICB9XG5cbiAgLy8gQHJldHVybnMgYSBTdHJpbmcgb2JqZWN0IHdpdGggdGhlIGVuY29kaW5nIHNldCBmcm9tIGEgc3RyaW5nIGxpdGVyYWxcbiAgT3BhbC5lbmMgPSBmdW5jdGlvbihzdHIsIG5hbWUpIHtcbiAgICB2YXIgZHVwID0gbmV3IFN0cmluZyhzdHIpO1xuICAgIGR1cCA9IE9wYWwuc2V0X2VuY29kaW5nKGR1cCwgbmFtZSk7XG4gICAgZHVwLmludGVybmFsX2VuY29kaW5nID0gZHVwLmVuY29kaW5nO1xuICAgIHJldHVybiBkdXBcbiAgfVxuXG4gIC8vIEByZXR1cm5zIGEgU3RyaW5nIG9iamVjdCB3aXRoIHRoZSBpbnRlcm5hbCBlbmNvZGluZyBzZXQgdG8gQmluYXJ5XG4gIE9wYWwuYmluYXJ5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIGR1cCA9IG5ldyBTdHJpbmcoc3RyKTtcbiAgICByZXR1cm4gT3BhbC5zZXRfZW5jb2RpbmcoZHVwLCBcImJpbmFyeVwiLCBcImludGVybmFsX2VuY29kaW5nXCIpO1xuICB9XG5cblxuICAvLyBJbml0aWFsaXphdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLVxuICBmdW5jdGlvbiAkQmFzaWNPYmplY3QoKSB7fVxuICBmdW5jdGlvbiAkT2JqZWN0KCkge31cbiAgZnVuY3Rpb24gJE1vZHVsZSgpIHt9XG4gIGZ1bmN0aW9uICRDbGFzcygpIHt9XG5cbiAgT3BhbC5CYXNpY09iamVjdCA9IEJhc2ljT2JqZWN0ID0gT3BhbC5hbGxvY2F0ZV9jbGFzcygnQmFzaWNPYmplY3QnLCBudWxsLCAkQmFzaWNPYmplY3QpO1xuICBPcGFsLk9iamVjdCAgICAgID0gX09iamVjdCAgICAgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKCdPYmplY3QnLCBPcGFsLkJhc2ljT2JqZWN0LCAkT2JqZWN0KTtcbiAgT3BhbC5Nb2R1bGUgICAgICA9IE1vZHVsZSAgICAgID0gT3BhbC5hbGxvY2F0ZV9jbGFzcygnTW9kdWxlJywgT3BhbC5PYmplY3QsICRNb2R1bGUpO1xuICBPcGFsLkNsYXNzICAgICAgID0gQ2xhc3MgICAgICAgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKCdDbGFzcycsIE9wYWwuTW9kdWxlLCAkQ2xhc3MpO1xuXG4gICRzZXRfcHJvdG8oT3BhbC5CYXNpY09iamVjdCwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG4gICRzZXRfcHJvdG8oT3BhbC5PYmplY3QsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuICAkc2V0X3Byb3RvKE9wYWwuTW9kdWxlLCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcbiAgJHNldF9wcm90byhPcGFsLkNsYXNzLCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcblxuICAvLyBCYXNpY09iamVjdCBjYW4gcmVhY2ggaXRzZWxmLCBhdm9pZCBjb25zdF9zZXQgdG8gc2tpcCB0aGUgJCRiYXNlX21vZHVsZSBsb2dpY1xuICBCYXNpY09iamVjdC4kJGNvbnN0W1wiQmFzaWNPYmplY3RcIl0gPSBCYXNpY09iamVjdDtcblxuICAvLyBBc3NpZ24gYmFzaWMgY29uc3RhbnRzXG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiQmFzaWNPYmplY3RcIiwgIEJhc2ljT2JqZWN0KTtcbiAgT3BhbC5jb25zdF9zZXQoX09iamVjdCwgXCJPYmplY3RcIiwgICAgICAgX09iamVjdCk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiTW9kdWxlXCIsICAgICAgIE1vZHVsZSk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsIFwiQ2xhc3NcIiwgICAgICAgIENsYXNzKTtcblxuICAvLyBGaXggYm9vdGVkIGNsYXNzZXMgdG8gaGF2ZSBjb3JyZWN0IC5jbGFzcyB2YWx1ZVxuICBCYXNpY09iamVjdC4kJGNsYXNzID0gQ2xhc3M7XG4gIF9PYmplY3QuJCRjbGFzcyAgICAgPSBDbGFzcztcbiAgTW9kdWxlLiQkY2xhc3MgICAgICA9IENsYXNzO1xuICBDbGFzcy4kJGNsYXNzICAgICAgID0gQ2xhc3M7XG5cbiAgLy8gRm9yd2FyZCAudG9TdHJpbmcoKSB0byAjdG9fc1xuICAkZGVmaW5lUHJvcGVydHkoX09iamVjdC4kJHByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRvX3MgPSB0aGlzLiR0b19zKCk7XG4gICAgaWYgKHRvX3MuJCRpc19zdHJpbmcgJiYgdHlwZW9mKHRvX3MpID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gYSBzdHJpbmcgY3JlYXRlZCB1c2luZyBuZXcgU3RyaW5nKCdzdHJpbmcnKVxuICAgICAgcmV0dXJuIHRvX3MudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdG9fcztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE1ha2UgS2VybmVsI3JlcXVpcmUgaW1tZWRpYXRlbHkgYXZhaWxhYmxlIGFzIGl0J3MgbmVlZGVkIHRvIHJlcXVpcmUgYWxsIHRoZVxuICAvLyBvdGhlciBjb3JlbGliIGZpbGVzLlxuICAkZGVmaW5lUHJvcGVydHkoX09iamVjdC4kJHByb3RvdHlwZSwgJyRyZXF1aXJlJywgT3BhbC5yZXF1aXJlKTtcblxuICAvLyBJbnN0YW50aWF0ZSB0aGUgbWFpbiBvYmplY3RcbiAgT3BhbC50b3AgPSBuZXcgX09iamVjdCgpO1xuICBPcGFsLnRvcC4kdG9fcyA9IE9wYWwudG9wLiRpbnNwZWN0ID0gZnVuY3Rpb24oKSB7IHJldHVybiAnbWFpbicgfTtcbiAgT3BhbC50b3AuJGRlZmluZV9tZXRob2QgPSB0b3BfZGVmaW5lX21ldGhvZDtcblxuICAvLyBGb3dhcmQgY2FsbHMgdG8gZGVmaW5lX21ldGhvZCBvbiB0aGUgdG9wIG9iamVjdCB0byBPYmplY3RcbiAgZnVuY3Rpb24gdG9wX2RlZmluZV9tZXRob2QoKSB7XG4gICAgdmFyIGFyZ3MgPSBPcGFsLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICB2YXIgYmxvY2sgPSB0b3BfZGVmaW5lX21ldGhvZC4kJHA7XG4gICAgdG9wX2RlZmluZV9tZXRob2QuJCRwID0gbnVsbDtcbiAgICByZXR1cm4gT3BhbC5zZW5kKF9PYmplY3QsICdkZWZpbmVfbWV0aG9kJywgYXJncywgYmxvY2spXG4gIH07XG5cblxuICAvLyBOaWxcbiAgZnVuY3Rpb24gJE5pbENsYXNzKCkge31cbiAgT3BhbC5OaWxDbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ05pbENsYXNzJywgT3BhbC5PYmplY3QsICROaWxDbGFzcyk7XG4gIE9wYWwuY29uc3Rfc2V0KF9PYmplY3QsICdOaWxDbGFzcycsIE9wYWwuTmlsQ2xhc3MpO1xuICBuaWwgPSBPcGFsLm5pbCA9IG5ldyBPcGFsLk5pbENsYXNzKCk7XG4gIG5pbC4kJGlkID0gbmlsX2lkO1xuICBuaWwuY2FsbCA9IG5pbC5hcHBseSA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBPcGFsLkxvY2FsSnVtcEVycm9yLiRuZXcoJ25vIGJsb2NrIGdpdmVuJyk7IH07XG5cbiAgLy8gRXJyb3JzXG4gIE9wYWwuYnJlYWtlciAgPSBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYnJlYWsgKG9sZCknKTtcbiAgT3BhbC5yZXR1cm5lciA9IG5ldyBFcnJvcigndW5leHBlY3RlZCByZXR1cm4nKTtcbiAgVHlwZUVycm9yLiQkc3VwZXIgPSBFcnJvcjtcbn0pLmNhbGwodGhpcyk7XG5PcGFsLmxvYWRlZChbXCJjb3JlbGliL3J1bnRpbWUuanNcIl0pOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7O0FBRUo7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJO0FBQ0E7O0FBRUo7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTs7QUFFRjtBQUNFOztBQUVGO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVKO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDSTs7QUFFSjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7O0FBR0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVFO0FBQ0U7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNKO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNKO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNFOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Q7QUFDSDtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ1U7QUFDQTtBQUNBO0FBQ0E7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFRjtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQSJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjAxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9oZWxwZXJzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHlwZV9lcnJvciwgY29lcmNlX3RvXG5cbm1vZHVsZSBPcGFsXG4gIGRlZiBzZWxmLmJyaWRnZShjb25zdHJ1Y3Rvciwga2xhc3MpXG4gICAgYE9wYWwuYnJpZGdlKGNvbnN0cnVjdG9yLCBrbGFzcylgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvZXJjZV90byEob2JqZWN0LCB0eXBlLCBtZXRob2QsICphcmdzKVxuICAgIGNvZXJjZWQgPSBgJGNvZXJjZV90byhvYmplY3QsIHR5cGUsIG1ldGhvZCwgYXJncylgXG5cbiAgICB1bmxlc3MgdHlwZSA9PT0gY29lcmNlZFxuICAgICAgcmFpc2UgYCR0eXBlX2Vycm9yKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKWBcbiAgICBlbmRcblxuICAgIGNvZXJjZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29lcmNlX3RvPyhvYmplY3QsIHR5cGUsIG1ldGhvZCwgKmFyZ3MpXG4gICAgcmV0dXJuIHVubGVzcyBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG5cbiAgICBjb2VyY2VkID0gYCRjb2VyY2VfdG8ob2JqZWN0LCB0eXBlLCBtZXRob2QsIGFyZ3MpYFxuXG4gICAgcmV0dXJuIGlmIGNvZXJjZWQubmlsP1xuXG4gICAgdW5sZXNzIHR5cGUgPT09IGNvZXJjZWRcbiAgICAgIHJhaXNlIGAkdHlwZV9lcnJvcihvYmplY3QsIHR5cGUsIG1ldGhvZCwgY29lcmNlZClgXG4gICAgZW5kXG5cbiAgICBjb2VyY2VkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iamVjdCwgdHlwZSwgbWV0aG9kKVxuICAgIHJldHVybiBvYmplY3QgaWYgdHlwZSA9PT0gb2JqZWN0XG5cbiAgICBpZiBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG4gICAgICBvYmplY3QuX19zZW5kX18gbWV0aG9kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbXBhcmUoYSwgYilcbiAgICBjb21wYXJlID0gYSA8PT4gYlxuXG4gICAgaWYgYGNvbXBhcmUgPT09IG5pbGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2EuY2xhc3N9IHdpdGggI3tiLmNsYXNzfSBmYWlsZWRcIlxuICAgIGVuZFxuXG4gICAgY29tcGFyZVxuICBlbmRcblxuICBkZWYgc2VsZi5kZXN0cnVjdHVyZShhcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmdzLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3NbaV07IH1cblxuICAgICAgICByZXR1cm4gYXJnc19hcnk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5yZXNwb25kX3RvPyhvYmosIG1ldGhvZCwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICAleHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCB8fCAhb2JqLiQkY2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9iai5yZXNwb25kX3RvPyhtZXRob2QsIGluY2x1ZGVfYWxsKVxuICBlbmRcblxuICBkZWYgc2VsZi5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNvZXJjZV90byEobmFtZSwgU3RyaW5nLCA6dG9fc3RyKVxuXG4gICAgdW5sZXNzIGAvXkBbYS16QS1aX11bYS16QS1aMC05X10qPyQvLnRlc3QobmFtZSlgXG4gICAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwiJyN7bmFtZX0nIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGluc3RhbmNlIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jb2VyY2VfdG8hKG5hbWUsIFN0cmluZywgOnRvX3N0cilcblxuICAgIGlmIGBuYW1lLmxlbmd0aCA8IDMgfHwgbmFtZS5zbGljZSgwLDIpICE9PSAnQEAnYFxuICAgICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcImAje25hbWV9JyBpcyBub3QgYWxsb3dlZCBhcyBhIGNsYXNzIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcbiAgICBjb25zdF9uYW1lID0gT3BhbC5jb2VyY2VfdG8hKGNvbnN0X25hbWUsIFN0cmluZywgOnRvX3N0cilcblxuICAgIGlmIGNvbnN0X25hbWVbMF0gIT0gY29uc3RfbmFtZVswXS51cGNhc2VcbiAgICAgIHJhaXNlIE5hbWVFcnJvciwgXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7Y29uc3RfbmFtZX1cIlxuICAgIGVuZFxuXG4gICAgY29uc3RfbmFtZVxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gICMgTWFyayBzb21lIG1ldGhvZHMgYXMgcHJpc3RpbmUgaW4gb3JkZXIgdG8gYXBwbHkgb3B0aW1pemF0aW9ucyB3aGVuIHRoZXlcbiAgIyBhcmUgc3RpbGwgaW4gdGhlaXIgb3JpZ2luYWwgZm9ybS4gVGhpcyBjb3VsZCBwcm9iYWJseSBiZSBtb3ZlZCB0b1xuICAjIHRoZSBgT3BhbC5kZWYoKWAgSlMgQVBJLCBidXQgZm9yIG5vdyBpdCB3aWxsIHN0YXkgbWFudWFsLlxuICAjXG4gICMgQGV4YW1wbGVcbiAgI1xuICAjICAgT3BhbC5wcmlzdGluZSBBcnJheSwgOmFsbG9jYXRlLCA6Y29weV9pbnN0YW5jZV92YXJpYWJsZXMsIDppbml0aWFsaXplX2R1cFxuICAjXG4gICMgICBjbGFzcyBBcnJheVxuICAjICAgICBkZWYgZHVwXG4gICMgICAgICAgJXh7XG4gICMgICAgICAgICBpZiAoXG4gICMgICAgICAgICAgIHNlbGYuJGFsbG9jYXRlLiQkcHJpc3RpbmUgJiZcbiAgIyAgICAgICAgICAgc2VsZi4kY29weV9pbnN0YW5jZV92YXJpYWJsZXMuJCRwcmlzdGluZSAmJlxuICAjICAgICAgICAgICBzZWxmLiRpbml0aWFsaXplX2R1cC4kJHByaXN0aW5lXG4gICMgICAgICAgICApIHJldHVybiBzZWxmLnNsaWNlKDApO1xuICAjICAgICAgIH1cbiAgI1xuICAjICAgICAgIHN1cGVyXG4gICMgICAgIGVuZFxuICAjICAgZW5kXG4gICNcbiAgIyBAcGFyYW0gb3duZXJfY2xhc3MgW0NsYXNzXSB0aGUgY2xhc3Mgb3duaW5nIHRoZSBtZXRob2RzXG4gICMgQHBhcmFtIG1ldGhvZF9uYW1lcyBbQXJyYXk8U3ltYm9sPl0gdGhlIGxpc3Qgb2YgbWV0aG9kcyBuYW1lcyB0byBtYXJrXG4gICMgQHJldHVybiBbbmlsXVxuICBkZWYgc2VsZi5wcmlzdGluZShvd25lcl9jbGFzcywgKm1ldGhvZF9uYW1lcylcbiAgICAleHtcbiAgICAgIHZhciBtZXRob2RfbmFtZSwgbWV0aG9kO1xuICAgICAgZm9yICh2YXIgaSA9IG1ldGhvZF9uYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBtZXRob2RfbmFtZSA9IG1ldGhvZF9uYW1lc1tpXTtcbiAgICAgICAgbWV0aG9kID0gb3duZXJfY2xhc3MuJCRwcm90b3R5cGVbJyQnK21ldGhvZF9uYW1lXTtcblxuICAgICAgICBpZiAobWV0aG9kICYmICFtZXRob2QuJCRzdHViKSB7XG4gICAgICAgICAgbWV0aG9kLiQkcHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5pbFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImJyaWRnZSIsInNlbGYiLCJjb2VyY2VfdG8hIiwiY29lcmNlZCIsInR5cGUiLCI9PT0iLCJyYWlzZSIsImNvZXJjZV90bz8iLCJvYmplY3QiLCJyZXNwb25kX3RvPyIsIm1ldGhvZCIsIm5pbD8iLCJ0cnlfY29udmVydCIsIl9fc2VuZF9fIiwiY29tcGFyZSIsImEiLCI8PT4iLCJiIiwiY2xhc3MiLCJkZXN0cnVjdHVyZSIsIm9iaiIsImluY2x1ZGVfYWxsIiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJuYW1lIiwibmV3IiwiY2xhc3NfdmFyaWFibGVfbmFtZSEiLCJjb25zdF9uYW1lISIsImNvbnN0X25hbWUiLCJbXSIsIjAiLCIhPSIsInVwY2FzZSIsInByaXN0aW5lIl0sIm1hcHBpbmdzIjoiOzs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBQyxVQUFJQyxJQUFKRCxhQUFBQSxpQkFBQUEsa0JBQWdCLFdBQUQsRUFBYyxLQUE3QkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQywrQkFBRDtBQURGQSxJQUFBQSxDQUFBQSw0QkFBQUEsQ0FBQTtBQUFBLElBSUFFLFVBQUlELElBQUpDLGlCQUFBQSx5QkFBQUEsU0FBb0IsTUFBRCxFQUFTLElBQVQsRUFBZSxNQUFmLEVBUnJCLEVBUUVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQVJGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBUTRDLE1BQUEsa0JBUjVDO0FBQUEsTUFTSUMsVUFBVyxzQ0FUZjtBQUFBLE1BV0ksSUFBQSxRQUFPQyxJQUFBQyxRQUFBQSxDQUFTRixPQUFURSxDQUFQLENBQUE7QUFBQSxNQUFBO0FBQUEsWUFDRUMsT0FBQUEsQ0FBTywwQ0FBUEE7QUFERixNQUFBLENBWEo7QUFBQSxNQWVJLE9BQUFILE9BZko7QUFRRUQsSUFBQUEsQ0FBQUEscUNBQUFBLENBSkE7QUFBQSxJQWNBSyxVQUFJTixJQUFKTSxpQkFBQUEseUJBQUFBLFNBQW9CLE1BQUQsRUFBUyxJQUFULEVBQWUsTUFBZixFQWxCckIsRUFrQkVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQWxCRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQWtCNEMsTUFBQSxrQkFsQjVDO0FBQUEsTUFtQkksSUFBQSxRQUFjQyxNQUFBQyxnQkFBQUEsQ0FBbUJDLE1BQW5CRCxDQUFkLENB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SkE7QUFBQSxNQWlKSSxPQUFBLEdBakpKO0FBcUlFQSxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FBQUEsb0JBaklBO0FBREZqQyxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI3NjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21vZHVsZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgY29lcmNlX3RvXG5cbmNsYXNzIE1vZHVsZVxuICBkZWYgc2VsZi5hbGxvY2F0ZVxuICAgICV4e1xuICAgICAgdmFyIG1vZHVsZSA9IE9wYWwuYWxsb2NhdGVfbW9kdWxlKG5pbCwgZnVuY3Rpb24oKXt9KTtcbiAgICAgIC8vIExpbmsgdGhlIHByb3RvdHlwZSBvZiBNb2R1bGUgc3ViY2xhc3Nlc1xuICAgICAgaWYgKHNlbGYgIT09IE9wYWwuTW9kdWxlKSBPYmplY3Quc2V0UHJvdG90eXBlT2YobW9kdWxlLCBzZWxmLiQkcHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXG4gICAgbW9kdWxlX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cbiAgZW5kXG5cbiAgZGVmID09PShvYmplY3QpXG4gICAgcmV0dXJuIGZhbHNlIGlmIGBvYmplY3QgPT0gbnVsbGBcblxuICAgIGBPcGFsLmlzX2Eob2JqZWN0LCBzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgdW5sZXNzIE1vZHVsZSA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ2NvbXBhcmVkIHdpdGggbm9uIGNsYXNzL21vZHVsZSdcbiAgICBlbmRcblxuICAgICMgY2xhc3MgY2Fubm90IGJlIGEgZGVzY2VuZGFudCBvZiBpdHNlbGZcbiAgICAleHtcbiAgICAgIHZhciB3b3JraW5nID0gc2VsZixcbiAgICAgICAgICBhbmNlc3RvcnMsXG4gICAgICAgICAgaSwgbGVuZ3RoO1xuXG4gICAgICBpZiAod29ya2luZyA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhzZWxmKSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbmNlc3RvcnNbaV0gPT09IG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMob3RoZXIpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yc1tpXSA9PT0gc2VsZikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIGVxdWFsPyhvdGhlcikgfHwgc2VsZiA8IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA+KG90aGVyKVxuICAgIHVubGVzcyBNb2R1bGUgPT09IG90aGVyXG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdjb21wYXJlZCB3aXRoIG5vbiBjbGFzcy9tb2R1bGUnXG4gICAgZW5kXG5cbiAgICBvdGhlciA8IHNlbGZcbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgIGVxdWFsPyhvdGhlcikgfHwgc2VsZiA+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIE1vZHVsZSA9PT0gb3RoZXJcbiAgICAgIHJldHVybiBuaWxcbiAgICBlbmRcblxuICAgIGx0ID0gc2VsZiA8IG90aGVyXG4gICAgcmV0dXJuIG5pbCBpZiBsdC5uaWw/XG4gICAgbHQgPyAtMSA6IDFcbiAgZW5kXG5cbiAgZGVmIGFsaWFzX21ldGhvZChuZXduYW1lLCBvbGRuYW1lKVxuICAgIG5ld25hbWUgPSBgJGNvZXJjZV90byhuZXduYW1lLCAje1N0cmluZ30sICd0b19zdHInKWBcbiAgICBvbGRuYW1lID0gYCRjb2VyY2VfdG8ob2xkbmFtZSwgI3tTdHJpbmd9LCAndG9fc3RyJylgXG4gICAgYE9wYWwuYWxpYXMoc2VsZiwgbmV3bmFtZSwgb2xkbmFtZSlgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhbGlhc19uYXRpdmUobWlkLCBqc2lkID0gbWlkKVxuICAgIGBPcGFsLmFsaWFzX25hdGl2ZShzZWxmLCBtaWQsIGpzaWQpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYW5jZXN0b3JzXG4gICAgYE9wYWwuYW5jZXN0b3JzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgYXBwZW5kX2ZlYXR1cmVzKGluY2x1ZGVyKVxuICAgIGBPcGFsLmFwcGVuZF9mZWF0dXJlcyhzZWxmLCBpbmNsdWRlcilgXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYXR0cl9hY2Nlc3NvcigqbmFtZXMpXG4gICAgYXR0cl9yZWFkZXIoKm5hbWVzKVxuICAgIGF0dHJfd3JpdGVyKCpuYW1lcylcbiAgZW5kXG5cbiAgZGVmIGF0dHIoKmFyZ3MpXG4gICAgJXh7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPT0gMiAmJiAoYXJnc1sxXSA9PT0gdHJ1ZSB8fCBhcmdzWzFdID09PSBmYWxzZSkpIHtcbiAgICAgICAgI3t3YXJuICdvcHRpb25hbCBib29sZWFuIGFyZ3VtZW50IGlzIG9ic29sZXRlZCcsIHVwbGV2ZWw6IDF9XG5cbiAgICAgICAgYXJnc1sxXSA/ICN7YXR0cl9hY2Nlc3NvcihgYXJnc1swXWApfSA6ICN7YXR0cl9yZWFkZXIoYGFyZ3NbMF1gKX07XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cl9yZWFkZXIoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiBhdHRyX3JlYWRlcigqbmFtZXMpXG4gICAgJXh7XG4gICAgICB2YXIgcHJvdG8gPSBzZWxmLiQkcHJvdG90eXBlO1xuXG4gICAgICBmb3IgKHZhciBpID0gbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXSxcbiAgICAgICAgICAgIGlkICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICAgICAgaXZhciA9IE9wYWwuaXZhcihuYW1lKTtcblxuICAgICAgICAvLyB0aGUgY2xvc3VyZSBoZXJlIGlzIG5lZWRlZCBiZWNhdXNlIG5hbWUgd2lsbCBjaGFuZ2UgYXQgdGhlIG5leHRcbiAgICAgICAgLy8gY3ljbGUsIEkgd2lzaCB3ZSBjb3VsZCB1c2UgbGV0LlxuICAgICAgICB2YXIgYm9keSA9IChmdW5jdGlvbihpdmFyKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaXZhcl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzW2l2YXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0pKGl2YXIpO1xuXG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGluc3RhbmNlIHZhcmlhYmxlIGFzIG5pbFxuICAgICAgICBPcGFsLmRlZmluZVByb3BlcnR5KHByb3RvLCBpdmFyLCBuaWwpO1xuXG4gICAgICAgIGJvZHkuJCRwYXJhbWV0ZXJzID0gW107XG4gICAgICAgIGJvZHkuJCRhcml0eSA9IDA7XG5cbiAgICAgICAgT3BhbC5kZWZuKHNlbGYsIGlkLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGF0dHJfd3JpdGVyKCpuYW1lcylcbiAgICAleHtcbiAgICAgIHZhciBwcm90byA9IHNlbGYuJCRwcm90b3R5cGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBuYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldLFxuICAgICAgICAgICAgaWQgICA9ICckJyArIG5hbWUgKyAnPScsXG4gICAgICAgICAgICBpdmFyID0gT3BhbC5pdmFyKG5hbWUpO1xuXG4gICAgICAgIC8vIHRoZSBjbG9zdXJlIGhlcmUgaXMgbmVlZGVkIGJlY2F1c2UgbmFtZSB3aWxsIGNoYW5nZSBhdCB0aGUgbmV4dFxuICAgICAgICAvLyBjeWNsZSwgSSB3aXNoIHdlIGNvdWxkIHVzZSBsZXQuXG4gICAgICAgIHZhciBib2R5ID0gKGZ1bmN0aW9uKGl2YXIpe1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbaXZhcl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKGl2YXIpO1xuXG4gICAgICAgIGJvZHkuJCRwYXJhbWV0ZXJzID0gW1sncmVxJ11dO1xuICAgICAgICBib2R5LiQkYXJpdHkgPSAxO1xuXG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGluc3RhbmNlIHZhcmlhYmxlIGFzIG5pbFxuICAgICAgICBPcGFsLmRlZmluZVByb3BlcnR5KHByb3RvLCBpdmFyLCBuaWwpO1xuXG4gICAgICAgIE9wYWwuZGVmbihzZWxmLCBpZCwgYm9keSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBhdXRvbG9hZChjb25zdCwgcGF0aClcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkYXV0b2xvYWQgPT0gbnVsbCkgc2VsZi4kJGF1dG9sb2FkID0ge307XG4gICAgICBPcGFsLmNvbnN0X2NhY2hlX3ZlcnNpb24rKztcbiAgICAgIHNlbGYuJCRhdXRvbG9hZFsje2NvbnN0fV0gPSAje3BhdGh9O1xuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZXNcbiAgICBgT2JqZWN0LmtleXMoT3BhbC5jbGFzc192YXJpYWJsZXMoc2VsZikpYFxuICBlbmRcblxuICBkZWYgY2xhc3NfdmFyaWFibGVfZ2V0KG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlX2dldChzZWxmLCBuYW1lLCBmYWxzZSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9zZXQobmFtZSwgdmFsdWUpXG4gICAgbmFtZSA9IE9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldChzZWxmLCBuYW1lLCB2YWx1ZSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9kZWZpbmVkPyhuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5jbGFzc192YXJpYWJsZXMoc2VsZikuaGFzT3duUHJvcGVydHkobmFtZSlgXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfY2xhc3NfdmFyaWFibGUobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICBpZiAoT3BhbC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGYuJCRjdmFycywgbmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc2VsZi4kJGN2YXJzW25hbWVdO1xuICAgICAgICBkZWxldGUgc2VsZi4kJGN2YXJzW25hbWVdO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvciwgXCJjYW5ub3QgcmVtb3ZlICN7bmFtZX0gZm9yICN7c2VsZn1cIn1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25zdGFudHMoaW5oZXJpdCA9IHRydWUpXG4gICAgYE9wYWwuY29uc3RhbnRzKHNlbGYsIGluaGVyaXQpYFxuICBlbmRcblxuICBkZWYgc2VsZi5jb25zdGFudHMoaW5oZXJpdCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChpbmhlcml0ID09IG51bGwpIHtcbiAgICAgICAgdmFyIG5lc3RpbmcgPSAoc2VsZi4kJG5lc3RpbmcgfHwgW10pLmNvbmNhdChPcGFsLk9iamVjdCksXG4gICAgICAgICAgICBjb25zdGFudCwgY29uc3RhbnRzID0ge30sXG4gICAgICAgICAgICBpLCBpaTtcblxuICAgICAgICBmb3IoaSA9IDAsIGlpID0gbmVzdGluZy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgZm9yIChjb25zdGFudCBpbiBuZXN0aW5nW2ldLiQkY29uc3QpIHtcbiAgICAgICAgICAgIGNvbnN0YW50c1tjb25zdGFudF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoY29uc3RhbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLmNvbnN0YW50cyhzZWxmLCBpbmhlcml0KVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYubmVzdGluZ1xuICAgIGBzZWxmLiQkbmVzdGluZyB8fCBbXWBcbiAgZW5kXG5cbiAgIyBjaGVjayBmb3IgY29uc3RhbnQgd2l0aGluIGN1cnJlbnQgc2NvcGVcbiAgIyBpZiBpbmhlcml0IGlzIHRydWUgb3Igc2VsZiBpcyBPYmplY3QsIHdpbGwgYWxzbyBjaGVjayBhbmNlc3RvcnNcbiAgZGVmIGNvbnN0X2RlZmluZWQ/KG5hbWUsIGluaGVyaXQgPSB0cnVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwid3JvbmcgY29uc3RhbnQgbmFtZSAje25hbWV9XCIsIG5hbWUpIHVubGVzcyBuYW1lID1+IE9wYWw6OkNPTlNUX05BTUVfUkVHRVhQXG5cbiAgICAleHtcbiAgICAgIHZhciBtb2R1bGUsIG1vZHVsZXMgPSBbc2VsZl0sIG1vZHVsZV9jb25zdGFudHMsIGksIGlpO1xuXG4gICAgICAvLyBBZGQgdXAgYW5jZXN0b3JzIGlmIGluaGVyaXQgaXMgdHJ1ZVxuICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KE9wYWwuYW5jZXN0b3JzKHNlbGYpKTtcblxuICAgICAgICAvLyBBZGQgT2JqZWN0J3MgYW5jZXN0b3JzIGlmIGl0J3MgYSBtb2R1bGUg4oCTIG1vZHVsZXMgaGF2ZSBubyBhbmNlc3RvcnMgb3RoZXJ3aXNlXG4gICAgICAgIGlmIChzZWxmLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KFtPcGFsLk9iamVjdF0pLmNvbmNhdChPcGFsLmFuY2VzdG9ycyhPcGFsLk9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGlpID0gbW9kdWxlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG1vZHVsZSA9IG1vZHVsZXNbaV07XG4gICAgICAgIGlmIChtb2R1bGUuJCRjb25zdFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0X2dldChuYW1lLCBpbmhlcml0ID0gdHJ1ZSlcbiAgICBuYW1lID0gT3BhbC5jb25zdF9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICBpZiAobmFtZS5pbmRleE9mKCc6OicpID09PSAwICYmIG5hbWUgIT09ICc6Oicpe1xuICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBgbmFtZS5pbmRleE9mKCc6OicpICE9IC0xICYmIG5hbWUgIT0gJzo6J2BcbiAgICAgIHJldHVybiBuYW1lLnNwbGl0KCc6OicpLmluamVjdChzZWxmKSB7IHxvLCBjfCBvLmNvbnN0X2dldChjKSB9XG4gICAgZW5kXG5cbiAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwid3JvbmcgY29uc3RhbnQgbmFtZSAje25hbWV9XCIsIG5hbWUpIHVubGVzcyBuYW1lID1+IE9wYWw6OkNPTlNUX05BTUVfUkVHRVhQXG5cbiAgICAleHtcbiAgICAgIGlmIChpbmhlcml0KSB7XG4gICAgICAgIHJldHVybiAkJChbc2VsZl0sIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuY29uc3RfZ2V0X2xvY2FsKHNlbGYsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0X21pc3NpbmcobmFtZSlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkYXV0b2xvYWQpIHtcbiAgICAgICAgdmFyIGZpbGUgPSBzZWxmLiQkYXV0b2xvYWRbbmFtZV07XG5cbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICBzZWxmLiRyZXF1aXJlKGZpbGUpO1xuXG4gICAgICAgICAgcmV0dXJuICN7Y29uc3RfZ2V0IG5hbWV9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVsbF9jb25zdF9uYW1lID0gc2VsZiA9PSBPYmplY3QgPyBuYW1lIDogXCIje3NlbGZ9Ojoje25hbWV9XCJcblxuICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmluaXRpYWxpemVkIGNvbnN0YW50ICN7ZnVsbF9jb25zdF9uYW1lfVwiLCBuYW1lKVxuICBlbmRcblxuICBkZWYgY29uc3Rfc2V0KG5hbWUsIHZhbHVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICBpZiBuYW1lICF+IE9wYWw6OkNPTlNUX05BTUVfUkVHRVhQIHx8IG5hbWUuc3RhcnRfd2l0aD8oJzo6JylcbiAgICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIGBPcGFsLmNvbnN0X3NldChzZWxmLCBuYW1lLCB2YWx1ZSlgXG5cbiAgICB2YWx1ZVxuICBlbmRcblxuICBkZWYgcHVibGljX2NvbnN0YW50KGNvbnN0X25hbWUpXG4gIGVuZFxuXG4gIGRlZiBkZWZpbmVfbWV0aG9kKG5hbWUsIG1ldGhvZCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBtZXRob2QgPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNyZWF0ZSBhIFByb2Mgb2JqZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICBlbmRcblxuICAgIGJsb2NrIHx8PSBjYXNlIG1ldGhvZFxuICAgICAgICAgICAgICB3aGVuIFByb2NcbiAgICAgICAgICAgICAgICBtZXRob2RcblxuICAgICAgICAgICAgICB3aGVuIE1ldGhvZFxuICAgICAgICAgICAgICAgIGAje21ldGhvZC50b19wcm9jfS4kJHVuYm91bmRgXG5cbiAgICAgICAgICAgICAgd2hlbiBVbmJvdW5kTWV0aG9kXG4gICAgICAgICAgICAgICAgLT4oKmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgIGJvdW5kID0gbWV0aG9kLmJpbmQoc2VsZilcbiAgICAgICAgICAgICAgICAgIGJvdW5kLmNhbGwoKmFyZ3MpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Jsb2NrLmNsYXNzfSAoZXhwZWN0ZWQgUHJvYy9NZXRob2QpXCJcbiAgICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBpZCA9ICckJyArIG5hbWU7XG5cbiAgICAgIGJsb2NrLiQkanNpZCAgICAgICAgPSBuYW1lO1xuICAgICAgYmxvY2suJCRzICAgICAgICAgICA9IG51bGw7XG4gICAgICBibG9jay4kJGRlZiAgICAgICAgID0gYmxvY2s7XG4gICAgICBibG9jay4kJGRlZmluZV9tZXRoID0gdHJ1ZTtcblxuICAgICAgT3BhbC5kZWZuKHNlbGYsIGlkLCBibG9jayk7XG5cbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9tZXRob2QoKm5hbWVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwucmRlZihzZWxmLCBcIiRcIiArIG5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fY2xhc3M/XG4gICAgYCEhc2VsZi4kJGlzX3NpbmdsZXRvbmBcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGUoKm1vZHMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gbW9kcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcblxuICAgICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICAgIH1cblxuICAgICAgICAje2Btb2RgLmFwcGVuZF9mZWF0dXJlcyBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5pbmNsdWRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlZF9tb2R1bGVzXG4gICAgYE9wYWwuaW5jbHVkZWRfbW9kdWxlcyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG1vZClcbiAgICAleHtcbiAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpaSwgbW9kMiwgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMoc2VsZik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGlpID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbW9kMiA9IGFuY2VzdG9yc1tpXTtcbiAgICAgICAgaWYgKG1vZDIgPT09IG1vZCAmJiBtb2QyICE9PSBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX21ldGhvZChuYW1lKVxuICAgICV4e1xuICAgICAgdmFyIG1ldGggPSBzZWxmLiQkcHJvdG90eXBlWyckJyArIG5hbWVdO1xuXG4gICAgICBpZiAoIW1ldGggfHwgbWV0aC4kJHN0dWIpIHtcbiAgICAgICAgI3tyYWlzZSBOYW1lRXJyb3IubmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgI3tuYW1lfScgZm9yIGNsYXNzIGAje3NlbGYubmFtZX0nXCIsIG5hbWUpfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7VW5ib3VuZE1ldGhvZC5uZXcoc2VsZiwgYG1ldGguJCRvd25lciB8fCAje3NlbGZ9YCwgYG1ldGhgLCBuYW1lKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfbWV0aG9kcyhpbmNsdWRlX3N1cGVyID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgkdHJ1dGh5KCN7aW5jbHVkZV9zdXBlcn0pKSB7XG4gICAgICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyhzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlZChtb2QpXG4gIGVuZFxuXG4gIGRlZiBleHRlbmRlZChtb2QpXG4gIGVuZFxuXG4gIGRlZiBleHRlbmRfb2JqZWN0KG9iamVjdClcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9hZGRlZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX3JlbW92ZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF91bmRlZmluZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1vZHVsZV9ldmFsKCphcmdzLCAmYmxvY2spXG4gICAgaWYgYmxvY2submlsPyAmJiBgISFPcGFsLmNvbXBpbGVgXG4gICAgICBLZXJuZWwucmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEuLjMpJyB1bmxlc3MgKDEuLjMpLmNvdmVyPyBhcmdzLnNpemVcblxuICAgICAgc3RyaW5nLCBmaWxlLCBfbGluZW5vID0gKmFyZ3NcbiAgICAgIGRlZmF1bHRfZXZhbF9vcHRpb25zID0geyBmaWxlOiAoZmlsZSB8fCAnKGV2YWwpJyksIGV2YWw6IHRydWUgfVxuICAgICAgY29tcGlsaW5nX29wdGlvbnMgPSBfX09QQUxfQ09NUElMRVJfQ09ORklHX18ubWVyZ2UoZGVmYXVsdF9ldmFsX29wdGlvbnMpXG4gICAgICBjb21waWxlZCA9IE9wYWwuY29tcGlsZSBzdHJpbmcsIGNvbXBpbGluZ19vcHRpb25zXG4gICAgICBibG9jayA9IEtlcm5lbC5wcm9jIGRvXG4gICAgICAgICV4e1xuICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIGV2YWwoY29tcGlsZWQpO1xuICAgICAgICAgIH0pKHNlbGYpXG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVsc2lmIGFyZ3MuYW55P1xuICAgICAgS2VybmVsLnJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLnNpemV9IGZvciAwKVwiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG5cXG4gIE5PVEU6SWYgeW91IHdhbnQgdG8gZW5hYmxlIHBhc3NpbmcgYSBTdHJpbmcgYXJndW1lbnQgcGxlYXNlIGFkZCBcXFwicmVxdWlyZSAnb3BhbC1wYXJzZXInXFxcIiB0byB5b3VyIHNjcmlwdFxcblwiXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBvbGQgPSBibG9jay4kJHMsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gYmxvY2suYXBwbHkoc2VsZiwgW3NlbGZdKTtcbiAgICAgIGJsb2NrLiQkcyA9IG9sZDtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGNsYXNzX2V2YWwgbW9kdWxlX2V2YWxcblxuICBkZWYgbW9kdWxlX2V4ZWMoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICN7cmFpc2UgTG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbid9XG4gICAgICB9XG5cbiAgICAgIHZhciBibG9ja19zZWxmID0gYmxvY2suJCRzLCByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG4gICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIGJsb2NrLiQkcyA9IGJsb2NrX3NlbGY7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBjbGFzc19leGVjIG1vZHVsZV9leGVjXG5cbiAgZGVmIG1ldGhvZF9kZWZpbmVkPyhtZXRob2QpXG4gICAgJXh7XG4gICAgICB2YXIgYm9keSA9IHNlbGYuJCRwcm90b3R5cGVbJyQnICsgbWV0aG9kXTtcbiAgICAgIHJldHVybiAoISFib2R5KSAmJiAhYm9keS4kJHN0dWI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbW9kdWxlX2Z1bmN0aW9uKCptZXRob2RzKVxuICAgICV4e1xuICAgICAgaWYgKG1ldGhvZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYuJCRtb2R1bGVfZnVuY3Rpb24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtZXRob2RzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG1ldGggPSBtZXRob2RzW2ldLFxuICAgICAgICAgICAgICBpZCAgID0gJyQnICsgbWV0aCxcbiAgICAgICAgICAgICAgZnVuYyA9IHNlbGYuJCRwcm90b3R5cGVbaWRdO1xuXG4gICAgICAgICAgT3BhbC5kZWZzKHNlbGYsIGlkLCBmdW5jKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBuYW1lXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGZ1bGxfbmFtZSkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGZ1bGxfbmFtZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBiYXNlID0gc2VsZjtcblxuICAgICAgd2hpbGUgKGJhc2UpIHtcbiAgICAgICAgLy8gR2l2ZSB1cCBpZiBhbnkgb2YgdGhlIGFuY2VzdG9ycyBpcyB1bm5hbWVkXG4gICAgICAgIGlmIChiYXNlLiQkbmFtZSA9PT0gbmlsIHx8IGJhc2UuJCRuYW1lID09IG51bGwpIHJldHVybiBuaWw7XG5cbiAgICAgICAgcmVzdWx0LnVuc2hpZnQoYmFzZS4kJG5hbWUpO1xuXG4gICAgICAgIGJhc2UgPSBiYXNlLiQkYmFzZV9tb2R1bGU7XG5cbiAgICAgICAgaWYgKGJhc2UgPT09IE9wYWwuT2JqZWN0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRmdWxsX25hbWUgPSByZXN1bHQuam9pbignOjonKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwcmVwZW5kKCptb2RzKVxuICAgICV4e1xuICAgICAgaWYgKG1vZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuIDAsIGV4cGVjdGVkIDErKSd9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBtb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xuXG4gICAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7YG1vZGAucHJlcGVuZF9mZWF0dXJlcyBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5wcmVwZW5kZWQgc2VsZn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcHJlcGVuZF9mZWF0dXJlcyhwcmVwZW5kZXIpXG4gICAgJXh7XG4gICAgICBpZiAoIXNlbGYuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3NlbGYuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgfVxuXG4gICAgICBPcGFsLnByZXBlbmRfZmVhdHVyZXMoc2VsZiwgcHJlcGVuZGVyKVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmVwZW5kZWQobW9kKVxuICBlbmRcblxuICBkZWYgcmVtb3ZlX2NvbnN0KG5hbWUpXG4gICAgYE9wYWwuY29uc3RfcmVtb3ZlKHNlbGYsIG5hbWUpYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGBPcGFsLk1vZHVsZS4kbmFtZS5jYWxsKHNlbGYpYCB8fCBcIiM8I3tgc2VsZi4kJGlzX21vZHVsZSA/ICdNb2R1bGUnIDogJ0NsYXNzJ2B9OjB4I3tfX2lkX18udG9fcygxNil9PlwiXG4gIGVuZFxuXG4gIGRlZiB1bmRlZl9tZXRob2QoKm5hbWVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwudWRlZihzZWxmLCBcIiRcIiArIG5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBjb25zdHMgPSBjb25zdGFudHNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KG5hbWUpICYmIG5hbWUuY2hhckF0KDApICE9PSAnJCcgJiYgbmFtZSAhPT0gJ2NvbnN0cnVjdG9yJyAmJiAhI3tjb25zdHMuaW5jbHVkZT8oYG5hbWVgKX0pIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgnQCcgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBzdXBlclxuICAgIGNvcHkuY29weV9jbGFzc192YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmNvcHlfY29uc3RhbnRzKHNlbGYpXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgY29weV9jbGFzc192YXJpYWJsZXMob3RoZXIpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG90aGVyLiQkY3ZhcnMpIHtcbiAgICAgICAgc2VsZi4kJGN2YXJzW25hbWVdID0gb3RoZXIuJCRjdmFyc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb3B5X2NvbnN0YW50cyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBuYW1lLCBvdGhlcl9jb25zdGFudHMgPSBvdGhlci4kJGNvbnN0O1xuXG4gICAgICBmb3IgKG5hbWUgaW4gb3RoZXJfY29uc3RhbnRzKSB7XG4gICAgICAgIE9wYWwuY29uc3Rfc2V0KHNlbGYsIG5hbWUsIG90aGVyX2NvbnN0YW50c1tuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiYWxsb2NhdGUiLCJzZWxmIiwiaW5pdGlhbGl6ZSIsImJsb2NrX2dpdmVuPyIsIm1vZHVsZV9ldmFsIiwiYmxvY2siLCI9PT0iLCI8Iiwib3RoZXIiLCJyYWlzZSIsIjw9IiwiJHJldF9vcl8xIiwiZXF1YWw/IiwiPiIsIj49IiwiJHJldF9vcl8yIiwiPD0+IiwibHQiLCJuaWw/IiwiLTEiLCIxIiwiYWxpYXNfbWV0aG9kIiwibmV3bmFtZSIsIm9sZG5hbWUiLCJhbGlhc19uYXRpdmUiLCJtaWQiLCJhbmNlc3RvcnMiLCJhcHBlbmRfZmVhdHVyZXMiLCJhdHRyX2FjY2Vzc29yIiwiYXR0cl9yZWFkZXIiLCJuYW1lcyIsImF0dHJfd3JpdGVyIiwiYXR0ciIsIndhcm4iLCJhcmdzIiwiYXV0b2xvYWQiLCJjb25zdCQiLCJwYXRoIiwiY2xhc3NfdmFyaWFibGVzIiwiY2xhc3NfdmFyaWFibGVfZ2V0IiwibmFtZSIsImNsYXNzX3ZhcmlhYmxlX25hbWUhIiwiY2xhc3NfdmFyaWFibGVfc2V0IiwiY2xhc3NfdmFyaWFibGVfZGVmaW5lZD8iLCJyZW1vdmVfY2xhc3NfdmFyaWFibGUiLCJjb25zdGFudHMiLCJuZXN0aW5nIiwiY29uc3RfZGVmaW5lZD8iLCJjb25zdF9uYW1lISIsIj1+IiwibmV3IiwiY29uc3RfZ2V0IiwiaW5qZWN0Iiwic3BsaXQiLCJvIiwiYyIsImNvbnN0X21pc3NpbmciLCJmdWxsX2NvbnN0X25hbWUiLCI9PSIsImNvbnN0X3NldCIsIiRyZXRfb3JfMyIsIiF+Iiwic3RhcnRfd2l0aD8iLCJ2YWx1ZSIsInB1YmxpY19jb25zdGFudCIsImRlZmluZV9tZXRob2QiLCIkcmV0X29yXzQiLCJtZXRob2QiLCJ0b19wcm9jIiwiYm91bmQiLCJiaW5kIiwiY2FsbCIsInJlbW92ZV9tZXRob2QiLCJzaW5nbGV0b25fY2xhc3M/IiwiaW5jbHVkZSIsImluY2x1ZGVkIiwiaW5jbHVkZWRfbW9kdWxlcyIsImluY2x1ZGU/IiwiaW5zdGFuY2VfbWV0aG9kIiwiaW5zdGFuY2VfbWV0aG9kcyIsImluY2x1ZGVfc3VwZXIiLCJleHRlbmRlZCIsImV4dGVuZF9vYmplY3QiLCJtZXRob2RfYWRkZWQiLCJtZXRob2RfcmVtb3ZlZCIsIm1ldGhvZF91bmRlZmluZWQiLCIkcmV0X29yXzUiLCIzIiwiY292ZXI/Iiwic2l6ZSIsInN0cmluZyIsImZpbGUiLCJfbGluZW5vIiwiZGVmYXVsdF9ldmFsX29wdGlvbnMiLCIkcmV0X29yXzYiLCJjb21waWxpbmdfb3B0aW9ucyIsIl9fT1BBTF9DT01QSUxFUl9DT05GSUdfXyIsIm1lcmdlIiwiY29tcGlsZWQiLCJjb21waWxlIiwicHJvYyIsImFueT8iLCJtb2R1bGVfZXhlYyIsIm1ldGhvZF9kZWZpbmVkPyIsIm1vZHVsZV9mdW5jdGlvbiIsInByZXBlbmQiLCJwcmVwZW5kX2ZlYXR1cmVzIiwicHJlcGVuZGVkIiwicmVtb3ZlX2NvbnN0IiwidG9fcyIsIiRyZXRfb3JfNyIsIl9faWRfXyIsIjE2IiwidW5kZWZfbWV0aG9kIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiY29uc3RzIiwiZHVwIiwiY29weSIsImNvcHlfY2xhc3NfdmFyaWFibGVzIiwiY29weV9jb25zdGFudHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0VBRUEsT0FBQUE7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LENBQVA7QUFBQSxNQUNBQSxJQUFBQyxzQkFBQUEsQ0FBMEJySCxJQUExQnFILENBREE7QUFBQSxNQUVBRCxJQUFBRSxnQkFBQUEsQ0FBb0J0SCxJQUFwQnNILENBRkE7QUFBQSxNQUdBLE9BQUFGLElBSEE7QUFERkQsSUFBQUEsQ0FBQUEsNEJBQUFBLENBN29CQTtBQUFBO0FBb3BCQUUsSUFBQUEsd0NBQUFBLGtDQUFBQSxnQ0FBeUIsS0FBekJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBTEVBLElBQUFBLENBQUFBLDZDQUFBQSxDQXBwQkE7QUFBQSxJQTRwQkEsT0FBQUMsQ0FBQUEsa0NBQUFBLDRCQUFBQSwwQkFBbUIsS0FBbkJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBUEVBLElBQUFBLENBQUFBLHVDQUFBQSxDQUFBQSwwQkE1cEJBO0FBREZ4SCxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjM3MjksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NsYXNzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvbW9kdWxlJ1xuXG5jbGFzcyBDbGFzc1xuICBkZWYgc2VsZi5uZXcoc3VwZXJjbGFzcyA9IE9iamVjdCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKCFzdXBlcmNsYXNzLiQkaXNfY2xhc3MpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcInN1cGVyY2xhc3MgbXVzdCBiZSBhIENsYXNzXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIga2xhc3MgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG5pbCwgc3VwZXJjbGFzcyk7XG4gICAgICBzdXBlcmNsYXNzLiRpbmhlcml0ZWQoa2xhc3MpO1xuICAgICAgI3tga2xhc3NgLmNsYXNzX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj99XG4gICAgICByZXR1cm4ga2xhc3M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYWxsb2NhdGVcbiAgICAleHtcbiAgICAgIHZhciBvYmogPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKCk7XG4gICAgICBvYmouJCRpZCA9IE9wYWwudWlkKCk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluaGVyaXRlZChjbHMpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2R1cChvcmlnaW5hbClcbiAgICBpbml0aWFsaXplX2NvcHkob3JpZ2luYWwpXG4gICAgJXh7XG4gICAgICBzZWxmLiQkbmFtZSA9IG51bGw7XG4gICAgICBzZWxmLiQkZnVsbF9uYW1lID0gbnVsbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBuZXcoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBvYmplY3QgPSAje2FsbG9jYXRlfTtcbiAgICAgIE9wYWwuc2VuZChvYmplY3QsIG9iamVjdC4kaW5pdGlhbGl6ZSwgYXJncywgYmxvY2spO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdXBlcmNsYXNzXG4gICAgYHNlbGYuJCRzdXBlciB8fCBuaWxgXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgJXh7XG4gICAgICB2YXIgc2luZ2xldG9uX29mID0gc2VsZi4kJHNpbmdsZXRvbl9vZjtcblxuICAgICAgaWYgKHNpbmdsZXRvbl9vZiAmJiBzaW5nbGV0b25fb2YuJCRpc19hX21vZHVsZSkge1xuICAgICAgICByZXR1cm4gI3tcIiM8Q2xhc3M6I3tgc2luZ2xldG9uX29mYC5uYW1lfT5cIn07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzaW5nbGV0b25fb2YpIHtcbiAgICAgICAgLy8gYSBzaW5nbGV0b24gY2xhc3MgY3JlYXRlZCBmcm9tIGFuIG9iamVjdFxuICAgICAgICByZXR1cm4gI3tcIiM8Q2xhc3M6Izwje2BzaW5nbGV0b25fb2YuJCRjbGFzc2AubmFtZX06MHgje2BPcGFsLmlkKHNpbmdsZXRvbl9vZilgLnRvX3MoMTYpfT4+XCJ9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tzdXBlcigpfTtcbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwibmV3Iiwic2VsZiIsImJsb2NrX2dpdmVuPyIsImNsYXNzX2V2YWwiLCJibG9jayIsImFsbG9jYXRlIiwiaW5oZXJpdGVkIiwiaW5pdGlhbGl6ZV9kdXAiLCJpbml0aWFsaXplX2NvcHkiLCJvcmlnaW5hbCIsInN1cGVyY2xhc3MiLCJ0b19zIiwibmFtZSIsIjE2Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQUFBO0FBQUEsRUFFQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQUMsVUFBSUMsSUFBSkQsVUFBQUEsZUFBQUEsU0FBYSxVQUFiQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFKRjtBQUlvQyxNQUFBLG1DQUpwQztBQUFBO0FBSWUsTUFBQTtBQUFBLE1BQUEsZUFBYSxzQkFBYjtBQUFBLE1BQUEsQ0FKZjtBQUFBO0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFRLGFBQUEsSUFBOEJFLGVBQTlCO0FBQUEsUUFBQSxPQUFBQyxNQUFBLENBQUMsS0FBRCxDQUFBQSxjQUFBQSxFQUFBQSxFQUFBQSxFQUFvQkMsZ0JBQXBCRDtBQUFBLE1BQUE7QUFBQTtBQUFBLE1BQUEsQ0FBQTtBQUNSO0FBQ0EsSUFkQTtBQUlFSCxJQUFBQSxDQUFBQSwyQkFBQUEsQ0FBQTtBQUFBO0FBYUFLLElBQUFBLDRCQUFBQSxvQkFBQUEsb0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBTEVBLElBQUFBLENBQUFBLCtCQUFBQSxDQWJBO0FBQUE7QUFxQkFDLElBQUFBLDZCQUFBQSxxQkFBQUEscUJBQWMsR0FBZEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BekJGLE9BQUE7QUF5QkVBLElBQUFBLENBQUFBLGdDQUFBQSxDQXJCQTtBQUFBO0FBd0JBQyxJQUFBQSxrQ0FBQUEsMEJBQUFBLDBCQUFtQixRQUFuQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsVUFBQUMsaUJBQUFBLENBQWdCQyxRQUFoQkQsQ0FBQTtBQUFBO0FBRUo7QUFDQTtBQUNBLElBSkk7QUFERkQsSUFBQUEsQ0FBQUEscUNBQUFBLENBeEJBO0FBQUE7QUFnQ0FQLElBQUFBLHVCQUFBQSxlQUFBQSxTQXBDRixFQW9DRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBcENGO0FBb0NpQixNQUFBLG1DQXBDakI7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQW9DVSxNQUFBLGtCQXBDVjtBQUFBO0FBc0NBLHVCQUFxQkssVUFBQUEsQ0FBQUEsQ0FBUztBQUM5QjtBQUNBO0FBQ0EsSUF6Q0E7QUFvQ0VMLElBQUFBLENBQUFBLDJCQUFBQSxDQWhDQTtBQUFBO0FBd0NBVSxJQUFBQSw4QkFBQUEsc0JBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLG1CQUFEO0FBREZBLElBQUFBLENBQUFBLGlDQUFBQSxDQXhDQTtBQUFBLElBNENBLE9BQUFDLENBQUFBLHdCQUFBQSxnQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQUVGOztBQUVBO0FBQ0EsZUFBaUIsRUFBQSxHQUFBLFVBQUEsR0FBQSxDQUFXLENBQUMsWUFBRCxDQUFBQyxNQUFBQSxDQUFBQSxDQUFYLENBQUEsR0FBQSxHQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxlQUFpQixFQUFBLEdBQUEsWUFBQSxHQUFBLENBQWEsQ0FBQyxvQkFBRCxDQUFBQSxNQUFBQSxDQUFBQSxDQUFiLENBQUEsR0FBQSxLQUFBLEdBQUEsQ0FBOEMsQ0FBQyxxQkFBRCxDQUFBRCxNQUFBQSxDQUE2QkUsRUFBN0JGLENBQTlDLENBQUEsR0FBQSxJQUFtRjtBQUNwRzs7QUFFQSxhQUFlLFdBQUEsRUFBQSxvRUFBQSxRQUFBLEVBQUEsRUFBQSxNQUFBLENBQVE7QUFDdkI7QUFiRUEsSUFBQUEsQ0FBQUEsMkJBQUFBLENBQUFBLGdCQTVDQTtBQURGWixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQUZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6Mzg0MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvYmFzaWNfb2JqZWN0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEJhc2ljT2JqZWN0XG4gIGRlZiBpbml0aWFsaXplKCopXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgc2VsZiA9PT0gb3RoZXJgXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHNlbGYgPT0gb3RoZXJcbiAgZW5kXG5cbiAgYWxpYXMgZXF1YWw/ID09XG5cbiAgZGVmIF9faWRfX1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkaWQ7XG4gICAgICB9XG4gICAgICBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYsICckJGlkJywgT3BhbC51aWQoKSk7XG4gICAgICByZXR1cm4gc2VsZi4kJGlkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIF9fc2VuZF9fKHN5bWJvbCwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBmdW5jID0gc2VsZlsnJCcgKyBzeW1ib2xdXG5cbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgZnVuYy4kJHAgPSBibG9jaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBzZWxmLiRtZXRob2RfbWlzc2luZy4kJHAgPSBibG9jaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJG1ldGhvZF9taXNzaW5nLmFwcGx5KHNlbGYsIFtzeW1ib2xdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgIVxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiAhPShvdGhlcilcbiAgICAhKHNlbGYgPT0gb3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9ldmFsKCphcmdzLCAmYmxvY2spXG4gICAgaWYgYmxvY2submlsPyAmJiBgISFPcGFsLmNvbXBpbGVgXG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxLi4zKScgdW5sZXNzICgxLi4zKS5jb3Zlcj8gYXJncy5zaXplXG5cbiAgICAgIHN0cmluZywgZmlsZSwgX2xpbmVubyA9ICphcmdzXG4gICAgICBkZWZhdWx0X2V2YWxfb3B0aW9ucyA9IHsgZmlsZTogKGZpbGUgfHwgJyhldmFsKScpLCBldmFsOiB0cnVlIH1cbiAgICAgIGNvbXBpbGluZ19vcHRpb25zID0gX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fLm1lcmdlKGRlZmF1bHRfZXZhbF9vcHRpb25zKVxuICAgICAgY29tcGlsZWQgPSA6Ok9wYWwuY29tcGlsZSBzdHJpbmcsIGNvbXBpbGluZ19vcHRpb25zXG4gICAgICBibG9jayA9IDo6S2VybmVsLnByb2MgZG9cbiAgICAgICAgJXh7XG4gICAgICAgICAgcmV0dXJuIChmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZhbChjb21waWxlZCk7XG4gICAgICAgICAgfSkoc2VsZilcbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZWxzaWYgYXJncy5hbnk/XG4gICAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLnNpemV9IGZvciAwKVwiXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBvbGQgPSBibG9jay4kJHMsXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBibG9jay4kJHMgPSBudWxsO1xuXG4gICAgICAvLyBOZWVkIHRvIHBhc3MgJCRldmFsIHNvIHRoYXQgbWV0aG9kIGRlZmluaXRpb25zIGtub3cgaWYgdGhpcyBpc1xuICAgICAgLy8gYmVpbmcgZG9uZSBvbiBhIGNsYXNzL21vZHVsZS4gQ2Fubm90IGJlIGNvbXBpbGVyIGRyaXZlbiBzaW5jZVxuICAgICAgLy8gc2VuZCg6aW5zdGFuY2VfZXZhbCkgbmVlZHMgdG8gd29yay5cbiAgICAgIGlmIChzZWxmLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgICAgc2VsZi4kJGV2YWwgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGJsb2NrLmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgc2VsZi4kJGV2YWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGJsb2NrLmNhbGwoc2VsZiwgc2VsZik7XG4gICAgICB9XG5cbiAgICAgIGJsb2NrLiQkcyA9IG9sZDtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9leGVjKCphcmdzLCAmYmxvY2spXG4gICAgOjpLZXJuZWwucmFpc2UgOjpBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgYmxvY2tfc2VsZiA9IGJsb2NrLiQkcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG5cbiAgICAgIGlmIChzZWxmLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgICAgc2VsZi4kJGV2YWwgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgIHNlbGYuJCRldmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgYmxvY2suJCRzID0gYmxvY2tfc2VsZjtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX2FkZGVkKCopXG4gIGVuZFxuXG4gIGRlZiBzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoKilcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9tZXRob2RfdW5kZWZpbmVkKCopXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfbWlzc2luZyhzeW1ib2wsICphcmdzLCAmYmxvY2spXG4gICAgbWVzc2FnZSA9IGlmIGBzZWxmLiRpbnNwZWN0ICYmICFzZWxmLiRpbnNwZWN0LiQkc3R1YmBcbiAgICAgICAgICAgICAgICBcInVuZGVmaW5lZCBtZXRob2QgYCN7c3ltYm9sfScgZm9yICN7aW5zcGVjdH06I3tgc2VsZi4kJGNsYXNzYH1cIlxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgXCJ1bmRlZmluZWQgbWV0aG9kIGAje3N5bWJvbH0nIGZvciAje2BzZWxmLiQkY2xhc3NgfVwiXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgOjpLZXJuZWwucmFpc2UgOjpOb01ldGhvZEVycm9yLm5ldyhtZXNzYWdlLCBzeW1ib2wpXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1ldGhvZF9uYW1lLCBpbmNsdWRlX2FsbCA9IGZhbHNlKVxuICAgIGZhbHNlXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJpbml0aWFsaXplIiwiPT0iLCJlcWw/Iiwic2VsZiIsIm90aGVyIiwiX19pZF9fIiwiX19zZW5kX18iLCIhIiwiIT0iLCJpbnN0YW5jZV9ldmFsIiwiJHJldF9vcl8xIiwiYmxvY2siLCJuaWw/IiwiMSIsIjMiLCJjb3Zlcj8iLCJhcmdzIiwic2l6ZSIsInJhaXNlIiwic3RyaW5nIiwiZmlsZSIsIl9saW5lbm8iLCJkZWZhdWx0X2V2YWxfb3B0aW9ucyIsIiRyZXRfb3JfMiIsImNvbXBpbGluZ19vcHRpb25zIiwiX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fIiwibWVyZ2UiLCJjb21waWxlZCIsImNvbXBpbGUiLCJwcm9jIiwiYW55PyIsImluc3RhbmNlX2V4ZWMiLCJzaW5nbGV0b25fbWV0aG9kX2FkZGVkIiwic2luZ2xldG9uX21ldGhvZF9yZW1vdmVkIiwic2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQiLCJtZXRob2RfbWlzc2luZyIsIm1lc3NhZ2UiLCJzeW1ib2wiLCJpbnNwZWN0IiwibmV3IiwicmVzcG9uZF90b19taXNzaW5nPyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0U7QUFBQUMsSUFBQUEsOEJBQUFBLDRCQUFBQSxzQkFGRixFQUVFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFGRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxPQUFBLEdBQUE7QUFFRUEsSUFBQUEsQ0FBQUEsd0NBQUFBLENBQUE7QUFBQTtBQUdBQyxJQUFBQSxzQkFBQUEsd0JBQUFBLFNBQU8sS0FBUEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxjQUFEO0FBREZBLElBQUFBLENBQUFBLG1DQUFBQSxDQUhBO0FBQUE7QUFPQUMsSUFBQUEsd0JBQUFBLDBCQUFBQSxTQUFTLEtBQVRBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFDLElBQUFGLE9BQUFBLENBQVFHLEtBQVJIO0FBREZDLElBQUFBLENBQUFBLHFDQUFBQSxDQVBBO0FBQUEs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SnZDO0FBQUEsTUFvSkksT0FBQSxLQXBKSjtBQW1KRUEsSUFBQUEsQ0FBQUEsc0RBQUFBLENBQUFBLCtCQWpKQTtBQURGekMsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MDk2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9rZXJuZWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGNvZXJjZV90bywgcmVzcG9uZF90b1xuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBtZXRob2RfbWlzc2luZyhzeW1ib2wsICphcmdzLCAmYmxvY2spXG4gICAgcmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje3N5bWJvbH0nIGZvciAje2luc3BlY3R9XCIsIHN5bWJvbCwgYXJncylcbiAgZW5kXG5cbiAgZGVmID1+KG9iailcbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgIX4ob2JqKVxuICAgICEoc2VsZiA9fiBvYmopXG4gIGVuZFxuXG4gIGRlZiA9PT0ob3RoZXIpXG4gICAgb2JqZWN0X2lkID09IG90aGVyLm9iamVjdF9pZCB8fCBzZWxmID09IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgJXh7XG4gICAgICAvLyBzZXQgZ3VhcmQgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgc2VsZi4kJGNvbXBhcmFibGUgPSB0cnVlO1xuXG4gICAgICB2YXIgeCA9ICN7c2VsZiA9PSBvdGhlcn07XG5cbiAgICAgIGlmICh4ICYmIHggIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtZXRob2QobmFtZSlcbiAgICAleHtcbiAgICAgIHZhciBtZXRoID0gc2VsZlsnJCcgKyBuYW1lXTtcblxuICAgICAgaWYgKCFtZXRoIHx8IG1ldGguJCRzdHViKSB7XG4gICAgICAgICN7cmFpc2UgTmFtZUVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYCN7bmFtZX0nIGZvciBjbGFzcyBgI3tzZWxmLmNsYXNzfSdcIiwgbmFtZSl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tNZXRob2QubmV3KHNlbGYsIGBtZXRoLiQkb3duZXIgfHwgI3tzZWxmLmNsYXNzfWAsIGBtZXRoYCwgbmFtZSl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1ldGhvZHMoYWxsID0gdHJ1ZSlcbiAgICAleHtcbiAgICAgIGlmICgkdHJ1dGh5KCN7YWxsfSkpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwubWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLm93bl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHB1YmxpY19tZXRob2RzKGFsbCA9IHRydWUpXG4gICAgJXh7XG4gICAgICBpZiAoJHRydXRoeSgje2FsbH0pKSB7XG4gICAgICAgIHJldHVybiBPcGFsLm1ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5yZWNlaXZlcl9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIEFycmF5KG9iamVjdClcbiAgICAleHtcbiAgICAgIHZhciBjb2VyY2VkO1xuXG4gICAgICBpZiAob2JqZWN0ID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgY29lcmNlZCA9ICN7T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgIGlmIChjb2VyY2VkICE9PSBuaWwpIHsgcmV0dXJuIGNvZXJjZWQ7IH1cblxuICAgICAgY29lcmNlZCA9ICN7T3BhbC5jb2VyY2VfdG8/KG9iamVjdCwgQXJyYXksIDp0b19hKX07XG4gICAgICBpZiAoY29lcmNlZCAhPT0gbmlsKSB7IHJldHVybiBjb2VyY2VkOyB9XG5cbiAgICAgIHJldHVybiBbb2JqZWN0XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhdF9leGl0KCZibG9jaylcbiAgICAkX19hdF9leGl0X18gfHw9IFtdXG4gICAgJF9fYXRfZXhpdF9fIDw8IGJsb2NrXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIGNhbGxlcihzdGFydCA9IDEsIGxlbmd0aCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBzdGFjaywgcmVzdWx0XG5cbiAgICAgIHN0YWNrID0gKG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIpLnNwbGl0KFwiXFxuXCIpXG4gICAgICByZXN1bHQgPSBbXVxuXG4gICAgICAvLyBTa2lwIHRoZSBpbml0aWFsIGxpbmUgKFwiRXJyb3I6XCIpIGFuZCBLZXJuZWwjY2FsbGVyIHdpdGggaT0zXG4gICAgICBmb3IgKHZhciBpID0gMywgaWkgPSBzdGFjay5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmICghc3RhY2tbaV0ubWF0Y2goXCJydW50aW1lLmpzXCIpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2tbaV0ucmVwbGFjZSgvXiAqXFx3KyArLywgJycpKVxuICAgICAgICAgIGlmIChsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA9PSBsZW5ndGgpIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGFzc1xuICAgIGBzZWxmLiQkY2xhc3NgXG4gIGVuZFxuXG4gIGRlZiBjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3RoZXIpLCBpLCBpaSwgbmFtZTtcbiAgICAgIGZvciAoaSA9IDAsIGlpID0ga2V5cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBrZXlzW2ldO1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgIT09ICckJyAmJiBvdGhlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHNlbGZbbmFtZV0gPSBvdGhlcltuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvcHlfc2luZ2xldG9uX21ldGhvZHMob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbmFtZSwgbmFtZXMsIGxlbmd0aDtcblxuICAgICAgaWYgKG90aGVyLmhhc093blByb3BlcnR5KCckJG1ldGEnKSkge1xuICAgICAgICB2YXIgb3RoZXJfc2luZ2xldG9uX2NsYXNzID0gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG90aGVyKTtcbiAgICAgICAgdmFyIHNlbGZfc2luZ2xldG9uX2NsYXNzID0gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKHNlbGYpO1xuICAgICAgICBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG90aGVyX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZSk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgaWYgKE9wYWwuaXNfbWV0aG9kKG5hbWUpKSB7XG4gICAgICAgICAgICBzZWxmX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZVtuYW1lXSA9IG90aGVyX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZVtuYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmX3NpbmdsZXRvbl9jbGFzcy4kJGNvbnN0ID0gT2JqZWN0LmFzc2lnbih7fSwgb3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkY29uc3QpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoXG4gICAgICAgICAgc2VsZl9zaW5nbGV0b25fY2xhc3MuJCRwcm90b3R5cGUsXG4gICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKG90aGVyX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvdGhlciksIGxlbmd0aCA9IG5hbWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSAnJCcgJiYgbmFtZS5jaGFyQXQoMSkgIT09ICckJyAmJiBvdGhlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHNlbGZbbmFtZV0gPSBvdGhlcltuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNsb25lKGZyZWV6ZTogdHJ1ZSlcbiAgICBjb3B5ID0gc2VsZi5jbGFzcy5hbGxvY2F0ZVxuXG4gICAgY29weS5jb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9jbG9uZShzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9jbG9uZShvdGhlcilcbiAgICBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBkZWZpbmVfc2luZ2xldG9uX21ldGhvZChuYW1lLCBtZXRob2QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBzaW5nbGV0b25fY2xhc3MuZGVmaW5lX21ldGhvZChuYW1lLCBtZXRob2QsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBzZWxmLmNsYXNzLmFsbG9jYXRlXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3RoZXIpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxuICBlbmRcblxuICBkZWYgZW51bV9mb3IobWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgRW51bWVyYXRvci5mb3Ioc2VsZiwgbWV0aG9kLCAqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBhbGlhcyB0b19lbnVtIGVudW1fZm9yXG5cbiAgZGVmIGVxdWFsPyhvdGhlcilcbiAgICBgc2VsZiA9PT0gb3RoZXJgXG4gIGVuZFxuXG4gIGRlZiBleGl0KHN0YXR1cyA9IHRydWUpXG4gICAgJF9fYXRfZXhpdF9fIHx8PSBbXVxuXG4gICAgdW50aWwgJF9fYXRfZXhpdF9fLmVtcHR5P1xuICAgICAgYmxvY2sgPSAkX19hdF9leGl0X18ucG9wXG4gICAgICBibG9jay5jYWxsXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzdGF0dXMuJCRpc19ib29sZWFuKSB7XG4gICAgICAgIHN0YXR1cyA9IHN0YXR1cyA/IDAgOiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gJGNvZXJjZV90byhzdGF0dXMsICN7SW50ZWdlcn0sICd0b19pbnQnKVxuICAgICAgfVxuXG4gICAgICBPcGFsLmV4aXQoc3RhdHVzKTtcbiAgICB9XG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBleHRlbmQoKm1vZHMpXG4gICAgJXh7XG4gICAgICB2YXIgc2luZ2xldG9uID0gI3tzaW5nbGV0b25fY2xhc3N9O1xuXG4gICAgICBmb3IgKHZhciBpID0gbW9kcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbW9kID0gbW9kc1tpXTtcblxuICAgICAgICBpZiAoIW1vZC4kJGlzX21vZHVsZSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgbW9kYC5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICAgIH1cblxuICAgICAgICAje2Btb2RgLmFwcGVuZF9mZWF0dXJlcyBgc2luZ2xldG9uYH07XG4gICAgICAgICN7YG1vZGAuZXh0ZW5kX29iamVjdCBzZWxmfTtcbiAgICAgICAgI3tgbW9kYC5leHRlbmRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgX19pZF9fXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgdG9fc1xuICBlbmRcblxuICBkZWYgaW5zdGFuY2Vfb2Y/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ2NsYXNzIG9yIG1vZHVsZSByZXF1aXJlZCd9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNsYXNzID09PSBrbGFzcztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZV9kZWZpbmVkPyhuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgT3BhbC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGYsIG5hbWUuc3Vic3RyKDEpKWBcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX2dldChuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIHZhciBpdmFyID0gc2VsZltPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpXTtcblxuICAgICAgcmV0dXJuIGl2YXIgPT0gbnVsbCA/IG5pbCA6IGl2YXI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVfc2V0KG5hbWUsIHZhbHVlKVxuICAgIG5hbWUgPSBPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICBgc2VsZltPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpXSA9IHZhbHVlYFxuICBlbmRcblxuICBkZWYgcmVtb3ZlX2luc3RhbmNlX3ZhcmlhYmxlKG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgICV4e1xuICAgICAgdmFyIGtleSA9IE9wYWwuaXZhcihuYW1lLnN1YnN0cigxKSksXG4gICAgICAgICAgdmFsO1xuICAgICAgaWYgKHNlbGYuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YWwgPSBzZWxmW2tleV07XG4gICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmFpc2UgTmFtZUVycm9yLCBcImluc3RhbmNlIHZhcmlhYmxlICN7bmFtZX0gbm90IGRlZmluZWRcIlxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGl2YXI7XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gc2VsZikge1xuICAgICAgICBpZiAoc2VsZi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBuYW1lLmNoYXJBdCgwKSAhPT0gJyQnKSB7XG4gICAgICAgICAgaWYgKG5hbWUuc3Vic3RyKC0xKSA9PT0gJyQnKSB7XG4gICAgICAgICAgICBpdmFyID0gbmFtZS5zbGljZSgwLCBuYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdmFyID0gbmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2goJ0AnICsgaXZhcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBJbnRlZ2VyKHZhbHVlLCBiYXNlID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGksIHN0ciwgYmFzZV9kaWdpdHM7XG5cbiAgICAgIGlmICghdmFsdWUuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKGJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2Jhc2Ugc3BlY2lmaWVkIGZvciBub24gc3RyaW5nIHZhbHVlJ31cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgbmlsIGludG8gSW50ZWdlclwifVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS4kJGlzX251bWJlcikge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHwgdmFsdWUgPT09IC1JbmZpbml0eSB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7cmFpc2UgRmxvYXREb21haW5FcnJvciwgdmFsdWV9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyg6dG9faW50KX0pIHtcbiAgICAgICAgICBpID0gI3t2YWx1ZS50b19pbnR9O1xuICAgICAgICAgIGlmIChpICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3tPcGFsLmNvZXJjZV90byEodmFsdWUsIEludGVnZXIsIDp0b19pKX07XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gXCIwXCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChiYXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYmFzZSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlID0gJGNvZXJjZV90byhiYXNlLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGlmIChiYXNlID09PSAxIHx8IGJhc2UgPCAwIHx8IGJhc2UgPiAzNikge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhZGl4ICN7YmFzZX1cIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHIgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFxcZClfKD89XFxkKS9nLCAnJDEnKTtcblxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL14oXFxzKlsrLV0/KSgwW2JvZHhdPykvLCBmdW5jdGlvbiAoXywgaGVhZCwgZmxhZykge1xuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDIpIHtcbiAgICAgICAgICAgIGJhc2UgPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgY2FzZSAnMG8nOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDgpIHtcbiAgICAgICAgICAgIGJhc2UgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICcwZCc6XG4gICAgICAgICAgaWYgKGJhc2UgPT09IDAgfHwgYmFzZSA9PT0gMTApIHtcbiAgICAgICAgICAgIGJhc2UgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnMHgnOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDE2KSB7XG4gICAgICAgICAgICBiYXNlID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEludGVnZXIoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgfSk7XG5cbiAgICAgIGJhc2UgPSAoYmFzZSA9PT0gMCA/IDEwIDogYmFzZSk7XG5cbiAgICAgIGJhc2VfZGlnaXRzID0gJzAtJyArIChiYXNlIDw9IDEwID8gYmFzZSAtIDEgOiAnOWEtJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyAoYmFzZSAtIDExKSkpO1xuXG4gICAgICBpZiAoIShuZXcgUmVnRXhwKCdeXFxcXHMqWystXT9bJyArIGJhc2VfZGlnaXRzICsgJ10rXFxcXHMqJCcpKS50ZXN0KHN0cikpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEludGVnZXIoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgfVxuXG4gICAgICBpID0gcGFyc2VJbnQoc3RyLCBiYXNlKTtcblxuICAgICAgaWYgKGlzTmFOKGkpKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBJbnRlZ2VyKCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgRmxvYXQodmFsdWUpXG4gICAgJXh7XG4gICAgICB2YXIgc3RyO1xuXG4gICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IG5pbCBpbnRvIEZsb2F0XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS4kJGlzX3N0cmluZykge1xuICAgICAgICBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xuXG4gICAgICAgIC8vU3BlY2lhbCBjYXNlIGZvciBoZXggc3RyaW5ncyBvbmx5OlxuICAgICAgICBpZiAoL15cXHMqWy0rXT8wW3hYXVswLTlhLWZBLUZdK1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICByZXR1cm4gI3tJbnRlZ2VyKGBzdHJgKX07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIS9eXFxzKlstK10/WzAtOV0qXFwuP1swLTldKyhbZUVdWy0rXT9bMC05XSspP1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgRmxvYXQoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7T3BhbC5jb2VyY2VfdG8hKHZhbHVlLCBGbG9hdCwgOnRvX2YpfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBIYXNoKGFyZylcbiAgICByZXR1cm4ge30gaWYgYXJnLm5pbD8gfHwgYXJnID09IFtdXG4gICAgcmV0dXJuIGFyZyBpZiBIYXNoID09PSBhcmdcbiAgICBPcGFsLmNvZXJjZV90byEoYXJnLCBIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGlzX2E/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ2NsYXNzIG9yIG1vZHVsZSByZXF1aXJlZCd9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gT3BhbC5pc19hKHNlbGYsIGtsYXNzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpdHNlbGZcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG5cbiAgZGVmIGxhbWJkYSgmYmxvY2spXG4gICAgYE9wYWwubGFtYmRhKGJsb2NrKWBcbiAgZW5kXG5cbiAgZGVmIGxvYWQoZmlsZSlcbiAgICBmaWxlID0gT3BhbC5jb2VyY2VfdG8hKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBgT3BhbC5sb2FkKCN7ZmlsZX0pYFxuICBlbmRcblxuICBkZWYgbG9vcFxuICAgIHJldHVybiBlbnVtX2Zvcig6bG9vcCkgeyBGbG9hdDo6SU5GSU5JVFkgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICB3aGlsZSB0cnVlXG4gICAgICBiZWdpblxuICAgICAgICB5aWVsZFxuICAgICAgcmVzY3VlIFN0b3BJdGVyYXRpb24gPT4gZVxuICAgICAgICByZXR1cm4gZS5yZXN1bHRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbmlsP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgcHJpbnRmKCphcmdzKVxuICAgIGlmIGFyZ3MuYW55P1xuICAgICAgcHJpbnQgZm9ybWF0KCphcmdzKVxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBwcm9jKCZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYGJsb2NrLiQkaXNfbGFtYmRhID0gZmFsc2VgXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIHB1dHMoKnN0cnMpXG4gICAgJHN0ZG91dC5wdXRzKCpzdHJzKVxuICBlbmRcblxuICBkZWYgcCgqYXJncylcbiAgICBhcmdzLmVhY2ggeyB8b2JqfCAkc3Rkb3V0LnB1dHMgb2JqLmluc3BlY3QgfVxuXG4gICAgYXJncy5sZW5ndGggPD0gMSA/IGFyZ3NbMF0gOiBhcmdzXG4gIGVuZFxuXG4gIGRlZiBwcmludCgqc3RycylcbiAgICAkc3Rkb3V0LnByaW50KCpzdHJzKVxuICBlbmRcblxuICBkZWYgd2Fybigqc3RycywgdXBsZXZlbDogbmlsKVxuICAgIGlmIHVwbGV2ZWxcbiAgICAgIHVwbGV2ZWwgPSBPcGFsLmNvZXJjZV90byEodXBsZXZlbCwgSW50ZWdlciwgOnRvX3N0cilcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwibmVnYXRpdmUgbGV2ZWwgKCN7dXBsZXZlbH0pXCIgaWYgdXBsZXZlbCA8IDBcbiAgICAgIGxvY2F0aW9uID0gY2FsbGVyKHVwbGV2ZWwgKyAyLCAxKS5maXJzdFxuICAgICAgbG9jYXRpb24gPSBcIiN7bG9jYXRpb259OiBcIiBpZiBsb2NhdGlvblxuICAgICAgc3RycyA9IHN0cnMubWFwIHsgfHN8IFwiI3tsb2NhdGlvbn13YXJuaW5nOiAje3N9XCIgfVxuICAgIGVuZFxuXG4gICAgJHN0ZGVyci5wdXRzKCpzdHJzKSB1bmxlc3MgJFZFUkJPU0UubmlsPyB8fCBzdHJzLmVtcHR5P1xuICBlbmRcblxuICBkZWYgcmFpc2UoZXhjZXB0aW9uID0gdW5kZWZpbmVkLCBzdHJpbmcgPSBuaWwsIF9iYWNrdHJhY2UgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoZXhjZXB0aW9uID09IG51bGwgJiYgI3skIX0gIT09IG5pbCkge1xuICAgICAgICB0aHJvdyAjeyQhfTtcbiAgICAgIH1cbiAgICAgIGlmIChleGNlcHRpb24gPT0gbnVsbCkge1xuICAgICAgICBleGNlcHRpb24gPSAje1J1bnRpbWVFcnJvci5uZXd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7UnVudGltZUVycm9yLm5ldyBleGNlcHRpb259O1xuICAgICAgfVxuICAgICAgLy8gdXNpbmcgcmVzcG9uZF90bz8gYW5kIG5vdCBhbiB1bmRlZmluZWQgY2hlY2sgdG8gYXZvaWQgbWV0aG9kX21pc3NpbmcgbWF0Y2hpbmcgYXMgdHJ1ZVxuICAgICAgZWxzZSBpZiAoZXhjZXB0aW9uLiQkaXNfY2xhc3MgJiYgI3tleGNlcHRpb24ucmVzcG9uZF90bz8oOmV4Y2VwdGlvbil9KSB7XG4gICAgICAgIGV4Y2VwdGlvbiA9ICN7ZXhjZXB0aW9uLmV4Y2VwdGlvbiBzdHJpbmd9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tleGNlcHRpb24uaXNfYT8oRXhjZXB0aW9uKX0pIHtcbiAgICAgICAgLy8gZXhjZXB0aW9uIGlzIGZpbmVcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBleGNlcHRpb24gPSAje1R5cGVFcnJvci5uZXcgJ2V4Y2VwdGlvbiBjbGFzcy9vYmplY3QgZXhwZWN0ZWQnfTtcbiAgICAgIH1cblxuICAgICAgaWYgKCN7JCF9ICE9PSBuaWwpIHtcbiAgICAgICAgT3BhbC5leGNlcHRpb25zLnB1c2goI3skIX0pO1xuICAgICAgfVxuXG4gICAgICAjeyQhfSA9IGV4Y2VwdGlvbjtcblxuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmFpbCByYWlzZVxuXG4gIGRlZiByYW5kKG1heCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gI3tSYW5kb206OkRFRkFVTFQucmFuZH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXguJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKG1heCA8IDApIHtcbiAgICAgICAgICBtYXggPSBNYXRoLmFicyhtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heCAlIDEgIT09IDApIHtcbiAgICAgICAgICBtYXggPSBtYXguJHRvX2koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXggPT09IDApIHtcbiAgICAgICAgICBtYXggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgUmFuZG9tOjpERUZBVUxULnJhbmQobWF4KVxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90bz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICAleHtcbiAgICAgIHZhciBib2R5ID0gc2VsZlsnJCcgKyBuYW1lXTtcblxuICAgICAgaWYgKHR5cGVvZihib2R5KSA9PT0gXCJmdW5jdGlvblwiICYmICFib2R5LiQkc3R1Yikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGZbJyRyZXNwb25kX3RvX21pc3Npbmc/J10uJCRwcmlzdGluZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tyZXNwb25kX3RvX21pc3Npbmc/KG5hbWUsIGluY2x1ZGVfYWxsKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90b19taXNzaW5nPyhtZXRob2RfbmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICBmYWxzZVxuICBlbmRcblxuICBPcGFsLnByaXN0aW5lKHNlbGYsIDpyZXNwb25kX3RvPywgOnJlc3BvbmRfdG9fbWlzc2luZz8pXG5cbiAgZGVmIHJlcXVpcmUoZmlsZSlcbiAgICBmaWxlID0gT3BhbC5jb2VyY2VfdG8hKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBgT3BhbC5yZXF1aXJlKCN7ZmlsZX0pYFxuICBlbmRcblxuICBkZWYgcmVxdWlyZV9yZWxhdGl2ZShmaWxlKVxuICAgIE9wYWwudHJ5X2NvbnZlcnQhKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBmaWxlID0gRmlsZS5leHBhbmRfcGF0aCBGaWxlLmpvaW4oYE9wYWwuY3VycmVudF9maWxlYCwgJy4uJywgZmlsZSlcblxuICAgIGBPcGFsLnJlcXVpcmUoI3tmaWxlfSlgXG4gIGVuZFxuXG4gICMgYHBhdGhgIHNob3VsZCBiZSB0aGUgZnVsbCBwYXRoIHRvIGJlIGZvdW5kIGluIHJlZ2lzdGVyZWQgbW9kdWxlcyAoYE9wYWwubW9kdWxlc2ApXG4gIGRlZiByZXF1aXJlX3RyZWUocGF0aClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgcGF0aCA9ICN7RmlsZS5leHBhbmRfcGF0aChwYXRoKX1cbiAgICAgIHBhdGggPSBPcGFsLm5vcm1hbGl6ZShwYXRoKTtcbiAgICAgIGlmIChwYXRoID09PSAnLicpIHBhdGggPSAnJztcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gT3BhbC5tb2R1bGVzKSB7XG4gICAgICAgIGlmICgje2BuYW1lYC5zdGFydF93aXRoPyhwYXRoKX0pIHtcbiAgICAgICAgICByZXN1bHQucHVzaChbbmFtZSwgT3BhbC5yZXF1aXJlKG5hbWUpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNlbmQgICAgICAgIF9fc2VuZF9fXG4gIGFsaWFzIHB1YmxpY19zZW5kIF9fc2VuZF9fXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIGBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBzbGVlcChzZWNvbmRzID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKHNlY29uZHMgPT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IE5pbENsYXNzIGludG8gdGltZSBpbnRlcnZhbFwifVxuICAgICAgfVxuICAgICAgaWYgKCFzZWNvbmRzLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWNvbmRzLmNsYXNzfSBpbnRvIHRpbWUgaW50ZXJ2YWxcIn1cbiAgICAgIH1cbiAgICAgIGlmIChzZWNvbmRzIDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd0aW1lIGludGVydmFsIG11c3QgYmUgcG9zaXRpdmUnfVxuICAgICAgfVxuICAgICAgdmFyIGdldF90aW1lID0gT3BhbC5nbG9iYWwucGVyZm9ybWFuY2UgP1xuICAgICAgICBmdW5jdGlvbigpIHtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9IDpcbiAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBEYXRlKCl9XG5cbiAgICAgIHZhciB0ID0gZ2V0X3RpbWUoKTtcbiAgICAgIHdoaWxlIChnZXRfdGltZSgpIC0gdCA8PSBzZWNvbmRzICogMTAwMCk7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChzZWNvbmRzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzcmFuZChzZWVkID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIFJhbmRvbS5zcmFuZChzZWVkKVxuICBlbmRcblxuICBkZWYgU3RyaW5nKHN0cilcbiAgICBPcGFsLmNvZXJjZV90bz8oc3RyLCBTdHJpbmcsIDp0b19zdHIpIHx8XG4gICAgICBPcGFsLmNvZXJjZV90byEoc3RyLCBTdHJpbmcsIDp0b19zKVxuICBlbmRcblxuICBkZWYgdGFwKCZibG9jaylcbiAgICB5aWVsZCBzZWxmXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiM8I3tzZWxmLmNsYXNzfToweCN7X19pZF9fLnRvX3MoMTYpfT5cIlxuICBlbmRcblxuICBkZWYgY2F0Y2goc3ltKVxuICAgIHlpZWxkXG4gIHJlc2N1ZSBVbmNhdWdodFRocm93RXJyb3IgPT4gZVxuICAgIHJldHVybiBlLmFyZyBpZiBlLnN5bSA9PSBzeW1cbiAgICByYWlzZVxuICBlbmRcblxuICBkZWYgdGhyb3coKmFyZ3MpXG4gICAgcmFpc2UgVW5jYXVnaHRUaHJvd0Vycm9yLCBhcmdzXG4gIGVuZFxuXG4gICMgYmFzaWMgaW1wbGVtZW50YXRpb24gb2Ygb3BlbiwgZGVsZWdhdGUgdG8gRmlsZS5vcGVuXG4gIGRlZiBvcGVuKCphcmdzLCAmYmxvY2spXG4gICAgRmlsZS5vcGVuKCphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB5aWVsZF9zZWxmXG4gICAgcmV0dXJuIGVudW1fZm9yKDp5aWVsZF9zZWxmKSB7IDEgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgeWllbGQgc2VsZlxuICBlbmRcblxuICBhbGlhcyB0aGVuIHlpZWxkX3NlbGZcblxuICBPcGFsLnByaXN0aW5lKHNlbGYsIDptZXRob2RfbWlzc2luZylcbmVuZFxuXG5jbGFzcyBPYmplY3RcbiAgaW5jbHVkZSBLZXJuZWxcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIm1ldGhvZF9taXNzaW5nIiwicmFpc2UiLCJuZXciLCJzeW1ib2wiLCJpbnNwZWN0IiwiYXJncyIsIj1+IiwiIX4iLCJzZWxmIiwib2JqIiwiISIsIj09PSIsIiRyZXRfb3JfMSIsIm9iamVjdF9pZCIsIj09Iiwib3RoZXIiLCI8PT4iLCJtZXRob2QiLCJuYW1lIiwiY2xhc3MiLCJtZXRob2RzIiwiYWxsIiwicHVibGljX21ldGhvZHMiLCJBcnJheSIsImNvZXJjZV90bz8iLCJvYmplY3QiLCJhdF9leGl0IiwiJF9fYXRfZXhpdF9fIiwiJHJldF9vcl8yIiwiPDwiLCJibG9jayIsImNhbGxlciIsIjEiLCJjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJjbG9uZSIsImNvcHkiLCJhbGxvY2F0ZSIsImluaXRpYWxpemVfY2xvbmUiLCJpbml0aWFsaXplX2NvcHkiLCJkZWZpbmVfc2luZ2xldG9uX21ldGhvZCIsImRlZmluZV9tZXRob2QiLCJzaW5nbGV0b25fY2xhc3MiLCJkdXAiLCJpbml0aWFsaXplX2R1cCIsImVudW1fZm9yIiwiZm9yIiwiZXF1YWw/IiwiZXhpdCIsIiRyZXRfb3JfMyIsImVtcHR5PyIsInBvcCIsImNhbGwiLCJleHRlbmQiLCJhcHBlbmRfZmVhdHVyZXMiLCJleHRlbmRfb2JqZWN0IiwiZXh0ZW5kZWQiLCJoYXNoIiwiX19pZF9fIiwidG9fcyIsImluc3RhbmNlX29mPyIsImluc3RhbmNlX3ZhcmlhYmxlX2RlZmluZWQ/IiwiaW5zdGFuY2VfdmFyaWFibGVfbmFtZSEiLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCJpbnN0YW5jZV92YXJpYWJsZV9zZXQiLCJyZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJJbnRlZ2VyIiwidmFsdWUiLCJyZXNwb25kX3RvPyIsInRvX2ludCIsImNvZXJjZV90byEiLCJiYXNlIiwiRmxvYXQiLCJIYXNoIiwiJHJldF9vcl80IiwiYXJnIiwibmlsPyIsImlzX2E/IiwiaXRzZWxmIiwibGFtYmRhIiwibG9hZCIsImZpbGUiLCJsb29wIiwiYmxvY2tfZ2l2ZW4/IiwiZSIsInJlc3VsdCIsInByaW50ZiIsImFueT8iLCJwcmludCIsImZvcm1hdCIsInByb2MiLCJwdXRzIiwiJHN0ZG91dCIsInN0cnMiLCJwIiwiZWFjaCIsIjw9IiwibGVuZ3RoIiwiW10iLCIwIiwid2FybiIsInVwbGV2ZWwiLCI8IiwibG9jYXRpb24iLCIrIiwiMiIsImZpcnN0IiwibWFwIiwicyIsIiRyZXRfb3JfNSIsIiRWRVJCT1NFIiwiJHN0ZGVyciIsIiQhIiwiZXhjZXB0aW9uIiwic3RyaW5nIiwicmFuZCIsIm1heCIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJpbmNsdWRlX2FsbCIsInByaXN0aW5lIiwicmVxdWlyZSIsInJlcXVpcmVfcmVsYXRpdmUiLCJ0cnlfY29udmVydCEiLCJleHBhbmRfcGF0aCIsImpvaW4iLCJyZXF1aXJlX3RyZWUiLCJwYXRoIiwic3RhcnRfd2l0aD8iLCJzbGVlcCIsInNlY29uZHMiLCJzcmFuZCIsIm5ld19zZWVkIiwic2VlZCIsIlN0cmluZyIsIiRyZXRfb3JfNiIsInN0ciIsInRhcCIsInRvX3Byb2MiLCIxNiIsImNhdGNoIiwic3ltIiwidGhyb3ciLCJvcGVuIiwieWllbGRfc2VsZiIsImluY2x1ZGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUVBLEVBQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRTtBQUFBQyxJQUFB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QThyQmtCLE1BQUEsc0NBOXJCbEI7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQThyQlcsTUFBQSxrQkE5ckJYO0FBQUEsTUErckJJLE9BQUFBLE1BQUEsb0JBQUFBLFFBQUFBLEVBQVUsVUFBQzFJLElBQUQsQ0FBVjBJLEVBQWtCakgsZ0JBQWxCaUgsQ0EvckJKO0FBOHJCRUEsSUFBQUEsQ0FBQUEsOEJBQUFBLENBMXJCQTtBQUFBO0FBOHJCQUMsSUFBQUEsOEJBQUFBLHdCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBQ0UsTUFBQSxJQUEwQzVELGdCQUExQztBQUFBLE1BQUE7QUFBQSxRQUFBLE9BQU92QyxVQUFBQSxZQUFBQSxFQUFBQSxDQUFTLFlBQVRBLENBQUFBLEVBbnNCWCxpQkFBQSxFQUFBOztBQUFBLFFBbXNCbUMsT0FBQWIsQ0Fuc0JuQyxtQkFBQSxrQkFBQSxNQW1zQldhO0FBQVAsTUFBQSxDQUFBO0FBQUEsTUFDQSxPQUFBLG9CQUFNckMsSUFBTixDQUFBLENBREE7QUFERndJLElBQUFBLENBQUFBLG1DQUFBQSxDQTlyQkE7QUFBQSxJQW1zQkEsaUJBQU0sTUFBTixFQUFXLFlBQVgsQ0Fuc0JBO0FBQUEsSUFxc0JBLE9BQUEsb0JBQUF4QixVQUFBQSxDQUFjaEgsTUFBTSxnQkFBcEJnSCxDQXJzQkE7QUFERnpILEVBQUFBLEdBQUFBLFdBQUFBLFdBQUE7QUFBQSxFQXlzQkEsT0FBQW9CO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRSxXQUFBOEgsU0FBQUEsQ0FBUSxzQkFBUkE7QUFERjlILEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBenNCQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjUyMDYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Vycm9yLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEV4Y2VwdGlvbiA8IGBFcnJvcmBcbiAgIyBgdmFyIEtlcm5lbCRyYWlzZSA9ICN7S2VybmVsfS4kcmFpc2VgXG4gIGB2YXIgc3RhY2tfdHJhY2VfbGltaXRgXG5cbiAgZGVmIHNlbGYubmV3KCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIG1lc3NhZ2UgICA9IChhcmdzLmxlbmd0aCA+IDApID8gYXJnc1swXSA6IG5pbDtcbiAgICAgIHZhciBlcnJvciAgICAgPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKG1lc3NhZ2UpO1xuICAgICAgZXJyb3IubmFtZSAgICA9IHNlbGYuJCRuYW1lO1xuICAgICAgZXJyb3IubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICBPcGFsLnNlbmQoZXJyb3IsIGVycm9yLiRpbml0aWFsaXplLCBhcmdzKTtcblxuICAgICAgLy8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoKSB3aWxsIHVzZSAubmFtZSBhbmQgLnRvU3RyaW5nIHRvIGJ1aWxkIHRoZVxuICAgICAgLy8gZmlyc3QgbGluZSBvZiB0aGUgc3RhY2sgdHJhY2Ugc28gaXQgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGVycm9yXG4gICAgICAvLyBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC12Ni54L2RvY3MvYXBpL2Vycm9ycy5odG1sXG4gICAgICBpZiAoT3BhbC5jb25maWcuZW5hYmxlX3N0YWNrX3RyYWNlICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgIC8vIFBhc3NpbmcgS2VybmVsLnJhaXNlIHdpbGwgY3V0IHRoZSBzdGFjayB0cmFjZSBmcm9tIHRoYXQgcG9pbnQgYWJvdmVcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIHN0YWNrX3RyYWNlX2xpbWl0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgZW5kXG4gIGBzdGFja190cmFjZV9saW1pdCA9IHNlbGYuJG5ld2BcblxuICBkZWYgc2VsZi5leGNlcHRpb24oKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqYXJncylcbiAgICAjIHVzaW5nIHNlbGYubWVzc2FnZSBha2EgQG1lc3NhZ2UgdG8gcmV0YWluIGNvbXBhdGliaWxpdHkgd2l0aCBuYXRpdmUgZXhjZXB0aW9uJ3MgbWVzc2FnZSBwcm9wZXJ0eVxuICAgIGBzZWxmLm1lc3NhZ2UgPSAoYXJncy5sZW5ndGggPiAwKSA/IGFyZ3NbMF0gOiBuaWxgXG4gIGVuZFxuXG4gIGRlZiBiYWNrdHJhY2VcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmJhY2t0cmFjZSkge1xuICAgICAgICAvLyBuaWwgaXMgYSB2YWxpZCBiYWNrdHJhY2VcbiAgICAgICAgcmV0dXJuIHNlbGYuYmFja3RyYWNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFja3RyYWNlID0gc2VsZi5zdGFjaztcblxuICAgICAgaWYgKHR5cGVvZihiYWNrdHJhY2UpID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYmFja3RyYWNlLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDAsIDE1KTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJhY2t0cmFjZSkge1xuICAgICAgICByZXR1cm4gYmFja3RyYWNlLnNsaWNlKDAsIDE1KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGV4Y2VwdGlvbihzdHIgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoc3RyID09PSBuaWwgfHwgc2VsZiA9PT0gc3RyKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvbmVkID0gI3tjbG9uZX07XG4gICAgICBjbG9uZWQubWVzc2FnZSA9IHN0cjtcbiAgICAgIGNsb25lZC5zdGFjayA9IHNlbGYuc3RhY2s7XG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cbiAgZW5kXG5cbiAgIyBub3QgdXNpbmcgYWxpYXMgbWVzc2FnZSB0b19zIGJlY2F1c2UgeW91IG5lZWQgdG8gYmUgYWJsZSB0byBvdmVycmlkZSB0b19zIGFuZCBoYXZlIG1lc3NhZ2UgdXNlIG92ZXJyaWRkZW4gbWV0aG9kLCB3b24ndCB3b3JrIHdpdGggYWxpYXNcbiAgZGVmIG1lc3NhZ2VcbiAgICB0b19zXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgYXNfc3RyID0gdG9fc1xuICAgIGFzX3N0ci5lbXB0eT8gPyBzZWxmLmNsYXNzLnRvX3MgOiBcIiM8I3tzZWxmLmNsYXNzLnRvX3N9OiAje3RvX3N9PlwiXG4gIGVuZFxuXG4gIGRlZiBzZXRfYmFja3RyYWNlKGJhY2t0cmFjZSlcbiAgICAleHtcbiAgICAgIHZhciB2YWxpZCA9IHRydWUsIGksIGlpO1xuXG4gICAgICBpZiAoYmFja3RyYWNlID09PSBuaWwpIHtcbiAgICAgICAgc2VsZi5iYWNrdHJhY2UgPSBuaWw7XG4gICAgICAgIHNlbGYuc3RhY2sgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAoYmFja3RyYWNlLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gW2JhY2t0cmFjZV07XG4gICAgICAgIHNlbGYuc3RhY2sgPSBiYWNrdHJhY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYmFja3RyYWNlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGJhY2t0cmFjZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWJhY2t0cmFjZVtpXS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ2JhY2t0cmFjZSBtdXN0IGJlIEFycmF5IG9mIFN0cmluZyd9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IGJhY2t0cmFjZTtcbiAgICAgICAgc2VsZi5zdGFjayA9IGJhY2t0cmFjZS5qb2luKCdcXG4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhY2t0cmFjZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgIyB1c2luZyBzZWxmLm1lc3NhZ2UgYWthIEBtZXNzYWdlIHRvIHJldGFpbiBjb21wYXRpYmlsaXR5IHdpdGggbmF0aXZlIGV4Y2VwdGlvbidzIG1lc3NhZ2UgcHJvcGVydHlcbiAgICAoQG1lc3NhZ2UgJiYgQG1lc3NhZ2UudG9fcykgfHwgc2VsZi5jbGFzcy50b19zXG4gIGVuZFxuZW5kXG5cbiMga2VlcCB0aGUgaW5kZW50YXRpb24sIGl0IG1ha2VzIHRoZSBleGNlcHRpb24gaGllcmFyY2h5IGNsZWFyXG5jbGFzcyBTY3JpcHRFcnJvciAgICAgICA8IEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyBTeW50YXhFcnJvciAgICAgICAgIDwgU2NyaXB0RXJyb3I7IGVuZFxuY2xhc3MgTG9hZEVycm9yICAgICAgICAgICA8IFNjcmlwdEVycm9yOyBlbmRcbmNsYXNzIE5vdEltcGxlbWVudGVkRXJyb3IgPCBTY3JpcHRFcnJvcjsgZW5kXG5cbmNsYXNzIFN5c3RlbUV4aXQgICAgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIE5vTWVtb3J5RXJyb3IgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIFNpZ25hbEV4Y2VwdGlvbiAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIEludGVycnVwdCAgICAgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIFNlY3VyaXR5RXJyb3IgICAgIDwgRXhjZXB0aW9uOyBlbmRcblxuY2xhc3MgU3RhbmRhcmRFcnJvciAgICAgPCBFeGNlcHRpb247IGVuZFxuY2xhc3MgRW5jb2RpbmdFcnJvciAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgWmVyb0RpdmlzaW9uRXJyb3IgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgTmFtZUVycm9yICAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgTm9NZXRob2RFcnJvciAgICAgICAgIDwgTmFtZUVycm9yOyBlbmRcbmNsYXNzIFJ1bnRpbWVFcnJvciAgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIEZyb3plbkVycm9yICAgICAgICAgICA8IFJ1bnRpbWVFcnJvcjsgZW5kXG5jbGFzcyBMb2NhbEp1bXBFcnJvciAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBUeXBlRXJyb3IgICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBBcmd1bWVudEVycm9yICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBJbmRleEVycm9yICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBTdG9wSXRlcmF0aW9uICAgICAgICAgPCBJbmRleEVycm9yOyBlbmRcbmNsYXNzIEtleUVycm9yICAgICAgICAgICAgICA8IEluZGV4RXJyb3I7IGVuZFxuY2xhc3MgUmFuZ2VFcnJvciAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgRmxvYXREb21haW5FcnJvciAgICAgIDwgUmFuZ2VFcnJvcjsgZW5kXG5jbGFzcyBJT0Vycm9yICAgICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBTeXN0ZW1DYWxsRXJyb3IgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5cbm1vZHVsZSBFcnJub1xuICBjbGFzcyBFSU5WQUwgICAgICAgICAgICAgIDwgU3lzdGVtQ2FsbEVycm9yXG4gICAgZGVmIHNlbGYubmV3KG5hbWUgPSBuaWwpXG4gICAgICBtZXNzYWdlID0gJ0ludmFsaWQgYXJndW1lbnQnXG4gICAgICBtZXNzYWdlICs9IFwiIC0gI3tuYW1lfVwiIGlmIG5hbWVcbiAgICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFVuY2F1Z2h0VGhyb3dFcnJvciA8IEFyZ3VtZW50RXJyb3JcbiAgYXR0cl9yZWFkZXIgOnN5bSwgOmFyZ1xuXG4gIGRlZiBpbml0aWFsaXplKGFyZ3MpXG4gICAgQHN5bSA9IGFyZ3NbMF1cbiAgICBAYXJnID0gYXJnc1sxXSBpZiBhcmdzLmxlbmd0aCA+IDFcblxuICAgIHN1cGVyKFwidW5jYXVnaHQgdGhyb3cgI3tAc3ltLmluc3BlY3R9XCIpXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5hbWVFcnJvclxuICBhdHRyX3JlYWRlciA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKG1lc3NhZ2UsIG5hbWUgPSBuaWwpXG4gICAgc3VwZXIgbWVzc2FnZVxuICAgIEBuYW1lID0gbmFtZVxuICBlbmRcbmVuZFxuXG5jbGFzcyBOb01ldGhvZEVycm9yXG4gIGF0dHJfcmVhZGVyIDphcmdzXG5cbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgbmFtZSA9IG5pbCwgYXJncyA9IFtdKVxuICAgIHN1cGVyIG1lc3NhZ2UsIG5hbWVcbiAgICBAYXJncyA9IGFyZ3NcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RvcEl0ZXJhdGlvblxuICBhdHRyX3JlYWRlciA6cmVzdWx0XG5lbmRcblxuY2xhc3MgS2V5RXJyb3JcbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgcmVjZWl2ZXI6IG5pbCwga2V5OiBuaWwpXG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBAcmVjZWl2ZXIgPSByZWNlaXZlclxuICAgIEBrZXkgPSBrZXlcbiAgZW5kXG5cbiAgZGVmIHJlY2VpdmVyXG4gICAgQHJlY2VpdmVyIHx8IHJhaXNlKEFyZ3VtZW50RXJyb3IsICdubyByZWNlaXZlciBpcyBhdmFpbGFibGUnKVxuICBlbmRcblxuICBkZWYga2V5XG4gICAgQGtleSB8fCByYWlzZShBcmd1bWVudEVycm9yLCAnbm8ga2V5IGlzIGF2YWlsYWJsZScpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBKU1xuICBjbGFzcyBFcnJvclxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwibmV3Iiwic2VsZiIsImV4Y2VwdGlvbiIsImFyZ3MiLCJpbml0aWFsaXplIiwiYmFja3RyYWNlIiwiY2xvbmUiLCJtZXNzYWdlIiwidG9fcyIsImluc3BlY3QiLCJhc19zdHIiLCJlbXB0eT8iLCJzZXRfYmFja3RyYWNlIiwicmFpc2UiLCIkcmV0X29yXzEiLCIkcmV0X29yXzIiLCJAbWVzc2FnZSIsIm1vZHVsZSIsIm5hbWUiLCIrIiwiYXR0cl9yZWFkZXIiLCJAc3ltIiwiW10iLCIwIiwiPiIsImxlbmd0aCIsIjEiLCJAYXJnIiwiQG5hbWUiLCJAYXJncyIsIkByZWNlaXZlciIsInJlY2VpdmVyIiwiQGtleSIsImtleSIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUVFLElBQUMscUJBQUQ7QUFBQSxJQUVBQyxVQUFJQyxJQUFKRCxVQUFBQSxtQkFBQUEsU0FMRixFQUtFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFMRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQUtlLE1BQUEsa0JBTGY7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBdkJBO0FBS0VBLElBQUFBLENBQUFBLCtCQUFBQSxDQUZBO0FBQUEsSUFzQkMsNkJBdEJEO0FBQUEsSUF3QkFFLFVBQUlELElBQUpDLGdCQUFBQSx5QkFBQUEscUJBM0JGLEVBMkJFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUEzQkY7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUEyQnFCLE1BQUEsa0JBM0JyQjtBQUFBLE1BNEJJLE9BQUFGLFVBQUFBLE9BQUFBLEVBQUksVUFBQ0csSUFBRCxDQUFKSCxDQTVCSjtBQTJC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QTs7QUFBQUE7QUFBQUEsSUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFERmtCLEVBQUFBLEdBQUFBLFdBQUFBLFdBL01BOzsifX0seyJvZmZzZXQiOnsibGluZSI6NTczMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvY29uc3RhbnRzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIlJVQllfUExBVEZPUk0gICAgICAgPSAnb3BhbCdcblJVQllfRU5HSU5FICAgICAgICAgPSAnb3BhbCdcblJVQllfVkVSU0lPTiAgICAgICAgPSAnMy4wLjInXG5SVUJZX0VOR0lORV9WRVJTSU9OID0gJzEuMi4wJ1xuUlVCWV9SRUxFQVNFX0RBVEUgICA9ICcyMDIxLTA3LTI4J1xuUlVCWV9QQVRDSExFVkVMICAgICA9IDBcblJVQllfUkVWSVNJT04gICAgICAgPSAnMCdcblJVQllfQ09QWVJJR0hUICAgICAgPSAnb3BhbCAtIENvcHlyaWdodCAoQykgMjAxMy0yMDIxIEFkYW0gQmV5bm9uIGFuZCB0aGUgT3BhbCBjb250cmlidXRvcnMnXG5SVUJZX0RFU0NSSVBUSU9OICAgID0gXCJvcGFsICN7UlVCWV9FTkdJTkVfVkVSU0lPTn0gKCN7UlVCWV9SRUxFQVNFX0RBVEV9IHJldmlzaW9uICN7UlVCWV9SRVZJU0lPTn0pXCJcbiJdLCJuYW1lcyI6WyIwIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBLEVBQUEsNkNBQXNCLE1BQXRCLENBQUE7QUFBQSxFQUNBLDJDQUFzQixNQUF0QixDQURBO0FBQUEsRUFFQSw0Q0FBc0IsT0FBdEIsQ0FGQTtBQUFBLEVBR0EsbURBQXNCLE9BQXRCLENBSEE7QUFBQSxFQUlBLGlEQUFzQixZQUF0QixDQUpBO0FBQUEsRUFLQSwrQ0FBc0JBLENBQXRCLENBTEE7QUFBQSxFQU1BLDZDQUFzQixHQUF0QixDQU5BO0FBQUEsRUFPQSw4Q0FBc0Isc0VBQXRCLENBUEE7QUFBQSxFQVFBLE9BQUEsZ0RBQXNCLEVBQUEsR0FBQSxPQUFBLEdBQUEsQ0FBUSxtQ0FBUixDQUFBLEdBQUEsSUFBQSxHQUFBLENBQWdDLGlDQUFoQyxDQUFBLEdBQUEsWUFBQSxHQUFBLENBQThELDZCQUE5RCxDQUFBLEdBQUEsR0FBdEIsQ0FSQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjU3NDcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL2Jhc2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9ydW50aW1lJ1xucmVxdWlyZSAnY29yZWxpYi9oZWxwZXJzJ1xucmVxdWlyZSAnY29yZWxpYi9tb2R1bGUnXG5yZXF1aXJlICdjb3JlbGliL2NsYXNzJ1xucmVxdWlyZSAnY29yZWxpYi9iYXNpY19vYmplY3QnXG5yZXF1aXJlICdjb3JlbGliL2tlcm5lbCdcbnJlcXVpcmUgJ2NvcmVsaWIvZXJyb3InXG5cbnJlcXVpcmUgJ2NvcmVsaWIvY29uc3RhbnRzJ1xuIl0sIm5hbWVzIjpbInJlcXVpcmUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsaUJBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQURBO0FBQUEsTUFFQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FGQTtBQUFBLE1BR0FBLFNBQUFBLENBQVEsZUFBUkEsQ0FIQTtBQUFBLE1BSUFBLFNBQUFBLENBQVEsc0JBQVJBLENBSkE7QUFBQSxNQUtBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQUxBO0FBQUEsTUFNQUEsU0FBQUEsQ0FBUSxlQUFSQSxDQU5BO0FBQUEsRUFRQSxXQUFBQSxTQUFBQSxDQUFRLG1CQUFSQSxDQVJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6NTc2MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbmlsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE5pbENsYXNzXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkbWV0YSA9ICN7c2VsZn1gXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgIVxuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgYG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICBgb3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgb3RoZXIgPT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICduaWwnXG4gIGVuZFxuXG4gIGRlZiBuaWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgTmlsQ2xhc3NcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBbXVxuICBlbmRcblxuICBkZWYgdG9faFxuICAgIGBPcGFsLmhhc2goKWBcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICAwXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2YgdG9faVxuXG4gIGRlZiB0b19zXG4gICAgJydcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICBDb21wbGV4Lm5ldygwLCAwKVxuICBlbmRcblxuICBkZWYgcmF0aW9uYWxpemUoKmFyZ3MpXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciBpZiBhcmdzLmxlbmd0aCA+IDFcbiAgICBSYXRpb25hbCgwLCAxKVxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIFJhdGlvbmFsKDAsIDEpXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBbXVxuICBlbmRcbmVuZFxuXG5OSUwgPSBuaWxcbiJdLCJuYW1lcyI6WyJjbGFzcyIsInNlbGYiLCJhbGxvY2F0ZSIsInJhaXNlIiwibmFtZSIsIiEiLCImIiwifCIsIl4iLCI9PSIsImR1cCIsImNsb25lIiwiaW5zcGVjdCIsIm5pbD8iLCJzaW5nbGV0b25fY2xhc3MiLCJ0b19hIiwidG9faCIsInRvX2kiLCIwIiwidG9fcyIsInRvX2MiLCJuZXciLCJyYXRpb25hbGl6ZSIsIj4iLCJhcmdzIiwibGVuZ3RoIiwiMSIsIlJhdGlvbmFsIiwidG9fciIsImluc3RhbmNlX3ZhcmlhYmxlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUMsMEJBQTRCQyxJQUE3QjtBQUFBLElBRUE7QUFBQSxNQUFBOztBQUFBO0FBQ0U7QUFBQUMsTUFBQUEsNEJBQUFBLGNBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxXQUFBQyxPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSwwQkFBQSxHQUFBLEtBQTJCQyxNQUFBQSxDQUFBQSxDQUEzQixDQUFqQkQ7QUFERkQsTUFBQUEsQ0FBQUEseUJBQUFBLENBQUE7QUFBQTs7QUFJQSxNQUFBLHNCQUFNLEtBQU47aUJBSkE7QUFERixJQUFBLDRCQUFTRCxJQUFULFlBRkE7QUFBQTtBQVVBSSxJQUFBQSxxQkFBQUEsb0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBVkE7QUFBQTtBQWNBQyxJQUFBQSxxQkFBQUEsZ0JBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQTtBQURGQSxJQUFBQSxDQUFBQSwyQkFBQUEsQ0FkQTtBQUFBO0FBa0JBQyxJQUFBQSxx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QUFBLHVDQUFBQSxDQXhFQTtBQUFBO0FBNkVBTSxJQUFBQSx3QkFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBRCxVQUFBQSxDQUFTVCxHQUFHUSxDQUFaQztBQURGQyxJQUFBQSxDQUFBQSwrQkFBQUEsQ0E3RUE7QUFBQSxJQWlGQSxPQUFBQyxDQUFBQSxzQ0FBQUEsa0NBQUFBLDhCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBO0FBREZBLElBQUFBLENBQUFBLDZDQUFBQSxDQUFBQSw4QkFqRkE7QUFERjdCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBQUE7QUFBQSxFQXVGQSxPQUFBLG1DQUFNLEdBQU4sQ0F2RkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1OTI1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9ib29sZWFuLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIEJvb2xlYW4gPCBgQm9vbGVhbmBcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfYm9vbGVhbicsIHRydWUpYFxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRtZXRhJywgI3tzZWxmfSlgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgYHNlbGYudmFsdWVPZigpID8gMiA6IDBgXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgIVxuICAgIGBzZWxmICE9IHRydWVgXG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbCkgOiBmYWxzZWBcbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gdHJ1ZSA6IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbClgXG4gIGVuZFxuXG4gIGRlZiBeKG90aGVyKVxuICAgIGAoc2VsZiA9PSB0cnVlKSA/IChvdGhlciA9PT0gZmFsc2UgfHwgb3RoZXIgPT09IG5pbCkgOiAob3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWwpYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID09PSBvdGhlci52YWx1ZU9mKClgXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PVxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzc1xuICAgIEJvb2xlYW5cbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyAndHJ1ZScgOiAnZmFsc2UnYFxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIHNlbGZcbiAgZW5kXG5lbmRcblxuVHJ1ZUNsYXNzICA9IEJvb2xlYW5cbkZhbHNlQ2xhc3MgPSBCb29sZWFuXG5cblRSVUUgID0gdHJ1ZVxuRkFMU0UgPSBmYWxzZVxuIl0sIm5hbWVzIjpbImNsYXNzIiwic2VsZiIsImFsbG9jYXRlIiwicmFpc2UiLCJuYW1lIiwiX19pZF9fIiwiISIsIiYiLCJ8IiwiXiIsIj09Iiwic2luZ2xldG9uX2NsYXNzIiwidG9fcyIsImR1cCIsImNsb25lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQywyREFBRDtBQUFBLElBQ0MsZ0RBQWtEQyxJQUFLLENBRHhEO0FBQUEsSUFHQTtBQUFBLE1BQUE7O0FBQUE7QUFDRTtBQUFBQyxNQUFBQSw0QkFBQUEsY0FBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUNFLFdBQUFDLE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLDBCQUFBLEdBQUEsS0FBMkJDLE1BQUFBLENBQUFBLENBQTNCLENBQWpCRDtBQURGRCxNQUFBQSxDQUFBQSx5QkFBQUEsQ0FBQTtBQUFBOztBQUlBLE1BQUEsc0JBQU0sS0FBTjtpQkFKQTtBQURGLElBQUEsNEJBQVNELElBQVQsWUFIQTtBQUFBO0FBV0FJLElBQUFBLDBCQUFBQSxvQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsc0JBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBWEE7QUFBQSxJQWVBLGlCQUFNLFdBQU4sRUFBZ0IsUUFBaEIsQ0FmQTtBQUFBO0FBaUJBQyxJQUFBQSxxQkFBQUEsbUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsWUFBRDtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FqQkE7QUFBQTtBQXFCQUMsSUFBQUEscUJBQUFBLGVBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQywyREFBRDtBQURGQSxJQUFBQSxDQUFBQSwwQkFBQUEsQ0FyQkE7QUFBQTtBQXlCQUMsSUFBQUEscUJBQUFBLGVBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQywwREFBRDtBQURGQSxJQUFBQSxDQUFBQSwwQkFBQUEsQ0F6QkE7QUFBQTtBQTZCQUMsSUFBQUEscUJBQUFBLGVBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyx3RkFBRDtBQURGQSxJQUFBQSxDQUFBQSwwQkFBQUEsQ0E3QkE7QUFBQTtBQWlDQUMsSUFBQUEsc0JBQUFBLG9CQUFBQSxTQUFPLEtBQVBBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsa0NBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBakNBO0FBQUEsSUFxQ0EsaUJBQU0sUUFBTixFQUFhLElBQWIsQ0FyQ0E7QUFBQSxJQXNDQSxpQkFBTSxNQUFOLEVBQVcsSUFBWCxDQXRDQTtBQUFBO0FBd0NBQyxJQUFBQSxtQ0FBQUEsNkJBQUFBLDJCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBO0FBREZBLElBQUFBLENBQUFBLHdDQUFBQSxDQXhDQTtBQUFBO0FBNENBQyxJQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLGlDQUFEO0FBREZBLElBQUFBLENBQUFBLDZCQUFBQSxDQTVDQTtBQUFBO0FBZ0RBQyxJQUFBQSx1QkFBQUEsa0JBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFaO0FBREZZLElBQUFBLENBQUFBLDZCQUFBQSxDQWhEQTtBQUFBLElBb0RBLE9BQUFDLENBQUFBLHlCQUFBQSxvQkFBQUEsaUJBdERGLE9Bc0RFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUF0REY7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxDQUFBO0FBQUE7QUFzRFksTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLFdBQVE7QUFBUixNQUFBLENBdERaO0FBQUEsTUF1REksT0FBQWIsSUF2REo7QUFzREVhLElBQUFBLENBQUFBLGdDQUFBQSxDQUFBQSxpQkFwREE7QUFERmQsRUFBQUEsR0FBQUEsV0FBQUEsRUFBaUIsT0FBakJBLFdBQUE7QUFBQSxFQTBEQSx5Q0FBYSx1QkFBYixDQTFEQTtBQUFBLEVBMkRBLDBDQUFhLHVCQUFiLENBM0RBO0FBQUEsRUE2REEsb0NBQVEsSUFBUixDQTdEQTtBQUFBLEVBOERBLE9BQUEscUNBQVEsS0FBUixDQTlEQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYwMzUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbXBhcmFibGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBmYWxzeVxuXG5tb2R1bGUgQ29tcGFyYWJsZVxuICAleHtcbiAgICBmdW5jdGlvbiBub3JtYWxpemUod2hhdCkge1xuICAgICAgaWYgKE9wYWwuaXNfYSh3aGF0LCBPcGFsLkludGVnZXIpKSB7IHJldHVybiB3aGF0OyB9XG5cbiAgICAgIGlmICgje2B3aGF0YCA+IDB9KSB7IHJldHVybiAxOyB9XG4gICAgICBpZiAoI3tgd2hhdGAgPCAwfSkgeyByZXR1cm4gLTE7IH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZhaWxfY29tcGFyaXNvbihsaHMsIHJocykge1xuICAgICAgdmFyIGNsYXNzX25hbWU7XG4gICAgICAje1xuICAgICAgICBjYXNlIGByaHNgXG4gICAgICAgIHdoZW4gbmlsLCB0cnVlLCBmYWxzZSwgSW50ZWdlciwgRmxvYXRcbiAgICAgICAgICBgY2xhc3NfbmFtZSA9IHJocy4kaW5zcGVjdCgpYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgYGNsYXNzX25hbWUgPSByaHMuJCRjbGFzc2BcbiAgICAgICAgZW5kXG4gICAgICB9XG4gICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2BsaHNgLmNsYXNzfSB3aXRoICN7YGNsYXNzX25hbWVgfSBmYWlsZWRcIn1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbXBfb3JfZmFpbChsaHMsIHJocykge1xuICAgICAgdmFyIGNtcCA9ICN7YGxoc2AgPD0+IGByaHNgfTtcbiAgICAgIGlmICgkZmFsc3koY21wKSkgZmFpbF9jb21wYXJpc29uKGxocywgcmhzKTtcbiAgICAgIHJldHVybiBub3JtYWxpemUoY21wKTtcbiAgICB9XG4gIH1cblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIHRydWUgaWYgZXF1YWw/KG90aGVyKVxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZltcIiQ8PT5cIl0gPT0gT3BhbC5LZXJuZWxbXCIkPD0+XCJdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgZm9yIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgaWYgKHNlbGYuJCRjb21wYXJhYmxlKSB7XG4gICAgICAgIGRlbGV0ZSBzZWxmLiQkY29tcGFyYWJsZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgY21wID0gKHNlbGYgPD0+IG90aGVyKVxuXG4gICAgYG5vcm1hbGl6ZShjbXApID09IDBgXG4gIGVuZFxuXG4gIGRlZiA+KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPiAwYFxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgYGNtcF9vcl9mYWlsKHNlbGYsIG90aGVyKSA+PSAwYFxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpIDwgMGBcbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPD0gMGBcbiAgZW5kXG5cbiAgZGVmIGJldHdlZW4/KG1pbiwgbWF4KVxuICAgIHJldHVybiBmYWxzZSBpZiBzZWxmIDwgbWluXG4gICAgcmV0dXJuIGZhbHNlIGlmIHNlbGYgPiBtYXhcbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBjbGFtcChtaW4sIG1heCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBjLCBleGNsO1xuXG4gICAgICBpZiAobWF4ID09PSBuaWwpIHtcbiAgICAgICAgLy8gV2UgYXJlIGRlYWxpbmcgd2l0aCBhIG5ldyBSdWJ5IDIuNyBiZWhhdmlvdXIgdGhhdCB3ZSBhcmUgYWJsZSB0b1xuICAgICAgICAvLyBwcm92aWRlIGEgc2luZ2xlIFJhbmdlIGFyZ3VtZW50IGluc3RlYWQgb2YgMiBDb21wYXJhYmxlcy5cblxuICAgICAgICBpZiAoIU9wYWwuaXNfYShtaW4sIE9wYWwuUmFuZ2UpKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje21pbi5jbGFzc30gKGV4cGVjdGVkIFJhbmdlKVwifVxuICAgICAgICB9XG5cbiAgICAgICAgZXhjbCA9IG1pbi5leGNsO1xuICAgICAgICBtYXggPSBtaW4uZW5kO1xuICAgICAgICBtaW4gPSBtaW4uYmVnaW47XG5cbiAgICAgICAgaWYgKG1heCAhPT0gbmlsICYmIGV4Y2wpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdjYW5ub3QgY2xhbXAgd2l0aCBhbiBleGNsdXNpdmUgcmFuZ2UnfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW4gIT09IG5pbCAmJiBtYXggIT09IG5pbCAmJiBjbXBfb3JfZmFpbChtaW4sIG1heCkgPiAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ21pbiBhcmd1bWVudCBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXggYXJndW1lbnQnfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluICE9PSBuaWwpIHtcbiAgICAgICAgYyA9IGNtcF9vcl9mYWlsKHNlbGYsIG1pbik7XG5cbiAgICAgICAgaWYgKGMgPT0gMCkgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmIChjIDwgMCkgcmV0dXJuIG1pbjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heCAhPT0gbmlsKSB7XG4gICAgICAgIGMgPSBjbXBfb3JfZmFpbChzZWxmLCBtYXgpO1xuXG4gICAgICAgIGlmIChjID4gMCkgcmV0dXJuIG1heDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIj4iLCIwIiwiPCIsInJhaXNlIiwiY2xhc3MiLCI8PT4iLCI9PSIsImVxdWFsPyIsIm90aGVyIiwiY21wIiwic2VsZiIsIj49IiwiPD0iLCJiZXR3ZWVuPyIsIm1pbiIsIm1heCIsImNsYW1wIl0sIm1h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LGNBQVliLE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLHNCQUFBLEdBQUEsQ0FBdUJXLEdBQUFWLE9BQUFBLENBQUFBLENBQXZCLENBQUEsR0FBQSxtQkFBakJEO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBWUEsT0FBQUEsQ0FBTSwrQkFBZSxzQ0FBckJBO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVVBLE9BQUFBLENBQU0sK0JBQWUsZ0RBQXJCQTtBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBbEhBO0FBMkVFYSxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0FBQUEsaUJBdkVBO0FBREZqQixFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYxODUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JlZ2V4cC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGNvZXJjZV90b1xuXG5jbGFzcyBSZWdleHBFcnJvciA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuXG5jbGFzcyBSZWdleHAgPCBgUmVnRXhwYFxuICBJR05PUkVDQVNFID0gMVxuICBFWFRFTkRFRCA9IDJcbiAgTVVMVElMSU5FID0gNFxuXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3JlZ2V4cCcsIHRydWUpYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIGFsbG9jYXRlZCA9IHN1cGVyXG4gICAgICBgI3thbGxvY2F0ZWR9LnVuaW5pdGlhbGl6ZWQgPSB0cnVlYFxuICAgICAgYWxsb2NhdGVkXG4gICAgZW5kXG5cbiAgICBkZWYgZXNjYXBlKHN0cmluZylcbiAgICAgIGBPcGFsLmVzY2FwZV9yZWdleHAoc3RyaW5nKWBcbiAgICBlbmRcblxuICAgIGRlZiBsYXN0X21hdGNoKG4gPSBuaWwpXG4gICAgICBpZiBuLm5pbD9cbiAgICAgICAgJH5cbiAgICAgIGVsc2VcbiAgICAgICAgJH5bbl1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYWxpYXMgcXVvdGUgZXNjYXBlXG5cbiAgICBkZWYgdW5pb24oKnBhcnRzKVxuICAgICAgJXh7XG4gICAgICAgIHZhciBpc19maXJzdF9wYXJ0X2FycmF5LCBxdW90ZWRfdmFsaWRhdGVkLCBwYXJ0LCBvcHRpb25zLCBlYWNoX3BhcnRfb3B0aW9ucztcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIC8oPyEpLztcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gZmFzdCBpZiB0aGVyZSdzIG9ubHkgb25lIGVsZW1lbnRcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PSAxICYmIHBhcnRzWzBdLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvdmVyIHRoZSAyIGFycmF5cyBwYXNzZWQgYXMgYXJndW1lbnRzIGNhc2VcbiAgICAgICAgaXNfZmlyc3RfcGFydF9hcnJheSA9IHBhcnRzWzBdLiQkaXNfYXJyYXk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxICYmIGlzX2ZpcnN0X3BhcnRfYXJyYXkpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ25vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgQXJyYXkgaW50byBTdHJpbmcnfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlYWwgd2l0aCBzcGxhdCBpc3N1ZXMgKHJlbGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9pc3N1ZXMvODU4KVxuICAgICAgICBpZiAoaXNfZmlyc3RfcGFydF9hcnJheSkge1xuICAgICAgICAgIHBhcnRzID0gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBpZiAocGFydC4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCN7ZXNjYXBlKGBwYXJ0YCl9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAocGFydC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgICAgZWFjaF9wYXJ0X29wdGlvbnMgPSAje2BwYXJ0YC5vcHRpb25zfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zICE9IGVhY2hfcGFydF9vcHRpb25zKSB7XG4gICAgICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnQWxsIGV4cHJlc3Npb25zIG11c3QgdXNlIHRoZSBzYW1lIG9wdGlvbnMnfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucyA9IGVhY2hfcGFydF9vcHRpb25zO1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCcoJytwYXJ0LnNvdXJjZSsnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1b3RlZF92YWxpZGF0ZWQucHVzaCgje2VzY2FwZShgcGFydGAudG9fc3RyKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgIyBUYWtlIGFkdmFudGFnZSBvZiBsb2dpYyB0aGF0IGNhbiBwYXJzZSBvcHRpb25zIGZyb20gSlMgUmVnZXhcbiAgICAgIG5ldyhgcXVvdGVkX3ZhbGlkYXRlZGAuam9pbignfCcpLCBgb3B0aW9uc2ApXG4gICAgZW5kXG5cbiAgICBkZWYgbmV3KHJlZ2V4cCwgb3B0aW9ucyA9IHVuZGVmaW5lZClcbiAgICAgICV4e1xuICAgICAgICBpZiAocmVnZXhwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2V4cCA9ICN7T3BhbC5jb2VyY2VfdG8hKHJlZ2V4cCwgU3RyaW5nLCA6dG9fc3RyKX07XG5cbiAgICAgICAgaWYgKHJlZ2V4cC5jaGFyQXQocmVnZXhwLmxlbmd0aCAtIDEpID09PSAnXFxcXCcgJiYgcmVnZXhwLmNoYXJBdChyZWdleHAubGVuZ3RoIC0gMikgIT09ICdcXFxcJykge1xuICAgICAgICAgICN7cmFpc2UgUmVnZXhwRXJyb3IsIFwidG9vIHNob3J0IGVzY2FwZSBzZXF1ZW5jZTogLyN7cmVnZXhwfS9cIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgI3shb3B0aW9uc30pIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9ICcnO1xuICAgICAgICAgIGlmICgje0lHTk9SRUNBU0V9ICYgb3B0aW9ucykgeyB0ZW1wICs9ICdpJzsgfVxuICAgICAgICAgIGlmICgje01VTFRJTElORX0gICYgb3B0aW9ucykgeyB0ZW1wICs9ICdtJzsgfVxuICAgICAgICAgIG9wdGlvbnMgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSAnaSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHAsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgYWxpYXMgY29tcGlsZSBuZXdcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGBvdGhlciBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBzZWxmLnRvU3RyaW5nKCkgPT09IG90aGVyLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiA9PT0oc3RyaW5nKVxuICAgIGAje21hdGNoKE9wYWwuY29lcmNlX3RvPyhzdHJpbmcsIFN0cmluZywgOnRvX3N0cikpfSAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgPX4oc3RyaW5nKVxuICAgIG1hdGNoKHN0cmluZykgJiYgJH4uYmVnaW4oMClcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBpbnNwZWN0XG4gICAgIyBVc2UgYSByZWdleHAgdG8gZXh0cmFjdCB0aGUgcmVndWxhciBleHByZXNzaW9uIGFuZCB0aGUgb3B0aW9uYWwgbW9kZSBtb2RpZmllcnMgZnJvbSB0aGUgc3RyaW5nLlxuICAgICMgSW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiwgZXNjYXBlIGFueSBmcm9udCBzbGFzaCAobm90IGFscmVhZHkgZXNjYXBlZCkgd2l0aCBhIGJhY2tzbGFzaC5cbiAgICAleHtcbiAgICAgIHZhciByZWdleHBfZm9ybWF0ID0gL15cXC8oLiopXFwvKFteXFwvXSopJC87XG4gICAgICB2YXIgdmFsdWUgPSBzZWxmLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbWF0Y2hlcyA9IHJlZ2V4cF9mb3JtYXQuZXhlYyh2YWx1ZSk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB2YXIgcmVnZXhwX3BhdHRlcm4gPSBtYXRjaGVzWzFdO1xuICAgICAgICB2YXIgcmVnZXhwX2ZsYWdzID0gbWF0Y2hlc1syXTtcbiAgICAgICAgdmFyIGNoYXJzID0gcmVnZXhwX3BhdHRlcm4uc3BsaXQoJycpO1xuICAgICAgICB2YXIgY2hhcnNfbGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciByZWdleHBfcGF0dGVybl9lc2NhcGVkID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnNfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY3VycmVudF9jaGFyID0gY2hhcnNbaV07XG4gICAgICAgICAgaWYgKCFjaGFyX2VzY2FwZWQgJiYgY3VycmVudF9jaGFyID09ICcvJykge1xuICAgICAgICAgICAgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCA9IHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQuY29uY2F0KCdcXFxcJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgPSByZWdleHBfcGF0dGVybl9lc2NhcGVkLmNvbmNhdChjdXJyZW50X2NoYXIpO1xuICAgICAgICAgIGlmIChjdXJyZW50X2NoYXIgPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpZiAoY2hhcl9lc2NhcGVkKSB7XG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IG92ZXIgZXNjYXBlXG4gICAgICAgICAgICAgIGNoYXJfZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnLycgKyByZWdleHBfcGF0dGVybl9lc2NhcGVkICsgJy8nICsgcmVnZXhwX2ZsYWdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1hdGNoKHN0cmluZywgcG9zID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIHZhciBtID0gc2VsZi5leGVjKCRjb2VyY2VfdG8oc3RyaW5nLCAje1N0cmluZ30sICd0b19zdHInKSk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgI3skfiA9IE1hdGNoRGF0YS5uZXcoYHNlbGZgLCBgbWApfTtcbiAgICAgICAgICByZXR1cm4gYmxvY2sgPT09IG5pbCA/ICN7JH59IDogI3t5aWVsZCAkfn07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBvcyA9ICRjb2VyY2VfdG8ocG9zLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzdHJpbmcgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9ICRjb2VyY2VfdG8oc3RyaW5nLCAje1N0cmluZ30sICd0b19zdHInKTtcblxuICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zICs9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdsb2JhbCBSZWdFeHAgbWFpbnRhaW5zIHN0YXRlLCBzbyBub3QgdXNpbmcgc2VsZi90aGlzXG4gICAgICB2YXIgbWQsIHJlID0gT3BhbC5nbG9iYWxfcmVnZXhwKHNlbGYpO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBtZCA9IHJlLmV4ZWMoc3RyaW5nKTtcbiAgICAgICAgaWYgKG1kID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICN7JH4gPSBuaWx9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZC5pbmRleCA+PSBwb3MpIHtcbiAgICAgICAgICAjeyR+ID0gTWF0Y2hEYXRhLm5ldyhgcmVgLCBgbWRgKX07XG4gICAgICAgICAgcmV0dXJuIGJsb2NrID09PSBuaWwgPyAjeyR+fSA6ICN7eWllbGQgJH59O1xuICAgICAgICB9XG4gICAgICAgIHJlLmxhc3RJbmRleCA9IG1kLmluZGV4ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaD8oc3RyaW5nLCBwb3MgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi51bmluaXRpYWxpemVkKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndW5pbml0aWFsaXplZCBSZWdleHAnfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyA9PT0gbmlsID8gZmFsc2UgOiBzZWxmLnRlc3QoJGNvZXJjZV90byhzdHJpbmcsICN7U3RyaW5nfSwgJ3RvX3N0cicpKTtcbiAgICAgIH1cblxuICAgICAgcG9zID0gJGNvZXJjZV90byhwb3MsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gJGNvZXJjZV90byhzdHJpbmcsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2xvYmFsIFJlZ0V4cCBtYWludGFpbnMgc3RhdGUsIHNvIG5vdCB1c2luZyBzZWxmL3RoaXNcbiAgICAgIHZhciBtZCwgcmUgPSBPcGFsLmdsb2JhbF9yZWdleHAoc2VsZik7XG5cbiAgICAgIG1kID0gcmUuZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKG1kID09PSBudWxsIHx8IG1kLmluZGV4IDwgcG9zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIH5cbiAgICBzZWxmID1+ICRfXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VcbiAgICBgc2VsZi5zb3VyY2VgXG4gIGVuZFxuXG4gIGRlZiBvcHRpb25zXG4gICAgIyBGbGFncyB3b3VsZCBiZSBuaWNlIHRvIHVzZSB3aXRoIHRoaXMsIGJ1dCBzdGlsbCBleHBlcmltZW50YWwgLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAvZmxhZ3NcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLnVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICd1bmluaXRpYWxpemVkIFJlZ2V4cCd9XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICAgIC8vIHNob3VsZCBiZSBzdXBwb3J0ZWQgaW4gSUU2IGFjY29yZGluZyB0byBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5LzdmNXoyNnc0KHY9dnMuOTQpLmFzcHhcbiAgICAgIGlmIChzZWxmLm11bHRpbGluZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tNVUxUSUxJTkV9O1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYuaWdub3JlQ2FzZSkge1xuICAgICAgICByZXN1bHQgfD0gI3tJR05PUkVDQVNFfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FzZWZvbGQ/XG4gICAgYHNlbGYuaWdub3JlQ2FzZWBcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBzb3VyY2VcbmVuZFxuXG5jbGFzcyBNYXRjaERhdGFcbiAgYXR0cl9yZWFkZXIgOnBvc3RfbWF0Y2gsIDpwcmVfbWF0Y2gsIDpyZWdleHAsIDpzdHJpbmdcblxuICBkZWYgaW5pdGlhbGl6ZShyZWdleHAsIG1hdGNoX2dyb3VwcylcbiAgICAkfiAgICAgICAgICA9IHNlbGZcbiAgICBAcmVnZXhwICAgICA9IHJlZ2V4cFxuICAgIEBiZWdpbiAgICAgID0gYG1hdGNoX2dyb3Vwcy5pbmRleGBcbiAgICBAc3RyaW5nICAgICA9IGBtYXRjaF9ncm91cHMuaW5wdXRgXG4gICAgQHByZV9tYXRjaCAgPSBgbWF0Y2hfZ3JvdXBzLmlucHV0LnNsaWNlKDAsIG1hdGNoX2dyb3Vwcy5pbmRleClgXG4gICAgQHBvc3RfbWF0Y2ggPSBgbWF0Y2hfZ3JvdXBzLmlucHV0LnNsaWNlKG1hdGNoX2dyb3Vwcy5pbmRleCArIG1hdGNoX2dyb3Vwc1swXS5sZW5ndGgpYFxuICAgIEBtYXRjaGVzICAgID0gW11cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1hdGNoX2dyb3Vwcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBtYXRjaF9ncm91cHNbaV07XG5cbiAgICAgICAgaWYgKGdyb3VwID09IG51bGwpIHtcbiAgICAgICAgICAje0BtYXRjaGVzfS5wdXNoKG5pbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgI3tAbWF0Y2hlc30ucHVzaChncm91cCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXSgqYXJncylcbiAgICBAbWF0Y2hlc1sqYXJnc11cbiAgZW5kXG5cbiAgZGVmIG9mZnNldChuKVxuICAgICV4e1xuICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnTWF0Y2hEYXRhI29mZnNldCBvbmx5IHN1cHBvcnRzIDB0aCBlbGVtZW50J31cbiAgICAgIH1cbiAgICAgIHJldHVybiBbc2VsZi5iZWdpbiwgc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgTWF0Y2hEYXRhID09PSBvdGhlclxuXG4gICAgYHNlbGYuc3RyaW5nID09IG90aGVyLnN0cmluZ2AgJiZcbiAgICAgIGBzZWxmLnJlZ2V4cC50b1N0cmluZygpID09IG90aGVyLnJlZ2V4cC50b1N0cmluZygpYCAmJlxuICAgICAgYHNlbGYucHJlX21hdGNoID09IG90aGVyLnByZV9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLnBvc3RfbWF0Y2ggPT0gb3RoZXIucG9zdF9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLmJlZ2luID09IG90aGVyLmJlZ2luYFxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIGJlZ2luKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjYmVnaW4gb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlbmQobilcbiAgICAleHtcbiAgICAgIGlmIChuICE9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNlbmQgb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FwdHVyZXNcbiAgICBgI3tAbWF0Y2hlc30uc2xpY2UoMSlgXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gXCIjPE1hdGNoRGF0YSBcIiArICN7YCN7QG1hdGNoZXN9WzBdYC5pbnNwZWN0fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9ICN7QG1hdGNoZXN9Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBcIiBcIiArIGkgKyBcIjpcIiArICN7YCN7QG1hdGNoZXN9W2ldYC5pbnNwZWN0fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0ciArIFwiPlwiO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BtYXRjaGVzfS5sZW5ndGhgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIHRvX2FcbiAgICBAbWF0Y2hlc1xuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGAje0BtYXRjaGVzfVswXWBcbiAgZW5kXG5cbiAgZGVmIHZhbHVlc19hdCgqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBpLCBhLCBpbmRleCwgdmFsdWVzID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgaWYgKGFyZ3NbaV0uJCRpc19yYW5nZSkge1xuICAgICAgICAgIGEgPSAje2BhcmdzW2ldYC50b19hfTtcbiAgICAgICAgICBhLnVuc2hpZnQoaSwgMSk7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShhcmdzLCBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gI3tPcGFsLmNvZXJjZV90byEoYGFyZ3NbaV1gLCBJbnRlZ2VyLCA6dG9faW50KX07XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9ICN7QG1hdGNoZXN9Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChuaWwpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVzLnB1c2goI3tAbWF0Y2hlc31baW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCIxIiwiMiIsIjQiLCJhbGxvY2F0ZSIsImFsbG9jYXRlZCIsImVzY2FwZSIsImxhc3RfbWF0Y2giLCJuIiwibmlsPyIsIiR+IiwiW10iLCJ1bmlvbiIsInJhaXNlIiwib3B0aW9ucyIsInRvX3N0ciIsIm5ldyIsImpvaW4iLCJjb2VyY2VfdG8hIiwicmVnZXhwIiwiISIsInNlbGYiLCI9PSIsIj09PSIsIm1hdGNoIiwiY29lcmNlX3RvPyIsInN0cmluZyIsIj1+IiwiJHJldF9vcl8xIiwiYmVnaW4iLCIwIiwiaW5zcGVjdCIsIm1hdGNoPyIsIn4iLCIkXyIsInNvdXJjZSIsImNhc2Vmb2xkPyIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkByZWdleHAiLCJAYmVnaW4iLCJAc3RyaW5nIiwiQHByZV9tYXRjaCIsIkBwb3N0X21hdGNoIiwiQG1hdGNoZXMiLCJhcmdzIiwib2Zmc2V0Iiwib3RoZXIiLCIkcmV0X29yXzIiLCIkcmV0X29yXzMiLCIkcmV0X29yXzQiLCIkcmV0X29yXzUiLCJlbmQiLCJjYXB0dXJlcyIsImxlbmd0aCIsInRvX2EiLCJ0b19zIiwidmFsdWVzX2F0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFFQSxFQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBLEVBQUFBLEdBQUFBLFdBQUFBLEVBQW9CLDZCQUFwQkEsV0FBQTtBQUFBLEVBRUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBLDBDQUFhQyxDQUFiLENBQUE7QUFBQSxJQUNBLHdDQUFXQyxDQUFYLENBREE7QUFBQSxJQUVBLHlDQUFZQyxDQUFaLENBRkE7QUFBQSxJQUlDLDBEQUpEO0FBQUEsSUFNQTtBQUFBLE1BQUE7O0FBQUE7QUFDRTtBQUFBQyxNQUFBQSw0QkFBQUEsY0FBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQSxRQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFlBQVksV0FBQSxFQUFBLHNFQUFB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IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG8sIHJlc3BvbmRfdG9cblxucmVxdWlyZSAnY29yZWxpYi9jb21wYXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9yZWdleHAnXG5cbmNsYXNzIFN0cmluZyA8IGBTdHJpbmdgXG4gIGluY2x1ZGUgQ29tcGFyYWJsZVxuXG4gICV4e1xuICAgIE9wYWwuZGVmaW5lUHJvcGVydHkoI3tzZWxmfS4kJHByb3RvdHlwZSwgJyQkaXNfc3RyaW5nJywgdHJ1ZSk7XG5cbiAgICBPcGFsLmRlZmluZVByb3BlcnR5KCN7c2VsZn0uJCRwcm90b3R5cGUsICckJGNhc3QnLCBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciBrbGFzcyA9IHRoaXMuJCRjbGFzcztcbiAgICAgIGlmIChrbGFzcy4kJGNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcga2xhc3MuJCRjb25zdHJ1Y3RvcihzdHJpbmcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGVmIF9faWRfX1xuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgc2VsZi50cnlfY29udmVydCh3aGF0KVxuICAgIE9wYWwuY29lcmNlX3RvPyh3aGF0LCBTdHJpbmcsIDp0b19zdHIpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ldygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBhcmdzWzBdIHx8IFwiXCI7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3NbYXJncy5sZW5ndGgtMV07XG4gICAgICBzdHIgPSAkY29lcmNlX3RvKHN0ciwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLiQkaXNfaGFzaCkge1xuICAgICAgICBpZiAob3B0cy4kJHNtYXAuZW5jb2RpbmcpIHN0ciA9IHN0ci4kZm9yY2VfZW5jb2Rpbmcob3B0cy4kJHNtYXAuZW5jb2RpbmcpO1xuICAgICAgfVxuICAgICAgc3RyID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcihzdHIpO1xuICAgICAgaWYgKCFzdHIuJGluaXRpYWxpemUuJCRwcmlzdGluZSkgI3tgc3RyYC5pbml0aWFsaXplKCphcmdzKX07XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgZW5kXG5cbiAgIyBPdXIgaW5pdGlhbGl6ZSBtZXRob2QgZG9lcyBub3RoaW5nLCB0aGUgc3RyaW5nIHZhbHVlIHNldHVwIGlzIGJlaW5nXG4gICMgZG9uZSBieSBTdHJpbmcubmV3LiBUaGVyZWZvcmUgbm90IGFsbCBraW5kcyBvZiBzdWJjbGFzc2luZyB3aWxsIHdvcmsuXG4gICMgQXMgYSBydWxlIG9mIHRodW1iLCB3aGVuIHN1YmNsYXNzaW5nIFN0cmluZywgZWl0aGVyIG1ha2Ugc3VyZSB0byBvdmVycmlkZVxuICAjIC5uZXcgb3IgbWFrZSBzdXJlIHRoYXQgdGhlIGZpcnN0IGFyZ3VtZW50IGdpdmVuIHRvIGEgY29uc3RydWN0b3IgaXNcbiAgIyBhIHN0cmluZyB3ZSB3YW50IG91ciBzdWJjbGFzcy1zdHJpbmcgdG8gaG9sZC5cbiAgZGVmIGluaXRpYWxpemUoc3RyID0gdW5kZWZpbmVkLCBlbmNvZGluZzogbmlsLCBjYXBhY2l0eTogbmlsKVxuICBlbmRcblxuICBkZWYgJShkYXRhKVxuICAgIGlmIEFycmF5ID09PSBkYXRhXG4gICAgICBmb3JtYXQoc2VsZiwgKmRhdGEpXG4gICAgZWxzZVxuICAgICAgZm9ybWF0KHNlbGYsIGRhdGEpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAqKGNvdW50KVxuICAgICV4e1xuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJndW1lbnQnfVxuICAgICAgfVxuXG4gICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KCcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYudG9TdHJpbmcoKTtcblxuICAgICAgLy8gQWxsIGNyZWRpdCBmb3IgdGhlIGJpdC10d2lkZGxpbmcgbWFnaWMgY29kZSBiZWxvdyBnb2VzIHRvIE1vemlsbGFcbiAgICAgIC8vIHBvbHlmaWxsIGltcGxlbWVudGF0aW9uIG9mIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KCkgcG9zdGVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvcmVwZWF0XG5cbiAgICAgIGlmIChzdHJpbmcubGVuZ3RoICogY291bnQgPj0gMSA8PCAyOCkge1xuICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsICdtdWx0aXBseSBjb3VudCBtdXN0IG5vdCBvdmVyZmxvdyBtYXhpbXVtIHN0cmluZyBzaXplJ31cbiAgICAgIH1cblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoKGNvdW50ICYgMSkgPT09IDEpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ID4+Pj0gMTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgKyhvdGhlcilcbiAgICBvdGhlciA9IGAkY29lcmNlX3RvKCN7b3RoZXJ9LCAje1N0cmluZ30sICd0b19zdHInKWBcblxuICAgICV4e1xuICAgICAgaWYgKG90aGVyID09IFwiXCIgJiYgc2VsZi4kJGNsYXNzID09PSBPcGFsLlN0cmluZykgcmV0dXJuICN7c2VsZn07XG4gICAgICBpZiAoc2VsZiA9PSBcIlwiICYmIG90aGVyLiQkY2xhc3MgPT09IE9wYWwuU3RyaW5nKSByZXR1cm4gI3tvdGhlcn07XG4gICAgICB2YXIgb3V0ID0gc2VsZiArIG90aGVyO1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcgPT09IG91dC5lbmNvZGluZyAmJiBvdGhlci5lbmNvZGluZyA9PT0gb3V0LmVuY29kaW5nKSByZXR1cm4gb3V0O1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcubmFtZSA9PT0gXCJVVEYtOFwiIHx8IG90aGVyLmVuY29kaW5nLm5hbWUgPT09IFwiVVRGLThcIikgcmV0dXJuIG91dDtcbiAgICAgIHJldHVybiBPcGFsLmVuYyhvdXQsIHNlbGYuZW5jb2RpbmcpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fc3RyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX3N0ci50b19zXG5cbiAgICAgIGBzZWxmID4gb3RoZXIgPyAxIDogKHNlbGYgPCBvdGhlciA/IC0xIDogMClgXG4gICAgZWxzZVxuICAgICAgJXh7XG4gICAgICAgIHZhciBjbXAgPSAje290aGVyIDw9PiBzZWxmfTtcblxuICAgICAgICBpZiAoY21wID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjbXAgPiAwID8gLTEgOiAoY21wIDwgMCA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudG9TdHJpbmcoKSA9PT0gb3RoZXIudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICgkcmVzcG9uZF90byhvdGhlciwgJyR0b19zdHInKSkge1xuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cbiAgYWxpYXMgPT09ID09XG5cbiAgZGVmID1+KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAndHlwZSBtaXNtYXRjaDogU3RyaW5nIGdpdmVuJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje290aGVyID1+IHNlbGZ9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLCBleGNsdWRlO1xuXG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xuICAgICAgICBleGNsdWRlID0gaW5kZXguZXhjbDtcbiAgICAgICAgbGVuZ3RoICA9ICRjb2VyY2VfdG8oaW5kZXguZW5kLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGluZGV4ICAgPSAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGluZGV4KSA+IHNpemUpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgIGxlbmd0aCArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFleGNsdWRlKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggPSBsZW5ndGggLSBpbmRleDtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zdWJzdHIoaW5kZXgsIGxlbmd0aCkpO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3N0cmluZykge1xuICAgICAgICBpZiAobGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvcn1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZi5pbmRleE9mKGluZGV4KSAhPT0gLTEgPyBzZWxmLiQkY2FzdChpbmRleCkgOiBuaWw7XG4gICAgICB9XG5cblxuICAgICAgaWYgKGluZGV4LiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHNlbGYubWF0Y2goaW5kZXgpO1xuXG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgICN7JH4gPSBNYXRjaERhdGEubmV3KGBpbmRleGAsIGBtYXRjaGApfVxuXG4gICAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChtYXRjaFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChsZW5ndGggPCAwICYmIC1sZW5ndGggPCBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QobWF0Y2hbbGVuZ3RoICs9IG1hdGNoLmxlbmd0aF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8IG1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChtYXRjaFtsZW5ndGhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cblxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2l6ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpbmRleCA+PSBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYuc3Vic3RyKGluZGV4LCAxKSk7XG4gICAgICB9XG5cbiAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA+IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnN1YnN0cihpbmRleCwgbGVuZ3RoKSk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBieXRlc2xpY2UgW11cblxuICBkZWYgYlxuICAgIGBuZXcgU3RyaW5nKCN7c2VsZn0pYC5mb3JjZV9lbmNvZGluZygnYmluYXJ5JylcbiAgZW5kXG5cbiAgZGVmIGNhcGl0YWxpemVcbiAgICBgc2VsZi4kJGNhc3Qoc2VsZi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNlbGYuc3Vic3RyKDEpLnRvTG93ZXJDYXNlKCkpYFxuICBlbmRcblxuICBkZWYgY2FzZWNtcChvdGhlcilcbiAgICByZXR1cm4gbmlsIHVubGVzcyBvdGhlci5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgIG90aGVyID0gYCRjb2VyY2VfdG8ob3RoZXIsICN7U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG4gICAgJXh7XG4gICAgICB2YXIgYXNjaWlfb25seSA9IC9eW1xceDAwLVxceDdGXSokLztcbiAgICAgIGlmIChhc2NpaV9vbmx5LnRlc3Qoc2VsZikgJiYgYXNjaWlfb25seS50ZXN0KG90aGVyKSkge1xuICAgICAgICBzZWxmID0gc2VsZi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBvdGhlciA9IG90aGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYgPD0+IG90aGVyXG4gIGVuZFxuXG4gIGRlZiBjYXNlY21wPyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBjbXAgPSAje2Nhc2VjbXAob3RoZXIpfTtcbiAgICAgIGlmIChjbXAgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNtcCA9PT0gMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjZW50ZXIod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3tTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBsanVzdGlmaWVkID0gI3tsanVzdCAoKHdpZHRoICsgYHNlbGYubGVuZ3RoYCkgLyAyKS5jZWlsLCBwYWRzdHJ9LFxuICAgICAgICAgIHJqdXN0aWZpZWQgPSAje3JqdXN0ICgod2lkdGggKyBgc2VsZi5sZW5ndGhgKSAvIDIpLmZsb29yLCBwYWRzdHJ9O1xuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qocmp1c3RpZmllZCArIGxqdXN0aWZpZWQuc2xpY2Uoc2VsZi5sZW5ndGgpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjaG9tcChzZXBhcmF0b3IgPSAkLylcbiAgICByZXR1cm4gc2VsZiBpZiBgc2VwYXJhdG9yID09PSBuaWwgfHwgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBzZXBhcmF0b3IgPSBPcGFsLmNvZXJjZV90byEoc2VwYXJhdG9yLCBTdHJpbmcsIDp0b19zdHIpLnRvX3NcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gXCJcXG5cIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnJlcGxhY2UoL1xccj9cXG4/JC8sICcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlcGFyYXRvciA9PT0gXCJcIikge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnJlcGxhY2UoLyhcXHI/XFxuKSskLywgJycpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VsZi5sZW5ndGggPj0gc2VwYXJhdG9yLmxlbmd0aCkge1xuICAgICAgICB2YXIgdGFpbCA9IHNlbGYuc3Vic3RyKHNlbGYubGVuZ3RoIC0gc2VwYXJhdG9yLmxlbmd0aCwgc2VwYXJhdG9yLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRhaWwgPT09IHNlcGFyYXRvcikge1xuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIHNlbGYubGVuZ3RoIC0gc2VwYXJhdG9yLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNob3BcbiAgICAleHtcbiAgICAgIHZhciBsZW5ndGggPSBzZWxmLmxlbmd0aCwgcmVzdWx0O1xuXG4gICAgICBpZiAobGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gXCJcIjtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5jaGFyQXQobGVuZ3RoIC0gMSkgPT09IFwiXFxuXCIgJiYgc2VsZi5jaGFyQXQobGVuZ3RoIC0gMikgPT09IFwiXFxyXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5zdWJzdHIoMCwgbGVuZ3RoIC0gMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBzZWxmLnN1YnN0cigwLCBsZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hyXG4gICAgYHNlbGYuY2hhckF0KDApYFxuICBlbmRcblxuICBkZWYgY2xvbmVcbiAgICBjb3B5ID0gYG5ldyBTdHJpbmcoc2VsZilgXG4gICAgY29weS5jb3B5X3NpbmdsZXRvbl9tZXRob2RzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2Nsb25lKHNlbGYpXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IGBuZXcgU3RyaW5nKHNlbGYpYFxuICAgIGNvcHkuaW5pdGlhbGl6ZV9kdXAoc2VsZilcbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBjb3VudCgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggLSBzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cChjaGFyX2NsYXNzLCAnZycpLCAnJykubGVuZ3RoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZSgqc2V0cylcbiAgICAleHtcbiAgICAgIGlmIChzZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdBcmd1bWVudEVycm9yOiB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKyknfVxuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoY2hhcl9jbGFzcywgJ2cnKSwgJycpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfcHJlZml4KHByZWZpeClcbiAgICAleHtcbiAgICAgIGlmICghcHJlZml4LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHByZWZpeCA9ICRjb2VyY2VfdG8ocHJlZml4LCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc2xpY2UoMCwgcHJlZml4Lmxlbmd0aCkgPT09IHByZWZpeCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zbGljZShwcmVmaXgubGVuZ3RoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfc3VmZml4KHN1ZmZpeClcbiAgICAleHtcbiAgICAgIGlmICghc3VmZml4LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHN1ZmZpeCA9ICRjb2VyY2VfdG8oc3VmZml4LCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuc2xpY2Uoc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSA9PT0gc3VmZml4KSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnNsaWNlKDAsIHNlbGYubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZG93bmNhc2VcbiAgICBgc2VsZi4kJGNhc3Qoc2VsZi50b0xvd2VyQ2FzZSgpKWBcbiAgZW5kXG5cbiAgZGVmIGVhY2hfbGluZShzZXBhcmF0b3IgPSAkLywgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9saW5lLCBzZXBhcmF0b3IgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSBuaWwpIHtcbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIHNlbGYpO1xuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBzZXBhcmF0b3IgPSAkY29lcmNlX3RvKHNlcGFyYXRvciwgI3tTdHJpbmd9LCAndG9fc3RyJylcblxuICAgICAgdmFyIGEsIGksIG4sIGxlbmd0aCwgY2hvbXBlZCwgdHJhaWxpbmcsIHNwbGl0dGVkO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmb3IgKGEgPSBzZWxmLnNwbGl0KC8oXFxuezIsfSkvKSwgaSA9IDAsIG4gPSBhLmxlbmd0aDsgaSA8IG47IGkgKz0gMikge1xuICAgICAgICAgIGlmIChhW2ldIHx8IGFbaSArIDFdKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAoYVtpXSB8fCBcIlwiKSArIChhW2kgKyAxXSB8fCBcIlwiKTtcbiAgICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLiQkY2FzdCh2YWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBjaG9tcGVkICA9ICN7Y2hvbXAoc2VwYXJhdG9yKX07XG4gICAgICB0cmFpbGluZyA9IHNlbGYubGVuZ3RoICE9IGNob21wZWQubGVuZ3RoO1xuICAgICAgc3BsaXR0ZWQgPSBjaG9tcGVkLnNwbGl0KHNlcGFyYXRvcik7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNwbGl0dGVkLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSB8fCB0cmFpbGluZykge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLiQkY2FzdChzcGxpdHRlZFtpXSArIHNlcGFyYXRvcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmLiQkY2FzdChzcGxpdHRlZFtpXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYubGVuZ3RoID09PSAwYFxuICBlbmRcblxuICBkZWYgZW5kX3dpdGg/KCpzdWZmaXhlcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdWZmaXhlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VmZml4ID0gJGNvZXJjZV90byhzdWZmaXhlc1tpXSwgI3tTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgICBpZiAoc2VsZi5sZW5ndGggPj0gc3VmZml4Lmxlbmd0aCAmJlxuICAgICAgICAgICAgc2VsZi5zdWJzdHIoc2VsZi5sZW5ndGggLSBzdWZmaXgubGVuZ3RoLCBzdWZmaXgubGVuZ3RoKSA9PSBzdWZmaXgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGFsaWFzIGVxdWFsPyA9PT1cblxuICBkZWYgZ3N1YihwYXR0ZXJuLCByZXBsYWNlbWVudCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3tlbnVtX2ZvciA6Z3N1YiwgcGF0dGVybn07XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAnJywgbWF0Y2hfZGF0YSA9IG5pbCwgaW5kZXggPSAwLCBtYXRjaCwgX3JlcGxhY2VtZW50O1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdEluZGV4O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZik7XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICByZXN1bHQgKz0gc2VsZi5zbGljZShpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRjaF9kYXRhID0gI3tNYXRjaERhdGEubmV3IGBwYXR0ZXJuYCwgYG1hdGNoYH07XG5cbiAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsYXN0SW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSBibG9jayhtYXRjaFswXSk7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggPSBsYXN0SW5kZXg7IC8vIHNhdmUgYW5kIHJlc3RvcmUgbGFzdEluZGV4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVwbGFjZW1lbnQuJCRpc19oYXNoKSB7XG4gICAgICAgICAgX3JlcGxhY2VtZW50ID0gI3tgcmVwbGFjZW1lbnRgW2BtYXRjaFswXWBdLnRvX3N9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICghcmVwbGFjZW1lbnQuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gJGNvZXJjZV90byhyZXBsYWNlbWVudCwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZXBsYWNlbWVudCA9IHJlcGxhY2VtZW50LnJlcGxhY2UoLyhbXFxcXF0rKShbMC05KyZgJ10pL2csIGZ1bmN0aW9uIChvcmlnaW5hbCwgc2xhc2hlcywgY29tbWFuZCkge1xuICAgICAgICAgICAgaWYgKHNsYXNoZXMubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSBtYXRjaC5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIGNhc2UgXCImXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgbWF0Y2hbMF07XG4gICAgICAgICAgICBjYXNlIFwiYFwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgY2FzZSBcIidcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6ICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIChtYXRjaFtjb21tYW5kXSB8fCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICByZXN1bHQgKz0gKHNlbGYuc2xpY2UoaW5kZXgsIG1hdGNoLmluZGV4KSArIF9yZXBsYWNlbWVudCArIChzZWxmW21hdGNoLmluZGV4XSB8fCBcIlwiKSk7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgKz0gKHNlbGYuc2xpY2UoaW5kZXgsIG1hdGNoLmluZGV4KSArIF9yZXBsYWNlbWVudClcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgfVxuXG4gICAgICAjeyR+ID0gYG1hdGNoX2RhdGFgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiBoZXhcbiAgICB0b19pIDE2XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhvdGhlcilcbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgb3RoZXIgPSAkY29lcmNlX3RvKG90aGVyLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLmluZGV4T2Yob3RoZXIpICE9PSAtMTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleChzZWFyY2gsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICByZWdleDtcblxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAkY29lcmNlX3RvKG9mZnNldCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgIG9mZnNldCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYXJjaC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICByZWdleCA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAoc2VhcmNoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAjeyR+ID0gbmlsfTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID49IG9mZnNldCkge1xuICAgICAgICAgICAgI3skfiA9IE1hdGNoRGF0YS5uZXcoYHJlZ2V4YCwgYG1hdGNoYCl9XG4gICAgICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZ2V4Lmxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoID0gJGNvZXJjZV90byhzZWFyY2gsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpZiAoc2VhcmNoLmxlbmd0aCA9PT0gMCAmJiBvZmZzZXQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXggPSBzZWxmLmluZGV4T2Yoc2VhcmNoLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyBuaWwgOiBpbmRleDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx1MDA3Ri1cXHUwMDlGXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgICBtZXRhID0ge1xuICAgICAgICAgICAgJ1xcdTAwMDcnOiAnXFxcXGEnLFxuICAgICAgICAgICAgJ1xcdTAwMWInOiAnXFxcXGUnLFxuICAgICAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgICAgICdcXHYnOiAnXFxcXHYnLFxuICAgICAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlc2NhcGVkID0gc2VsZi5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGNocikge1xuICAgICAgICAgICAgaWYgKG1ldGFbY2hyXSkgcmV0dXJuIG1ldGFbY2hyXTtcbiAgICAgICAgICAgIGNociA9IGNoci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYgKGNociA8PSAweGZmICYmIChzZWxmLmVuY29kaW5nW1wiJGJpbmFyeT9cIl0oKSB8fCBzZWxmLmludGVybmFsX2VuY29kaW5nW1wiJGJpbmFyeT9cIl0oKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxceCcgKyAoJzAwJyArIGNoci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdcXFxcdScgKyAoJzAwMDAnICsgY2hyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICByZXR1cm4gJ1wiJyArIGVzY2FwZWQucmVwbGFjZSgvXFwjW1xcJFxcQFxce10vZywgJ1xcXFwkJicpICsgJ1wiJztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnRlcm5cbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgbGluZXMoc2VwYXJhdG9yID0gJC8sICZibG9jaylcbiAgICBlID0gZWFjaF9saW5lKHNlcGFyYXRvciwgJmJsb2NrKVxuICAgIGJsb2NrID8gc2VsZiA6IGUudG9fYVxuICBlbmRcblxuICBkZWYgbGp1c3Qod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3tTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBpbmRleCAgPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBcIlwiO1xuXG4gICAgICB3aWR0aCAtPSBzZWxmLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCB3aWR0aCkge1xuICAgICAgICByZXN1bHQgKz0gcGFkc3RyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZiArIHJlc3VsdC5zbGljZSgwLCB3aWR0aCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL15cXHMqLywgJycpYFxuICBlbmRcblxuICBkZWYgYXNjaWlfb25seT9cbiAgICAjIG5vbi1BU0NJSS1jb21wYXRpYmxlIGVuY29kaW5nIG11c3QgcmV0dXJuIGZhbHNlXG4gICAgJXh7XG4gICAgICBpZiAoIXNlbGYuZW5jb2RpbmcuYXNjaWkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiAvXltcXHgwMC1cXHg3Rl0qJC8udGVzdChzZWxmKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtYXRjaChwYXR0ZXJuLCBwb3MgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBTdHJpbmcgPT09IHBhdHRlcm4gfHwgcGF0dGVybi5yZXNwb25kX3RvPyg6dG9fc3RyKVxuICAgICAgcGF0dGVybiA9IFJlZ2V4cC5uZXcocGF0dGVybi50b19zdHIpXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgUmVnZXhwID09PSBwYXR0ZXJuXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje3BhdHRlcm4uY2xhc3N9IChleHBlY3RlZCBSZWdleHApXCJcbiAgICBlbmRcblxuICAgIHBhdHRlcm4ubWF0Y2goc2VsZiwgcG9zLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtYXRjaD8ocGF0dGVybiwgcG9zID0gdW5kZWZpbmVkKVxuICAgIGlmIFN0cmluZyA9PT0gcGF0dGVybiB8fCBwYXR0ZXJuLnJlc3BvbmRfdG8/KDp0b19zdHIpXG4gICAgICBwYXR0ZXJuID0gUmVnZXhwLm5ldyhwYXR0ZXJuLnRvX3N0cilcbiAgICBlbmRcblxuICAgIHVubGVzcyBSZWdleHAgPT09IHBhdHRlcm5cbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7cGF0dGVybi5jbGFzc30gKGV4cGVjdGVkIFJlZ2V4cClcIlxuICAgIGVuZFxuXG4gICAgcGF0dGVybi5tYXRjaD8oc2VsZiwgcG9zKVxuICBlbmRcblxuICBkZWYgbmV4dFxuICAgICV4e1xuICAgICAgdmFyIGkgPSBzZWxmLmxlbmd0aDtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdCgnJyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc2VsZjtcbiAgICAgIHZhciBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4ID0gc2VsZi5zZWFyY2goL1thLXpBLVowLTldLyk7XG4gICAgICB2YXIgY2FycnkgPSBmYWxzZTtcbiAgICAgIHZhciBjb2RlO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb2RlID0gc2VsZi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB8fFxuICAgICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTIyKSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNTc6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gNDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDkwOlxuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgY29kZSA9IDY1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMjI6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gOTc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FycnkgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZpcnN0X2FscGhhbnVtX2NoYXJfaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMjU1KSB7XG4gICAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29kZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXJyeSA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIHJlc3VsdC5zbGljZShpICsgMSk7XG4gICAgICAgIGlmIChjYXJyeSAmJiAoaSA9PT0gMCB8fCBpID09PSBmaXJzdF9hbHBoYW51bV9jaGFyX2luZGV4KSkge1xuICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgNjU6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk3OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyByZXN1bHQuc2xpY2UoaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhcnJ5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYXJyeSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBvY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgc3RyaW5nID0gc2VsZixcbiAgICAgICAgICByYWRpeCA9IDg7XG5cbiAgICAgIGlmICgvXlxccypfLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pKC4rKSQvaSwgZnVuY3Rpb24gKG9yaWdpbmFsLCBoZWFkLCBmbGFnLCB0YWlsKSB7XG4gICAgICAgIHN3aXRjaCAodGFpbC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgaWYgKHRhaWwuY2hhckF0KDEpID09PSAneCcgJiYgZmxhZyA9PT0gJzB4Jykge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIHJhZGl4ID0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICByYWRpeCA9IDg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzBkJzpcbiAgICAgICAgICByYWRpeCA9IDEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgcmFkaXggPSAxNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLnJlcGxhY2UoL18oPyFfKS9nLCAnJyksIHJhZGl4KTtcbiAgICAgIHJldHVybiBpc05hTihyZXN1bHQpID8gMCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBvcmRcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZi5jb2RlUG9pbnRBdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNvZGVQb2ludEF0KDApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmLmNoYXJDb2RlQXQoMCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcGFydGl0aW9uKHNlcClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtO1xuXG4gICAgICBpZiAoc2VwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBzZXAuZXhlYyhzZWxmKTtcbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3tNYXRjaERhdGEubmV3IGBzZXBgLCBgbWB9O1xuICAgICAgICAgIHNlcCA9IG1bMF07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcCA9ICRjb2VyY2VfdG8oc2VwLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaSA9IHNlbGYuaW5kZXhPZihzZXApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFtzZWxmLCAnJywgJyddO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzZWxmLnNsaWNlKDAsIGkpLFxuICAgICAgICBzZWxmLnNsaWNlKGksIGkgKyBzZXAubGVuZ3RoKSxcbiAgICAgICAgc2VsZi5zbGljZShpICsgc2VwLmxlbmd0aClcbiAgICAgIF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmV2ZXJzZVxuICAgIGBzZWxmLnNwbGl0KCcnKS5yZXZlcnNlKCkuam9pbignJylgXG4gIGVuZFxuXG4gIGRlZiByaW5kZXgoc2VhcmNoLCBvZmZzZXQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbSwgciwgX207XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvZmZzZXQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldCA9ICRjb2VyY2VfdG8ob2Zmc2V0LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VhcmNoLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBudWxsO1xuICAgICAgICByID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZWFyY2gpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIF9tID0gci5leGVjKHNlbGYpO1xuICAgICAgICAgIGlmIChfbSA9PT0gbnVsbCB8fCBfbS5pbmRleCA+IG9mZnNldCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG0gPSBfbTtcbiAgICAgICAgICByLmxhc3RJbmRleCA9IG0uaW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3tNYXRjaERhdGEubmV3IGByYCwgYG1gfTtcbiAgICAgICAgICBpID0gbS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VhcmNoID0gJGNvZXJjZV90byhzZWFyY2gsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpID0gc2VsZi5sYXN0SW5kZXhPZihzZWFyY2gsIG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpID09PSAtMSA/IG5pbCA6IGk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmp1c3Qod2lkdGgsIHBhZHN0ciA9ICcgJylcbiAgICB3aWR0aCAgPSBgJGNvZXJjZV90bygje3dpZHRofSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgIHBhZHN0ciA9IGAkY29lcmNlX3RvKCN7cGFkc3RyfSwgI3tTdHJpbmd9LCAndG9fc3RyJylgLnRvX3NcblxuICAgIGlmIHBhZHN0ci5lbXB0eT9cbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd6ZXJvIHdpZHRoIHBhZGRpbmcnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gc2VsZiBpZiBgd2lkdGggPD0gc2VsZi5sZW5ndGhgXG5cbiAgICAleHtcbiAgICAgIHZhciBjaGFycyAgICAgPSBNYXRoLmZsb29yKHdpZHRoIC0gc2VsZi5sZW5ndGgpLFxuICAgICAgICAgIHBhdHRlcm5zICA9IE1hdGguZmxvb3IoY2hhcnMgLyBwYWRzdHIubGVuZ3RoKSxcbiAgICAgICAgICByZXN1bHQgICAgPSBBcnJheShwYXR0ZXJucyArIDEpLmpvaW4ocGFkc3RyKSxcbiAgICAgICAgICByZW1haW5pbmcgPSBjaGFycyAtIHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQgKyBwYWRzdHIuc2xpY2UoMCwgcmVtYWluaW5nKSArIHNlbGYpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJwYXJ0aXRpb24oc2VwKVxuICAgICV4e1xuICAgICAgdmFyIGksIG0sIHIsIF9tO1xuXG4gICAgICBpZiAoc2VwLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIG0gPSBudWxsO1xuICAgICAgICByID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChzZXApO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgX20gPSByLmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKF9tID09PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbSA9IF9tO1xuICAgICAgICAgIHIubGFzdEluZGV4ID0gbS5pbmRleCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAje01hdGNoRGF0YS5uZXcgYHJgLCBgbWB9O1xuICAgICAgICAgIHNlcCA9IG1bMF07XG4gICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VwID0gJGNvZXJjZV90byhzZXAsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpID0gc2VsZi5sYXN0SW5kZXhPZihzZXApO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFsnJywgJycsIHNlbGZdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBzZWxmLnNsaWNlKDAsIGkpLFxuICAgICAgICBzZWxmLnNsaWNlKGksIGkgKyBzZXAubGVuZ3RoKSxcbiAgICAgICAgc2VsZi5zbGljZShpICsgc2VwLmxlbmd0aClcbiAgICAgIF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgcnN0cmlwXG4gICAgYHNlbGYucmVwbGFjZSgvW1xcc1xcdTAwMDBdKiQvLCAnJylgXG4gIGVuZFxuXG4gIGRlZiBzY2FuKHBhdHRlcm4sICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBtYXRjaF9kYXRhID0gbmlsLFxuICAgICAgICAgIG1hdGNoO1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKG1hdGNoID0gcGF0dGVybi5leGVjKHNlbGYpKSAhPSBudWxsKSB7XG4gICAgICAgIG1hdGNoX2RhdGEgPSAje01hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfTtcbiAgICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgICBtYXRjaC5sZW5ndGggPT0gMSA/IHJlc3VsdC5wdXNoKG1hdGNoWzBdKSA6IHJlc3VsdC5wdXNoKCN7YG1hdGNoX2RhdGFgLmNhcHR1cmVzfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2gubGVuZ3RoID09IDEgPyBibG9jayhtYXRjaFswXSkgOiBibG9jay5jYWxsKHNlbGYsICN7YG1hdGNoX2RhdGFgLmNhcHR1cmVzfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdHRlcm4ubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgI3skfiA9IGBtYXRjaF9kYXRhYH1cblxuICAgICAgcmV0dXJuIChibG9jayAhPT0gbmlsID8gc2VsZiA6IHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzbGljZSBbXVxuXG4gIGRlZiBzcGxpdChwYXR0ZXJuID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbWl0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbWl0ID0gI3tPcGFsLmNvZXJjZV90byEobGltaXQsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgaWYgKGxpbWl0ID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFtzZWxmXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkIHx8IHBhdHRlcm4gPT09IG5pbCkge1xuICAgICAgICBwYXR0ZXJuID0gI3skOyB8fCAnICd9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc3RyaW5nID0gc2VsZi50b1N0cmluZygpLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBpLCBpaTtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAocGF0dGVybik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXR0ZXJuID0gJGNvZXJjZV90byhwYXR0ZXJuLCAje1N0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuICAgICAgICBpZiAocGF0dGVybiA9PT0gJyAnKSB7XG4gICAgICAgICAgcGF0dGVybiA9IC9cXHMrL2dtO1xuICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eXFxzKy8sICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyksICdnbScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IHN0cmluZy5zcGxpdChwYXR0ZXJuKTtcblxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEgJiYgcmVzdWx0WzBdID09PSBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIFtzZWxmLiQkY2FzdChyZXN1bHRbMF0pXTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKChpID0gcmVzdWx0LmluZGV4T2YodW5kZWZpbmVkKSkgIT09IC0xKSB7XG4gICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhc3RSZXN1bHQoKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRbaV0gPSBzZWxmLiQkY2FzdChyZXN1bHRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA9PT0gMCkge1xuICAgICAgICB3aGlsZSAocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAgICByZXN1bHQubGVuZ3RoIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgY2FzdFJlc3VsdCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBtYXRjaCA9IHBhdHRlcm4uZXhlYyhzdHJpbmcpO1xuXG4gICAgICBpZiAobGltaXQgPCAwKSB7XG4gICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaFswXSA9PT0gJycgJiYgcGF0dGVybi5zb3VyY2UuaW5kZXhPZignKD89JykgPT09IC0xKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBtYXRjaC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhc3RSZXN1bHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIG1hdGNoWzBdID09PSAnJykge1xuICAgICAgICByZXN1bHQuc3BsaWNlKGxpbWl0IC0gMSwgcmVzdWx0Lmxlbmd0aCAtIDEsIHJlc3VsdC5zbGljZShsaW1pdCAtIDEpLmpvaW4oJycpKTtcbiAgICAgICAgY2FzdFJlc3VsdCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobGltaXQgPj0gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGkgPSAwO1xuICAgICAgd2hpbGUgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgaW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgICAgaWYgKGkgKyAxID09PSBsaW1pdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoID0gcGF0dGVybi5leGVjKHN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXN1bHQuc3BsaWNlKGxpbWl0IC0gMSwgcmVzdWx0Lmxlbmd0aCAtIDEsIHN0cmluZy5zbGljZShpbmRleCkpO1xuICAgICAgY2FzdFJlc3VsdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzcXVlZXplKCpzZXRzKVxuICAgICV4e1xuICAgICAgaWYgKHNldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnJlcGxhY2UoLyguKVxcMSsvZywgJyQxJykpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYXJfY2xhc3MgPSBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpO1xuICAgICAgaWYgKGNoYXJfY2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoJygnICsgY2hhcl9jbGFzcyArICcpXFxcXDErJywgJ2cnKSwgJyQxJykpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN0YXJ0X3dpdGg/KCpwcmVmaXhlcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBwcmVmaXhlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocHJlZml4ZXNbaV0uJCRpc19yZWdleHApIHtcbiAgICAgICAgICB2YXIgcmVnZXhwID0gcHJlZml4ZXNbaV07XG4gICAgICAgICAgdmFyIG1hdGNoID0gcmVnZXhwLmV4ZWMoc2VsZik7XG5cbiAgICAgICAgICBpZiAobWF0Y2ggIT0gbnVsbCAmJiBtYXRjaC5pbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgI3skfiA9IE1hdGNoRGF0YS5uZXcoYHJlZ2V4cGAsIGBtYXRjaGApfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gJGNvZXJjZV90byhwcmVmaXhlc1tpXSwgI3tTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgICAgIGlmIChzZWxmLmluZGV4T2YocHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzdHJpcFxuICAgIGBzZWxmLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1tcXHNcXHUwMDAwXSokLywgJycpYFxuICBlbmRcblxuICBkZWYgc3ViKHBhdHRlcm4sIHJlcGxhY2VtZW50ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoIXBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9ICRjb2VyY2VfdG8ocGF0dGVybiwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQsIG1hdGNoID0gcGF0dGVybi5leGVjKHNlbGYpO1xuXG4gICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgI3skfiA9IG5pbH1cbiAgICAgICAgcmVzdWx0ID0gc2VsZi50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgI3tNYXRjaERhdGEubmV3IGBwYXR0ZXJuYCwgYG1hdGNoYH1cblxuICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDEgZm9yIDIpJ31cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyBibG9jayhtYXRjaFswXSkgKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlcGxhY2VtZW50LiQkaXNfaGFzaCkge1xuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAje2ByZXBsYWNlbWVudGBbYG1hdGNoWzBdYF0udG9fc30gKyBzZWxmLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSAkY29lcmNlX3RvKHJlcGxhY2VtZW50LCAje1N0cmluZ30sICd0b19zdHInKTtcblxuICAgICAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQucmVwbGFjZSgvKFtcXFxcXSspKFswLTkrJmAnXSkvZywgZnVuY3Rpb24gKG9yaWdpbmFsLCBzbGFzaGVzLCBjb21tYW5kKSB7XG4gICAgICAgICAgICBpZiAoc2xhc2hlcy5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IG1hdGNoLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgY2FzZSBcIiZcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBtYXRjaFswXTtcbiAgICAgICAgICAgIGNhc2UgXCJgXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgZGVmYXVsdDogIHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgKG1hdGNoW2NvbW1hbmRdIHx8ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZi5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyByZXBsYWNlbWVudCArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3VjYyBuZXh0XG5cbiAgZGVmIHN1bShuID0gMTYpXG4gICAgJXh7XG4gICAgICBuID0gJGNvZXJjZV90byhuLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIHZhciByZXN1bHQgPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBzZWxmLmNoYXJDb2RlQXQoaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCAmIChNYXRoLnBvdygyLCBuKSAtIDEpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN3YXBjYXNlXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc2VsZi5yZXBsYWNlKC8oW2Etel0rKXwoW0EtWl0rKS9nLCBmdW5jdGlvbigkMCwkMSwkMikge1xuICAgICAgICByZXR1cm4gJDEgPyAkMC50b1VwcGVyQ2FzZSgpIDogJDAudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2VsZi5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje3NlbGYuY2xhc3MubmV3IGBzdHJgfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5jaGFyQXQoMCkgPT09ICdfJykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRmxvYXQoc2VsZi5yZXBsYWNlKC9fL2csICcnKSk7XG5cbiAgICAgIGlmIChpc05hTihyZXN1bHQpIHx8IHJlc3VsdCA9PSBJbmZpbml0eSB8fCByZXN1bHQgPT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faShiYXNlID0gMTApXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHN0cmluZyA9IHNlbGYudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICByYWRpeCA9ICRjb2VyY2VfdG8oYmFzZSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAocmFkaXggPT09IDEgfHwgcmFkaXggPCAwIHx8IHJhZGl4ID4gMzYpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tgcmFkaXhgfVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoL15cXHMqXy8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXihcXHMqWystXT8pKDBbYm9keF0/KSguKykkLywgZnVuY3Rpb24gKG9yaWdpbmFsLCBoZWFkLCBmbGFnLCB0YWlsKSB7XG4gICAgICAgIHN3aXRjaCAodGFpbC5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgaWYgKHRhaWwuY2hhckF0KDEpID09PSAneCcgJiYgZmxhZyA9PT0gJzB4JyAmJiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDE2KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgY2FzZSAnMGInOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMikge1xuICAgICAgICAgICAgcmFkaXggPSAyO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgIGNhc2UgJzBvJzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDgpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gODtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzBkJzpcbiAgICAgICAgICBpZiAocmFkaXggPT09IDAgfHwgcmFkaXggPT09IDEwKSB7XG4gICAgICAgICAgICByYWRpeCA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMHgnOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMTYpIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMTY7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFxuICAgICAgfSk7XG5cbiAgICAgIHJlc3VsdCA9IHBhcnNlSW50KHN0cmluZy5yZXBsYWNlKC9fKD8hXykvZywgJycpLCByYWRpeCk7XG4gICAgICByZXR1cm4gaXNOYU4ocmVzdWx0KSA/IDAgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIG1ldGhvZF9uYW1lID0gJyQnICsgYHNlbGYudmFsdWVPZigpYFxuXG4gICAgcHJvYyBkbyB8KmFyZ3MsICZibG9ja3xcbiAgICAgICV4e1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdubyByZWNlaXZlciBnaXZlbid9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjdiA9IGFyZ3NbMF07XG5cbiAgICAgICAgaWYgKHJlY3YgPT0gbnVsbCkgcmVjdiA9IG5pbDtcblxuICAgICAgICB2YXIgYm9keSA9IHJlY3ZbI3ttZXRob2RfbmFtZX1dO1xuXG4gICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgIHJldHVybiByZWN2LiRtZXRob2RfbWlzc2luZy5hcHBseShyZWN2LCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBib2R5LiQkcCA9IGJsb2NrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGJvZHkuY2FsbChyZWN2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYm9keS5hcHBseShyZWN2LCBhcmdzLnNsaWNlKDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGFsaWFzIHRvX3N0ciB0b19zXG5cbiAgYWxpYXMgdG9fc3ltIGludGVyblxuXG4gIGRlZiB0cihmcm9tLCB0bylcbiAgICAleHtcbiAgICAgIGZyb20gPSAkY29lcmNlX3RvKGZyb20sICN7U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG4gICAgICB0byA9ICRjb2VyY2VfdG8odG8sICN7U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG5cbiAgICAgIGlmIChmcm9tLmxlbmd0aCA9PSAwIHx8IGZyb20gPT09IHRvKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgaW5fcmFuZ2UsIGMsIGNoLCBzdGFydCwgZW5kLCBsZW5ndGg7XG4gICAgICB2YXIgc3VicyA9IHt9O1xuICAgICAgdmFyIGZyb21fY2hhcnMgPSBmcm9tLnNwbGl0KCcnKTtcbiAgICAgIHZhciBmcm9tX2xlbmd0aCA9IGZyb21fY2hhcnMubGVuZ3RoO1xuICAgICAgdmFyIHRvX2NoYXJzID0gdG8uc3BsaXQoJycpO1xuICAgICAgdmFyIHRvX2xlbmd0aCA9IHRvX2NoYXJzLmxlbmd0aDtcblxuICAgICAgdmFyIGludmVyc2UgPSBmYWxzZTtcbiAgICAgIHZhciBnbG9iYWxfc3ViID0gbnVsbDtcbiAgICAgIGlmIChmcm9tX2NoYXJzWzBdID09PSAnXicgJiYgZnJvbV9jaGFycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGludmVyc2UgPSB0cnVlO1xuICAgICAgICBmcm9tX2NoYXJzLnNoaWZ0KCk7XG4gICAgICAgIGdsb2JhbF9zdWIgPSB0b19jaGFyc1t0b19sZW5ndGggLSAxXVxuICAgICAgICBmcm9tX2xlbmd0aCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJvbV9jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgdmFyIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBmcm9tX2NoYXJzW2ldO1xuICAgICAgICBpZiAobGFzdF9mcm9tID09IG51bGwpIHtcbiAgICAgICAgICBsYXN0X2Zyb20gPSBjaDtcbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICBpZiAobGFzdF9mcm9tID09PSAnLScpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGkgPT0gZnJvbV9sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgc3RhcnQgPSBsYXN0X2Zyb20uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBlbmQgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyb21fY2hhcnMgPSBmcm9tX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcblxuICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0b19sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHRvX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICAgICAgdmFyIGxhc3RfdG8gPSBudWxsO1xuICAgICAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaCA9IHRvX2NoYXJzW2ldO1xuICAgICAgICAgICAgaWYgKGxhc3RfdG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0X3RvID0gY2g7XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgICBpZiAobGFzdF90byA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmIChpID09IHRvX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgICAgICBzdGFydCA9IGxhc3RfdG8uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgbGFzdF90byA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9fY2hhcnMgPSB0b19jaGFyc19leHBhbmRlZDtcbiAgICAgICAgICB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSBmcm9tX2xlbmd0aCAtIHRvX2xlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aF9kaWZmID4gMCkge1xuICAgICAgICAgIHZhciBwYWRfY2hhciA9ICh0b19sZW5ndGggPiAwID8gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV0gOiAnJyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aF9kaWZmOyBpKyspIHtcbiAgICAgICAgICAgIHRvX2NoYXJzLnB1c2gocGFkX2NoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRvX2NoYXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdfc3RyID0gJydcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBzZWxmLmNoYXJBdChpKTtcbiAgICAgICAgdmFyIHN1YiA9IHN1YnNbY2hdO1xuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgIG5ld19zdHIgKz0gKHN1YiA9PSBudWxsID8gZ2xvYmFsX3N1YiA6IGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBuZXdfc3RyICs9IChzdWIgIT0gbnVsbCA/IHN1YiA6IGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KG5ld19zdHIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyX3MoZnJvbSwgdG8pXG4gICAgJXh7XG4gICAgICBmcm9tID0gJGNvZXJjZV90byhmcm9tLCAje1N0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuICAgICAgdG8gPSAkY29lcmNlX3RvKHRvLCAje1N0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuXG4gICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGluX3JhbmdlLCBjLCBjaCwgc3RhcnQsIGVuZCwgbGVuZ3RoO1xuICAgICAgdmFyIHN1YnMgPSB7fTtcbiAgICAgIHZhciBmcm9tX2NoYXJzID0gZnJvbS5zcGxpdCgnJyk7XG4gICAgICB2YXIgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcbiAgICAgIHZhciB0b19jaGFycyA9IHRvLnNwbGl0KCcnKTtcbiAgICAgIHZhciB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG5cbiAgICAgIHZhciBpbnZlcnNlID0gZmFsc2U7XG4gICAgICB2YXIgZ2xvYmFsX3N1YiA9IG51bGw7XG4gICAgICBpZiAoZnJvbV9jaGFyc1swXSA9PT0gJ14nICYmIGZyb21fY2hhcnMubGVuZ3RoID4gMSkge1xuICAgICAgICBpbnZlcnNlID0gdHJ1ZTtcbiAgICAgICAgZnJvbV9jaGFycy5zaGlmdCgpO1xuICAgICAgICBnbG9iYWxfc3ViID0gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV1cbiAgICAgICAgZnJvbV9sZW5ndGggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZyb21fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgIHZhciBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gZnJvbV9jaGFyc1tpXTtcbiAgICAgICAgaWYgKGxhc3RfZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdF9mcm9tID0gY2g7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgaWYgKGxhc3RfZnJvbSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpID09IGZyb21fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5fcmFuZ2UgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbl9yYW5nZSkge1xuICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmcm9tX2NoYXJzID0gZnJvbV9jaGFyc19leHBhbmRlZDtcbiAgICAgIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG5cbiAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodG9fbGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0b19jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgICAgIHZhciBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b19sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2ggPSB0b19jaGFyc1tpXTtcbiAgICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0X2Zyb20gPSBjaDtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0X3RvID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gdG9fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gbGFzdF9mcm9tLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BTdHJpbmcuZnJvbUNoYXJDb2RlKHN0YXJ0KWB9LSN7YFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kKWB9XFxcIiBpbiBzdHJpbmcgdHJhbnNsaXRlcmF0aW9uXCJ9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9fY2hhcnMgPSB0b19jaGFyc19leHBhbmRlZDtcbiAgICAgICAgICB0b19sZW5ndGggPSB0b19jaGFycy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSBmcm9tX2xlbmd0aCAtIHRvX2xlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aF9kaWZmID4gMCkge1xuICAgICAgICAgIHZhciBwYWRfY2hhciA9ICh0b19sZW5ndGggPiAwID8gdG9fY2hhcnNbdG9fbGVuZ3RoIC0gMV0gOiAnJyk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aF9kaWZmOyBpKyspIHtcbiAgICAgICAgICAgIHRvX2NoYXJzLnB1c2gocGFkX2NoYXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmcm9tX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc3Vic1tmcm9tX2NoYXJzW2ldXSA9IHRvX2NoYXJzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbmV3X3N0ciA9ICcnXG4gICAgICB2YXIgbGFzdF9zdWJzdGl0dXRlID0gbnVsbFxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IHNlbGYuY2hhckF0KGkpO1xuICAgICAgICB2YXIgc3ViID0gc3Vic1tjaF1cbiAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICBpZiAoc3ViID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsYXN0X3N1YnN0aXR1dGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZXdfc3RyICs9IGdsb2JhbF9zdWI7XG4gICAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3X3N0ciArPSBjaDtcbiAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChzdWIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxhc3Rfc3Vic3RpdHV0ZSA9PSBudWxsIHx8IGxhc3Rfc3Vic3RpdHV0ZSAhPT0gc3ViKSB7XG4gICAgICAgICAgICAgIG5ld19zdHIgKz0gc3ViO1xuICAgICAgICAgICAgICBsYXN0X3N1YnN0aXR1dGUgPSBzdWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3X3N0ciArPSBjaDtcbiAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QobmV3X3N0cik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdXBjYXNlXG4gICAgYHNlbGYuJCRjYXN0KHNlbGYudG9VcHBlckNhc2UoKSlgXG4gIGVuZFxuXG4gIGRlZiB1cHRvKHN0b3AsIGV4Y2wgPSBmYWxzZSwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6dXB0bywgc3RvcCwgZXhjbCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7XG4gICAgICB2YXIgYSwgYiwgcyA9IHNlbGYudG9TdHJpbmcoKTtcblxuICAgICAgc3RvcCA9ICRjb2VyY2VfdG8oc3RvcCwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgIGlmIChzLmxlbmd0aCA9PT0gMSAmJiBzdG9wLmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgIGEgPSBzLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGIgPSBzdG9wLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgd2hpbGUgKGEgPD0gYikge1xuICAgICAgICAgIGlmIChleGNsICYmIGEgPT09IGIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJsb2NrKFN0cmluZy5mcm9tQ2hhckNvZGUoYSkpO1xuXG4gICAgICAgICAgYSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VJbnQocywgMTApLnRvU3RyaW5nKCkgPT09IHMgJiYgcGFyc2VJbnQoc3RvcCwgMTApLnRvU3RyaW5nKCkgPT09IHN0b3ApIHtcblxuICAgICAgICBhID0gcGFyc2VJbnQocywgMTApO1xuICAgICAgICBiID0gcGFyc2VJbnQoc3RvcCwgMTApO1xuXG4gICAgICAgIHdoaWxlIChhIDw9IGIpIHtcbiAgICAgICAgICBpZiAoZXhjbCAmJiBhID09PSBiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBibG9jayhhLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgYSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgd2hpbGUgKHMubGVuZ3RoIDw9IHN0b3AubGVuZ3RoICYmIHMgPD0gc3RvcCkge1xuICAgICAgICAgIGlmIChleGNsICYmIHMgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJsb2NrKHMpO1xuXG4gICAgICAgICAgcyA9ICN7YHNgLnN1Y2N9O1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gY2hhcl9jbGFzc19mcm9tX2NoYXJfc2V0cyhzZXRzKSB7XG4gICAgICBmdW5jdGlvbiBleHBsb2RlX3NlcXVlbmNlc19pbl9jaGFyYWN0ZXJfc2V0KHNldCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBpLCBsZW4gPSBzZXQubGVuZ3RoLFxuICAgICAgICAgICAgY3Vycl9jaGFyLFxuICAgICAgICAgICAgc2tpcF9uZXh0X2Rhc2gsXG4gICAgICAgICAgICBjaGFyX2NvZGVfZnJvbSxcbiAgICAgICAgICAgIGNoYXJfY29kZV91cHRvLFxuICAgICAgICAgICAgY2hhcl9jb2RlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjdXJyX2NoYXIgPSBzZXQuY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChjdXJyX2NoYXIgPT09ICctJyAmJiBpID4gMCAmJiBpIDwgKGxlbiAtIDEpICYmICFza2lwX25leHRfZGFzaCkge1xuICAgICAgICAgICAgY2hhcl9jb2RlX2Zyb20gPSBzZXQuY2hhckNvZGVBdChpIC0gMSk7XG4gICAgICAgICAgICBjaGFyX2NvZGVfdXB0byA9IHNldC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChjaGFyX2NvZGVfZnJvbSA+IGNoYXJfY29kZV91cHRvKSB7XG4gICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHJhbmdlIFxcXCIje2BjaGFyX2NvZGVfZnJvbWB9LSN7YGNoYXJfY29kZV91cHRvYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY2hhcl9jb2RlID0gY2hhcl9jb2RlX2Zyb20gKyAxOyBjaGFyX2NvZGUgPCBjaGFyX2NvZGVfdXB0byArIDE7IGNoYXJfY29kZSsrKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJfY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCA9IHRydWU7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoID0gKGN1cnJfY2hhciA9PT0gJ1xcXFwnKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjdXJyX2NoYXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludGVyc2VjdGlvbihzZXRBLCBzZXRCKSB7XG4gICAgICAgIGlmIChzZXRBLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBzZXRCO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAgIGksIGxlbiA9IHNldEEubGVuZ3RoLFxuICAgICAgICAgICAgY2hyO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjaHIgPSBzZXRBLmNoYXJBdChpKTtcbiAgICAgICAgICBpZiAoc2V0Qi5pbmRleE9mKGNocikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gY2hyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgbGVuLCBzZXQsIG5lZywgY2hyLCB0bXAsXG4gICAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9ICcnLFxuICAgICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSAnJztcblxuICAgICAgZm9yIChpID0gMCwgbGVuID0gc2V0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzZXQgPSAkY29lcmNlX3RvKHNldHNbaV0sICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBuZWcgPSAoc2V0LmNoYXJBdCgwKSA9PT0gJ14nICYmIHNldC5sZW5ndGggPiAxKTtcbiAgICAgICAgc2V0ID0gZXhwbG9kZV9zZXF1ZW5jZXNfaW5fY2hhcmFjdGVyX3NldChuZWcgPyBzZXQuc2xpY2UoMSkgOiBzZXQpO1xuICAgICAgICBpZiAobmVnKSB7XG4gICAgICAgICAgbmVnX2ludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbihuZWdfaW50ZXJzZWN0aW9uLCBzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb24ocG9zX2ludGVyc2VjdGlvbiwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocG9zX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwICYmIG5lZ19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICB0bXAgPSAnJztcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcG9zX2ludGVyc2VjdGlvbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNociA9IHBvc19pbnRlcnNlY3Rpb24uY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChuZWdfaW50ZXJzZWN0aW9uLmluZGV4T2YoY2hyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRtcCArPSBjaHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvc19pbnRlcnNlY3Rpb24gPSB0bXA7XG4gICAgICAgIG5lZ19pbnRlcnNlY3Rpb24gPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc19pbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gJ1snICsgI3tSZWdleHAuZXNjYXBlKGBwb3NfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVnX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiAnW14nICsgI3tSZWdleHAuZXNjYXBlKGBuZWdfaW50ZXJzZWN0aW9uYCl9ICsgJ10nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgW11cbiAgZW5kXG5cbiAgZGVmIHNlbGYuX2xvYWQoKmFyZ3MpXG4gICAgbmV3KCphcmdzKVxuICBlbmRcblxuICBkZWYgdW5pY29kZV9ub3JtYWxpemUoZm9ybSA9IDpuZmMpXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJJbnZhbGlkIG5vcm1hbGl6YXRpb24gZm9ybSAje2Zvcm19XCIgdW5sZXNzICVpW25mYyBuZmQgbmZrYyBuZmtkXS5pbmNsdWRlPyhmb3JtKVxuICAgIGBzZWxmLm5vcm1hbGl6ZSgje2Zvcm0udXBjYXNlfSlgXG4gIGVuZFxuXG4gIGRlZiB1bmljb2RlX25vcm1hbGl6ZWQ/KGZvcm0gPSA6bmZjKVxuICAgIHVuaWNvZGVfbm9ybWFsaXplKGZvcm0pID09IHNlbGZcbiAgZW5kXG5cbiAgZGVmIHVucGFjayhmb3JtYXQpXG4gICAgcmFpc2UgXCJUbyB1c2UgU3RyaW5nI3VucGFjaywgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvdW5wYWNrJy5cIlxuICBlbmRcblxuICBkZWYgdW5wYWNrMShmb3JtYXQpXG4gICAgcmFpc2UgXCJUbyB1c2UgU3RyaW5nI3VucGFjazEsIHlvdSBtdXN0IGZpcnN0IHJlcXVpcmUgJ2NvcmVsaWIvc3RyaW5nL3VucGFjaycuXCJcbiAgZW5kXG5cbiAgZGVmIGZyZWV6ZVxuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBzZWxmID09PSAnc3RyaW5nJykgcmV0dXJuIHNlbGY7XG4gICAgICBzZWxmLiQkZnJvemVuID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgK0AgZHVwXG5cbiAgZGVmIC1AXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnKSByZXR1cm4gc2VsZjtcbiAgICAgIGlmIChzZWxmLiQkZnJvemVuID09PSB0cnVlKSByZXR1cm4gc2VsZjtcbiAgICAgIGlmIChzZWxmLmVuY29kaW5nLm5hbWUgPT0gJ1VURi04JyAmJiBzZWxmLmludGVybmFsX2VuY29kaW5nLm5hbWUgPT0gJ1VURi04JykgcmV0dXJuIHNlbGYudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBzZWxmLiRkdXAoKS4kZnJlZXplKCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZnJvemVuP1xuICAgIGB0eXBlb2Ygc2VsZiA9PT0gJ3N0cmluZycgfHwgc2VsZi4kJGZyb3plbiA9PT0gdHJ1ZWBcbiAgZW5kXG5cbiAgT3BhbC5wcmlzdGluZSBzZWxmLCA6aW5pdGlhbGl6ZVxuZW5kXG5cblN5bWJvbCA9IFN0cmluZ1xuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsImluY2x1ZGUiLCJzZWxmIiwiX19pZF9fIiwidHJ5X2NvbnZlcnQiLCJjb2VyY2VfdG8/Iiwid2hhdCIsIm5ldyIsImluaXRpYWxpemUiLCJhcmdzIiwiJSIsIj09PSIsImRhdGEiLCJmb3JtYXQiLCIqIiwicmFpc2UiLCIrIiwib3RoZXIiLCI8PT4iLCJyZXNwb25kX3RvPyIsInRvX3N0ciIsInRvX3MiLCI9PSIsIj1+IiwiW10iLCIkfiIsImIiLCJmb3JjZV9lbmNvZGluZyIsImNhcGl0YWxpemUiLCJjYXNlY21wIiwiY2FzZWNtcD8iLCJjZW50ZXIiLCJ3aWR0aCIsInBhZHN0ciIsImVtcHR5PyIsImxqdXN0IiwiLyIsIjIiLCJjZWlsIiwicmp1c3QiLCJmbG9vciIsImNob21wIiwiJC8iLCJzZXBhcmF0b3IiLCJjb2VyY2VfdG8hIiwiY2hvcCIsImNociIsImNsb25lIiwiY29weSIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJpbml0aWFsaXplX2Nsb25lIiwiZHVwIiwiaW5pdGlhbGl6ZV9kdXAiLCJjb3VudCIsImRlbGV0ZSIsImRlbGV0ZV9wcmVmaXgiLCJkZWxldGVfc3VmZml4IiwiZG93bmNhc2UiLCJlYWNoX2xpbmUiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImVuZF93aXRoPyIsImdzdWIiLCJwYXR0ZXJuIiwiaGFzaCIsImhleCIsInRvX2kiLCIxNiIsImluY2x1ZGU/IiwiaW5kZXgiLCJpbnNwZWN0IiwiaW50ZXJuIiwibGluZXMiLCJlIiwiYmxvY2siLCJ0b19hIiwibHN0cmlwIiwiYXNjaWlfb25seT8iLCJtYXRjaCIsIiRyZXRfb3JfMSIsInBvcyIsIm1hdGNoPyIsIiRyZXRfb3JfMiIsIm5leHQiLCJvY3QiLCJvcmQiLCJwYXJ0aXRpb24iLCJyZXZlcnNlIiwicmluZGV4IiwicnBhcnRpdGlvbiIsInJzdHJpcCIsInNjYW4iLCJjYXB0dXJlcyIsInNwbGl0IiwibGltaXQiLCIkcmV0X29yXzMiLCIkOyIsInNxdWVlemUiLCJzdGFydF93aXRoPyIsInN0cmlwIiwic3ViIiwic3VtIiwic3dhcGNhc2UiLCJ0b19mIiwiMTAiLCJ0b19wcm9jIiwibWV0aG9kX25hbWUiLCJwcm9jIiwidHIiLCJ0cl9zIiwidXBjYXNlIiwidXB0byIsInN0b3AiLCJleGNsIiwic3VjYyIsImVzY2FwZSIsImluc3RhbmNlX3ZhcmlhYmxlcyIsIl9sb2FkIiwidW5pY29kZV9ub3JtYWxpemUiLCJmb3JtIiwidW5pY29kZV9ub3JtYWxpemVkPyIsInVucGFjayIsInVucGFjazEiLCJmcmVlemUiLCItQCIsImZyb3plbj8iLCJwcmlzdGluZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRUEsTUFBQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FBQTtBQUFBLE1BQ0FBLFNBQUFBLENBQVEsZ0JBQVJBLENBREE7QUFBQSxFQUdBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FBQTtBQUFBO0FBR0Ysd0JBQTBCQyxJQUFLOztBQUUvQix3QkFBMEJBLElBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQWJFO0FBQUE7QUFlQUMsSUFBQUEsMEJBQUFBLG1CQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxlQUFEO0FBREZBLElBQUFBLENBQUFBLDhCQUFBQSxDQWZBO0FBQUEsSUFtQkEsaUJBQU0sV0FBTixFQUFnQixRQUFoQixDQW5CQTtBQUFBLElBcUJBQyxVQUFJRixJQUFKRSxrQkFBQUEsd0JBQUFBLHVCQUFxQixJQUFyQkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxvQkFBQUMsZUFBQUEsQ0FBZ0JDLE1BQU0sd0JBQVEsUUFBOUJEO0FBREZELElBQUFBLENBQUFBLG1DQUFBQSxDQXJCQTtBQUFBLElBeUJBRyxVQUFJTCxJQUFKSyxVQUFBQSxnQkFBQUEsU0FoQ0YsRUFnQ0VBO0FBQUFBLE1BQUFBOztBQUFBQTtBQWhDRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQWdDZSxNQUFBLGtCQWhDZjtBQUFBO0FBa0NBO0FBQ0E7QUFDQSw0QkFBOEIsc0JBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBeUNDLE1BQUEsQ0FBQyxHQUFELENBQUFBLGNBQUFBLEVBQWlCLFVBQUNDLElBQUQsQ0FBakJELENBQXdCO0FBQ2pFO0FBQ0EsSUEzQ0E7QUFnQ0VELElBQUFBLENBQUFBLDRCQUFBQSxDQXpCQTtBQUFBO0FBNENBQyxJQUFBQSw4QkFBQUEsdUJBQUFBLHNCQW5ERixFQW1EZ0IsRUFuRGhCLEVBbURFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFuREY7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUFBQSxNQUFBLHlDQUFBO0FBQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxDQUFBO0FBQUE7QUFtRGlCLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUEsQ0FuRGpCO0FBQUE7QUFtRGtDLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxhQUFVO0FBQVYsTUFBQSxDQW5EbEM7QUFBQTtBQW1EaUQsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLGFBQVU7QUFBVixNQUFBLENBbkRqRDtBQUFBLE1BQUEsT0FBQSxHQUFBO0FBbURFQSxJQUFBQSxDQUFBQSxtQ0FBQUEsQ0E1Q0E7QUFBQTtBQStDQUUsSUFBQUEscUJBQUFBLHFCQUFBQSxTQUFNLElBQU5BO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLElBQUEsUUFBRyxxQkFBQUMsUUFBQUEsQ0FBVUMsSUFBVkQsQ0FBSCxDQUFBO0FBQUEsUUFDRSxPQUFBRSxVQUFBQSxVQUFBQSxHQUFPWCxhQUFNLFVBQUNVLElBQUQsRUFBYkM7QUFERixNQUFBO0FBQUEsUUFHRSxXQUFBQSxRQUFBQSxDQUFPWCxNQUFNVSxJQUFiQztBQUhGLE1BQUE7QUFERkgsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBL0NBO0FBQUE7QUF1REFJLElBQUFBLHFCQUFBQSxjQUFBQSxTQUFNLEtBQU5BO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGLGdDQUFrQyx1QkFBUTs7QUFFMUM7QUFDQSxZQUFVQyxPQUFBQSxDQUFNLCtCQUFlLG1CQUFyQkE7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFVQSxPQUFBQSxDQUFNLDRCQUFZLHNEQUFsQkE7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBbkNFRCxJQUFBQSxDQUFBQSx5QkFBQUEsQ0F2REE7QUFBQTtBQTZGQUUsSUFBQUEscUJBQUFBLGtCQUFBQSxTQUFNLEtBQU5BO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLFFBQVMsV0FBYUEsS0FBTSxFQUFJLHNCQUFPLFdBQXZDO0FBQUE7QUFHSiw4REFBZ0VmLElBQUs7QUFDckUsOERBQWdFZSxLQUFNO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFUSTtBQURGRCxJQUFBQSxDQUFBQSw2QkFBQUEsQ0E3RkE7QUFBQTtBQTBHQUUsSUFBQUEsdUJBQUFBLHNCQUFBQSxTQUFRLEtBQVJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLElBQUEsUUFBR0QsS0FBQUUsZ0JBQUFBLENBQWtCLFFBQWxCQSxDQUFILENBQUE7QUFBQTtBQUNFLFFBQUFGLFFBQVFBLEtBQUFHLFFBQUFBLENBQUFBLENBQUFDLE1BQUFBLENBQUFBLENBQVI7QUFBQSxRQUVBLE9BQUMsMENBQUQsQ0FGQTtBQURGLE1BQUE7QUFBQTtBQU1KLGtCQUFvQkosS0FBQUMsUUFBQUEsQ0FBVWhCLElBQVZnQixDQUFlOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRJLE1BQUE7QUFERkEsSUFBQUEsQ0FBQUEsaUNBQUFBLENBMUdBO0FBQUE7QUE2SEFJLElBQUFBLHNCQUFBQSxtQkFBQUEsU0FBTyxLQUFQQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWlCTCxLQUFBSyxPQUFBQSxDQUFTcEIsSUFBVG9CLENBQWM7QUFDL0I7QUFDQTtBQUNBO0FBVEVBLElBQUFBLENBQUFBLDhCQUFBQSxDQTdIQTtBQUFBLElBeUlBLGlCQUFNLE1BQU4sRUFBVyxJQUFYLENBeklBO0FBQUEsSUEwSUEsaUJBQU0sS0FBTixFQUFVLElBQVYsQ0ExSUE7QUFBQTtBQTRJQUMsSUFBQUEsc0JBQUFBLHVCQUFBQSxTQUFPLEtBQVBBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0EsWUFBVVIsT0FBQUEsQ0FBTSwyQkFBVyw2QkFBakJBLENBQStDO0FBQ3pEOztBQUVBLGFBQWVFLEtBQUFNLE9BQUFBLENBQVNyQixJQUFUcUIsQ0FBYztBQUM3QjtBQVBFQSxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0E1SUE7QUFBQTtBQXNKQUMsSUFBQUEsc0JBQUFBLGdCQUFBQSxTQUFPLEtBQUQsRUFBUSxNQUFkQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE3SkYsTUFBQTtBQUFBO0FBK0pBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBMEMsdUJBQVE7QUFDbEQsMENBQTRDLHVCQUFROztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxjQUFZVCxPQUFBQSxDQUFNLHlCQUFOQTtBQUNaO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLFVBQVlVLENBQUFBLGNBQUssR0FBTEE7QUFDWjtBQUNBOztBQUVBLFFBQVVBLENBQUFBLGNBQUsseUJBQUFsQixLQUFBQSxDQUFlLE9BQVMsS0FBeEJBLENBQUxrQjs7QUFFVjtBQUNBO0FBQ0E7O0FBRUEsb0NBQXNDLHVCQUFROztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLGdDQUFrQyx1QkFBUTs7QUFFMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBb0MsdUJBQVE7O0FBRTVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQTVQQTtBQTZKRUQsSUFBQUEsQ0FBQUEsNEJBQUFBLENBdEpBO0FBQUEsSUF3UEEsaUJBQU0sV0FBTixFQUFnQixJQUFoQixDQXhQQTtBQUFBO0FBMFBBRSxJQUFBQSxxQkFBQUEsZUFBQUEsYUFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxDQUFDLFdBQWF4QixJQUFLLENBQW5CLENBQUF5QixnQkFBQUEsQ0FBcUMsUUFBckNBO0FBREZELElBQUFBLENBQUFBLDBCQUFBQSxDQTFQQTtBQUFBO0FBOFBBRSxJQUFBQSw4QkFBQUEsd0JBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLHdFQUFEO0FBREZBLElBQUFBLENBQUFBLG1DQUFBQSxDQTlQQTtBQUFBO0FBa1FBQyxJQUFBQSwyQkFBQUEscUJBQUFBLG1CQUFZLEtBQVpBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUEsSUFBQSxRQUFrQlosS0FBQUUsZ0JBQUFBLENBQWtCLFFBQWxCQSxDQUFsQixDQUFBO0FBQUEsTUFBQTtBQUFBLFFBQUEsT0FBTztBQUFQLE1BQUEsQ0FBQTtBQUFBLE1BQ0FGLFFBQVEsQ0FBQyxrQkFBb0Isc0JBQU8sV0FBNUIsQ0FBQUksTUFBQUEsQ0FBQUEsQ0FEUjtBQUFBO0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBUkk7QUFBQSxNQVNBLE9BQUFuQixJQUFBZ0IsUUFBQUEsQ0FBU0QsS0FBVEMsQ0FUQTtBQURGVyxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FsUUE7QUFBQTtBQStRQUMsSUFBQUEsNEJBQUFBLDBCQUFBQSxTQUFhLEtBQWJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGLG9CQUFrQkQsU0FBQUEsQ0FBUVosS0FBUlksQ0FBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSRUMsSUFBQUEsQ0FBQUEscUNBQUFBLENBL1FBO0FBQUE7QUEwUkFDLElBQUFBLDBCQUFBQSxvQkFBQUEsa0JBQVcsS0FBRCxFQUFRLE1BQWxCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFqU0Y7QUFpU29CLE1BQUE7QUFBQSxNQUFBLFdBQVMsR0FBVDtBQUFBLE1BQUEsQ0FqU3BCO0FBQUEsTUFrU0lDLFFBQVUsV0FBYUEsS0FBTSxFQUFJLHVCQUFRLFdBbFM3QztBQUFBLE1BbVNJQyxTQUFTLENBQUMsV0FBYUEsTUFBTyxFQUFJLHNCQUFPLFdBQWhDLENBQUFaLE1BQUFBLENBQUFBLENBblNiO0FBQUEsTUFxU0ksSUFBQSxRQUFHWSxNQUFBQyxXQUFBQSxDQUFBQSxDQUFILENBQUE7QUFBQSxZQUNFbkIsT0FBQUEsQ0FBTSwrQkFBZSxvQkFBckJBLENBREYsQ0FyU0o7QUFBQSxNQXlTSSxJQUFBLFFBQWdCLG9CQUFoQixDQUFBO0FBQUEsUUFBQSxPQUFPYixJQUFQLENBelNKO0FBQUE7QUE0U0EsMkJBQXlCaUMsT0FBQUEsQ0FBT0MsV0FBQ3BCLFNBQUFnQixLQUFBaEIsRUFBUyxXQUFUQSxDQUFEb0IsRUFBMEJDLENBQTFCRCxDQUFERSxNQUFBQSxDQUFBQSxHQUFvQ0wsTUFBMUNFLENBQWlEO0FBQzFFLDJCQUF5QkksT0FBQUEsQ0FBT0gsV0FBQ3BCLFNBQUFnQixLQUFBaEIsRUFBUyxXQUFUQSxDQUFEb0IsRUFBMEJDLENBQTFCRCxDQUFESSxPQUFBQSxDQUFBQSxHQUFxQ1AsTUFBM0NNLENBQWtEOztBQUUzRTtBQUNBLElBaFRBO0FBaVNFUixJQUFBQSxDQUFBQSxnQ0FBQUEsQ0ExUkE7QUFBQTtBQTRTQVUsSUFBQUEseUJBQUFBLG1CQUFBQSxpQkFBVSxTQUFWQTtBQUFBQSxNQUFBQTtBQUFBQTs7QUFBQUE7QUFuVEY7QUFtVFksTUFBQTtBQUFBLE1BQUEsY0FBWUMsV0FBWjtBQUFBLE1BQUEsQ0FuVFo7QUFBQSxNQW9USSxJQUFBLFFBQWdCLHNDQUFoQixDQUFBO0FBQUEsUUFBQSxPQUFPeEMsSUFBUCxDQXBUSjtBQUFBLE1Bc1RJeUMsWUFBWSxvQkFBQUMsZUFBQUEsQ0FBZ0JELFdBQVcsd0JBQVEsUUFBbkNDLENBQUF2QixNQUFBQSxDQUFBQSxDQXRUaEI7QUFBQTtBQXlUQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBNVVBO0FBQUEsTUE4VUksT0FBQW5CLElBOVVKO0FBbVRFdUMsSUFBQUEsQ0FBQUEsK0JBQUFBLENBNVNBO0FBQUE7QUEwVUFJLElBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFiRUEsSUFBQUEsQ0FBQUEsNkJBQUFBLENBMVVBO0FBQUE7QUEwVkFDLElBQUFBLHVCQUFBQSxpQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxjQUFEO0FBREZBLElBQUFBLENBQUFBLDRCQUFBQSxDQTFWQTtBQUFBO0FBOFZBQyxJQUFBQSx5QkFBQUEsbUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBQyxPQUFRLGdCQUFSO0FBQUEsTUFDQUEsSUFBQUMsd0JBQUFBLENBQTRCL0MsSUFBNUIrQyxDQURBO0FBQUEsTUFFQUQsSUFBQUUsa0JBQUFBLENBQXNCaEQsSUFBdEJnRCxDQUZBO0FBQUEsTUFHQSxPQUFBRixJQUhBO0FBREZELElBQUFBLENBQUFBLDhCQUFBQSxDQTlWQTtBQUFBO0FBcVdBSSxJQUFBQSx1QkFBQUEsaUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFILE9BQVEsZ0JBQVI7QUFBQSxNQUNBQSxJQUFBSSxnQkFBQUEsQ0FBb0JsRCxJQUFwQmtELENBREE7QUFBQSxNQUVBLE9BQUFKLElBRkE7QUFERkcsSUFBQUEsQ0FBQUEsNEJBQUFBLENBcldBO0FBQUE7QUEyV0FFLElBQUFBLHlCQUFBQSxtQkFBQUEsaUJBbFhGLEVBa1hFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFsWEY7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUFrWFksTUFBQSxrQkFsWFo7QUFBQTtBQW9YQTtBQUNBLFlBQVV0QyxPQUFBQSxDQUFNLCtCQUFlLHFEQUFyQkE7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQTVYQTtBQWtYRXNDLElBQUFBLENBQUFBLCtCQUFBQSxDQTNXQTtBQUFBO0FBd1hBQyxJQUFBQSwwQkFBQUEsb0JBQUFBLFNBL1hGLEVBK1hFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUEvWEY7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUErWGEsTUFBQSxrQkEvWGI7QUFBQTtBQWlZQTtBQUNBLFlBQVV2QyxPQUFBQSxDQUFNLCtCQUFlLHFEQUFyQkE7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQXpZQTtBQStYRXVDLElBQUFBLENBQUFBLGdDQUFBQSxDQXhYQTtBQUFBO0FBcVlBQyxJQUFBQSxpQ0FBQUEsMkJBQUFBLHlCQUFrQixNQUFsQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQSxvQ0FBc0Msc0JBQU87QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEVBLElBQUFBLENBQUFBLHNDQUFBQSxDQXJZQTtBQUFBO0FBbVpBQyxJQUFBQSxpQ0FBQUEsMkJBQUFBLHlCQUFrQixNQUFsQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQSxvQ0FBc0Msc0JBQU87QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEVBLElBQUFBLENBQUFBLHNDQUFBQSxDQW5aQTtBQUFBO0FBaWFBQyxJQUFBQSw0QkFBQUEsc0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLCtCQUFEO0FBREZBLElBQUFBLENBQUFBLGlDQUFBQSxDQWphQTtBQUFBO0FBcWFBQyxJQUFBQSw2QkFBQUEsdUJBQUFBLHFCQUFjLFNBQWRBO0FBQUFBLE1BQUFBO0FBQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQTVhRjtBQTRhZ0MsTUFBQSwyQ0E1YWhDO0FBQUE7QUE0YWdCLE1BQUE7QUFBQSxNQUFBLGNBQVloQixXQUFaO0FBQUEsTUFBQSxDQTVhaEI7QUFBQSxNQTZhSSxJQUE2Q2lCLGVBQTdDO0FBQUEsTUFBQTtBQUFBLFFBQUEsV0FBT0MsVUFBQUEsQ0FBUyxhQUFZakIsU0FBckJpQjtBQUFQLE1BQUEsQ0E3YUo7QUFBQTtBQWdiQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQTBDLHNCQUFPOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFtQm5CLE9BQUFBLENBQU1FLFNBQU5GLENBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBamRBO0FBQUEsTUFtZEksT0FBQXZDLElBbmRKO0FBNGFFd0QsSUFBQUEsQ0FBQUEsbUNBQUFBLENBcmFBO0FBQUE7QUErY0F4QixJQUFBQSwwQkFBQUEsd0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsaUJBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsbUNBQUFBLENBL2NBO0FBQUE7QUFtZEEyQixJQUFBQSw2QkFBQUEsMkJBQUFBLFNBMWRGLEVBMGRFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUExZEY7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUEwZGdCLE1BQUEsc0JBMWRoQjtBQUFBO0FBNGRBO0FBQ0EsNkNBQStDLHNCQUFPOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFwZUE7QUFBQSxNQXNlSSxPQUFBLEtBdGVKO0FBMGRFQSxJQUFBQSxDQUFBQSx1Q0FBQUEsQ0FuZEE7QUFBQSxJQWtlQSxpQkFBTSxRQUFOLEVBQWEsS0FBYixDQWxlQTtBQUFBO0FBb2VBQyxJQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFTLE9BQUQsRUFBVSxXQUFsQkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBM2VGO0FBMmU2QyxNQUFBLHNDQTNlN0M7QUFBQSxNQUFBO0FBQUE7QUE2ZUE7QUFDQSxtQkFBaUJGLFVBQUFBLENBQVMsUUFBT0csT0FBaEJILENBQXdCO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUF3QyxzQkFBTztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVluQyxDQUFBQSxjQUFLLEdBQUxBO0FBQ1o7QUFDQTtBQUNBOztBQUVBLHFCQUF1Qix5QkFBQWxCLEtBQUFBLENBQWUsU0FBVyxLQUExQkEsQ0FBaUM7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUEyQixDQUFDLFdBQUQsQ0FBQWlCLE9BQUFBLENBQWUsUUFBZkEsQ0FBQUgsTUFBQUEsQ0FBQUEsQ0FBK0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esa0RBQW9ELHNCQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQVFJLENBQUFBLGNBQU0sVUFBTkE7QUFDUjtBQUNBLElBbGpCQTtBQTJlRXFDLElBQUFBLENBQUFBLDhCQUFBQSxDQXBlQTtBQUFBO0FBOGlCQUUsSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxlQUFEO0FBREZBLElBQUFBLENBQUFBLDZCQUFBQSxDQTlpQkE7QUFBQTtBQWtqQkFDLElBQUFBLHVCQUFBQSxpQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsV0FBQUMsTUFBQUEsQ0FBS0MsRUFBTEQ7QUFERkQsSUFBQUEsQ0FBQUEsNEJBQUFBLENBbGpCQTtBQUFBO0FBc2pCQUcsSUFBQUEsNEJBQUFBLDBCQUFBQSxTQUFhLEtBQWJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0Esa0NBQW9DLHNCQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQU5FQSxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0F0akJBO0FBQUE7QUErakJBQyxJQUFBQSx5QkFBQUEsbUJBQUFBLGlCQUFVLE1BQUQsRUFBUyxNQUFsQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBdGtCRixNQUFBO0FBQUE7QUF3a0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBc0MsdUJBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQWM1QyxDQUFBQSxjQUFLLEdBQUxBLENBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFjQSxDQUFBQSxjQUFLLHlCQUFBbEIsS0FBQUEsQ0FBZSxPQUFTLEtBQXhCQSxDQUFMa0I7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBc0Msc0JBQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFsbkJBO0FBc2tCRTRDLElBQUFBLENBQUFBLCtCQUFBQSxDQS9qQkE7QUFBQTtBQThtQkFDLElBQUFBLDJCQUFBQSxxQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpCRUEsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBOW1CQTtBQUFBO0FBMG9CQUMsSUFBQUEsMEJBQUFBLG9CQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxlQUFEO0FBREZBLElBQUFBLENBQUFBLCtCQUFBQSxDQTFvQkE7QUFBQTtBQThvQkFDLElBQUFBLHlCQUFBQSxtQkFBQUEsaUJBQVUsU0FBVkE7QUFBQUEsTUFBQUE7QUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBcnBCRjtBQXFwQjRCLE1BQUEsdUNBcnBCNUI7QUFBQTtBQXFwQlksTUFBQTtBQUFBLE1BQUEsY0FBWTlCLFdBQVo7QUFBQSxNQUFBLENBcnBCWjtBQUFBLE1Bc3BCSStCLElBQUlmLFVBQUFBLGFBQUFBLEVBQUFBLENBQVVmLFNBQVZlLENBQUFBLEVBQXNCZ0IsZ0JBQXRCaEIsQ0F0cEJSO0FBQUEsTUF1cEJJLElBQUEsUUFBQWdCLEtBQUEsQ0FBQTtBQUFBLFFBQVEsT0FBQXhFO0FBQVIsTUFBQTtBQUFBLFFBQWUsT0FBQXVFLENBQUFFLE1BQUFBLENBQUFBO0FBQWYsTUFBQSxDQXZwQko7QUFxcEJFSCxJQUFBQSxDQUFBQSwrQkFBQUEsQ0E5b0JBO0FBQUE7QUFtcEJBckMsSUFBQUEseUJBQUFBLG1CQUFBQSxpQkFBVSxLQUFELEVBQVEsTUFBakJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQTFwQkY7QUEwcEJtQixNQUFBO0FBQUEsTUFBQSxXQUFTLEdBQVQ7QUFBQSxNQUFBLENBMXBCbkI7QUFBQSxNQTJwQklILFFBQVUsV0FBYUEsS0FBTSxFQUFJLHVCQUFRLFdBM3BCN0M7QUFBQSxNQTRwQklDLFNBQVMsQ0FBQyxXQUFhQSxNQUFPLEVBQUksc0JBQU8sV0FBaEMsQ0FBQVosTUFBQUEsQ0FBQUEsQ0E1cEJiO0FBQUEsTUE4cEJJLElBQUEsUUFBR1ksTUFBQUMsV0FBQUEsQ0FBQUEsQ0FBSCxDQUFBO0FBQUEsWUFDRW5CLE9BQUFBLENBQU0sK0JBQWUsb0JBQXJCQSxDQURGLENBOXBCSjtBQUFBLE1Ba3FCSSxJQUFBLFFBQWdCLG9CQUFoQixDQUFBO0FBQUEsUUFBQSxPQUFPYixJQUFQLENBbHFCSjtBQUFBO0FBcXFCQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBL3FCQTtBQTBwQkVpQyxJQUFBQSxDQUFBQSwrQkFBQUEsQ0FucEJBO0FBQUE7QUEycUJBeUMsSUFBQUEsMEJBQUFBLG9CQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyx3QkFBRDtBQURGQSxJQUFBQSxDQUFBQSwrQkFBQUEsQ0EzcUJBO0FBQUE7QUErcUJBQyxJQUFBQSwrQkFBQUEsNkJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUdGO0FBQ0E7QUFDQTtBQUxFQSxJQUFBQSxDQUFBQSx3Q0FBQUEsQ0EvcUJBO0FBQUE7QUF1ckJBQyxJQUFBQSx5QkFBQUEsbUJBQUFBLGlCQUFVLE9BQUQsRUFBVSxHQUFuQkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBOXJCRjtBQThyQnNDLE1BQUEsdUNBOXJCdEM7QUFBQSxNQUFBO0FBQUEsTUErckJJLElBQUEsUUFBRyxhQUFBLElBQUEsUUEvckJQQyxDQUFBQSxZQStyQk8sc0JBQUFwRSxRQUFBQSxDQUFXb0QsT0FBWHBELENBL3JCUG9FLENBK3JCTyxDQUFBO0FBQUEsUUEvckJQLE9BQUE7QUErckJPLE1BQUE7QUFBQSxRQUFzQixPQUFBaEIsT0FBQTVDLGdCQUFBQSxDQUFvQixRQUFwQkE7QUFBdEIsTUFBQSxDQUFBLGtCQUFILENBQUE7QUFBQSxRQUNFNEMsVUFBVSxzQkFBQXhELEtBQUFBLENBQVd3RCxPQUFBM0MsUUFBQUEsQ0FBQUEsQ0FBWGIsQ0FEWixDQS9yQko7QUFBQSxNQW1zQkksSUFBQSxRQUFPLHNCQUFBSSxRQUFBQSxDQUFXb0QsT0FBWHBELENBQVAsQ0FBQTtBQUFBLE1BQUE7QUFBQSxZQUNFSSxPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSxzQkFBQSxHQUFBLENBQXVCZ0QsT0FBQS9ELE9BQUFBLENBQUFBLENBQXZCLENBQUEsR0FBQSxvQkFBakJlO0FBREYsTUFBQSxDQW5zQko7QUFBQSxNQXVzQkksT0FBQStELE1BQUFmLE9BQUFlLFNBQUFBLEVBQUFBLENBQWM1RSxNQUFNOEUsR0FBcEJGLENBQUFBLEVBQTBCSixnQkFBMUJJLENBdnNCSjtBQThyQkVBLElBQUFBLENBQUFBLCtCQUFBQSxDQXZyQkE7QUFBQTtBQW1zQkFHLElBQUFBLDBCQUFBQSx3QkFBQUEsU0FBVyxPQUFELEVBQVUsR0FBcEJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQTFzQkYsTUFBQTtBQUFBLE1BMnNCSSxJQUFBLFFBQUcsYUFBQSxJQUFBLFFBM3NCUEMsQ0FBQUEsWUEyc0JPLHNCQUFBdkUsUUFBQUEsQ0FBV29ELE9BQVhwRCxDQTNzQlB1RSxDQTJzQk8sQ0FBQTtBQUFBLFFBM3NCUCxPQUFBO0FBMnNCTyxNQUFBO0FBQUEsUUFBc0IsT0FBQW5CLE9BQUE1QyxnQkFBQUEsQ0FBb0IsUUFBcEJBO0FBQXRCLE1BQUEsQ0FBQSxrQkFBSCxDQUFBO0FBQUEsUUFDRTRDLFVBQVUsc0JBQUF4RCxLQUFBQSxDQUFXd0QsT0FBQTNDLFFBQUFBLENBQUFBLENBQVhiLENBRFosQ0Ezc0JKO0FBQUEsTUErc0JJLElBQUEsUUFBTyxzQkFBQUksUUFBQUEsQ0FBV29ELE9BQVhwRCxDQUFQLENBQUE7QUFBQSxNQUFBO0FBQUEsWUFDRUksT0FBQUEsQ0FBTSwyQkFBVyxFQUFBLEdBQUEsc0JBQUEsR0FBQSxDQUF1QmdELE9BQUEvRCxPQUFBQSxDQUFBQSxDQUF2QixDQUFBLEdBQUEsb0JBQWpCZTtBQURGLE1BQUEsQ0Evc0JKO0FBQUEsTUFtdEJJLE9BQUFnRCxPQUFBa0IsV0FBQUEsQ0FBZS9FLE1BQU04RSxHQUFyQkMsQ0FudEJKO0FBMHNCRUEsSUFBQUEsQ0FBQUEsb0NBQUFBLENBbnNCQTtBQUFBO0FBK3NCQUUsSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkVFQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0Evc0JBO0FBQUE7QUFxeEJBQyxJQUFBQSx1QkFBQUEsaUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQXhDRUEsSUFBQUEsQ0FBQUEsNEJBQUFBLENBcnhCQTtBQUFBO0FBZzBCQUMsSUFBQUEsdUJBQUFBLGlCQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJFQSxJQUFBQSxDQUFBQSw0QkFBQUEsQ0FoMEJBO0FBQUE7QUEyMEJBQyxJQUFBQSw2QkFBQUEsdUJBQUFBLHFCQUFjLEdBQWRBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFZLHlCQUFBL0UsS0FBQUEsQ0FBZSxLQUFPLENBQXRCQSxDQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUFnQyxzQkFBTztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzQkUrRSxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0EzMEJBO0FBQUE7QUF5MkJBQyxJQUFBQSwyQkFBQUEscUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLGlDQUFEO0FBREZBLElBQUFBLENBQUFBLGdDQUFBQSxDQXoyQkE7QUFBQTtBQTYyQkFDLElBQUFBLDBCQUFBQSxvQkFBQUEsa0JBQVcsTUFBRCxFQUFTLE1BQW5CQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFwM0JGLE1BQUE7QUFBQTtBQXMzQkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQXNDLHVCQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVkvRCxDQUFBQSxjQUFLLEdBQUxBO0FBQ1o7QUFDQTtBQUNBLFVBQVkseUJBQUFsQixLQUFBQSxDQUFlLEdBQUssQ0FBcEJBLENBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG9DQUFzQyxzQkFBTztBQUM3QztBQUNBOztBQUVBO0FBQ0EsSUE1NUJBO0FBbzNCRWlGLElBQUFBLENBQUFBLGdDQUFBQSxDQTcyQkE7QUFBQTtBQXc1QkFqRCxJQUFBQSx5QkFBQUEsbUJBQUFBLGlCQUFVLEtBQUQsRUFBUSxNQUFqQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBLzVCRjtBQSs1Qm1CLE1BQUE7QUFBQSxNQUFBLFdBQVMsR0FBVDtBQUFBLE1BQUEsQ0EvNUJuQjtBQUFBLE1BZzZCSVAsUUFBVSxXQUFhQSxLQUFNLEVBQUksdUJBQVEsV0FoNkI3QztBQUFBLE1BaTZCSUMsU0FBUyxDQUFDLFdBQWFBLE1BQU8sRUFBSSxzQkFBTyxXQUFoQyxDQUFBWixNQUFBQSxDQUFBQSxDQWo2QmI7QUFBQSxNQW02QkksSUFBQSxRQUFHWSxNQUFBQyxXQUFBQSxDQUFBQSxDQUFILENBQUE7QUFBQSxZQUNFbkIsT0FBQUEsQ0FBTSwrQkFBZSxvQkFBckJBLENBREYsQ0FuNkJKO0FBQUEsTUF1NkJJLElBQUEsUUFBZ0Isb0JBQWhCLENBQUE7QUFBQSxRQUFBLE9BQU9iLElBQVAsQ0F2NkJKO0FBQUE7QUEwNkJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFoN0JBO0FBKzVCRXFDLElBQUFBLENBQUFBLCtCQUFBQSxDQXg1QkE7QUFBQTtBQTQ2QkFrRCxJQUFBQSw4QkFBQUEsd0JBQUFBLHNCQUFlLEdBQWZBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVkseUJBQUFsRixLQUFBQSxDQUFlLEdBQUssQ0FBcEJBLENBQXVCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUFnQyxzQkFBTztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2Q0VrRixJQUFBQSxDQUFBQSxtQ0FBQUEsQ0E1NkJBO0FBQUE7QUFzOUJBQyxJQUFBQSwwQkFBQUEsb0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLGdDQUFEO0FBREZBLElBQUFBLENBQUFBLCtCQUFBQSxDQXQ5QkE7QUFBQTtBQTA5QkFDLElBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBQVMsT0FBVEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBaitCRjtBQWkrQm9CLE1BQUEsc0NBaitCcEI7QUFBQTtBQW0rQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUF3QyxzQkFBTztBQUMvQztBQUNBOztBQUVBO0FBQ0EscUJBQXVCLHlCQUFBcEYsS0FBQUEsQ0FBZSxTQUFXLEtBQTFCQSxDQUFpQztBQUN4RDtBQUNBLGtFQUFvRSxDQUFDLFVBQUQsQ0FBQXFGLFVBQUFBLENBQUFBLENBQXNCO0FBQzFGO0FBQ0EsaUVBQW1FLENBQUMsVUFBRCxDQUFBQSxVQUFBQSxDQUFBQSxDQUFzQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQVFuRSxDQUFBQSxjQUFNLFVBQU5BOztBQUVSO0FBQ0EsSUE3L0JBO0FBaStCRWtFLElBQUFBLENBQUFBLDZCQUFBQSxDQTE5QkE7QUFBQSxJQXkvQkEsaUJBQU0sT0FBTixFQUFZLElBQVosQ0F6L0JBO0FBQUE7QUEyL0JBRSxJQUFBQSx5QkFBQUEsbUJBQUFBLGlCQUFVLE9BQUQsRUFBc0IsS0FBL0JBO0FBQUFBLE1BQUFBO0FBQUFBOztBQUFBQTtBQWxnQ0YsTUFBQTtBQUFBLE1BQUE7QUFBQTtBQW9nQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFrQixvQkFBQWpELGVBQUFBLENBQWdCa0QsT0FBTyx5QkFBUyxRQUFoQ2xELENBQXlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQW9CLGFBQUEsSUFBQSxRQWxoQ3BCbUQsQ0FBQUEsWUFraENvQkMsV0FsaENwQkQsQ0FraENvQixDQUFBO0FBQUEsUUFsaENwQixPQUFBO0FBa2hDb0IsTUFBQTtBQUFBLFFBQU0sT0FBQTtBQUFOLE1BQUEsQ0FBQSxrQkFBVTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUF3QyxzQkFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFsbUNBO0FBa2dDRUYsSUFBQUEsQ0FBQUEsK0JBQUFBLENBMy9CQTtBQUFBO0FBOGxDQUksSUFBQUEsMkJBQUFBLHFCQUFBQSxtQkFybUNGLEVBcW1DRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBcm1DRjtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQXFtQ2MsTUFBQSxrQkFybUNkO0FBQUE7QUF1bUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQS9tQ0E7QUFxbUNFQSxJQUFBQSxDQUFBQSxpQ0FBQUEsQ0E5bENBO0FBQUE7QUEybUNBQyxJQUFBQSwrQkFBQUEsNkJBQUFBLFNBbG5DRixFQWtuQ0VBO0FBQUFBLE1BQUFBOztBQUFBQTtBQWxuQ0Y7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUFrbkNrQixNQUFBLHNCQWxuQ2xCO0FBQUE7QUFvbkNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBY3pFLENBQUFBLGNBQUsseUJBQUFsQixLQUFBQSxDQUFlLFFBQVUsS0FBekJBLENBQUxrQixDQUFzQztBQUNwRDtBQUNBO0FBQ0EsWUFBY0EsQ0FBQUEsY0FBSyxHQUFMQTtBQUNkO0FBQ0E7QUFDQSwrQ0FBaUQsc0JBQU87O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQXpvQ0E7QUFrbkNFeUUsSUFBQUEsQ0FBQUEseUNBQUFBLENBM21DQTtBQUFBO0FBcW9DQUMsSUFBQUEseUJBQUFBLG1CQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxvREFBRDtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0Fyb0NBO0FBQUE7QUF5b0NBQyxJQUFBQSx1QkFBQUEsaUJBQUFBLGVBQVEsT0FBRCxFQUFVLFdBQWpCQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFocENGO0FBZ3BDNEMsTUFBQSxxQ0FocEM1QztBQUFBLE1BQUE7QUFBQTtBQWtwQ0E7QUFDQSxzQ0FBd0Msc0JBQU87QUFDL0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVUzRSxDQUFBQSxjQUFLLEdBQUxBO0FBQ1Y7QUFDQTtBQUNBLFFBQVUseUJBQUFsQixLQUFBQSxDQUFlLFNBQVcsS0FBMUJBOztBQUVWOztBQUVBO0FBQ0EsZ0JBQWNRLE9BQUFBLENBQU0sK0JBQWUscUNBQXJCQTtBQUNkO0FBQ0E7O0FBRUE7O0FBRUEsZ0RBQWtELENBQUMsV0FBRCxDQUFBUyxPQUFBQSxDQUFlLFFBQWZBLENBQUFILE1BQUFBLENBQUFBLENBQStCOztBQUVqRjs7QUFFQSxnREFBa0Qsc0JBQU87O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQXRzQ0E7QUFncENFK0UsSUFBQUEsQ0FBQUEsNkJBQUFBLENBem9DQTtBQUFBLElBa3NDQSxpQkFBTSxNQUFOLEVBQVcsTUFBWCxDQWxzQ0E7QUFBQTtBQW9zQ0FDLElBQUFBLHVCQUFBQSxpQkFBQUEsZUFBUSxDQUFSQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUEzc0NGO0FBMnNDVSxNQUFBO0FBQUEsTUFBQSxNQUFJbEMsRUFBSjtBQUFBLE1BQUEsQ0Ezc0NWO0FBQUE7QUE2c0NBLHdCQUEwQix1QkFBUTs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQTV0Q0E7QUEyc0NFa0MsSUFBQUEsQ0FBQUEsNkJBQUFBLENBcHNDQTtBQUFBO0FBd3RDQUMsSUFBQUEsNEJBQUFBLHNCQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxhQUFlcEcsSUFBQUYsT0FBQUEsQ0FBQUEsQ0FBQU8sS0FBQUEsQ0FBZ0IsR0FBaEJBLENBQXFCO0FBQ3BDO0FBWEUrRixJQUFBQSxDQUFBQSxpQ0FBQUEsQ0F4dENBO0FBQUE7QUFzdUNBQyxJQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkRUEsSUFBQUEsQ0FBQUEsNkJBQUFBLENBdHVDQTtBQUFBO0FBdXZDQXJDLElBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBQVMsSUFBVEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBOXZDRjtBQTh2Q1csTUFBQTtBQUFBLE1BQUEsU0FBT3NDLEVBQVA7QUFBQSxNQUFBLENBOXZDWDtBQUFBO0FBZ3dDQTtBQUNBO0FBQ0EsbUNBQXFDLHVCQUFROztBQUU3QztBQUNBLFlBQVV6RixPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSxnQkFBQSxHQUFBLENBQWtCLEtBQWxCLENBQXJCQTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBdHpDQTtBQTh2Q0VtRCxJQUFBQSxDQUFBQSw4QkFBQUEsQ0F2dkNBO0FBQUE7QUFrekNBdUMsSUFBQUEsMkJBQUFBLHFCQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBQ0UsTUFBQUMsY0FBYzFGLFNBQUEsR0FBQUEsRUFBTyxjQUFQQSxDQUFkO0FBQUEsTUFFQSxPQUFBMkYsVUFBQUEsUUFBQUEsRUFBQUEsRUFBQUEsRUE1ekNKLGlCQUFBLEVBQUEsRUFBQTs7QUFBQTtBQUFBO0FBNHpDb0IsUUFBQSwyQkE1ekNwQjtBQUFBO0FBQUEsUUFBQSw0REFBQTtBQUFBO0FBNHpDYSxRQUFBLGtCQTV6Q2I7QUFBQTtBQTh6Q0E7QUFDQSxjQUFZNUYsT0FBQUEsQ0FBTSwrQkFBZSxtQkFBckJBO0FBQ1o7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQTBCMkYsV0FBWTs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFyMUNBLENBQUEsbUJBQUEsbUJBQUEsTUE0ekNJQyxDQUZBO0FBREZGLElBQUFBLENBQUFBLGdDQUFBQSxDQWx6Q0E7QUFBQTtBQWsxQ0FwRixJQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLGVBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsNkJBQUFBLENBbDFDQTtBQUFBLElBczFDQSxpQkFBTSxRQUFOLEVBQWEsTUFBYixDQXQxQ0E7QUFBQSxJQXcxQ0EsaUJBQU0sUUFBTixFQUFhLFFBQWIsQ0F4MUNBO0FBQUE7QUEwMUNBdUYsSUFBQUEsc0JBQUFBLGdCQUFBQSxjQUFPLElBQUQsRUFBTyxFQUFiQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRiw4QkFBZ0Msc0JBQU87QUFDdkMsMEJBQTRCLHNCQUFPOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBYzdGLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLGtCQUFBLEdBQUEsQ0FBb0IsMEJBQXBCLENBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBb0Qsd0JBQXBELENBQUEsR0FBQSw4QkFBckJBO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFrQkEsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsa0JBQUEsR0FBQSxDQUFvQiwwQkFBcEIsQ0FBQSxHQUFBLEdBQUEsR0FBQSxDQUFvRCx3QkFBcEQsQ0FBQSxHQUFBLDhCQUFyQkE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlJRTZGLElBQUFBLENBQUFBLDJCQUFBQSxDQTExQ0E7QUFBQTtBQTIrQ0FDLElBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBQVMsSUFBRCxFQUFPLEVBQWZBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGLDhCQUFnQyxzQkFBTztBQUN2QywwQkFBNEIsc0JBQU87O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFjOUYsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsa0JBQUEsR0FBQSxDQUFvQiwwQkFBcEIsQ0FBQSxHQUFBLEdBQUEsR0FBQSxDQUFvRCx3QkFBcEQsQ0FBQSxHQUFBLDhCQUFyQkE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQWtCQSxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSxrQkFBQSxHQUFBLENBQW9CLDBCQUFwQixDQUFBLEdBQUEsR0FBQSxHQUFBLENBQW9ELHdCQUFwRCxDQUFBLEdBQUEsOEJBQXJCQTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhLRThGLElBQUFBLENBQUFBLDZCQUFBQSxDQTMrQ0E7QUFBQTtBQThvREFDLElBQUFBLDBCQUFBQSxvQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsK0JBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBOW9EQTtBQUFBO0FBa3BEQUMsSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBUyxJQUFELEVBQU8sSUFBZkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBenBERjtBQXlwRCtCLE1BQUEsc0NBenBEL0I7QUFBQTtBQXlwRGlCLE1BQUE7QUFBQSxNQUFBLFNBQU8sS0FBUDtBQUFBLE1BQUEsQ0F6cERqQjtBQUFBLE1BMHBESSxJQUF5Q3BELGVBQXpDO0FBQUEsTUFBQTtBQUFBLFFBQUEsV0FBT0MsVUFBQUEsQ0FBUyxRQUFPb0QsTUFBTUMsSUFBdEJyRDtBQUFQLE1BQUEsQ0ExcERKO0FBQUE7QUE0cERBOztBQUVBLDhCQUFnQyxzQkFBTzs7QUFFdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxjQUFnQixDQUFDLENBQUQsQ0FBQXNELE1BQUFBLENBQUFBLENBQVM7QUFDekI7O0FBRUE7QUFDQTtBQUNBLElBNXNEQTtBQXlwREVILElBQUFBLENBQUFBLDhCQUFBQSxDQWxwREE7QUFBQTtBQXlzREY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWdCaEcsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsa0JBQUEsR0FBQSxDQUFvQixjQUFwQixDQUFBLEdBQUEsR0FBQSxHQUFBLENBQXdDLGNBQXhDLENBQUEsR0FBQSw4QkFBckJBO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBb0Msc0JBQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXVCLHNCQUFBb0csUUFBQUEsQ0FBZSxnQkFBZkEsQ0FBa0M7QUFDekQ7O0FBRUE7QUFDQSxzQkFBd0Isc0JBQUFBLFFBQUFBLENBQWUsZ0JBQWZBLENBQWtDO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSxFQTV4REU7QUFBQTtBQTh4REFDLElBQUFBLHNDQUFBQSxnQ0FBQUEsOEJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEsMkNBQUFBLENBOXhEQTtBQUFBLElBa3lEQUMsVUFBSW5ILElBQUptSCxZQUFBQSxtQkFBQUEsaUJBenlERixFQXl5REVBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXp5REY7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUF5eURpQixNQUFBLGtCQXp5RGpCO0FBQUEsTUEweURJLE9BQUE5RyxVQUFBQSxPQUFBQSxFQUFJLFVBQUNFLElBQUQsQ0FBSkYsQ0ExeURKO0FBeXlERThHLElBQUFBLENBQUFBLCtCQUFBQSxDQWx5REE7QUFBQTtBQXN5REFDLElBQUFBLHFDQUFBQSwrQkFBQUEsNkJBQXNCLElBQXRCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE3eURGO0FBNnlEd0IsTUFBQTtBQUFBLE1BQUEsU0FBTyxLQUFQO0FBQUEsTUFBQSxDQTd5RHhCO0FBQUEsTUE4eURJLElBQUEsUUFBaUUsQ0FBRyxLQUFILEVBQU8sS0FBUCxFQUFXLE1BQVgsRUFBZ0IsTUFBaEIsQ0FBQWxELGFBQUFBLENBQStCbUQsSUFBL0JuRCxDQUFqRSxDQUFBO0FBQUEsTUFBQTtBQUFBLFlBQUFyRCxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSw2QkFBQSxHQUFBLENBQThCd0csSUFBOUIsQ0FBckJ4RztBQUFBLE1BQUEsQ0E5eURKO0FBQUEsTUEreURJLE9BQUMsZUFBaUJ3RyxJQUFBVCxRQUFBQSxDQUFBQSxDQUFZLENBL3lEbEM7QUE2eURFUSxJQUFBQSxDQUFBQSwyQ0FBQUEsQ0F0eURBO0FBQUE7QUEyeURBRSxJQUFBQSx1Q0FBQUEscUNBQUFBLFNBQXdCLElBQXhCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFsekRGO0FBa3pEMEIsTUFBQTtBQUFBLE1BQUEsU0FBTyxLQUFQO0FBQUEsTUFBQSxDQWx6RDFCO0FBQUEsTUFtekRJLFdBQUFGLG1CQUFBQSxDQUFrQkMsSUFBbEJELENBQUFoRyxPQUFBQSxDQUEyQnBCLElBQTNCb0IsQ0FuekRKO0FBa3pERWtHLElBQUFBLENBQUFBLGlEQUFBQSxDQTN5REE7QUFBQTtBQSt5REFDLElBQUFBLDBCQUFBQSxvQkFBQUEsa0JBQVcsTUFBWEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsV0FBQTFHLE9BQUFBLENBQU0sdUVBQU5BO0FBREYwRyxJQUFBQSxDQUFBQSwrQkFBQUEsQ0EveURBO0FBQUE7QUFtekRBQyxJQUFBQSwyQkFBQUEscUJBQUFBLG1CQUFZLE1BQVpBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLFdBQUEzRyxPQUFBQSxDQUFNLHdFQUFOQTtBQURGMkcsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBbnpEQTtBQUFBO0FBdXpEQUMsSUFBQUEsMEJBQUFBLG9CQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFMRUEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBdnpEQTtBQUFBLElBK3pEQSxpQkFBTSxJQUFOLEVBQVMsS0FBVCxDQS96REE7QUFBQTtBQWkwREFDLElBQUFBLHNCQUFBQSxxQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5FQSxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FqMERBO0FBQUE7QUEwMERBQyxJQUFBQSwyQkFBQUEseUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsa0RBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsb0NBQUFBLENBMTBEQTtBQUFBLElBODBEQSxPQUFBLG9CQUFBQyxVQUFBQSxDQUFjNUgsTUFBTSxZQUFwQjRILENBOTBEQTtBQURGOUgsRUFBQUEsR0FBQUEsV0FBQUEsRUFBZ0IsTUFBaEJBLFdBSEE7QUFBQSxFQXExREEsT0FBQSxzQ0FBUyxzQkFBVCxDQXIxREE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo4OTIzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lbnVtZXJhYmxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogZmFsc3ksIHRydXRoeSwgY29lcmNlX3RvXG5cbm1vZHVsZSBFbnVtZXJhYmxlXG4gICV4e1xuICAgIGZ1bmN0aW9uIGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhbHVlID0gW25pbF07XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBhbGw/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gZmFsc2UgdW5sZXNzIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgdW5sZXNzIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIHVubGVzcyBPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgYW55PyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgY29tcGFyYWJsZSA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG5cbiAgICAgICAgcmV0dXJuIHRydWUgaWYgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiB5aWVsZCgqdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIE9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBjaHVuaygmYmxvY2spXG4gICAgcmV0dXJuIHRvX2VudW0oOmNodW5rKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIDo6RW51bWVyYXRvci5uZXcgZG8gfHlpZWxkZXJ8XG4gICAgICAleHtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gbmlsLCBhY2N1bXVsYXRlID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gcmVsZWFzZUFjY3VtdWxhdGUoKSB7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBwcmV2aW91c2AsIGBhY2N1bXVsYXRlYCl9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciBrZXkgPSBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgICAgaWYgKGtleSA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZWxlYXNlQWNjdW11bGF0ZSgpO1xuICAgICAgICAgICAgYWNjdW11bGF0ZSA9IFtdO1xuICAgICAgICAgICAgcHJldmlvdXMgPSBuaWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gbmlsIHx8IHByZXZpb3VzID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlbGVhc2VBY2N1bXVsYXRlKCk7XG4gICAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmV2aW91cyA9IGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgcmVsZWFzZUFjY3VtdWxhdGUoKTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNodW5rX3doaWxlKCZibG9jaylcbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gYmxvY2sgZ2l2ZW4nIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNsaWNlX3doZW4geyB8YmVmb3JlLCBhZnRlcnwgISh5aWVsZCBiZWZvcmUsIGFmdGVyKSB9XG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0X2NvbmNhdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0X2NvbmNhdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgbWFwIHsgfGl0ZW18IHlpZWxkIGl0ZW0gfS5mbGF0dGVuKDEpXG4gIGVuZFxuXG4gIGRlZiBjb3VudChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICByZXN1bHQgPSAwXG5cbiAgICAleHtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiBgb2JqZWN0ICE9IG51bGxgXG4gICAgICBibG9jayA9IHByb2MgZG8gfCphcmdzfFxuICAgICAgICBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpID09IG9iamVjdFxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2submlsP1xuICAgICAgYmxvY2sgPSBwcm9jIHsgdHJ1ZSB9XG4gICAgZW5kXG5cbiAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgIGByZXN1bHQrK2AgaWYgYE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKWBcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgY3ljbGUobiA9IG5pbCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6Y3ljbGUsIG4pIGRvXG4gICAgICAgIGlmIG4ubmlsP1xuICAgICAgICAgIHJlc3BvbmRfdG8/KDpzaXplKSA/IEZsb2F0OjpJTkZJTklUWSA6IG5pbFxuICAgICAgICBlbHNlXG4gICAgICAgICAgbiA9IE9wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KVxuICAgICAgICAgIG4gPiAwID8gZW51bWVyYXRvcl9zaXplICogbiA6IDBcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIG4gPSBPcGFsLmNvZXJjZV90byEgbiwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgICByZXR1cm4gaWYgYG4gPD0gMGBcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIGFsbCA9IFtdLCBpLCBsZW5ndGgsIHZhbHVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBhbGwucHVzaChwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgaWYgKGFsbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPT09IG5pbCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgYWxsW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB3aGlsZSAobiA+IDEpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhbGwubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIGFsbFtpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGV0ZWN0KGlmbm9uZSA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZGV0ZWN0LCBpZm5vbmUgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICB2YWx1ZSA9IE9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcbiAgICAgIGlmIHlpZWxkKHZhbHVlKVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoaWZub25lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZihpZm5vbmUpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGlmbm9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBpZm5vbmU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGRyb3AobnVtYmVyKVxuICAgIG51bWJlciA9IGAkY29lcmNlX3RvKG51bWJlciwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYG51bWJlciA8IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byBkcm9wIG5lZ2F0aXZlIHNpemUnXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgID0gW10sXG4gICAgICAgICAgY3VycmVudCA9IDA7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChudW1iZXIgPD0gY3VycmVudCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQrKztcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRyb3Bfd2hpbGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZHJvcF93aGlsZSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgICA9IFtdLFxuICAgICAgICAgIGRyb3BwaW5nID0gdHJ1ZTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgaWYgKGRyb3BwaW5nKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAgIGlmICgkZmFsc3kodmFsdWUpKSB7XG4gICAgICAgICAgICBkcm9wcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NvbnMobiwgJmJsb2NrKVxuICAgIGlmIGBhcmd1bWVudHMubGVuZ3RoICE9IDFgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMSlcIlxuICAgIGVuZFxuXG4gICAgbiA9IE9wYWwudHJ5X2NvbnZlcnQgbiwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYG4gPD0gMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdpbnZhbGlkIHNpemUnXG4gICAgZW5kXG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfY29ucywgbikgZG9cbiAgICAgICAgZW51bV9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICAgIGlmIGVudW1fc2l6ZS5uaWw/XG4gICAgICAgICAgbmlsXG4gICAgICAgIGVsc2lmIGVudW1fc2l6ZSA9PSAwIHx8IGVudW1fc2l6ZSA8IG5cbiAgICAgICAgICAwXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbnVtX3NpemUgLSBuICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgYnVmZmVyID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG4gICAgICAgIGJ1ZmZlci5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IG4pIHtcbiAgICAgICAgICBidWZmZXIuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSBuKSB7XG4gICAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIGJ1ZmZlci5zbGljZSgwLCBuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfZW50cnkoKmRhdGEsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gdG9fZW51bSg6ZWFjaF9lbnRyeSwgKmRhdGEpIHsgZW51bWVyYXRvcl9zaXplIH1cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgZGF0YSk7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfc2xpY2UobiwgJmJsb2NrKVxuICAgIG4gPSBgJGNvZXJjZV90bygje259LCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgbiA8PSAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2xpY2Ugc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9zbGljZSwgbikgeyByZXNwb25kX3RvPyg6c2l6ZSkgPyAoc2l6ZSAvIG4pLmNlaWwgOiBuaWwgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBzbGljZSA9IFtdXG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgIHNsaWNlLnB1c2gocGFyYW0pO1xuXG4gICAgICAgIGlmIChzbGljZS5sZW5ndGggPT09IG4pIHtcbiAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2xpY2UpO1xuICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgLy8gb3VyIFwibGFzdFwiIGdyb3VwLCBpZiBzbWFsbGVyIHRoYW4gbiB0aGVuIHdvbid0IGhhdmUgYmVlbiB5aWVsZGVkXG4gICAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2xpY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZWFjaF93aXRoX2luZGV4KCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfaW5kZXgsICphcmdzKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgYmxvY2socGFyYW0sIGluZGV4KTtcblxuICAgICAgICBpbmRleCsrO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3dpdGhfb2JqZWN0KG9iamVjdCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF93aXRoX29iamVjdCwgb2JqZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgYmxvY2socGFyYW0sIG9iamVjdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG4gICAgfVxuXG4gICAgb2JqZWN0XG4gIGVuZFxuXG4gIGRlZiBlbnRyaWVzKCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXN1bHQucHVzaCgje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZpbHRlcl9tYXAoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZmlsdGVyX21hcCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBtYXAoJmJsb2NrKS5zZWxlY3QoJjppdHNlbGYpXG4gIGVuZFxuXG4gIGFsaWFzIGZpbmQgZGV0ZWN0XG5cbiAgZGVmIGZpbmRfYWxsKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmZpbmRfYWxsKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGZpbHRlciBmaW5kX2FsbFxuXG4gIGRlZiBmaW5kX2luZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZmluZF9pbmRleCBpZiBgb2JqZWN0ID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcblxuICAgICV4e1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4ID0gMFxuXG4gICAgaWYgYG9iamVjdCAhPSBudWxsYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiBPcGFsLmRlc3RydWN0dXJlKHZhbHVlKSA9PSBvYmplY3RcbiAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYGluZGV4ICs9IDFgXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gaW5kZXhcbiAgICAgICAgZW5kXG5cbiAgICAgICAgYGluZGV4ICs9IDFgXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZmlyc3QobnVtYmVyID0gdW5kZWZpbmVkKVxuICAgIGlmIGBudW1iZXIgPT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfHZhbHVlfFxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIHJlc3VsdCA9IFtdXG4gICAgICBudW1iZXIgPSBgJGNvZXJjZV90byhudW1iZXIsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgaWYgYG51bWJlciA8IDBgXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIHRha2UgbmVnYXRpdmUgc2l6ZSdcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbnVtYmVyID09IDBgXG4gICAgICAgIHJldHVybiBbXVxuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnQgPSAwXG5cbiAgICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgICBgcmVzdWx0LnB1c2goI3tPcGFsLmRlc3RydWN0dXJlKGFyZ3MpfSlgXG5cbiAgICAgICAgaWYgYG51bWJlciA8PSArK2N1cnJlbnRgXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgZmxhdF9tYXAgY29sbGVjdF9jb25jYXRcblxuICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IHVubGVzcyBwYXR0ZXJuLl9fc2VuZF9fKDo9PT0sICpjbXApXG4gICAgICBpZiBibG9ja19naXZlbj9cbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdIGlmIHZhbHVlLmxlbmd0aCA+IDFcbiAgICAgICAgdmFsdWUgPSB5aWVsZCgqdmFsdWUpXG4gICAgICBlbHNpZiB2YWx1ZS5sZW5ndGggPD0gMVxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdXG4gICAgICBlbmRcblxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIGdyZXBfdihwYXR0ZXJuLCAmYmxvY2spXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgIGNtcCA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG4gICAgICBuZXh0IGlmIHBhdHRlcm4uX19zZW5kX18oOj09PSwgKmNtcClcbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV0gaWYgdmFsdWUubGVuZ3RoID4gMVxuICAgICAgICB2YWx1ZSA9IHlpZWxkKCp2YWx1ZSlcbiAgICAgIGVsc2lmIHZhbHVlLmxlbmd0aCA8PSAxXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF1cbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgZ3JvdXBfYnkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Z3JvdXBfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaGFzaCA9IHt9XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICN7KGhhc2hbYHZhbHVlYF0gfHw9IFtdKSA8PCBgcGFyYW1gfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoXG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhvYmopXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICBpZiBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpID09IG9ialxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaW5qZWN0KG9iamVjdCA9IHVuZGVmaW5lZCwgc3ltID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0O1xuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCAmJiBzeW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBbcmVzdWx0LCB2YWx1ZV0pO1xuXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHN5bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCEje1N5bWJvbCA9PT0gb2JqZWN0fSkge1xuICAgICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiI3tvYmplY3QuaW5zcGVjdH0gaXMgbm90IGEgU3ltYm9sXCJ9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN5bSAgICA9IG9iamVjdDtcbiAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSAje2ByZXN1bHRgLl9fc2VuZF9fIHN5bSwgYHZhbHVlYH07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGF6eVxuICAgIEVudW1lcmF0b3I6OkxhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVudW1lcmF0b3Jfc2l6ZVxuICAgIHJlc3BvbmRfdG8/KDpzaXplKSA/IHNpemUgOiBuaWxcbiAgZW5kXG5cbiAgYWxpYXMgbWFwIGNvbGxlY3RcblxuICBkZWYgbWF4KG4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgbiA9PT0gbmlsKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgW2l0ZW0sIHJlc3VsdF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICN7YGl0ZW1gIDw9PiBgcmVzdWx0YH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG4gPSAkY29lcmNlX3RvKG4sICN7SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICB9XG5cbiAgICBzb3J0KCZibG9jaykucmV2ZXJzZS5maXJzdChuKVxuICBlbmRcblxuICBkZWYgbWF4X2J5KG4gPSBuaWwsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1heF9ieSwgbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIHJldHVybiBzb3J0X2J5KCZibG9jaykucmV2ZXJzZS50YWtlIG5cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA8PT4gYGJ5YH0gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFyYW1cbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBtZW1iZXI/IGluY2x1ZGU/XG5cbiAgZGVmIG1pbihuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIHJldHVybiBzb3J0IHsgfGEsIGJ8IHlpZWxkIGEsIGIgfS50YWtlIG5cbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHNvcnQudGFrZSBuXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhbHVlID0gYmxvY2socGFyYW0sIHJlc3VsdCk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCN7T3BhbC5jb21wYXJlKGBwYXJhbWAsIGByZXN1bHRgKX0gPCAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbl9ieShuID0gbmlsLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDptaW5fYnksIG4pIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICB1bmxlc3Mgbi5uaWw/XG4gICAgICByZXR1cm4gc29ydF9ieSgmYmxvY2spLnRha2UgblxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGJ5O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgIDw9PiBgYnlgfSA8IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbVxuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtaW5tYXgoJmJsb2NrKVxuICAgIGJsb2NrIHx8PSBwcm9jIHsgfGEsIGJ8IGEgPD0+IGIgfVxuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gbmlsLCBtYXggPSBuaWwsIGZpcnN0X3RpbWUgPSB0cnVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuICAgICAgICBpZiAoZmlyc3RfdGltZSkge1xuICAgICAgICAgIG1pbiA9IG1heCA9IGVsZW1lbnQ7XG4gICAgICAgICAgZmlyc3RfdGltZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtaW5fY21wID0gI3tibG9jay5jYWxsKGBtaW5gLCBgZWxlbWVudGApfTtcblxuICAgICAgICAgIGlmIChtaW5fY21wID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ31cbiAgICAgICAgICB9IGVsc2UgaWYgKG1pbl9jbXAgPiAwKSB7XG4gICAgICAgICAgICBtaW4gPSBlbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtYXhfY21wID0gI3tibG9jay5jYWxsKGBtYXhgLCBgZWxlbWVudGApfTtcblxuICAgICAgICAgIGlmIChtYXhfY21wID09PSBuaWwpIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvbXBhcmlzb24gZmFpbGVkJ31cbiAgICAgICAgICB9IGVsc2UgaWYgKG1heF9jbXAgPCAwKSB7XG4gICAgICAgICAgICBtYXggPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbm1heF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDptaW5tYXhfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBtaW5fcmVzdWx0ID0gbmlsLFxuICAgICAgICAgIG1heF9yZXN1bHQgPSBuaWwsXG4gICAgICAgICAgbWluX2J5LFxuICAgICAgICAgIG1heF9ieTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKChtaW5fYnkgPT09IHVuZGVmaW5lZCkgfHwgI3tgdmFsdWVgIDw9PiBgbWluX2J5YH0gPCAwKSB7XG4gICAgICAgICAgbWluX3Jlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIG1pbl9ieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgobWF4X2J5ID09PSB1bmRlZmluZWQpIHx8ICN7YHZhbHVlYCA8PT4gYG1heF9ieWB9ID4gMCkge1xuICAgICAgICAgIG1heF9yZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBtYXhfYnkgICAgID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFttaW5fcmVzdWx0LCBtYXhfcmVzdWx0XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBub25lPyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgY29tcGFyYWJsZSA9IGBjb21wYXJhYmxlRm9yUGF0dGVybih2YWx1ZSlgXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaXRlbSA9IE9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGl0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgb25lPyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgY291bnQgPSAwXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgICAgIGNvdW50ICs9IDFcbiAgICAgICAgICByZXR1cm4gZmFsc2UgaWYgY291bnQgPiAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIG5leHQgdW5sZXNzIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgY291bnQgKz0gMVxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgbmV4dCB1bmxlc3MgT3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcbiAgICAgICAgY291bnQgKz0gMVxuXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgY291bnQgPT0gMVxuICBlbmRcblxuICBkZWYgcGFydGl0aW9uKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnBhcnRpdGlvbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciB0cnV0aHkgPSBbXSwgZmFsc3kgPSBbXSwgcmVzdWx0O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICB0cnV0aHkucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZmFsc3kucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFt0cnV0aHksIGZhbHN5XTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHJlZHVjZSBpbmplY3RcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgaWYgKCRmYWxzeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlX2VhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmV2ZXJzZV9lYWNoKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXN1bHQucHVzaChhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIE9wYWwueWllbGRYKGJsb2NrLCByZXN1bHRbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc2VsZWN0IGZpbmRfYWxsXG5cbiAgZGVmIHNsaWNlX2JlZm9yZShwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2JvdGggcGF0dGVybiBhbmQgYmxvY2sgYXJlIGdpdmVuJ1xuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZXhwZWN0ZWQgMSlcIlxuICAgIGVuZFxuXG4gICAgRW51bWVyYXRvci5uZXcgZG8gfGV8XG4gICAgICAleHtcbiAgICAgICAgdmFyIHNsaWNlID0gW107XG5cbiAgICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkgJiYgc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBibG9jayhwYXJhbSwgI3twYXR0ZXJuLmR1cH0pO1xuXG4gICAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICBpZiAoc2xpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICN7ZSA8PCBgc2xpY2VgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2xpY2VfYWZ0ZXIocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuID09PSB1bmRlZmluZWQgJiYgYmxvY2sgPT09IG5pbGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdib3RoIHBhdHRlcm4gYW5kIGJsb2NrIGFyZSBnaXZlbidcbiAgICBlbmRcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWQgJiYgYmxvY2sgIT09IG5pbCB8fCBhcmd1bWVudHMubGVuZ3RoID4gMWBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGV4cGVjdGVkIDEpXCJcbiAgICBlbmRcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBibG9jayA9IHByb2MgeyB8ZXwgcGF0dGVybiA9PT0gZSB9XG4gICAgZW5kXG5cbiAgICBFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgYWNjdW11bGF0ZTtcblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgIGVuZF9jaHVuayA9IE9wYWwueWllbGQxKGJsb2NrLCBlbGVtZW50KTtcblxuICAgICAgICAgIGlmIChhY2N1bXVsYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJHRydXRoeShlbmRfY2h1bmspKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAje3lpZWxkZXIueWllbGQoYGFjY3VtdWxhdGVgKX07XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjdW11bGF0ZS5wdXNoKGVsZW1lbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAgIGlmIChhY2N1bXVsYXRlICE9IG51bGwpIHtcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYGFjY3VtdWxhdGVgKX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNsaWNlX3doZW4oJmJsb2NrKVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxKScgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgRW51bWVyYXRvci5uZXcgZG8gfHlpZWxkZXJ8XG4gICAgICAleHtcbiAgICAgICAgdmFyIHNsaWNlID0gbmlsLCBsYXN0X2FmdGVyID0gbmlsO1xuXG4gICAgICAgIHNlbGYuJGVhY2hfY29ucy4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcGFyYW1zID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgIGJlZm9yZSA9IHBhcmFtc1swXSxcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJhbXNbMV0sXG4gICAgICAgICAgICAgIG1hdGNoID0gT3BhbC55aWVsZFgoYmxvY2ssIFtiZWZvcmUsIGFmdGVyXSk7XG5cbiAgICAgICAgICBsYXN0X2FmdGVyID0gYWZ0ZXI7XG5cbiAgICAgICAgICBpZiAoc2xpY2UgPT09IG5pbCkge1xuICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJHRydXRoeShtYXRjaCkpIHtcbiAgICAgICAgICAgIHNsaWNlLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgc2xpY2VgKX07XG4gICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbGljZS5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zKDIpO1xuXG4gICAgICAgIGlmIChzbGljZSAhPT0gbmlsKSB7XG4gICAgICAgICAgc2xpY2UucHVzaChsYXN0X2FmdGVyKTtcbiAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHNsaWNlYCl9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzb3J0KCZibG9jaylcbiAgICBhcnkgPSB0b19hXG4gICAgYmxvY2sgPSAtPihhLCBiKSB7IGEgPD0+IGIgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgYXJ5LnNvcnQoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgc29ydF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzb3J0X2J5KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGR1cCA9IG1hcCBkb1xuICAgICAgYXJnID0gT3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYClcbiAgICAgIFt5aWVsZChhcmcpLCBhcmddXG4gICAgZW5kXG4gICAgZHVwLnNvcnQhIHsgfGEsIGJ8IGBhWzBdYCA8PT4gYGJbMF1gIH1cbiAgICBkdXAubWFwISB7IHxpfCBgaVsxXWAgfVxuICBlbmRcblxuICBkZWYgc3VtKGluaXRpYWwgPSAwKVxuICAgIHJlc3VsdCA9IGluaXRpYWxcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgaXRlbSA9IGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICAgICAgICAgeWllbGQoKmFyZ3MpXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgT3BhbC5kZXN0cnVjdHVyZShhcmdzKVxuICAgICAgICAgICAgIGVuZFxuICAgICAgcmVzdWx0ICs9IGl0ZW1cbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgdGFrZShudW0pXG4gICAgZmlyc3QobnVtKVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDp0YWtlX3doaWxlIHVubGVzcyBibG9ja1xuXG4gICAgcmVzdWx0ID0gW11cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG5cbiAgICAgIHVubGVzcyB5aWVsZCh2YWx1ZSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgZW5kXG5cbiAgICAgIGByZXN1bHQucHVzaCh2YWx1ZSlgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1bmlxKCZibG9jaylcbiAgICBoYXNoID0ge31cblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgdmFsdWUgPSBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG5cbiAgICAgIHByb2R1Y2VkID0gaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgICAgICAgICAgICAgeWllbGQodmFsdWUpXG4gICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgdW5sZXNzIGhhc2gua2V5Pyhwcm9kdWNlZClcbiAgICAgICAgaGFzaFtwcm9kdWNlZF0gPSB2YWx1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBoYXNoLnZhbHVlc1xuICBlbmRcblxuICBkZWYgdGFsbHlcbiAgICBncm91cF9ieSgmOml0c2VsZikudHJhbnNmb3JtX3ZhbHVlcygmOmNvdW50KVxuICBlbmRcblxuICBhbGlhcyB0b19hIGVudHJpZXNcblxuICBkZWYgdG9faCgqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBtYXAoJmJsb2NrKS50b19oKCphcmdzKSBpZiBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSAje3t9fTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG4gICAgICAgIHZhciBhcnkgPSAje09wYWwuY29lcmNlX3RvPyhgcGFyYW1gLCBBcnJheSwgOnRvX2FyeSl9LCBrZXksIHZhbDtcbiAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGVsZW1lbnQgdHlwZSAje2BhcnlgLmNsYXNzfSAoZXhwZWN0ZWQgYXJyYXkpXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyeS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgYXJyYXkgbGVuZ3RoIChleHBlY3RlZCAyLCB3YXMgI3tgYXJ5YC5sZW5ndGh9KVwifVxuICAgICAgICB9XG4gICAgICAgIGtleSA9IGFyeVswXTtcbiAgICAgICAgdmFsID0gYXJ5WzFdO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWwpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgemlwKCpvdGhlcnMsICZibG9jaylcbiAgICB0b19hLnppcCgqb3RoZXJzKVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImFsbD8iLCJlYWNoIiwiY29tcGFyYWJsZSIsInB1YmxpY19zZW5kIiwicGF0dGVybiIsImJsb2NrX2dpdmVuPyIsInZhbHVlIiwiZGVzdHJ1Y3R1cmUiLCJhbnk/IiwiY2h1bmsiLCJ0b19lbnVtIiwiZW51bWVyYXRvcl9zaXplIiwibmV3IiwieWllbGRlciIsInlpZWxkIiwiY2h1bmtfd2hpbGUiLCJyYWlzZSIsInNsaWNlX3doZW4iLCJiZWZvcmUiLCJhZnRlciIsIiEiLCJjb2xsZWN0IiwiZW51bV9mb3IiLCJjb2xsZWN0X2NvbmNhdCIsIm1hcCIsIml0ZW0iLCJmbGF0dGVuIiwiMSIsImNvdW50IiwicmVzdWx0IiwiMCIsIndhcm4iLCJibG9jayIsInByb2MiLCJhcmdzIiwiPT0iLCJvYmplY3QiLCJuaWw/IiwiY3ljbGUiLCJuIiwicmVzcG9uZF90bz8iLCJjb2VyY2VfdG8hIiwiPiIsIioiLCJkZXRlY3QiLCJpZm5vbmUiLCJkcm9wIiwibnVtYmVyIiwiZHJvcF93aGlsZSIsImVhY2hfY29ucyIsInRyeV9jb252ZXJ0IiwiZW51bV9zaXplIiwiJHJldF9vcl8xIiwiPCIsIisiLCItIiwiZWFjaF9lbnRyeSIsImRhdGEiLCJlYWNoX3NsaWNlIiwiLyIsInNpemUiLCJjZWlsIiwiZWFjaF93aXRoX2luZGV4Iiwic2VsZiIsImVhY2hfd2l0aF9vYmplY3QiLCJlbnRyaWVzIiwiZmlsdGVyX21hcCIsInNlbGVjdCIsImZpbmRfYWxsIiwiZmluZF9pbmRleCIsImluZGV4IiwiZmlyc3QiLCJjdXJyZW50IiwiZ3JlcCIsImNtcCIsIl9fc2VuZF9fIiwibGVuZ3RoIiwiPD0iLCJbXSIsInB1c2giLCJncmVwX3YiLCJncm91cF9ieSIsImhhc2giLCIkcmV0X29yXzIiLCIkd3JpdGVyIiwiW109IiwiPDwiLCJpbmNsdWRlPyIsIm9iaiIsImluamVjdCIsIj09PSIsImluc3BlY3QiLCJzeW0iLCJsYXp5IiwiZW51bSQiLCJtYXgiLCI8PT4iLCJzb3J0IiwicmV2ZXJzZSIsIm1heF9ieSIsInNvcnRfYnkiLCJ0YWtlIiwibWluIiwiYSIsImIiLCJjb21wYXJlIiwibWluX2J5IiwibWlubWF4IiwiJHJldF9vcl8zIiwiY2FsbCIsIm1pbm1heF9ieSIsIm5vbmU/Iiwib25lPyIsInBhcnRpdGlvbiIsInJlamVjdCIsInJldmVyc2VfZWFjaCIsInNsaWNlX2JlZm9yZSIsImUiLCJkdXAiLCJzbGljZV9hZnRlciIsImFyeSIsInRvX2EiLCJhcmciLCJzb3J0ISIsIm1hcCEiLCJzdW0iLCJpbml0aWFsIiwibnVtIiwidGFrZV93aGlsZSIsInVuaXEiLCJwcm9kdWNlZCIsImtleT8iLCJ2YWx1ZXMiLCJ0YWxseSIsInRyYW5zZm9ybV92YWx1ZXMiLCJ0b19oIiwiY29lcmNlX3RvPyIsImNsYXNzIiwiemlwIiwib3RoZXJzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFaRTtBQUFBO0FBY0FDLElBQUFBLHdCQUFBQSx5QkFBQUEsU0FBUyxPQUFUQSxHQUFBQTs7QUFB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QWlCLFVBQUNyRyxJQUFELENBQWpCcUcsQ0FBUCxDQXZ0Q0o7QUFBQTtBQTB0Q0EsaUJBQW1CLFlBQUEsRUFBRzs7QUFFdEI7QUFDQSxvQkFBc0Isb0JBQUFoSSxhQUFBQSxDQUFrQixTQUFsQkEsQ0FBOEI7QUFDcEQsa0JBQW9CLG9CQUFBaUksZUFBQUEsQ0FBaUIsT0FBUSx1QkFBTyxRQUFoQ0EsQ0FBeUM7QUFDN0Q7QUFDQSxjQUFZeEgsT0FBQUEsQ0FBTSwyQkFBVyxFQUFBLEdBQUEscUJBQUEsR0FBQSxDQUFzQixDQUFDLEdBQUQsQ0FBQXlILE9BQUFBLENBQUFBLENBQXRCLENBQUEsR0FBQSxtQkFBakJ6SDtBQUNaO0FBQ0E7QUFDQSxjQUFZQSxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSxzQ0FBQSxHQUFBLENBQXVDLENBQUMsR0FBRCxDQUFBNEQsUUFBQUEsQ0FBQUEsQ0FBdkMsQ0FBQSxHQUFBLEdBQXJCNUQ7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBOXVDQTtBQXN0Q0V1SCxJQUFBQSxDQUFBQSxtQ0FBQUEsQ0FsdENBO0FBQUEsSUE2dUNBLE9BQUFHLENBQUFBLHVCQUFBQSxzQkFBQUEsZUFqdkNGLEVBaXZDRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBanZDRjtBQWl2Q21CLE1BQUEsMENBanZDbkI7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQWl2Q1UsTUFBQSxvQkFqdkNWO0FBQUEsTUFrdkNJLE9BQUFBLFVBQUFqQixNQUFBQSxDQUFBQSxDQUFBaUIsT0FBQUEsRUFBUyxVQUFDQyxNQUFELENBQVRELENBbHZDSjtBQWl2Q0VBLElBQUFBLENBQUFBLGtDQUFBQSxDQUFBQSxlQTd1Q0E7QUFERjNJLEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTA4OTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmF0b3IucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBicmVha2VyLCBzbGljZSwgZmFsc3ksIHRydXRoeSwgY29lcmNlX3RvXG5cbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuY2xhc3MgRW51bWVyYXRvclxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX2VudW1lcmF0b3IgPSB0cnVlYFxuXG4gIGRlZiBzZWxmLmZvcihvYmplY3QsIG1ldGhvZCA9IDplYWNoLCAqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9iaiA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICBvYmoub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgb2JqLnNpemUgICA9IGJsb2NrO1xuICAgICAgb2JqLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIG9iai5hcmdzICAgPSBhcmdzO1xuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoKiwgJmJsb2NrKVxuICAgIGlmIGJsb2NrXG4gICAgICBAb2JqZWN0ID0gR2VuZXJhdG9yLm5ldygmYmxvY2spXG4gICAgICBAbWV0aG9kID0gOmVhY2hcbiAgICAgIEBhcmdzICAgPSBbXVxuICAgICAgQHNpemUgICA9IGBhcmd1bWVudHNbMF0gfHwgbmlsYFxuXG4gICAgICBpZiBAc2l6ZSAmJiAhQHNpemUucmVzcG9uZF90bz8oOmNhbGwpXG4gICAgICAgIEBzaXplID0gYCRjb2VyY2VfdG8oI3tAc2l6ZX0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIEBvYmplY3QgPSBgYXJndW1lbnRzWzBdYFxuICAgICAgQG1ldGhvZCA9IGBhcmd1bWVudHNbMV0gfHwgXCJlYWNoXCJgXG4gICAgICBAYXJncyAgID0gYCRzbGljZS5jYWxsKGFyZ3VtZW50cywgMilgXG4gICAgICBAc2l6ZSAgID0gbmlsXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgaWYgYmxvY2submlsPyAmJiBhcmdzLmVtcHR5P1xuXG4gICAgYXJncyA9IEBhcmdzICsgYXJnc1xuXG4gICAgcmV0dXJuIHNlbGYuY2xhc3MubmV3KEBvYmplY3QsIEBtZXRob2QsICphcmdzKSBpZiBibG9jay5uaWw/XG5cbiAgICBAb2JqZWN0Ll9fc2VuZF9fKEBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgQHNpemUucmVzcG9uZF90bz8oOmNhbGwpID8gQHNpemUuY2FsbCgqQGFyZ3MpIDogQHNpemVcbiAgZW5kXG5cbiAgZGVmIHdpdGhfaW5kZXgob2Zmc2V0ID0gMCwgJmJsb2NrKVxuICAgIG9mZnNldCA9IGlmIG9mZnNldFxuICAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob2Zmc2V0LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgIGVuZFxuXG4gICAgcmV0dXJuIGVudW1fZm9yKDp3aXRoX2luZGV4LCBvZmZzZXQpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LCBpbmRleCA9IG9mZnNldDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHBhcmFtLCBpbmRleCk7XG5cbiAgICAgICAgaW5kZXgrKztcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiRlYWNoKCk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyB3aXRoX29iamVjdCBlYWNoX3dpdGhfb2JqZWN0XG5cbiAgZGVmIGVhY2hfd2l0aF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfaW5kZXgpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHN1cGVyXG4gICAgQG9iamVjdFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9IFwiIzwje3NlbGYuY2xhc3N9OiAje0BvYmplY3QuaW5zcGVjdH06I3tAbWV0aG9kfVwiXG5cbiAgICBpZiBAYXJncy5hbnk/XG4gICAgICByZXN1bHQgKz0gXCIoI3tAYXJncy5pbnNwZWN0W1JhbmdlLm5ldygxLCAtMildfSlcIlxuICAgIGVuZFxuXG4gICAgcmVzdWx0ICsgJz4nXG4gIGVuZFxuXG4gIGNsYXNzIEdlbmVyYXRvclxuICAgIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gICAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICAgcmFpc2UgTG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAgIEBibG9jayA9IGJsb2NrXG4gICAgZW5kXG5cbiAgICBkZWYgZWFjaCgqYXJncywgJmJsb2NrKVxuICAgICAgeWllbGRlciA9IFlpZWxkZXIubmV3KCZibG9jaylcblxuICAgICAgJXh7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXJncy51bnNoaWZ0KCN7eWllbGRlcn0pO1xuXG4gICAgICAgICAgT3BhbC55aWVsZFgoI3tAYmxvY2t9LCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlID09PSAkYnJlYWtlcikge1xuICAgICAgICAgICAgcmV0dXJuICRicmVha2VyLiR2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgWWllbGRlclxuICAgIGRlZiBpbml0aWFsaXplKCZibG9jaylcbiAgICAgIEBibG9jayA9IGJsb2NrXG4gICAgZW5kXG5cbiAgICBkZWYgeWllbGQoKnZhbHVlcylcbiAgICAgICV4e1xuICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWCgje0BibG9ja30sIHZhbHVlcyk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAkYnJlYWtlcikge1xuICAgICAgICAgIHRocm93ICRicmVha2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIDw8KCp2YWx1ZXMpXG4gICAgICBzZWxmLnlpZWxkKCp2YWx1ZXMpXG5cbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgY2xhc3MgTGF6eSA8IHNlbGZcbiAgICBjbGFzcyBTdG9wTGF6eUVycm9yIDwgRXhjZXB0aW9uOyBlbmRcblxuICAgIGRlZiBpbml0aWFsaXplKG9iamVjdCwgc2l6ZSA9IG5pbCwgJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IG5ldyB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgQGVudW1lcmF0b3IgPSBvYmplY3RcblxuICAgICAgc3VwZXIgc2l6ZSBkbyB8eWllbGRlciwgKmVhY2hfYXJnc3xcbiAgICAgICAgb2JqZWN0LmVhY2goKmVhY2hfYXJncykgZG8gfCphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KCN7eWllbGRlcn0pO1xuXG4gICAgICAgICAgICBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIHJlc2N1ZSBFeGNlcHRpb25cbiAgICAgICAgbmlsXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIGZvcmNlIHRvX2FcblxuICAgIGRlZiBsYXp5XG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgY29sbGVjdCgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSBtYXAgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIGVudW1lcmF0b3Jfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICAje2VudW0ueWllbGQgYHZhbHVlYH07XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGNvbGxlY3RfY29uY2F0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IG1hcCB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgje2B2YWx1ZWAucmVzcG9uZF90bz8gOmZvcmNlfSAmJiAje2B2YWx1ZWAucmVzcG9uZF90bz8gOmVhY2h9KSB7XG4gICAgICAgICAgICAje2B2YWx1ZWAuZWFjaCB7IHx2fCBlbnVtLnlpZWxkIHYgfX1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSAje09wYWwudHJ5X2NvbnZlcnQgYHZhbHVlYCwgQXJyYXksIDp0b19hcnl9O1xuXG4gICAgICAgICAgICBpZiAoYXJyYXkgPT09IG5pbCkge1xuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYHZhbHVlYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgI3tgdmFsdWVgLmVhY2ggeyB8dnwgZW51bS55aWVsZCB2IH19O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgZHJvcChuKVxuICAgICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgaWYgbiA8IDBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gZHJvcCBuZWdhdGl2ZSBzaXplJ1xuICAgICAgZW5kXG5cbiAgICAgIGN1cnJlbnRfc2l6ZSA9IGVudW1lcmF0b3Jfc2l6ZVxuICAgICAgc2V0X3NpemUgICAgID0gaWYgSW50ZWdlciA9PT0gY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICAgIG4gPCBjdXJyZW50X3NpemUgPyBuIDogY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIGRyb3BwZWQgPSAwXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBzZXRfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICBpZiBkcm9wcGVkIDwgblxuICAgICAgICAgIGRyb3BwZWQgKz0gMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBkcm9wX3doaWxlKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IGRyb3Bfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIHN1Y2NlZWRpbmcgPSB0cnVlXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgaWYgc3VjY2VlZGluZ1xuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAoJGZhbHN5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBzdWNjZWVkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgZW51bS55aWVsZCgqYXJncylcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBlbnVtX2ZvcihtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcbiAgICAgIHNlbGYuY2xhc3MuZm9yKHNlbGYsIG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgICBlbmRcblxuICAgIGFsaWFzIGZpbHRlciBmaW5kX2FsbFxuXG4gICAgZGVmIGZpbmRfYWxsKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHNlbGVjdCB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIGZsYXRfbWFwIGNvbGxlY3RfY29uY2F0XG5cbiAgICBkZWYgZ3JlcChwYXR0ZXJuLCAmYmxvY2spXG4gICAgICBpZiBibG9ja1xuICAgICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgICAleHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShhcmdzKX0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAje3BhdHRlcm4gPT09IGBwYXJhbWB9O1xuXG4gICAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKWB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGFyZ3MpfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAje2VudW0ueWllbGQgYHBhcmFtYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYWxpYXMgbWFwIGNvbGxlY3RcblxuICAgIGFsaWFzIHNlbGVjdCBmaW5kX2FsbFxuXG4gICAgZGVmIHJlamVjdCgmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3RyaWVkIHRvIGNhbGwgbGF6eSByZWplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoJGZhbHN5KHZhbHVlKSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB0YWtlKG4pXG4gICAgICBuID0gYCRjb2VyY2VfdG8oI3tufSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICBpZiBuIDwgMFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byB0YWtlIG5lZ2F0aXZlIHNpemUnXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudF9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICBzZXRfc2l6ZSAgICAgPSBpZiBJbnRlZ2VyID09PSBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgICAgbiA8IGN1cnJlbnRfc2l6ZSA/IG4gOiBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgdGFrZW4gPSAwXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBzZXRfc2l6ZSkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICBpZiB0YWtlbiA8IG5cbiAgICAgICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgICAgICAgIHRha2VuICs9IDFcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJhaXNlIFN0b3BMYXp5RXJyb3JcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiB0YWtlX3doaWxlKCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHRha2Vfd2hpbGUgd2l0aG91dCBhIGJsb2NrJ1xuICAgICAgZW5kXG5cbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAleHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICN7ZW51bS55aWVsZCgqYXJncyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICN7cmFpc2UgU3RvcExhenlFcnJvcn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGFsaWFzIHRvX2VudW0gZW51bV9mb3JcblxuICAgIGRlZiBpbnNwZWN0XG4gICAgICBcIiM8I3tzZWxmLmNsYXNzfTogI3tAZW51bWVyYXRvci5pbnNwZWN0fT5cIlxuICAgIGVuZFxuICBlbmRcblxuICBjbGFzcyBBcml0aG1ldGljU2VxdWVuY2UgPCBzZWxmXG4gICAgIyBXZSBuZWVkIHRvIHN0dWIgdGhpcyBmb3IgdGhlIHRpbWUgYmVpbmdcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwiZm9yIiwic2VsZiIsImFsbG9jYXRlIiwiaW5pdGlhbGl6ZSIsImJsb2NrIiwiQG9iamVjdCIsIm5ldyIsIkBtZXRob2QiLCJAYXJncyIsIkBzaXplIiwiJHJldF9vcl8xIiwicmVzcG9uZF90bz8iLCIhIiwiZWFjaCIsIiRyZXRfb3JfMiIsIm5pbD8iLCJhcmdzIiwiZW1wdHk/IiwiKyIsIl9fc2VuZF9fIiwic2l6ZSIsImNhbGwiLCJ3aXRoX2luZGV4IiwiMCIsIm9mZnNldCIsImVudW1fZm9yIiwiZGVzdHJ1Y3R1cmUiLCJlYWNoX3dpdGhfaW5kZXgiLCJibG9ja19naXZlbj8iLCJpbnNwZWN0IiwicmVzdWx0IiwiYW55PyIsIltdIiwiMSIsIi0yIiwicmFpc2UiLCJAYmxvY2siLCJ5aWVsZGVyIiwieWllbGQiLCI8PCIsInZhbHVlcyIsIkBlbnVtZXJhdG9yIiwib2JqZWN0IiwiZWFjaF9hcmdzIiwibGF6eSIsImNvbGxlY3QiLCJlbnVtZXJhdG9yX3NpemUiLCJlbnVtJCIsImNvbGxlY3RfY29uY2F0IiwidiIsInRyeV9jb252ZXJ0IiwiZHJvcCIsIm4iLCI8IiwiY3VycmVudF9zaXplIiwic2V0X3NpemUiLCI9PT0iLCJkcm9wcGVkIiwiZHJvcF93aGlsZSIsInN1Y2NlZWRpbmciLCJtZXRob2QiLCJmaW5kX2FsbCIsImdyZXAiLCJwYXR0ZXJuIiwicmVqZWN0IiwidGFrZSIsInRha2VuIiwidGFrZV93aGlsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRUEsTUFBQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsMEJBQVJBLENBQUE7QUFBQSxJQUVDLHVDQUZEO0FBQUEsSUFJQUMsVUFBSUMsSUFBSkQsVUFBQUEsb0JBQUFBLFNBQWEsTUFBRCxFQVZkLEVBVWMsRUFWZCxFQVVFQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUFWRjtBQVU4QyxNQUFBLHdDQVY5QztBQUFBO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBVXVCLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxXQUFTLE1BQVQ7QUFBQSxNQUFBLENBVnZCO0FBQUE7QUFVdUMsTUFBQSxrQkFWdkM7QUFBQTtBQVlBLG9CQUFrQkUsVUFBQUEsQ0FBQUEsQ0FBUzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQXBCQTtBQVVFRixJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FKQTtBQUFBO0FBaUJBRyxJQUFBQSw4QkFBQUEsMkJBQUFBLHNCQXZCRixFQXVCRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFB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QUFBQSxDQUFBQSxDQUFwQixDQUFBLEdBQUE7QUFERkEsTUFBQUEsQ0FBQUEsOEJBQUFBLENBQUFBLG1CQXpPQTtBQURGL0IsSUFBQUEsR0FBQUEsV0FBQUEsRUFBYUcsSUFBYkgsV0FySkE7QUFBQSxJQW9ZQSxPQUFBQTtBQUFBQSxJQUFBQTs7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQUFBLElBQUFBLEdBQUFBLFdBQUFBLEVBQTJCRyxJQUEzQkgsV0FwWUE7QUFERkEsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjExNjQzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9udW1lcmljLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcblxuY2xhc3MgTnVtZXJpY1xuICBpbmNsdWRlIENvbXBhcmFibGVcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGlmIG90aGVyLmluc3RhbmNlX29mPyBzZWxmLmNsYXNzXG4gICAgICByZXR1cm4gW290aGVyLCBzZWxmXVxuICAgIGVuZFxuXG4gICAgW0Zsb2F0KG90aGVyKSwgRmxvYXQoc2VsZildXG4gIGVuZFxuXG4gIGRlZiBfX2NvZXJjZWRfXyhtZXRob2QsIG90aGVyKVxuICAgIGlmIG90aGVyLnJlc3BvbmRfdG8/KDpjb2VyY2UpXG4gICAgICBhLCBiID0gb3RoZXIuY29lcmNlKHNlbGYpXG4gICAgICBhLl9fc2VuZF9fIG1ldGhvZCwgYlxuICAgIGVsc2VcbiAgICAgIGNhc2UgbWV0aG9kXG4gICAgICB3aGVuIDorLCA6LSwgOiosIDovLCA6JSwgOiYsIDp8LCA6XiwgOioqXG4gICAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gTnVtZXJpY1wiXG4gICAgICB3aGVuIDo+LCA6Pj0sIDo8LCA6PD0sIDo8PT5cbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje290aGVyLmNsYXNzfSBmYWlsZWRcIlxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgZXF1YWw/IG90aGVyXG4gICAgICByZXR1cm4gMFxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiArQFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgMCAtIHNlbGZcbiAgZW5kXG5cbiAgZGVmICUob3RoZXIpXG4gICAgc2VsZiAtIG90aGVyICogZGl2KG90aGVyKVxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgc2VsZiA8IDAgPyAtc2VsZiA6IHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFiczJcbiAgICBzZWxmICogc2VsZlxuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICBzZWxmIDwgMCA/IE1hdGg6OlBJIDogMFxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcblxuICBkZWYgY2VpbChuZGlnaXRzID0gMClcbiAgICB0b19mLmNlaWwobmRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIGNvbmpcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGNvbmp1Z2F0ZSBjb25qXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgdG9fci5kZW5vbWluYXRvclxuICBlbmRcblxuICBkZWYgZGl2KG90aGVyKVxuICAgIHJhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSBvJyBpZiBvdGhlciA9PSAwXG5cbiAgICAoc2VsZiAvIG90aGVyKS5mbG9vclxuICBlbmRcblxuICBkZWYgZGl2bW9kKG90aGVyKVxuICAgIFtkaXYob3RoZXIpLCBzZWxmICUgb3RoZXJdXG4gIGVuZFxuXG4gIGRlZiBmZGl2KG90aGVyKVxuICAgIHRvX2YgLyBvdGhlclxuICBlbmRcblxuICBkZWYgZmxvb3IobmRpZ2l0cyA9IDApXG4gICAgdG9fZi5mbG9vcihuZGlnaXRzKVxuICBlbmRcblxuICBkZWYgaVxuICAgIENvbXBsZXgoMCwgc2VsZilcbiAgZW5kXG5cbiAgZGVmIGltYWdcbiAgICAwXG4gIGVuZFxuXG4gIGFsaWFzIGltYWdpbmFyeSBpbWFnXG5cbiAgZGVmIGludGVnZXI/XG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgYWxpYXMgbWFnbml0dWRlIGFic1xuXG4gIGFsaWFzIG1vZHVsbyAlXG5cbiAgZGVmIG5vbnplcm8/XG4gICAgemVybz8gPyBuaWwgOiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICB0b19yLm51bWVyYXRvclxuICBlbmRcblxuICBhbGlhcyBwaGFzZSBhcmdcblxuICBkZWYgcG9sYXJcbiAgICBbYWJzLCBhcmddXG4gIGVuZFxuXG4gIGRlZiBxdW8ob3RoZXIpXG4gICAgT3BhbC5jb2VyY2VfdG8hKHNlbGYsIFJhdGlvbmFsLCA6dG9fcikgLyBvdGhlclxuICBlbmRcblxuICBkZWYgcmVhbFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlYWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgcmVjdFxuICAgIFtzZWxmLCAwXVxuICBlbmRcblxuICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG5cbiAgZGVmIHJvdW5kKGRpZ2l0cyA9IHVuZGVmaW5lZClcbiAgICB0b19mLnJvdW5kKGRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIHN0ZXAobGltaXQgPSB1bmRlZmluZWQsIHN0ZXAgPSB1bmRlZmluZWQsIHRvOiB1bmRlZmluZWQsIGJ5OiB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkICYmIHRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAndG8gaXMgZ2l2ZW4gdHdpY2UnfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RlcCAhPT0gdW5kZWZpbmVkICYmIGJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnc3RlcCBpcyBnaXZlbiB0d2ljZSd9XG4gICAgICB9XG5cbiAgICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbWl0ID0gdG87XG4gICAgICB9XG5cbiAgICAgIGlmIChieSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0ZXAgPSBieTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSBuaWw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUGFyYW1ldGVycygpIHtcbiAgICAgICAgaWYgKHN0ZXAgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnc3RlcCBtdXN0IGJlIG51bWVyaWMnfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgIT0gbnVsbCAmJiAje3N0ZXAgPT0gMH0pIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwic3RlcCBjYW4ndCBiZSAwXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCA9PT0gbmlsIHx8IHN0ZXAgPT0gbnVsbCkge1xuICAgICAgICAgIHN0ZXAgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpZ24gPSAje3N0ZXAgPD0+IDB9O1xuXG4gICAgICAgIGlmIChzaWduID09PSBuaWwpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiMCBjYW4ndCBiZSBjb2VyY2VkIGludG8gI3tzdGVwLmNsYXNzfVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbWl0ID09PSBuaWwgfHwgbGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgIGxpbWl0ID0gc2lnbiA+IDAgPyAje0Zsb2F0OjpJTkZJTklUWX0gOiAjey1GbG9hdDo6SU5GSU5JVFl9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tPcGFsLmNvbXBhcmUoc2VsZiwgbGltaXQpfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGVwRmxvYXRTaXplKCkge1xuICAgICAgICBpZiAoKHN0ZXAgPiAwICYmIHNlbGYgPiBsaW1pdCkgfHwgKHN0ZXAgPCAwICYmIHNlbGYgPCBsaW1pdCkpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzdGVwID09PSBJbmZpbml0eSB8fCBzdGVwID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYWJzID0gTWF0aC5hYnMsIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgICAgICAgZXJyID0gKGFicyhzZWxmKSArIGFicyhsaW1pdCkgKyBhYnMobGltaXQgLSBzZWxmKSkgLyBhYnMoc3RlcCkgKiAje0Zsb2F0OjpFUFNJTE9OfTtcblxuICAgICAgICAgIGlmIChlcnIgPT09IEluZmluaXR5IHx8IGVyciA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGVyciA+IDAuNSkge1xuICAgICAgICAgICAgICBlcnIgPSAwLjU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmbG9vcigobGltaXQgLSBzZWxmKSAvIHN0ZXAgKyBlcnIpICsgMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGVwU2l6ZSgpIHtcbiAgICAgICAgdmFsaWRhdGVQYXJhbWV0ZXJzKCk7XG5cbiAgICAgICAgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RlcCAlIDEgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gc3RlcEZsb2F0U2l6ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKChzdGVwID4gMCAmJiBzZWxmID4gbGltaXQpIHx8IChzdGVwIDwgMCAmJiBzZWxmIDwgbGltaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNlaWwgPSBNYXRoLmNlaWwsIGFicyA9IE1hdGguYWJzLFxuICAgICAgICAgICAgICBsaHMgPSBhYnMoc2VsZiAtIGxpbWl0KSArIDEsXG4gICAgICAgICAgICAgIHJocyA9IGFicyhzdGVwKTtcblxuICAgICAgICAgIHJldHVybiBjZWlsKGxocyAvIHJocyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBlbnVtX2Zvcig6c3RlcCwgbGltaXQsIHN0ZXAsICZgc3RlcFNpemVgKSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhbGlkYXRlUGFyYW1ldGVycygpO1xuXG4gICAgICB2YXIgaXNEZXNjID0gI3tzdGVwLm5lZ2F0aXZlP30sXG4gICAgICAgICAgaXNJbmYgPSAje3N0ZXAgPT0gMH0gfHxcbiAgICAgICAgICAgICAgICAgIChsaW1pdCA9PT0gSW5maW5pdHkgJiYgIWlzRGVzYykgfHxcbiAgICAgICAgICAgICAgICAgIChsaW1pdCA9PT0gLUluZmluaXR5ICYmIGlzRGVzYyk7XG5cbiAgICAgIGlmIChzZWxmLiQkaXNfbnVtYmVyICYmIHN0ZXAuJCRpc19udW1iZXIgJiYgbGltaXQuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKHNlbGYgJSAxID09PSAwICYmIChpc0luZiB8fCBsaW1pdCAlIDEgPT09IDApICYmIHN0ZXAgJSAxID09PSAwKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc2VsZjtcblxuICAgICAgICAgIGlmIChpc0luZikge1xuICAgICAgICAgICAgZm9yICg7OyB2YWx1ZSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRGVzYykge1xuICAgICAgICAgICAgZm9yICg7IHZhbHVlID49IGxpbWl0OyB2YWx1ZSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICg7IHZhbHVlIDw9IGxpbWl0OyB2YWx1ZSArPSBzdGVwKSB7XG4gICAgICAgICAgICAgIGJsb2NrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYmVnaW4gPSAje3RvX2Z9LnZhbHVlT2YoKTtcbiAgICAgICAgICBzdGVwID0gI3tzdGVwLnRvX2Z9LnZhbHVlT2YoKTtcbiAgICAgICAgICBsaW1pdCA9ICN7bGltaXQudG9fZn0udmFsdWVPZigpO1xuXG4gICAgICAgICAgdmFyIG4gPSBzdGVwRmxvYXRTaXplKCk7XG5cbiAgICAgICAgICBpZiAoIWlzRmluaXRlKHN0ZXApKSB7XG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgYmxvY2soYmVnaW4pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gMCkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgYmxvY2soYmVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICB2YXIgZCA9IGkgKiBzdGVwICsgc2VsZjtcbiAgICAgICAgICAgICAgaWYgKHN0ZXAgPj0gMCA/IGxpbWl0IDwgZCA6IGxpbWl0ID4gZCkge1xuICAgICAgICAgICAgICAgIGQgPSBsaW1pdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBibG9jayhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvdW50ZXIgPSBzZWxmXG5cbiAgICB3aGlsZSBgaXNEZXNjID8gI3tjb3VudGVyID49IGxpbWl0fSA6ICN7Y291bnRlciA8PSBsaW1pdH1gXG4gICAgICB5aWVsZCBjb3VudGVyXG4gICAgICBjb3VudGVyICs9IHN0ZXBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICBDb21wbGV4KHNlbGYsIDApXG4gIGVuZFxuXG4gIGRlZiB0b19pbnRcbiAgICB0b19pXG4gIGVuZFxuXG4gIGRlZiB0cnVuY2F0ZShuZGlnaXRzID0gMClcbiAgICB0b19mLnRydW5jYXRlKG5kaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiB6ZXJvP1xuICAgIHNlbGYgPT0gMFxuICBlbmRcblxuICBkZWYgcG9zaXRpdmU/XG4gICAgc2VsZiA+IDBcbiAgZW5kXG5cbiAgZGVmIG5lZ2F0aXZlP1xuICAgIHNlbGYgPCAwXG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZmluaXRlP1xuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIGluZmluaXRlP1xuICAgIG5pbFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsImluY2x1ZGUiLCJjb2VyY2UiLCJvdGhlciIsImluc3RhbmNlX29mPyIsInNlbGYiLCJGbG9hdCIsIl9fY29lcmNlZF9fIiwicmVzcG9uZF90bz8iLCJhIiwiYiIsIl9fc2VuZF9fIiwibWV0aG9kIiwicmFpc2UiLCI8PT4iLCJlcXVhbD8iLCIwIiwiK0AiLCItQCIsIi0iLCIlIiwiKiIsImRpdiIsImFicyIsIjwiLCJhYnMyIiwiYW5nbGUiLCJjZWlsIiwidG9fZiIsIm5kaWdpdHMiLCJjb25qIiwiZGVub21pbmF0b3IiLCJ0b19yIiwiPT0iLCIvIiwiZmxvb3IiLCJkaXZtb2QiLCJmZGl2IiwiaSIsIkNvbXBsZXgiLCJpbWFnIiwiaW50ZWdlcj8iLCJub256ZXJvPyIsInplcm8/IiwibnVtZXJhdG9yIiwicG9sYXIiLCJhcmciLCJxdW8iLCJjb2VyY2VfdG8hIiwicmVhbCIsInJlYWw/IiwicmVjdCIsInJvdW5kIiwiZGlnaXRzIiwic3RlcCIsImNvbXBhcmUiLCJsaW1pdCIsImJsb2NrX2dpdmVuPyIsImVudW1fZm9yIiwibmVnYXRpdmU/IiwiY291bnRlciIsIj49IiwiPD0iLCIrIiwidG9fYyIsInRvX2ludCIsInRvX2kiLCJ0cnVuY2F0ZSIsInBvc2l0aXZlPyIsIj4iLCJkdXAiLCJjbG9uZSIsImZpbml0ZT8iLCJpbmZpbml0ZT8iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsb0JBQVJBLENBQUE7QUFBQSxFQUVBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxTQUFBQSxDQUFRLDBCQUFSQSxDQUFBO0FBQUE7QUFFQUMsSUFBQUEsMEJBQUFBLG9CQUFBQSxrQkFBVyxLQUFYQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBLElBQUEsUUFBR0MsS0FBQUMsaUJBQUFBLENBQW1CQyxJQUFBTCxPQUFBQSxDQUFBQSxDQUFuQkksQ0FBSCxDQUFBO0FBQUEsUUFDRSxPQUFPLENBQUNELEtBQUQsRUFBUUUsSUFBUixDQURULENBQUE7QUFBQSxNQUlBLE9BQUEsS0FBQ0MsT0FBQUEsQ0FBTUgsS0FBTkcsQ0FBRCxNQUFlQSxPQUFBQSxDQUFNRCxJQUFOQyxDQUFmLENBSkE7QUFERkosSUFBQUEsQ0FBQUEsK0JBQUFBLENBRkE7QUFBQTtBQVVBSyxJQUFBQSwrQkFBQUEseUJBQUFBLHVCQUFnQixNQUFELEVBQVMsS0FBeEJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLElBQUEsUUFBR0osS0FBQUssZ0JBQUFBLENBQWtCLFFBQWxCQSxDQUFILENBQUE7QUFBQTtBQUNFLFFBQUEsS0FBT0wsS0FBQUQsUUFBQUEsQ0FBYUcsSUFBYkgsQ0FBUCxzQkFBQSxFQUFBTyxDQUFBQSxpQ0FBQUEsQ0FBQSxFQUFHQyxDQUFBQSxpQ0FBQUEsQ0FBSCxJQUFBO0FBQUEsUUFDQSxPQUFBRCxDQUFBRSxVQUFBQSxDQUFXQyxRQUFRRixDQUFuQkMsQ0FEQTtBQURGLE1BQUE7QUFBQSxRQUlFLE9BQUEsYUFBQSxRQUFLQyxNQUFMO0FBQUEsUUFDQSxJQUFLLGtCQUFMLElBQVMsa0JBQVQsSUFBYSxrQkFBYixJQUFpQixrQkFBakIsSUFBcUIsa0JBQXJCLElBQXlCLGtCQUF6QixJQUE2QixrQkFBN0IsSUFBaUMsa0JBQWpDLElBQXFDLG1CQUFyQyxHQUNFLFdBQUFDLE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLENBQUdWLEtBQUFILE9BQUFBLENBQUFBLENBQUgsQ0FBQSxHQUFBLGdDQUFqQmEsQ0FERjtBQURBLFFBQUEsS0FHQSxJQUFLLGtCQUFMLElBQVMsbUJBQVQsSUFBYyxrQkFBZCxJQUFrQixtQkFBbEIsSUFBdUIsb0JBQXZCLEdBQ0UsV0FBQUEsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsZ0JBQUEsR0FBQSxDQUFpQlIsSUFBQUwsT0FBQUEsQ0FBQUEsQ0FBakIsQ0FBQSxHQUFBLFFBQUEsR0FBQSxDQUFvQ0csS0FBQUgsT0FBQUEsQ0FBQUEsQ0FBcEMsQ0FBQSxHQUFBLFNBQXJCYSxDQURGO0FBSEEsUUFBQSxtQkFBQTtBQUpGLE1BQUE7QUFERk4sSUFBQUEsQ0FBQUEsb0NBQUFBLENBVkE7QUFBQTtBQXdCQU8sSUFBQUEsdUJBQUFBLHVCQUFBQSxTQUFRLEtBQVJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUEsSUFBQSxZQUFHQyxXQUFBQSxDQUFPWixLQUFQWSxDQUFILENBQUE7QUFBQSxRQUNFLE9BQU9DLENBRFQsQ0FBQTtBQUFBLE1BSUEsT0FBQSxHQUpBO0FBREZGLElBQUFBLENBQUFBLGtDQUFBQSxDQXhCQTtBQUFBO0FBZ0NBRyxJQUFBQSxzQkFBQUEsb0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFaO0FBREZZLElBQUFBLENBQUFBLCtCQUFBQSxDQWhDQTtBQUFBO0FBb0NBQyxJQUFBQSxzQkFBQUEscUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFDLFVBQUFILENBQUFHLEVBQUlkLElBQUpjO0FBREZELElBQUFBLENBQUFBLGdDQUFBQSxDQXBDQTtBQUFBO0FBd0NBRSxJQUFBQSxxQkFBQUEsc0JBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQUQsVUFBQWQsSUFBQWMsRUFBT0UsVUFBQWxCLEtBQUFrQixNQUFRQyxLQUFBQSxDQUFJbkIsS0FBSm1CLENBQVJELENBQVBGO0FBREZDLElBQUFBLENBQUFBLGlDQUFBQSxDQXhDQTtBQUFBO0FBNENBRyxJQUFBQSx1QkFBQUEsaUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLElBQUFDLE9BQUFuQixJQUFBbUIsRUFBT1IsQ0FBUFEsQ0FBQTtBQUFBLFFBQVcsT0FBQ25CLElBQURhLE9BQUFBLENBQUFBO0FBQVgsTUFBQTtBQUFBLFFBQW1CLE9BQUFiO0FBQW5CLE1BQUE7QUFERmtCLElBQUFBLENBQUFBLDRCQUFBQSxDQTVDQTtBQUFBO0FBZ0RBRSxJQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBSixVQUFBaEIsSUFBQWdCLEVBQU9oQixJQUFQZ0I7QUFERkksSUFBQUEsQ0FBQUEsNkJBQUFBLENBaERBO0FBQUE7QUFvREFDLElBQUFBLHlCQUFBQSxtQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLElBQUFGLE9BQUFuQixJQUFBbUIsRUFBT1IsQ0FBUFEsQ0FBQTtBQUFBLFFBQVcsT0FBQSxJQUFBLG9CQUFBO0FBQVgsTUFBQTtBQUFBLFFBQXNCLE9BQUFSO0FBQXRCLE1BQUE7QUFERlUsSUFBQUEsQ0FBQUEsOEJBQUFBLENBcERBO0FBQUEsSUF3REEsaUJBQU0sS0FBTixFQUFVLE9BQVYsQ0F4REE7QUFBQTtBQTBEQUMsSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBUyxPQUFUQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE5REY7QUE4RFcsTUFBQTtBQUFBLE1BQUEsWUFBVVgsQ0FBVjtBQUFBLE1BQUEsQ0E5RFg7QUFBQSxNQStESSxXQUFBWSxNQUFBQSxDQUFBQSxDQUFBRCxNQUFBQSxDQUFVRSxPQUFWRixDQS9ESjtBQThERUEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBMURBO0FBQUE7QUE4REFHLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUF6QjtBQURGeUIsSUFBQUEsQ0FBQUEsOEJBQUFBLENBOURBO0FBQUEsSUFrRUEsaUJBQU0sV0FBTixFQUFnQixNQUFoQixDQWxFQTtBQUFBO0FBb0VBQyxJQUFBQSwrQkFBQUEsMEJBQUFBLHVCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBQyxNQUFBQSxDQUFBQSxDQUFBRCxhQUFBQSxDQUFBQTtBQURGQSxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0FwRUE7QUFBQTtBQXdFQVQsSUFBQUEsdUJBQUFBLGtCQUFBQSxlQUFRLEtBQVJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUEsSUFBMkNuQixLQUFBOEIsT0FBQUEsQ0FBU2pCLENBQVRpQixDQUEzQztBQUFBLFlBQUFwQixPQUFBQSxDQUFNLG1DQUFtQixjQUF6QkEsQ0FBQSxDQUFBO0FBQUEsTUFFQSxPQUFDcUIsV0FBQTdCLElBQUE2QixFQUFPL0IsS0FBUCtCLENBQURDLE9BQUFBLENBQUFBLENBRkE7QUFERmIsSUFBQUEsQ0FBQUEsNkJBQUFBLENBeEVBO0FBQUE7QUE4RUFjLElBQUFBLDBCQUFBQSxxQkFBQUEsa0JBQVcsS0FBWEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxLQUFDZCxLQUFBQSxDQUFJbkIsS0FBSm1CLENBQUQsRUFBYWpCLElBQUFlLE1BQUFBLENBQU9qQixLQUFQaUIsQ0FBYjtBQURGZ0IsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBOUVBO0FBQUE7QUFrRkFDLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQVMsS0FBVEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQUgsZUFBQU4sTUFBQUEsQ0FBQUEsQ0FBQU0sRUFBTy9CLEtBQVArQjtBQURGRyxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FsRkE7QUFBQTtBQXNGQUYsSUFBQUEseUJBQUFBLG9CQUFBQSxpQkFBVSxPQUFWQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUExRkY7QUEwRlksTUFBQTtBQUFBLE1BQUEsWUFBVW5CLENBQVY7QUFBQSxNQUFBLENBMUZaO0FBQUEsTUEyRkksV0FBQVksTUFBQUEsQ0FBQUEsQ0FBQU8sT0FBQUEsQ0FBV04sT0FBWE0sQ0EzRko7QUEwRkVBLElBQUFBLENBQUFBLGdDQUFBQSxDQXRGQTtBQUFBO0FBMEZBRyxJQUFBQSxxQkFBQUEsZ0JBQUFBLGFBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLFdBQUFDLFNBQUFBLENBQVF2QixHQUFHWCxJQUFYa0M7QUFERkQsSUFBQUEsQ0FBQUEsMkJBQUFBLENBMUZBO0FBQUE7QUE4RkFFLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUF4QjtBQURGd0IsSUFBQUEsQ0FBQUEsOEJBQUFBLENBOUZBO0FBQUEsSUFrR0EsaUJBQU0sV0FBTixFQUFnQixNQUFoQixDQWxHQTtBQUFBO0FBb0dBQyxJQUFBQSw0QkFBQUEsMkJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEsc0NBQUFBLENBcEdBO0FBQUEsSUF3R0EsaUJBQU0sV0FBTixFQUFnQixLQUFoQixDQXhHQTtBQUFBLElBMEdBLGlCQUFNLFFBQU4sRUFBYSxHQUFiLENBMUdBO0FBQUE7QUE0R0FDLElBQUFBLDRCQUFBQSwyQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsSUFBQSxZQUFBQyxVQUFBQSxDQUFBQSxDQUFBLENBQUE7QUFBQSxRQUFRLE9BQUE7QUFBUixNQUFBO0FBQUEsUUFBYyxPQUFBdEM7QUFBZCxNQUFBO0FBREZxQyxJQUFBQSxDQUFBQSxzQ0FBQUEsQ0E1R0E7QUFBQTtBQWdIQUUsSUFBQUEsNkJBQUFBLHdCQUFBQSxxQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsV0FBQVosTUFBQUEsQ0FBQUEsQ0FBQVksV0FBQUEsQ0FBQUE7QUFERkEsSUFBQUEsQ0FBQUEsbUNBQUFBLENBaEhBO0FBQUEsSUFvSEEsaUJBQU0sT0FBTixFQUFZLEtBQVosQ0FwSEE7QUFBQTtBQXNIQUMsSUFBQUEseUJBQUFBLG9CQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxLQUFDdEIsS0FBQUEsQ0FBQUEsQ0FBRCxNQUFNdUIsS0FBQUEsQ0FBQUEsQ0FBTjtBQURGRCxJQUFBQSxDQUFBQSwrQkFBQUEsQ0F0SEE7QUFBQTtBQTBIQUUsSUFBQUEsdUJBQUFBLGtCQUFBQSxlQUFRLEtBQVJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFiLFdBQUEsb0JBQUFjLGVBQUFBLENBQWdCM0MsTUFBTSwwQkFBVSxNQUFoQzJDLENBQUFkLEVBQXlDL0IsS0FBekMrQjtBQURGYSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0ExSEE7QUFBQTtBQThIQUUsSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQTVDO0FBREY0QyxJQUFBQSxDQUFBQSw4QkFBQUEsQ0E5SEE7QUFBQTtBQWtJQUMsSUFBQUEseUJBQUFBLHdCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBO0FBREZBLElBQUFBLENBQUFBLG1DQUFBQSxDQWxJQTtBQUFBO0FBc0lBQyxJQUFBQSx3QkFBQUEsbUJBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLENBQUM5QyxJQUFELEVBQU9XLENBQVA7QUFERm1DLElBQUFBLENBQUFBLDhCQUFBQSxDQXRJQTtBQUFBLElBMElBLGlCQUFNLGFBQU4sRUFBa0IsTUFBbEIsQ0ExSUE7QUFBQTtBQTRJQUMsSUFBQUEseUJBQUFBLG9CQUFBQSxpQkFBVSxNQUFWQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFoSkYsTUFBQTtBQUFBLE1BaUpJLFdBQUF4QixNQUFBQSxDQUFBQSxDQUFBd0IsT0FBQUEsQ0FBV0MsTUFBWEQsQ0FqSko7QUFnSkVBLElBQUFBLENBQUFBLGdDQUFBQSxDQTVJQTtBQUFBO0FBZ0pBRSxJQUFBQSx3QkFBQUEsbUJBQUFBLGdCQXBKRixFQW9KVSxFQXBKVixFQW9KVSxFQXBKVixFQW9KRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBcEpGO0FBb0o4RSxNQUFBLHVDQXBKOUU7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQUFBLE1BQUEseUNBQUE7QUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLENBQUE7QUFBQTtBQW9KVyxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLENBcEpYO0FBQUE7QUFvSjhCLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUEsQ0FwSjlCO0FBQUE7QUFvSmdELE1BQUEsMEJBcEpoRDtBQUFBO0FBb0orRCxNQUFBLDBCQXBKL0Q7QUFBQTtBQXNKQTtBQUNBLFlBQVV6QyxPQUFBQSxDQUFNLCtCQUFlLG1CQUFyQkE7QUFDVjs7QUFFQTtBQUNBLFlBQVVBLE9BQUFBLENBQU0sK0JBQWUscUJBQXJCQTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFZQSxPQUFBQSxDQUFNLDJCQUFXLHNCQUFqQkE7QUFDWjs7QUFFQSw0QkFBOEJ5QyxJQUFBckIsT0FBQUEsQ0FBUWpCLENBQVJpQixDQUFVO0FBQ3hDLGNBQVlwQixPQUFBQSxDQUFNLCtCQUFlLGlCQUFyQkE7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQXFCeUMsSUFBQXhDLFFBQUFBLENBQVNFLENBQVRGLENBQVc7O0FBRWhDO0FBQ0EsY0FBWUQsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsMEJBQUEsR0FBQSxDQUEyQnlDLElBQUF0RCxPQUFBQSxDQUFBQSxDQUEzQixDQUFyQmE7QUFDWjs7QUFFQTtBQUNBLDZCQUErQixJQUFBLHFCQUFBLGFBQWdCLEdBQU0sSUFBQSxxQkFBQSxhQUFESyxPQUFBQSxDQUFBQSxDQUFpQjtBQUNyRTs7QUFFQSxRQUFVLG9CQUFBcUMsU0FBQUEsQ0FBYWxELE1BQU1tRCxLQUFuQkQ7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUFpRixJQUFBLHFCQUFBLFlBQWU7O0FBRWhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQTdPQTtBQUFBLE1BK09JLElBQXdERSxlQUF4RDtBQUFBLE1BQUE7QUFBQSxRQUFBLE9BQU9DLFVBQUFBLFlBQUFBLEVBQUFBLENBQVMsUUFBT0YsT0FBT0YsSUFBdkJJLENBQUFBLEVBQThCLENBQUMsUUFBRCxZQUE5QkE7QUFBUCxNQUFBLENBL09KO0FBQUE7QUFrUEE7O0FBRUEsbUJBQXFCSixJQUFBSyxjQUFBQSxDQUFBQSxDQUFlO0FBQ3BDLGtCQUFvQkwsSUFBQXJCLE9BQUFBLENBQVFqQixDQUFSaUIsQ0FBVTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQXdCTCxNQUFBQSxDQUFBQSxDQUFLO0FBQzdCLGlCQUFtQjBCLElBQUExQixNQUFBQSxDQUFBQSxDQUFVO0FBQzdCLGtCQUFvQjRCLEtBQUE1QixNQUFBQSxDQUFBQSxDQUFXOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUF0U0E7QUFBQSxNQXdTSWdDLFVBQVV2RCxJQXhTZDtBQUFBLE1BMFNJLE9BQUEsUUFBTyxTQUFXd0QsT0FBQUQsT0FBQUMsRUFBV0wsS0FBWEssQ0FBaUIsR0FBS0MsT0FBQUYsT0FBQUUsRUFBV04sS0FBWE0sQ0FBeEMsQ0FBQTtBQUFBO0FBQ0UsUUFBQSxtQkFBTUYsT0FBTixDQUFBO0FBQUEsUUFDQUEsVUE1U05HLFNBNFNNSCxPQTVTTkcsRUE0U2lCVCxJQTVTakJTLENBMlNNO0FBREYsTUFBQSxDQTFTSjtBQW9KRVQsSUFBQUEsQ0FBQUEsK0JBQUFBLENBaEpBO0FBQUE7QUE0U0FVLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLFdBQUF6QixTQUFBQSxDQUFRbEMsTUFBTVcsQ0FBZHVCO0FBREZ5QixJQUFBQSxDQUFBQSw4QkFBQUEsQ0E1U0E7QUFBQTtBQWdUQUMsSUFBQUEsMEJBQUFBLHFCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsV0FBQUMsTUFBQUEsQ0FBQUE7QUFERkQsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBaFRBO0FBQUE7QUFvVEFFLElBQUFBLDRCQUFBQSx1QkFBQUEsb0JBQWEsT0FBYkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBeFRGO0FBd1RlLE1BQUE7QUFBQSxNQUFBLFlBQVVuRCxDQUFWO0FBQUEsTUFBQSxDQXhUZjtBQUFBLE1BeVRJLFdBQUFZLE1BQUFBLENBQUFBLENBQUF1QyxVQUFBQSxDQUFjdEMsT0FBZHNDLENBelRKO0FBd1RFQSxJQUFBQSxDQUFBQSxtQ0FBQUEsQ0FwVEE7QUFBQTtBQXdUQXhCLElBQUFBLHlCQUFBQSx3QkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQXRDLElBQUE0QixPQUFBQSxDQUFRakIsQ0FBUmlCO0FBREZVLElBQUFBLENBQUFBLG1DQUFBQSxDQXhUQTtBQUFBO0FBNFRBeUIsSUFBQUEsNkJBQUFBLDRCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBQyxPQUFBaEUsSUFBQWdFLEVBQU9yRCxDQUFQcUQ7QUFERkQsSUFBQUEsQ0FBQUEsdUNBQUFBLENBNVRBO0FBQUE7QUFnVUFULElBQUFBLDZCQUFBQSw0QkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQW5DLE9BQUFuQixJQUFBbUIsRUFBT1IsQ0FBUFE7QUFERm1DLElBQUFBLENBQUFBLHVDQUFBQSxDQWhVQTtBQUFBO0FBb1VBVyxJQUFBQSx1QkFBQUEsa0JBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFqRTtBQURGaUUsSUFBQUEsQ0FBQUEsNkJBQUFBLENBcFVBO0FBQUE7QUF3VUFDLElBQUFBLHlCQUFBQSxvQkFBQUEsaUJBNVVGLE9BNFVFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE1VUY7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxDQUFBO0FBQUE7QUE0VVksTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBLFdBQVE7QUFBUixNQUFBLENBNVVaO0FBQUEsTUE2VUksT0FBQWxFLElBN1VKO0FBNFVFa0UsSUFBQUEsQ0FBQUEsZ0NBQUFBLENBeFVBO0FBQUE7QUE0VUFDLElBQUFBLDJCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQTtBQURGQSxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0E1VUE7QUFBQSxJQWdWQSxPQUFBQyxDQUFBQSw2QkFBQUEsNEJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEsdUNBQUFBLENBQUFBLHFCQWhWQTtBQURGekUsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjEyMTU3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9hcnJheS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHRydXRoeSwgZmFsc3ksIGhhc2hfaWRzLCB5aWVsZDEsIGhhc2hfZ2V0LCBoYXNoX3B1dCwgaGFzaF9kZWxldGUsIGNvZXJjZV90bywgcmVzcG9uZF90b1xuXG5yZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5yZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5cbmNsYXNzIEFycmF5IDwgYEFycmF5YFxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICAjIE1hcmsgYWxsIGphdmFzY3JpcHQgYXJyYXlzIGFzIGJlaW5nIHZhbGlkIHJ1YnkgYXJyYXlzXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2FycmF5JywgdHJ1ZSlgXG5cbiAgJXh7XG4gICAgLy8gUmVjZW50IHZlcnNpb25zIG9mIFY4ICg+IDcuMSkgb25seSB1c2UgYW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIHdoZW4gQXJyYXkucHJvdG90eXBlIGlzIHVubW9kaWZpZWQuXG4gICAgLy8gRm9yIGluc3RhbmNlLCBcImFycmF5LXNwbGljZS50cVwiIGhhcyBhIFwiZmFzdCBwYXRoXCIgKEV4dHJhY3RGYXN0SlNBcnJheSwgZGVmaW5lZCBpbiBcInNyYy9jb2RlZ2VuL2NvZGUtc3R1Yi1hc3NlbWJsZXIuY2NcIilcbiAgICAvLyBidXQgaXQncyBvbmx5IGVuYWJsZWQgd2hlbiBcIklzUHJvdG90eXBlSW5pdGlhbEFycmF5UHJvdG90eXBlKClcIiBpcyB0cnVlLlxuICAgIC8vXG4gICAgLy8gT2xkZXIgdmVyc2lvbnMgb2YgVjggd2VyZSB1c2luZyByZWxhdGl2ZWx5IGZhc3QgSlMtd2l0aC1leHRlbnNpb25zIGNvZGUgZXZlbiB3aGVuIEFycmF5LnByb3RvdHlwZSBpcyBtb2RpZmllZDpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi83LjAuMS9zcmMvanMvYXJyYXkuanMjTDU5OS1MNjQyXG4gICAgLy9cbiAgICAvLyBJbiBzaG9ydCwgQXJyYXkgb3BlcmF0aW9ucyBhcmUgc2xvdyBpbiByZWNlbnQgdmVyc2lvbnMgb2YgVjggd2hlbiB0aGUgQXJyYXkucHJvdG90eXBlIGhhcyBiZWVuIHRhbXBlcmVkLlxuICAgIC8vIFNvLCB3aGVuIHBvc3NpYmxlLCB3ZSBhcmUgdXNpbmcgZmFzdGVyIG9wZW4tY29kZWQgdmVyc2lvbiB0byBib29zdCB0aGUgcGVyZm9ybWFuY2UuXG5cbiAgICAvLyBBcyBvZiBWOCA4LjQsIGRlcGVuZGluZyBvbiB0aGUgc2l6ZSBvZiB0aGUgYXJyYXksIHRoaXMgaXMgdXAgdG8gfjI1eCB0aW1lcyBmYXN0ZXIgdGhhbiBBcnJheSNzaGlmdCgpXG4gICAgLy8gSW1wbGVtZW50YXRpb24gaXMgaGVhdmlseSBpbnNwaXJlZCBieTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvYmE2ODQ4MDViNmMwZWRlZDc2ZTVjZDg5ZWUwMDMyOGFjN2E1OTM2NS9saWIvaW50ZXJuYWwvdXRpbC5qcyNMMzQxLUwzNDdcbiAgICBmdW5jdGlvbiBzaGlmdE5vQXJnKGxpc3QpIHtcbiAgICAgIHZhciByID0gbGlzdFswXTtcbiAgICAgIHZhciBpbmRleCA9IDE7XG4gICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgbGlzdFtpbmRleCAtIDFdID0gbGlzdFtpbmRleF07XG4gICAgICB9XG4gICAgICBsaXN0LnBvcCgpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheVN1YmNsYXNzKG9iaiwga2xhc3MpIHtcbiAgICAgIGlmIChrbGFzcy4kJG5hbWUgPT09IE9wYWwuQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrbGFzcy4kYWxsb2NhdGUoKS4kcmVwbGFjZSgje2BvYmpgLnRvX2F9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBIGhlbHBlciBmb3Iga2VlcF9pZiBhbmQgZGVsZXRlX2lmLCBmaWx0ZXIgaXMgZWl0aGVyIE9wYWwudHJ1dGh5XG4gICAgLy8gb3IgT3BhbC5mYWxzeS5cbiAgICBmdW5jdGlvbiBmaWx0ZXJJZihzZWxmLCBmaWx0ZXIsIGJsb2NrKSB7XG4gICAgICB2YXIgdmFsdWUsIHJhaXNlZCA9IG51bGwsIHVwZGF0ZWQgPSBuZXcgQXJyYXkoc2VsZi5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaTIgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghcmFpc2VkKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSlcbiAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICByYWlzZWQgPSBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmFpc2VkIHx8IGZpbHRlcih2YWx1ZSkpIHtcbiAgICAgICAgICB1cGRhdGVkW2kyXSA9IHNlbGZbaV1cbiAgICAgICAgICBpMiArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpMiAhPT0gaSkge1xuICAgICAgICBzZWxmLnNwbGljZS5hcHBseShzZWxmLCBbMCwgdXBkYXRlZC5sZW5ndGhdLmNvbmNhdCh1cGRhdGVkKSk7XG4gICAgICAgIHNlbGYuc3BsaWNlKGkyLCB1cGRhdGVkLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyYWlzZWQpIHRocm93IHJhaXNlZDtcbiAgICB9XG4gIH1cblxuICBkZWYgc2VsZi5bXSgqb2JqZWN0cylcbiAgICBgdG9BcnJheVN1YmNsYXNzKG9iamVjdHMsIHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZShzaXplID0gbmlsLCBvYmogPSBuaWwsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChvYmogIT09IG5pbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogYmxvY2sgc3VwZXJzZWRlcyBkZWZhdWx0IHZhbHVlIGFyZ3VtZW50Jyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaXplID4gI3tJbnRlZ2VyOjpNQVh9KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2FycmF5IHNpemUgdG9vIGJpZyd9XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4yKVwifVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoc2l6ZS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgI3tyZXBsYWNlKHNpemUudG9fYSl9XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0gZWxzZSBpZiAoI3tzaXplLnJlc3BvbmRfdG8/IDp0b19hcnl9KSB7XG4gICAgICAgICAgI3tyZXBsYWNlKHNpemUudG9fYXJ5KX1cbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzaXplID0gJGNvZXJjZV90byhzaXplLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ31cbiAgICAgIH1cblxuICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgdmFyIGksIHZhbHVlO1xuXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwLCB2YWx1ZTsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gYmxvY2soaSk7XG4gICAgICAgICAgc2VsZltpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQob2JqKVxuICAgIE9wYWwuY29lcmNlX3RvPyBvYmosIEFycmF5LCA6dG9fYXJ5XG4gIGVuZFxuXG4gIGRlZiAmKG90aGVyKVxuICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgb3RoZXJbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICBpZiAoJGhhc2hfZGVsZXRlKGhhc2gsIGl0ZW0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3tBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgc2VsZltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoLiRrZXlzKCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICByZXR1cm4gam9pbihvdGhlci50b19zdHIpIGlmIG90aGVyLnJlc3BvbmRfdG8/IDp0b19zdHJcblxuICAgIG90aGVyID0gYCRjb2VyY2VfdG8ob3RoZXIsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgIGlmIGBvdGhlciA8IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJndW1lbnQnXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBjb252ZXJ0ZWQgPSAje3RvX2F9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChjb252ZXJ0ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3tBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICBgc2VsZi5jb25jYXQob3RoZXIpYFxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICBvdGhlciA9IGlmIEFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKG90aGVyLCAje0FycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG4gICAgcmV0dXJuIGBzZWxmLnNsaWNlKClgIGlmIGBvdGhlci5sZW5ndGggPT09IDBgXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW07XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBvdGhlcltpXSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwgaXRlbSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPDwob2JqZWN0KVxuICAgIGBzZWxmLnB1c2gob2JqZWN0KWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgIG90aGVyID0gb3RoZXIudG9fYVxuICAgIGVsc2lmIG90aGVyLnJlc3BvbmRfdG8/IDp0b19hcnlcbiAgICAgIG90aGVyID0gb3RoZXIudG9fYXJ5LnRvX2FcbiAgICBlbHNlXG4gICAgICByZXR1cm5cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKCN7aGFzaH0gPT09ICN7b3RoZXIuaGFzaH0pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb3VudCA9IE1hdGgubWluKHNlbGYubGVuZ3RoLCBvdGhlci5sZW5ndGgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHRtcCA9ICN7YHNlbGZbaV1gIDw9PiBgb3RoZXJbaV1gfTtcblxuICAgICAgICBpZiAodG1wICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tgc2VsZi5sZW5ndGhgIDw9PiBgb3RoZXIubGVuZ3RoYH07XG4gICAgfVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoYXJyYXksIG90aGVyKSB7XG4gICAgICAgIHZhciBpLCBsZW5ndGgsIGEsIGI7XG5cbiAgICAgICAgaWYgKGFycmF5ID09PSBvdGhlcilcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBpZiAoIW90aGVyLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBpZiAoJHJlc3BvbmRfdG8ob3RoZXIsICckdG9fYXJ5JykpIHtcbiAgICAgICAgICAgIHJldHVybiAje2BvdGhlcmAgPT0gYGFycmF5YH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJyYXkuJCRjb25zdHJ1Y3RvciAhPT0gQXJyYXkpXG4gICAgICAgICAgYXJyYXkgPSAje2BhcnJheWAudG9fYX07XG4gICAgICAgIGlmIChvdGhlci4kJGNvbnN0cnVjdG9yICE9PSBBcnJheSlcbiAgICAgICAgICBvdGhlciA9ICN7YG90aGVyYC50b19hfTtcblxuICAgICAgICBpZiAoYXJyYXkubGVuZ3RoICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZWN1cnNlZFsje2BhcnJheWAub2JqZWN0X2lkfV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYSA9IGFycmF5W2ldO1xuICAgICAgICAgIGIgPSBvdGhlcltpXTtcbiAgICAgICAgICBpZiAoYS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgICBpZiAoYi4kJGlzX2FycmF5ICYmIGIubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2VkLmhhc093blByb3BlcnR5KCN7YGFgLm9iamVjdF9pZH0pKSB7XG4gICAgICAgICAgICAgIGlmICghX2VxZXEoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYCA9PSBgYmB9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWVxKHNlbGYsIG90aGVyKTtcbiAgICB9XG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBpbmRleCkge1xuICAgICAgdmFyIHNpemUgPSBzZWxmLmxlbmd0aCxcbiAgICAgICAgICBleGNsdWRlLCBmcm9tLCB0bywgcmVzdWx0O1xuXG4gICAgICBleGNsdWRlID0gaW5kZXguZXhjbDtcbiAgICAgIGZyb20gICAgPSAkY29lcmNlX3RvKGluZGV4LmJlZ2luLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcbiAgICAgIHRvICAgICAgPSAkY29lcmNlX3RvKGluZGV4LmVuZCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICBmcm9tICs9IHNpemU7XG5cbiAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbSA+IHNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICB0byArPSBzaXplO1xuXG4gICAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFleGNsdWRlKSB7XG4gICAgICAgIHRvICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoZnJvbSwgdG8pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkYXJyYXlfc2xpY2VfaW5kZXhfbGVuZ3RoKHNlbGYsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIHZhciBzaXplID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgZXhjbHVkZSwgZnJvbSwgdG8sIHJlc3VsdDtcblxuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzaXplO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGZbaW5kZXhdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCBPcGFsLkludGVnZXIsICd0b19pbnQnKTtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCB8fCBpbmRleCA+IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoaW5kZXgsIGluZGV4ICsgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgZGVmIFtdKGluZGV4LCBsZW5ndGggPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoaW5kZXguJCRpc19yYW5nZSkge1xuICAgICAgICByZXR1cm4gJGFycmF5X3NsaWNlX3JhbmdlKHNlbGYsIGluZGV4KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJGFycmF5X3NsaWNlX2luZGV4X2xlbmd0aChzZWxmLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oaW5kZXgsIHZhbHVlLCBleHRyYSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpLCBzaXplID0gc2VsZi5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgUmFuZ2UgPT09IGluZGV4XG4gICAgICBkYXRhID0gaWYgQXJyYXkgPT09IHZhbHVlXG4gICAgICAgICAgICAgICB2YWx1ZS50b19hXG4gICAgICAgICAgICAgZWxzaWYgdmFsdWUucmVzcG9uZF90bz8gOnRvX2FyeVxuICAgICAgICAgICAgICAgdmFsdWUudG9fYXJ5LnRvX2FcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICBbdmFsdWVdXG4gICAgICAgICAgICAgZW5kXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgZXhjbHVkZSA9IGluZGV4LmV4Y2wsXG4gICAgICAgICAgICBmcm9tICAgID0gJGNvZXJjZV90byhpbmRleC5iZWdpbiwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpLFxuICAgICAgICAgICAgdG8gICAgICA9ICRjb2VyY2VfdG8oaW5kZXguZW5kLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgZnJvbSArPSBzaXplO1xuXG4gICAgICAgICAgaWYgKGZyb20gPCAwKSB7XG4gICAgICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsIFwiI3tpbmRleC5pbnNwZWN0fSBvdXQgb2YgcmFuZ2VcIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgIHRvICs9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4Y2x1ZGUpIHtcbiAgICAgICAgICB0byArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGZyb207IGkrKykge1xuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIDBdLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2Zyb20sIHRvIC0gZnJvbV0uY29uY2F0KGRhdGEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBpZiBgZXh0cmEgPT09IHVuZGVmaW5lZGBcbiAgICAgICAgbGVuZ3RoID0gMVxuICAgICAgZWxzZVxuICAgICAgICBsZW5ndGggPSB2YWx1ZVxuICAgICAgICB2YWx1ZSAgPSBleHRyYVxuXG4gICAgICAgIGRhdGEgPSBpZiBBcnJheSA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICAgdmFsdWUudG9fYVxuICAgICAgICAgICAgICAgZWxzaWYgdmFsdWUucmVzcG9uZF90bz8gOnRvX2FyeVxuICAgICAgICAgICAgICAgICB2YWx1ZS50b19hcnkudG9fYVxuICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICBbdmFsdWVdXG4gICAgICAgICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIG9sZDtcblxuICAgICAgICBpbmRleCAgPSAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICAgIGxlbmd0aCA9ICRjb2VyY2VfdG8obGVuZ3RoLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIG9sZCAgICA9IGluZGV4O1xuICAgICAgICAgIGluZGV4ICs9IHNpemU7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAje3JhaXNlIEluZGV4RXJyb3IsIFwiaW5kZXggI3tgb2xkYH0gdG9vIHNtYWxsIGZvciBhcnJheTsgbWluaW11bSAje2Atc2VsZi5sZW5ndGhgfVwifTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICN7cmFpc2UgSW5kZXhFcnJvciwgXCJuZWdhdGl2ZSBsZW5ndGggKCN7bGVuZ3RofSlcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA+IHNpemUpIHtcbiAgICAgICAgICBmb3IgKGkgPSBzaXplOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXh0cmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbGZbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2luZGV4LCBsZW5ndGhdLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhbnk/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBgaWYgKHNlbGYubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2VgXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpdGVtID0gc2VsZltpXSwgaXRlbS5sZW5ndGggJiYgI3tgaXRlbVswXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXQoaW5kZXgpXG4gICAgJXh7XG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7SW50ZWdlcn0sICd0b19pbnQnKVxuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoX2luZGV4KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmJzZWFyY2hfaW5kZXggdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgbWluID0gMCxcbiAgICAgICAgICBtYXggPSBzZWxmLmxlbmd0aCxcbiAgICAgICAgICBtaWQsXG4gICAgICAgICAgdmFsLFxuICAgICAgICAgIHJldCxcbiAgICAgICAgICBzbWFsbGVyID0gZmFsc2UsXG4gICAgICAgICAgc2F0aXNmaWVkID0gbmlsO1xuXG4gICAgICB3aGlsZSAobWluIDwgbWF4KSB7XG4gICAgICAgIG1pZCA9IG1pbiArIE1hdGguZmxvb3IoKG1heCAtIG1pbikgLyAyKTtcbiAgICAgICAgdmFsID0gc2VsZlttaWRdO1xuICAgICAgICByZXQgPSAkeWllbGQxKGJsb2NrLCB2YWwpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IHRydWUpIHtcbiAgICAgICAgICBzYXRpc2ZpZWQgPSBtaWQ7XG4gICAgICAgICAgc21hbGxlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmV0ID09PSBmYWxzZSB8fCByZXQgPT09IG5pbCkge1xuICAgICAgICAgIHNtYWxsZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXQuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBpZiAocmV0ID09PSAwKSB7IHJldHVybiBtaWQ7IH1cbiAgICAgICAgICBzbWFsbGVyID0gKHJldCA8IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3tgcmV0YC5jbGFzc30gKG11c3QgYmUgbnVtZXJpYywgdHJ1ZSwgZmFsc2Ugb3IgbmlsKVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNtYWxsZXIpIHsgbWF4ID0gbWlkOyB9IGVsc2UgeyBtaW4gPSBtaWQgKyAxOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzYXRpc2ZpZWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnNlYXJjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpic2VhcmNoIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGluZGV4ID0gYnNlYXJjaF9pbmRleCgmYmxvY2spXG5cbiAgICAleHtcbiAgICAgIGlmIChpbmRleCAhPSBudWxsICYmIGluZGV4LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjeWNsZShuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpjeWNsZSwgbikgZG9cbiAgICAgICAgaWYgbi5uaWw/XG4gICAgICAgICAgRmxvYXQ6OklORklOSVRZXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuID0gT3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpXG4gICAgICAgICAgbiA+IDAgPyBlbnVtZXJhdG9yX3NpemUgKiBuIDogMFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgcmV0dXJuIGlmIGVtcHR5PyB8fCBuID09IDBcblxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbmd0aCwgdmFsdWU7XG5cbiAgICAgIGlmIChuID09PSBuaWwpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG4gPSAje09wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xlYXJcbiAgICBgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpYFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY291bnQob2JqZWN0ID0gbmlsLCAmYmxvY2spXG4gICAgaWYgb2JqZWN0IHx8IGJsb2NrXG4gICAgICBzdXBlclxuICAgIGVsc2VcbiAgICAgIHNpemVcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgICByZXBsYWNlIG90aGVyXG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICBzZWxmW2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiBiaW5vbWlhbF9jb2VmZmljaWVudChuLCBrKSB7XG4gICAgICBpZiAobiA9PT0gayB8fCBrID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoayA+IDAgJiYgbiA+IGspIHtcbiAgICAgICAgcmV0dXJuIGJpbm9taWFsX2NvZWZmaWNpZW50KG4gLSAxLCBrIC0gMSkgKyBiaW5vbWlhbF9jb2VmZmljaWVudChuIC0gMSwgayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBjb21iaW5hdGlvbihuKVxuICAgIG51bSA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb21iaW5hdGlvbiwgbnVtKSB7IGBiaW5vbWlhbF9jb2VmZmljaWVudCgje3NlbGZ9Lmxlbmd0aCwgbnVtKWAgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHN0YWNrLCBjaG9zZW4sIGxldiwgZG9uZSwgbmV4dDtcblxuICAgICAgaWYgKG51bSA9PT0gMCkge1xuICAgICAgICAje3lpZWxkIFtdfVxuICAgICAgfSBlbHNlIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICN7eWllbGQgYFtzZWxmW2ldXWB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgI3t5aWVsZCBgc2VsZi5zbGljZSgpYH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA+PSAwICYmIG51bSA8IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPD0gbnVtICsgMTsgaSsrKSB7XG4gICAgICAgICAgc3RhY2sucHVzaCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNob3NlbiA9IFtdO1xuICAgICAgICBsZXYgPSAwO1xuICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIHN0YWNrWzBdID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW3N0YWNrW2xldisxXV07XG4gICAgICAgICAgd2hpbGUgKGxldiA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgIGxldisrO1xuICAgICAgICAgICAgbmV4dCA9IHN0YWNrW2xldisxXSA9IHN0YWNrW2xldl0gKyAxO1xuICAgICAgICAgICAgY2hvc2VuW2xldl0gPSBzZWxmW25leHRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAjeyB5aWVsZCBgY2hvc2VuLnNsaWNlKClgIH1cbiAgICAgICAgICBsZXYrKztcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBkb25lID0gKGxldiA9PT0gMCk7XG4gICAgICAgICAgICBzdGFja1tsZXZdKys7XG4gICAgICAgICAgICBsZXYtLTtcbiAgICAgICAgICB9IHdoaWxlICggc3RhY2tbbGV2KzFdICsgbnVtID09PSBzZWxmLmxlbmd0aCArIGxldiArIDEgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZXBlYXRlZF9jb21iaW5hdGlvbihuKVxuICAgIG51bSA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX2NvbWJpbmF0aW9uLCBudW0pIHsgYGJpbm9taWFsX2NvZWZmaWNpZW50KHNlbGYubGVuZ3RoICsgbnVtIC0gMSwgbnVtKWAgfVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKG1heCwgZnJvbSwgYnVmZmVyLCBzZWxmKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG1heCkge1xuICAgICAgICAgIHZhciBjb3B5ID0gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgI3t5aWVsZCBgY29weWB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHNlbGZbaV0pO1xuICAgICAgICAgIGl0ZXJhdGUobWF4LCBpLCBidWZmZXIsIHNlbGYpO1xuICAgICAgICAgIGJ1ZmZlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobnVtID49IDApIHtcbiAgICAgICAgaXRlcmF0ZShudW0sIDAsIFtdLCBzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY29tcGFjdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKGl0ZW0gPSBzZWxmW2ldKSAhPT0gbmlsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0IVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gc2VsZi5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmW2ldID09PSBuaWwpIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsID8gbmlsIDogc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb25jYXQoKm90aGVycylcbiAgICBvdGhlcnMgPSBvdGhlcnMubWFwIGRvIHxvdGhlcnxcbiAgICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgICAgZW5kXG5cbiAgICAgIGlmIG90aGVyLmVxdWFsPyhzZWxmKVxuICAgICAgICBvdGhlciA9IG90aGVyLmR1cFxuICAgICAgZW5kXG5cbiAgICAgIG90aGVyXG4gICAgZW5kXG5cbiAgICBvdGhlcnMuZWFjaCBkbyB8b3RoZXJ8XG4gICAgICAleHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG90aGVyLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5wdXNoKG90aGVyW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZGVsZXRlKG9iamVjdClcbiAgICAleHtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHNlbGYubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb3JpZ2luYWw7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gb2JqZWN0fSkge1xuICAgICAgICAgIHNlbGYuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWwpIHtcbiAgICAgICAgaWYgKCN7YmxvY2tfZ2l2ZW4/fSkge1xuICAgICAgICAgIHJldHVybiAje3lpZWxkfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfYXQoaW5kZXgpXG4gICAgJXh7XG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gc2VsZltpbmRleF07XG5cbiAgICAgIHNlbGYuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZGVsZXRlX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7ZmlsdGVySWYoc2VsZiwgJGZhbHN5LCBibG9jayl9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZGlmZmVyZW5jZSgqYXJyYXlzKVxuICAgIGFycmF5cy5yZWR1Y2UodG9fYS5kdXApIHsgfGEsIGJ8IGEgLSBiIH1cbiAgZW5kXG5cbiAgZGVmIGRpZyhpZHgsICppZHhzKVxuICAgIGl0ZW0gPSBzZWxmW2lkeF1cblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBpZHhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqaWR4cylcbiAgZW5kXG5cbiAgZGVmIGRyb3AobnVtYmVyKVxuICAgICV4e1xuICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZShudW1iZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5BcnJheSAmJlxuICAgICAgICAgIHNlbGYuJCRjbGFzcy4kYWxsb2NhdGUuJCRwcmlzdGluZSAmJlxuICAgICAgICAgIHNlbGYuJGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLiQkcHJpc3RpbmUgJiZcbiAgICAgICAgICBzZWxmLiRpbml0aWFsaXplX2R1cC4kJHByaXN0aW5lKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2luZGV4KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgcmVjdXJzZWQgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxbChhcnJheSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGksIGxlbmd0aCwgYSwgYjtcblxuICAgICAgICBpZiAoIW90aGVyLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9ICN7b3RoZXIudG9fYX07XG5cbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzZWRbI3tgYXJyYXlgLm9iamVjdF9pZH1dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGEgPSBhcnJheVtpXTtcbiAgICAgICAgICBiID0gb3RoZXJbaV07XG4gICAgICAgICAgaWYgKGEuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgaWYgKGIuJCRpc19hcnJheSAmJiBiLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZC5oYXNPd25Qcm9wZXJ0eSgje2BhYC5vYmplY3RfaWR9KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYC5lcWw/KGBiYCl9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWwoc2VsZiwgb3RoZXIpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZldGNoKGluZGV4LCBkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gaW5kZXg7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwgJiYgZGVmYXVsdHMgIT0gbnVsbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGJsb2NrIHN1cGVyc2VkZXMgZGVmYXVsdCB2YWx1ZSBhcmd1bWVudCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gYmxvY2sob3JpZ2luYWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmYXVsdHMgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAje3JhaXNlIEluZGV4RXJyb3IsIFwiaW5kZXggI3tgb3JpZ2luYWxgfSBvdXRzaWRlIG9mIGFycmF5IGJvdW5kczogMC4uLjBcIn1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAje3JhaXNlIEluZGV4RXJyb3IsIFwiaW5kZXggI3tgb3JpZ2luYWxgfSBvdXRzaWRlIG9mIGFycmF5IGJvdW5kczogLSN7YHNlbGYubGVuZ3RoYH0uLi4je2BzZWxmLmxlbmd0aGB9XCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZpbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlO1xuICAgIH1cblxuICAgIGlmIGJsb2NrXG4gICAgICBpZiBgYXJncy5sZW5ndGggPiAyYFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5sZW5ndGh9IGZvciAwLi4yKVwiXG4gICAgICBlbmRcblxuICAgICAgb25lLCB0d28gPSBhcmdzXG4gICAgZWxzZVxuICAgICAgaWYgYGFyZ3MubGVuZ3RoID09IDBgXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgwIGZvciAxLi4zKSdcbiAgICAgIGVsc2lmIGBhcmdzLmxlbmd0aCA+IDNgXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3thcmdzLmxlbmd0aH0gZm9yIDEuLjMpXCJcbiAgICAgIGVuZFxuXG4gICAgICBvYmosIG9uZSwgdHdvID0gYXJnc1xuICAgIGVuZFxuXG4gICAgaWYgUmFuZ2UgPT09IG9uZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnbGVuZ3RoIGludmFsaWQgd2l0aCByYW5nZScgaWYgdHdvXG5cbiAgICAgIGxlZnQgICA9IGAkY29lcmNlX3RvKG9uZS5iZWdpbiwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgYGxlZnQgKz0gdGhpcy5sZW5ndGhgIGlmIGBsZWZ0IDwgMGBcbiAgICAgIHJhaXNlIFJhbmdlRXJyb3IsIFwiI3tvbmUuaW5zcGVjdH0gb3V0IG9mIHJhbmdlXCIgaWYgYGxlZnQgPCAwYFxuXG4gICAgICByaWdodCA9IGAkY29lcmNlX3RvKG9uZS5lbmQsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGByaWdodCArPSB0aGlzLmxlbmd0aGAgaWYgYHJpZ2h0IDwgMGBcbiAgICAgIGByaWdodCArPSAxYCB1bmxlc3Mgb25lLmV4Y2x1ZGVfZW5kP1xuXG4gICAgICByZXR1cm4gc2VsZiBpZiBgcmlnaHQgPD0gbGVmdGBcbiAgICBlbHNpZiBvbmVcbiAgICAgIGxlZnQgICA9IGAkY29lcmNlX3RvKG9uZSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgYGxlZnQgKz0gdGhpcy5sZW5ndGhgIGlmIGBsZWZ0IDwgMGBcbiAgICAgIGxlZnQgICA9IDAgaWYgYGxlZnQgPCAwYFxuXG4gICAgICBpZiB0d29cbiAgICAgICAgcmlnaHQgPSBgJGNvZXJjZV90byh0d28sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgICByZXR1cm4gc2VsZiBpZiBgcmlnaHQgPT0gMGBcblxuICAgICAgICBgcmlnaHQgKz0gbGVmdGBcbiAgICAgIGVsc2VcbiAgICAgICAgcmlnaHQgPSBgdGhpcy5sZW5ndGhgXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBsZWZ0ICA9IDBcbiAgICAgIHJpZ2h0ID0gYHRoaXMubGVuZ3RoYFxuICAgIGVuZFxuXG4gICAgaWYgYGxlZnQgPiB0aGlzLmxlbmd0aGBcbiAgICAgICV4e1xuICAgICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aDsgaSA8IHJpZ2h0OyBpKyspIHtcbiAgICAgICAgICBzZWxmW2ldID0gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBpZiBgcmlnaHQgPiB0aGlzLmxlbmd0aGBcbiAgICAgIGB0aGlzLmxlbmd0aCA9IHJpZ2h0YFxuICAgIGVuZFxuXG4gICAgaWYgYmxvY2tcbiAgICAgICV4e1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRoaXMubGVuZ3RoOyBsZWZ0IDwgcmlnaHQ7IGxlZnQrKykge1xuICAgICAgICAgIHZhbHVlID0gYmxvY2sobGVmdCk7XG4gICAgICAgICAgc2VsZltsZWZ0XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgJXh7XG4gICAgICAgIGZvciAobGVuZ3RoID0gdGhpcy5sZW5ndGg7IGxlZnQgPCByaWdodDsgbGVmdCsrKSB7XG4gICAgICAgICAgc2VsZltsZWZ0XSA9ICN7b2JqfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZmlyc3QoY291bnQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoY291bnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IDAgPyBuaWwgOiBzZWxmWzBdO1xuICAgICAgfVxuXG4gICAgICBjb3VudCA9ICRjb2VyY2VfdG8oY291bnQsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKDAsIGNvdW50KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuKGxldmVsID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gX2ZsYXR0ZW4oYXJyYXksIGxldmVsKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIGksIGxlbmd0aCxcbiAgICAgICAgICAgIGl0ZW0sIGFyeTtcblxuICAgICAgICBhcnJheSA9ICN7YGFycmF5YC50b19hfTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBhcnJheVtpXTtcblxuICAgICAgICAgIGlmICghJHJlc3BvbmRfdG8oaXRlbSwgJyR0b19hcnknLCB0cnVlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnkgPSAje2BpdGVtYC50b19hcnl9O1xuXG4gICAgICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXJ5ID09PSBzZWxmKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoX2ZsYXR0ZW4oYXJ5KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX2ZsYXR0ZW4oYXJ5LCBsZXZlbCAtIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV2ZWwgPSAkY29lcmNlX3RvKGxldmVsLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZmxhdHRlbihzZWxmLCBsZXZlbCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmxhdHRlbiEobGV2ZWwgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgZmxhdHRlbmVkID0gI3tmbGF0dGVuIGxldmVsfTtcblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09IGZsYXR0ZW5lZC5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoc2VsZltpXSAhPT0gZmxhdHRlbmVkW2ldKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA9PSBsZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICN7cmVwbGFjZSBgZmxhdHRlbmVkYH07XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgICV4e1xuICAgICAgdmFyIHRvcCA9ICgkaGFzaF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgcmVzdWx0ID0gWydBJ10sXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIGl0ZW0sIGksIGtleTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICRoYXNoX2lkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gZWFybHkgZm9yIHJlY3Vyc2l2ZSBzdHJ1Y3R1cmVzXG4gICAgICAgIGlmICgkaGFzaF9pZHNbaGFzaF9pZF0pIHtcbiAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gJGhhc2hfaWRzKSB7XG4gICAgICAgICAgaXRlbSA9ICRoYXNoX2lkc1trZXldO1xuICAgICAgICAgIGlmICgje2VxbD8oYGl0ZW1gKX0pIHtcbiAgICAgICAgICAgIHJldHVybiAnc2VsZic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJGhhc2hfaWRzW2hhc2hfaWRdID0gc2VsZjtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0uJGhhc2goKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJywnKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAkaGFzaF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmNsdWRlPyhtZW1iZXIpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gbWVtYmVyfSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmRleChvYmplY3QgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlO1xuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGdpdmVuIGJsb2NrIG5vdCB1c2VkJyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UgJiYgdmFsdWUgIT09IG5pbCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7ZW51bV9mb3IgOmluZGV4fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNlcnQoaW5kZXgsICpvYmplY3RzKVxuICAgICV4e1xuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9IHNlbGYubGVuZ3RoICsgMTtcblxuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICN7IHJhaXNlIEluZGV4RXJyb3IsIFwiI3tpbmRleH0gaXMgb3V0IG9mIGJvdW5kc1wiIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IHNlbGYubGVuZ3RoOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgc2VsZi5wdXNoKG5pbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgW2luZGV4LCAwXS5jb25jYXQob2JqZWN0cykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBpZCAgICAgPSAje19faWRfX307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0gI3tzZWxmW2BpYF19O1xuXG4gICAgICAgIGlmICgje2BpdGVtYC5fX2lkX199ID09PSBpZCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCdbLi4uXScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCN7YGl0ZW1gLmluc3BlY3R9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnXSc7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW50ZXJzZWN0aW9uKCphcnJheXMpXG4gICAgYXJyYXlzLnJlZHVjZSh0b19hLmR1cCkgeyB8YSwgYnwgYSAmIGIgfVxuICBlbmRcblxuICBkZWYgam9pbihzZXAgPSBuaWwpXG4gICAgcmV0dXJuICcnIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIGlmIGBzZXAgPT09IG5pbGBcbiAgICAgIHNlcCA9ICQsXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBpLCBsZW5ndGgsIGl0ZW0sIHRtcDtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICBpZiAoJHJlc3BvbmRfdG8oaXRlbSwgJyR0b19zdHInKSkge1xuICAgICAgICAgIHRtcCA9ICN7YGl0ZW1gLnRvX3N0cn07XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCN7YHRtcGAudG9fc30pO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJHJlc3BvbmRfdG8oaXRlbSwgJyR0b19hcnknKSkge1xuICAgICAgICAgIHRtcCA9ICN7YGl0ZW1gLnRvX2FyeX07XG5cbiAgICAgICAgICBpZiAodG1wID09PSBzZWxmKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0bXAgIT09IG5pbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goI3tgdG1wYC5qb2luKHNlcCl9KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRyZXNwb25kX3RvKGl0ZW0sICckdG9fcycpKSB7XG4gICAgICAgICAgdG1wID0gI3tgaXRlbWAudG9fc307XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRtcCk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICN7cmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCIje2BPcGFsLmluc3BlY3QoaXRlbSlgfSBkb2Vzbid0IHJlc3BvbmQgdG8gI3RvX3N0ciwgI3RvX2FyeSBvciAjdG9fc1wiLCAndG9fc3RyJyl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VwID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oI3tPcGFsLmNvZXJjZV90byEoc2VwLCBTdHJpbmcsIDp0b19zdHIpLnRvX3N9KTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBrZWVwX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmtlZXBfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtmaWx0ZXJJZihzZWxmLCAkdHJ1dGh5LCBibG9jayl9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFzdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChjb3VudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gMCA/IG5pbCA6IHNlbGZbc2VsZi5sZW5ndGggLSAxXTtcbiAgICAgIH1cblxuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSd9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY291bnQgPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICBjb3VudCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZShzZWxmLmxlbmd0aCAtIGNvdW50LCBzZWxmLmxlbmd0aCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYHNlbGYubGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBtYXAgY29sbGVjdFxuXG4gIGFsaWFzIG1hcCEgY29sbGVjdCFcblxuICBkZWYgbWF4KG4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBlYWNoLm1heChuLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtaW4oJmJsb2NrKVxuICAgIGVhY2gubWluKCZibG9jaylcbiAgZW5kXG5cbiAgJXh7XG4gICAgLy8gUmV0dXJucyB0aGUgcHJvZHVjdCBvZiBmcm9tLCBmcm9tLTEsIC4uLiwgZnJvbSAtIGhvd19tYW55ICsgMS5cbiAgICBmdW5jdGlvbiBkZXNjZW5kaW5nX2ZhY3RvcmlhbChmcm9tLCBob3dfbWFueSkge1xuICAgICAgdmFyIGNvdW50ID0gaG93X21hbnkgPj0gMCA/IDEgOiAwO1xuICAgICAgd2hpbGUgKGhvd19tYW55KSB7XG4gICAgICAgIGNvdW50ICo9IGZyb207XG4gICAgICAgIGZyb20tLTtcbiAgICAgICAgaG93X21hbnktLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gIH1cblxuICBkZWYgcGVybXV0YXRpb24obnVtID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpwZXJtdXRhdGlvbiwgbnVtKSBkb1xuICAgICAgICBgZGVzY2VuZGluZ19mYWN0b3JpYWwoc2VsZi5sZW5ndGgsIG51bSA9PT0gdW5kZWZpbmVkID8gc2VsZi5sZW5ndGggOiBudW0pYFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBwZXJtdXRlLCBvZmZlbnNpdmUsIG91dHB1dDtcblxuICAgICAgaWYgKG51bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG51bSA9IHNlbGYubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG51bSA9ICRjb2VyY2VfdG8obnVtLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW0gPCAwIHx8IHNlbGYubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgIC8vIG5vIHBlcm11dGF0aW9ucywgeWllbGQgbm90aGluZ1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAwKSB7XG4gICAgICAgIC8vIGV4YWN0bHkgb25lIHBlcm11dGF0aW9uOiB0aGUgemVyby1sZW5ndGggYXJyYXlcbiAgICAgICAgI3sgeWllbGQgW10gfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAobnVtID09PSAxKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzcGVjaWFsLCBlYXN5IGNhc2VcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgI3sgeWllbGQgYFtzZWxmW2ldXWAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZ2VuZXJhbCBjYXNlXG4gICAgICAgICN7IHBlcm0gPSBBcnJheS5uZXcobnVtKSB9O1xuICAgICAgICAjeyB1c2VkID0gQXJyYXkubmV3KGBzZWxmLmxlbmd0aGAsIGZhbHNlKSB9O1xuXG4gICAgICAgIHBlcm11dGUgPSBmdW5jdGlvbihudW0sIHBlcm0sIGluZGV4LCB1c2VkLCBibGspIHtcbiAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZigjeyAhdXNlZFtgaWBdIH0pIHtcbiAgICAgICAgICAgICAgcGVybVtpbmRleF0gPSBpO1xuICAgICAgICAgICAgICBpZihpbmRleCA8IG51bSAtIDEpIHtcbiAgICAgICAgICAgICAgICB1c2VkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwZXJtdXRlLmNhbGwoc2VsZiwgbnVtLCBwZXJtLCBpbmRleCArIDEsIHVzZWQsIGJsayk7XG4gICAgICAgICAgICAgICAgdXNlZFtpXSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGVybS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2VsZltwZXJtW2pdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICR5aWVsZDEoYmxrLCBvdXRwdXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YmxvY2tfZ2l2ZW4/fSkge1xuICAgICAgICAgIC8vIG9mZmVuc2l2ZSAoYm90aCBkZWZpbml0aW9ucykgY29weS5cbiAgICAgICAgICBvZmZlbnNpdmUgPSBzZWxmLnNsaWNlKCk7XG4gICAgICAgICAgcGVybXV0ZS5jYWxsKG9mZmVuc2l2ZSwgbnVtLCBwZXJtLCAwLCB1c2VkLCBibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcGVybXV0ZS5jYWxsKHNlbGYsIG51bSwgcGVybSwgMCwgdXNlZCwgYmxvY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVwZWF0ZWRfcGVybXV0YXRpb24obilcbiAgICBudW0gPSBPcGFsLmNvZXJjZV90byEgbiwgSW50ZWdlciwgOnRvX2ludFxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVwZWF0ZWRfcGVybXV0YXRpb24sIG51bSkgeyBudW0gPj0gMCA/IHNpemUqKm51bSA6IDAgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZ1bmN0aW9uIGl0ZXJhdGUobWF4LCBidWZmZXIsIHNlbGYpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gbWF4KSB7XG4gICAgICAgICAgdmFyIGNvcHkgPSBidWZmZXIuc2xpY2UoKTtcbiAgICAgICAgICAje3lpZWxkIGBjb3B5YH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2goc2VsZltpXSk7XG4gICAgICAgICAgaXRlcmF0ZShtYXgsIGJ1ZmZlciwgc2VsZik7XG4gICAgICAgICAgYnVmZmVyLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGUobnVtLCBbXSwgc2VsZi5zbGljZSgpKTtcbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwb3AoY291bnQgPSB1bmRlZmluZWQpXG4gICAgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG4gICAgICByZXR1cm4gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuICAgICAgcmV0dXJuIGBzZWxmLnBvcCgpYFxuICAgIGVuZFxuXG4gICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYGNvdW50IDwgMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIFtdIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIGlmIGBjb3VudCA9PT0gMWBcbiAgICAgIGBbc2VsZi5wb3AoKV1gXG4gICAgZWxzaWYgYGNvdW50ID4gc2VsZi5sZW5ndGhgXG4gICAgICBgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpYFxuICAgIGVsc2VcbiAgICAgIGBzZWxmLnNwbGljZShzZWxmLmxlbmd0aCAtIGNvdW50LCBzZWxmLmxlbmd0aClgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBwcm9kdWN0KCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gI3tibG9ja19naXZlbj99ID8gbnVsbCA6IFtdLFxuICAgICAgICAgIG4gPSBhcmdzLmxlbmd0aCArIDEsXG4gICAgICAgICAgY291bnRlcnMgPSBuZXcgQXJyYXkobiksXG4gICAgICAgICAgbGVuZ3RocyAgPSBuZXcgQXJyYXkobiksXG4gICAgICAgICAgYXJyYXlzICAgPSBuZXcgQXJyYXkobiksXG4gICAgICAgICAgaSwgbSwgc3ViYXJyYXksIGxlbiwgcmVzdWx0bGVuID0gMTtcblxuICAgICAgYXJyYXlzWzBdID0gc2VsZjtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgYXJyYXlzW2ldID0gJGNvZXJjZV90byhhcmdzW2kgLSAxXSwgI3tBcnJheX0sICd0b19hcnknKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBsZW4gPSBhcnJheXNbaV0ubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdGxlbiAqPSBsZW47XG4gICAgICAgIGlmIChyZXN1bHRsZW4gPiAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCAndG9vIGJpZyB0byBwcm9kdWN0J31cbiAgICAgICAgfVxuICAgICAgICBsZW5ndGhzW2ldID0gbGVuO1xuICAgICAgICBjb3VudGVyc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIG91dGVyX2xvb3A6IGZvciAoOzspIHtcbiAgICAgICAgc3ViYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHN1YmFycmF5LnB1c2goYXJyYXlzW2ldW2NvdW50ZXJzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHN1YmFycmF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAje3lpZWxkIGBzdWJhcnJheWB9XG4gICAgICAgIH1cbiAgICAgICAgbSA9IG4gLSAxO1xuICAgICAgICBjb3VudGVyc1ttXSsrO1xuICAgICAgICB3aGlsZSAoY291bnRlcnNbbV0gPT09IGxlbmd0aHNbbV0pIHtcbiAgICAgICAgICBjb3VudGVyc1ttXSA9IDA7XG4gICAgICAgICAgaWYgKC0tbSA8IDApIGJyZWFrIG91dGVyX2xvb3A7XG4gICAgICAgICAgY291bnRlcnNbbV0rKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0IHx8IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHVzaCgqb2JqZWN0cylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmplY3RzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYucHVzaChvYmplY3RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGFwcGVuZCBwdXNoXG5cbiAgZGVmIHJhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICBpZiAoaXRlbS5sZW5ndGggJiYgaXRlbVsxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCN7YGl0ZW1bMV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBibG9jayhzZWxmW2ldKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIG9yaWdpbmFsID0gbGVuZ3RoXG4gICAgZGVsZXRlX2lmKCZibG9jaylcblxuICAgIHVubGVzcyBsZW5ndGggPT0gb3JpZ2luYWxcbiAgICAgIHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJlcGxhY2Uob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3tBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKTtcbiAgICAgIHNlbGYucHVzaC5hcHBseShzZWxmLCBvdGhlcik7XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmV2ZXJzZVxuICAgIGBzZWxmLnNsaWNlKDApLnJldmVyc2UoKWBcbiAgZW5kXG5cbiAgZGVmIHJldmVyc2UhXG4gICAgYHNlbGYucmV2ZXJzZSgpYFxuICBlbmRcblxuICBkZWYgcmV2ZXJzZV9lYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJldmVyc2VfZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgcmV2ZXJzZS5lYWNoKCZibG9jaylcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByaW5kZXgob2JqZWN0ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgdmFsdWU7XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7d2Fybignd2FybmluZzogZ2l2ZW4gYmxvY2sgbm90IHVzZWQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IHNlbGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAoaSA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBgb2JqZWN0YH0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSBzZWxmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGkgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IGZhbHNlICYmIHZhbHVlICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICN7ZW51bV9mb3IgOnJpbmRleH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcm90YXRlKG4gPSAxKVxuICAgICV4e1xuICAgICAgdmFyIGFyeSwgaWR4LCBmaXJzdFBhcnQsIGxhc3RQYXJ0O1xuXG4gICAgICBuID0gJGNvZXJjZV90byhuLCAje0ludGVnZXJ9LCAndG9faW50JylcblxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBhcnkgPSBzZWxmLnNsaWNlKCk7XG4gICAgICBpZHggPSBuICUgYXJ5Lmxlbmd0aDtcblxuICAgICAgZmlyc3RQYXJ0ID0gYXJ5LnNsaWNlKGlkeCk7XG4gICAgICBsYXN0UGFydCA9IGFyeS5zbGljZSgwLCBpZHgpO1xuICAgICAgcmV0dXJuIGZpcnN0UGFydC5jb25jYXQobGFzdFBhcnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZSEoY250ID0gMSlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCB8fCBzZWxmLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIGNudCA9ICRjb2VyY2VfdG8oY250LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG4gICAgfVxuICAgIGFyeSA9IHJvdGF0ZShjbnQpXG4gICAgcmVwbGFjZSBhcnlcbiAgZW5kXG5cbiAgY2xhc3MgU2FtcGxlUmFuZG9tXG4gICAgZGVmIGluaXRpYWxpemUocm5nKVxuICAgICAgQHJuZyA9IHJuZ1xuICAgIGVuZFxuXG4gICAgZGVmIHJhbmQoc2l6ZSlcbiAgICAgIHJhbmRvbSA9IGAkY29lcmNlX3RvKCN7QHJuZy5yYW5kKHNpemUpfSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ3JhbmRvbSB2YWx1ZSBtdXN0IGJlID49IDAnIGlmIGByYW5kb20gPCAwYFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ3JhbmRvbSB2YWx1ZSBtdXN0IGJlIGxlc3MgdGhhbiBBcnJheSBzaXplJyB1bmxlc3MgYHJhbmRvbSA8IHNpemVgXG5cbiAgICAgIHJhbmRvbVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2FtcGxlKGNvdW50ID0gdW5kZWZpbmVkLCBvcHRpb25zID0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBhdCBLZXJuZWwucmFuZChgc2VsZi5sZW5ndGhgKSBpZiBgY291bnQgPT09IHVuZGVmaW5lZGBcblxuICAgIGlmIGBvcHRpb25zID09PSB1bmRlZmluZWRgXG4gICAgICBpZiAobyA9IE9wYWwuY29lcmNlX3RvPyBjb3VudCwgSGFzaCwgOnRvX2hhc2gpXG4gICAgICAgIG9wdGlvbnMgPSBvXG4gICAgICAgIGNvdW50ID0gbmlsXG4gICAgICBlbHNlXG4gICAgICAgIG9wdGlvbnMgPSBuaWxcbiAgICAgICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgb3B0aW9ucyA9IGAkY29lcmNlX3RvKG9wdGlvbnMsICN7SGFzaH0sICd0b19oYXNoJylgXG4gICAgZW5kXG5cbiAgICBpZiBjb3VudCAmJiBgY291bnQgPCAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2NvdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnXG4gICAgZW5kXG5cbiAgICBybmcgPSBvcHRpb25zWzpyYW5kb21dIGlmIG9wdGlvbnNcbiAgICBybmcgPSBpZiBybmcgJiYgcm5nLnJlc3BvbmRfdG8/KDpyYW5kKVxuICAgICAgICAgICAgU2FtcGxlUmFuZG9tLm5ldyBybmdcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBLZXJuZWxcbiAgICAgICAgICBlbmRcblxuICAgIHJldHVybiBgc2VsZlsje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfV1gIHVubGVzcyBjb3VudFxuXG4gICAgJXh7XG5cbiAgICAgIHZhciBhYmFuZG9uLCBzcGluLCByZXN1bHQsIGksIGosIGssIHRhcmdldEluZGV4LCBvbGRWYWx1ZTtcblxuICAgICAgaWYgKGNvdW50ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgY291bnQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIFtzZWxmWyN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9XV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgaiA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICBqID0gaSA9PT0gMCA/IGkgKyAxIDogaSAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbc2VsZltpXSwgc2VsZltqXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHNlbGYubGVuZ3RoIC8gY291bnQgPiAzKSB7XG4gICAgICAgICAgICBhYmFuZG9uID0gZmFsc2U7XG4gICAgICAgICAgICBzcGluID0gMDtcblxuICAgICAgICAgICAgcmVzdWx0ID0gI3sgQXJyYXkubmV3KGNvdW50KSB9O1xuICAgICAgICAgICAgaSA9IDE7XG5cbiAgICAgICAgICAgIHJlc3VsdFswXSA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICBrID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICAgIGogPSAwO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChqIDwgaSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChrID09PSByZXN1bHRbal0pIHtcbiAgICAgICAgICAgICAgICAgIHNwaW4rKztcbiAgICAgICAgICAgICAgICAgIGlmIChzcGluID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFiYW5kb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGsgPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFiYW5kb24pIHsgYnJlYWs7IH1cblxuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhYmFuZG9uKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgICAgICAgcmVzdWx0W2ldID0gaztcblxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYWJhbmRvbikge1xuICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGZbcmVzdWx0W2ldXTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuc2xpY2UoKTtcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY291bnQ7IGMrKykge1xuICAgICAgICAgICAgdGFyZ2V0SW5kZXggPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gcmVzdWx0W2NdO1xuICAgICAgICAgICAgcmVzdWx0W2NdID0gcmVzdWx0W3RhcmdldEluZGV4XTtcbiAgICAgICAgICAgIHJlc3VsdFt0YXJnZXRJbmRleF0gPSBvbGRWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY291bnQgPT09IHNlbGYubGVuZ3RoID8gcmVzdWx0IDogI3tgcmVzdWx0YFswLCBjb3VudF19O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW0sIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBpdGVtKTtcblxuICAgICAgICBpZiAoJHRydXRoeSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcbiAgICAgICN7IGtlZXBfaWYoJmJsb2NrKSB9O1xuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbCA/IG5pbCA6IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuXG4gIGRlZiBzaGlmdChjb3VudCA9IHVuZGVmaW5lZClcbiAgICBpZiBgY291bnQgPT09IHVuZGVmaW5lZGBcbiAgICAgIHJldHVybiBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG4gICAgICByZXR1cm4gYHNoaWZ0Tm9Bcmcoc2VsZilgXG4gICAgZW5kXG5cbiAgICBjb3VudCA9IGAkY29lcmNlX3RvKGNvdW50LCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgY291bnQgPCAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnXG4gICAgZW5kXG5cbiAgICByZXR1cm4gW10gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgYHNlbGYuc3BsaWNlKDAsIGNvdW50KWBcbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcblxuICBkZWYgc2h1ZmZsZShybmcgPSB1bmRlZmluZWQpXG4gICAgZHVwLnRvX2Euc2h1ZmZsZSEocm5nKVxuICBlbmRcblxuICBkZWYgc2h1ZmZsZSEocm5nID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIHJhbmRnZW4sIGkgPSBzZWxmLmxlbmd0aCwgaiwgdG1wO1xuXG4gICAgICBpZiAocm5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcm5nID0gI3tPcGFsLmNvZXJjZV90bz8ocm5nLCBIYXNoLCA6dG9faGFzaCl9O1xuXG4gICAgICAgIGlmIChybmcgIT09IG5pbCkge1xuICAgICAgICAgIHJuZyA9ICN7cm5nWzpyYW5kb21dfTtcblxuICAgICAgICAgIGlmIChybmcgIT09IG5pbCAmJiAje3JuZy5yZXNwb25kX3RvPyg6cmFuZCl9KSB7XG4gICAgICAgICAgICByYW5kZ2VuID0gcm5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaSkge1xuICAgICAgICBpZiAocmFuZGdlbikge1xuICAgICAgICAgIGogPSByYW5kZ2VuLiRyYW5kKGkpLiR0b19pbnQoKTtcblxuICAgICAgICAgIGlmIChqIDwgMCkge1xuICAgICAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCBcInJhbmRvbSBudW1iZXIgdG9vIHNtYWxsICN7YGpgfVwifVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChqID49IGkpIHtcbiAgICAgICAgICAgICN7cmFpc2UgUmFuZ2VFcnJvciwgXCJyYW5kb20gbnVtYmVyIHRvbyBiaWcgI3tgamB9XCJ9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGogPSAje3JhbmQoYGlgKX07XG4gICAgICAgIH1cblxuICAgICAgICB0bXAgPSBzZWxmWy0taV07XG4gICAgICAgIHNlbGZbaV0gPSBzZWxmW2pdO1xuICAgICAgICBzZWxmW2pdID0gdG1wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNsaWNlIFtdXG5cbiAgZGVmIHNsaWNlIShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgIHJlc3VsdCA9IG5pbFxuXG4gICAgaWYgYGxlbmd0aCA9PT0gdW5kZWZpbmVkYFxuICAgICAgaWYgUmFuZ2UgPT09IGluZGV4XG4gICAgICAgIHJhbmdlID0gaW5kZXhcbiAgICAgICAgcmVzdWx0ID0gc2VsZltyYW5nZV1cblxuICAgICAgICByYW5nZV9zdGFydCA9IGAkY29lcmNlX3RvKHJhbmdlLmJlZ2luLCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIHJhbmdlX2VuZCA9IGAkY29lcmNlX3RvKHJhbmdlLmVuZCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IDApIHtcbiAgICAgICAgICAgIHJhbmdlX3N0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9lbmQgPCAwKSB7XG4gICAgICAgICAgICByYW5nZV9lbmQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZV9lbmQgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJhbmdlX2VuZCA9IHNlbGYubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5leGNsKSB7XG4gICAgICAgICAgICAgIHJhbmdlX2VuZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByYW5nZV9sZW5ndGggPSByYW5nZV9lbmQgLSByYW5nZV9zdGFydDtcbiAgICAgICAgICBpZiAocmFuZ2UuZXhjbCkge1xuICAgICAgICAgICAgcmFuZ2VfZW5kIC09IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlX2xlbmd0aCArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYW5nZV9zdGFydCA8IHNlbGYubGVuZ3RoICYmIHJhbmdlX3N0YXJ0ID49IDAgJiYgcmFuZ2VfZW5kIDwgc2VsZi5sZW5ndGggJiYgcmFuZ2VfZW5kID49IDAgJiYgcmFuZ2VfbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2VsZi5zcGxpY2UocmFuZ2Vfc3RhcnQsIHJhbmdlX2xlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHN0YXJ0ID0gYCRjb2VyY2VfdG8oaW5kZXgsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgc3RhcnQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSBzZWxmW3N0YXJ0XTtcblxuICAgICAgICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgc2VsZi5zaGlmdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnNwbGljZShzdGFydCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBzdGFydCA9IGAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBsZW5ndGggPSBgJGNvZXJjZV90byhsZW5ndGgsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgJXh7XG4gICAgICAgIGlmIChsZW5ndGggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxlbmd0aDtcblxuICAgICAgICByZXN1bHQgPSAje3NlbGZbc3RhcnQsIGxlbmd0aF19O1xuXG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICBzdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCArIGxlbmd0aCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggLSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCA8IHNlbGYubGVuZ3RoICYmIHN0YXJ0ID49IDApIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShzdGFydCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgc29ydCgmYmxvY2spXG4gICAgcmV0dXJuIHNlbGYgdW5sZXNzIGBzZWxmLmxlbmd0aCA+IDFgXG5cbiAgICAleHtcbiAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgIGJsb2NrID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiAje2BhYCA8PT4gYGJgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHJldCA9IGJsb2NrKHgsIHkpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7YHhgLmluc3BlY3R9IHdpdGggI3tgeWAuaW5zcGVjdH0gZmFpbGVkXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7YHJldGAgPiAwfSA/IDEgOiAoI3tgcmV0YCA8IDB9ID8gLTEgOiAwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvcnQhKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgcmVzdWx0ID0gI3tgc2VsZi5zbGljZSgpYC5zb3J0KCZibG9jayl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9ICN7YHNlbGYuc2xpY2UoKWAuc29ydH07XG4gICAgICB9XG5cbiAgICAgIHNlbGYubGVuZ3RoID0gMDtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2gocmVzdWx0W2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc29ydF9ieSEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c29ydF9ieSEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHJlcGxhY2Ugc29ydF9ieSgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiB0YWtlKGNvdW50KVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50IDwgMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3J9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZSgwLCBjb3VudCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdGFrZV93aGlsZSgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aCwgaXRlbSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcblxuICAgICAgICB2YWx1ZSA9IGJsb2NrKGl0ZW0pO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGNsYXNzID09PSBPcGFsLkFycmF5KSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLkFycmF5LiRuZXcoc2VsZik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fYXJ5XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9faCgmYmxvY2spXG4gICAgYXJyYXkgPSBzZWxmXG4gICAgYXJyYXkgPSBhcnJheS5tYXAoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGksIGxlbiA9IGFycmF5Lmxlbmd0aCwgYXJ5LCBrZXksIHZhbCwgaGFzaCA9ICN7e319O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYXJ5ID0gI3tPcGFsLmNvZXJjZV90bz8oYGFycmF5W2ldYCwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgICAgaWYgKCFhcnkuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGVsZW1lbnQgdHlwZSAje2BhcnlgLmNsYXNzfSBhdCAje2BpYH0gKGV4cGVjdGVkIGFycmF5KVwifVxuICAgICAgICB9XG4gICAgICAgIGlmIChhcnkubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIGFycmF5IGxlbmd0aCBhdCAje2BpYH0gKGV4cGVjdGVkIDIsIHdhcyAje2BhcnlgLmxlbmd0aH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gYXJ5WzBdO1xuICAgICAgICB2YWwgPSBhcnlbMV07XG4gICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG5cbiAgZGVmIHRyYW5zcG9zZVxuICAgIHJldHVybiBbXSBpZiBlbXB0eT9cblxuICAgIHJlc3VsdCA9IFtdXG4gICAgbWF4ICAgID0gbmlsXG5cbiAgICBlYWNoIGRvIHxyb3d8XG4gICAgICByb3cgPSBpZiBBcnJheSA9PT0gcm93XG4gICAgICAgICAgICAgIHJvdy50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKHJvdywgI3tBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICAgIG1heCB8fD0gYHJvdy5sZW5ndGhgXG5cbiAgICAgIGlmIGByb3cubGVuZ3RoYCAhPSBtYXhcbiAgICAgICAgcmFpc2UgSW5kZXhFcnJvciwgXCJlbGVtZW50IHNpemUgZGlmZmVycyAoI3tgcm93Lmxlbmd0aGB9IHNob3VsZCBiZSAje21heH0pXCJcbiAgICAgIGVuZFxuXG4gICAgICBgcm93Lmxlbmd0aGAudGltZXMgZG8gfGl8XG4gICAgICAgIGVudHJ5ID0gKHJlc3VsdFtpXSB8fD0gW10pXG4gICAgICAgIGVudHJ5IDw8IHJvdy5hdChpKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIHVuaW9uKCphcnJheXMpXG4gICAgYXJyYXlzLnJlZHVjZSh1bmlxKSB7IHxhLCBifCBhIHwgYiB9XG4gIGVuZFxuXG4gIGRlZiB1bmlxKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbSwga2V5O1xuXG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgICAgaWYgKCRoYXNoX2dldChoYXNoLCBpdGVtKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwgaXRlbSwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICAgIGtleSA9ICR5aWVsZDEoYmxvY2ssIGl0ZW0pO1xuICAgICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwga2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCBpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7YGhhc2hgLnZhbHVlc307XG4gICAgfVxuICBlbmRcblxuICBkZWYgdW5pcSEoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsX2xlbmd0aCA9IHNlbGYubGVuZ3RoLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbSwga2V5O1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvcmlnaW5hbF9sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAga2V5ID0gKGJsb2NrID09PSBuaWwgPyBpdGVtIDogJHlpZWxkMShibG9jaywgaXRlbSkpO1xuXG4gICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwga2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgaXRlbSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcbiAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbF9sZW5ndGggPyBuaWwgOiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVuc2hpZnQoKm9iamVjdHMpXG4gICAgJXh7XG4gICAgICB2YXIgc2VsZkxlbmd0aCA9IHNlbGYubGVuZ3RoXG4gICAgICB2YXIgb2JqZWN0c0xlbmd0aCA9IG9iamVjdHMubGVuZ3RoXG4gICAgICBpZiAob2JqZWN0c0xlbmd0aCA9PSAwKSByZXR1cm4gc2VsZjtcbiAgICAgIHZhciBpbmRleCA9IHNlbGZMZW5ndGggLSBvYmplY3RzTGVuZ3RoXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHNMZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2goc2VsZltpbmRleCArIGldKVxuICAgICAgfVxuICAgICAgdmFyIGxlbiA9IHNlbGZMZW5ndGggLSAxXG4gICAgICB3aGlsZSAobGVuIC0gb2JqZWN0c0xlbmd0aCA+PSAwKSB7XG4gICAgICAgIHNlbGZbbGVuXSA9IHNlbGZbbGVuIC0gb2JqZWN0c0xlbmd0aF1cbiAgICAgICAgbGVuLS1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0c0xlbmd0aDsgaisrKSB7XG4gICAgICAgIHNlbGZbal0gPSBvYmplY3RzW2pdXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHByZXBlbmQgdW5zaGlmdFxuXG4gIGRlZiB2YWx1ZXNfYXQoKmFyZ3MpXG4gICAgb3V0ID0gW11cblxuICAgIGFyZ3MuZWFjaCBkbyB8ZWxlbXxcbiAgICAgIGlmIGVsZW0uaXNfYT8gUmFuZ2VcbiAgICAgICAgZmluaXNoID0gYCRjb2VyY2VfdG8oI3tlbGVtLmxhc3R9LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIHN0YXJ0ID0gYCRjb2VyY2VfdG8oI3tlbGVtLmZpcnN0fSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgKyBzZWxmLmxlbmd0aDtcbiAgICAgICAgICAgICN7bmV4dH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJXh7XG4gICAgICAgICAgaWYgKGZpbmlzaCA8IDApIHtcbiAgICAgICAgICAgIGZpbmlzaCA9IGZpbmlzaCArIHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoI3tlbGVtLmV4Y2x1ZGVfZW5kP30pIHtcbiAgICAgICAgICAgIGZpbmlzaC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmluaXNoIDwgc3RhcnQpIHtcbiAgICAgICAgICAgICN7bmV4dH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQudXB0byhmaW5pc2gpIHsgfGl8IG91dCA8PCBhdChpKSB9XG4gICAgICBlbHNlXG4gICAgICAgIGkgPSBgJGNvZXJjZV90byhlbGVtLCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgIG91dCA8PCBhdChpKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBvdXRcbiAgZW5kXG5cbiAgZGVmIHppcCgqb3RoZXJzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIHNpemUgPSBzZWxmLmxlbmd0aCwgcGFydCwgbywgaSwgaiwgamo7XG5cbiAgICAgIGZvciAoaiA9IDAsIGpqID0gb3RoZXJzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgbyA9IG90aGVyc1tqXTtcbiAgICAgICAgaWYgKG8uJCRpc19hcnJheSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLiQkaXNfcmFuZ2UgfHwgby4kJGlzX2VudW1lcmF0b3IpIHtcbiAgICAgICAgICBvdGhlcnNbal0gPSBvLiR0YWtlKHNpemUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyc1tqXSA9ICN7KFxuICAgICAgICAgIE9wYWwuY29lcmNlX3RvPyhgb2AsIEFycmF5LCA6dG9fYXJ5KSB8fFxuICAgICAgICAgIE9wYWwuY29lcmNlX3RvIShgb2AsIEVudW1lcmF0b3IsIDp0b19lbnVtLCA6ZWFjaClcbiAgICAgICAgKS50b19hfTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBwYXJ0ID0gW3NlbGZbaV1dO1xuXG4gICAgICAgIGZvciAoaiA9IDAsIGpqID0gb3RoZXJzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICBvID0gb3RoZXJzW2pdW2ldO1xuXG4gICAgICAgICAgaWYgKG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgbyA9IG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0W2ogKyAxXSA9IG87XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRbaV0gPSBwYXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgYmxvY2socmVzdWx0W2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5pbmhlcml0ZWQoa2xhc3MpXG4gICAgJXh7XG4gICAgICBrbGFzcy4kJHByb3RvdHlwZS4kdG9fYSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbGljZSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVzXG4gICAgc3VwZXIucmVqZWN0IHsgfGl2YXJ8IGAvXkBcXGQrJC8udGVzdCgje2l2YXJ9KWAgfHwgaXZhciA9PSAnQGxlbmd0aCcgfVxuICBlbmRcblxuICBPcGFsLnByaXN0aW5lIHNpbmdsZXRvbl9jbGFzcywgOmFsbG9jYXRlXG4gIE9wYWwucHJpc3RpbmUgc2VsZiwgOmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzLCA6aW5pdGlhbGl6ZV9kdXBcblxuICBkZWYgcGFjaygqYXJncylcbiAgICByYWlzZSBcIlRvIHVzZSBBcnJheSNwYWNrLCB5b3UgbXVzdCBmaXJzdCByZXF1aXJlICdjb3JlbGliL2FycmF5L3BhY2snLlwiXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsInRvX2EiLCJbXSIsInNlbGYiLCJpbml0aWFsaXplIiwid2FybiIsInJhaXNlIiwicmVwbGFjZSIsInNpemUiLCJyZXNwb25kX3RvPyIsInRvX2FyeSIsInRyeV9jb252ZXJ0IiwiY29lcmNlX3RvPyIsIm9iaiIsIiYiLCJvdGhlciIsIj09PSIsInwiLCIqIiwiam9pbiIsInRvX3N0ciIsIisiLCItIiwiPDwiLCI8PT4iLCJoYXNoIiwiPT0iLCJvYmplY3RfaWQiLCJbXT0iLCJpbmRleCIsImRhdGEiLCJ2YWx1ZSIsImluc3BlY3QiLCJsZW5ndGgiLCIxIiwiZXh0cmEiLCJhbnk/IiwiYXNzb2MiLCJvYmplY3QiLCJhdCIsImJzZWFyY2hfaW5kZXgiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImJzZWFyY2giLCJibG9jayIsImN5Y2xlIiwibiIsIm5pbD8iLCJjb2VyY2VfdG8hIiwiPiIsIjAiLCJlbnVtZXJhdG9yX3NpemUiLCIkcmV0X29yXzEiLCJlbXB0eT8iLCJjbGVhciIsImNvdW50IiwiJHJldF9vcl8yIiwiaW5pdGlhbGl6ZV9jb3B5IiwiY29sbGVjdCIsImNvbGxlY3QhIiwiY29tYmluYXRpb24iLCJudW0iLCJyZXBlYXRlZF9jb21iaW5hdGlvbiIsImNvbXBhY3QiLCJjb21wYWN0ISIsImNvbmNhdCIsIm90aGVycyIsIm1hcCIsImVxdWFsPyIsImR1cCIsImVhY2giLCJkZWxldGUiLCJkZWxldGVfYXQiLCJkZWxldGVfaWYiLCJkaWZmZXJlbmNlIiwicmVkdWNlIiwiYXJyYXlzIiwiYSIsImIiLCJkaWciLCJpdGVtIiwiaWR4IiwiaWR4cyIsImRyb3AiLCJlYWNoX2luZGV4IiwiZXFsPyIsImZldGNoIiwiZmlsbCIsImFyZ3MiLCJvbmUiLCJ0d28iLCJsZWZ0IiwicmlnaHQiLCJleGNsdWRlX2VuZD8iLCJmaXJzdCIsImZsYXR0ZW4iLCJmbGF0dGVuISIsImxldmVsIiwiaW5jbHVkZT8iLCJtZW1iZXIiLCJpbnNlcnQiLCJfX2lkX18iLCJpbnRlcnNlY3Rpb24iLCJzZXAiLCIkLCIsInRvX3MiLCJuZXciLCJrZWVwX2lmIiwibGFzdCIsIm1heCIsIm1pbiIsInBlcm11dGF0aW9uIiwicGVybSIsInVzZWQiLCIhIiwicmVwZWF0ZWRfcGVybXV0YXRpb24iLCI+PSIsIioqIiwicG9wIiwicHJvZHVjdCIsInB1c2giLCJyYXNzb2MiLCJyZWplY3QiLCJyZWplY3QhIiwib3JpZ2luYWwiLCJyZXZlcnNlIiwicmV2ZXJzZSEiLCJyZXZlcnNlX2VhY2giLCJyaW5kZXgiLCJyb3RhdGUiLCJyb3RhdGUhIiwiYXJ5IiwiY250IiwiQHJuZyIsInJuZyIsInJhbmQiLCJyYW5kb20iLCJzYW1wbGUiLCJvIiwib3B0aW9ucyIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsInNlbGVjdCIsInNlbGVjdCEiLCJzaGlmdCIsInNodWZmbGUiLCJzaHVmZmxlISIsInNsaWNlISIsInJlc3VsdCIsInJhbmdlIiwicmFuZ2Vfc3RhcnQiLCJyYW5nZV9lbmQiLCJzdGFydCIsInNvcnQiLCI8Iiwic29ydCEiLCJzb3J0X2J5ISIsInNvcnRfYnkiLCJ0YWtlIiwidGFrZV93aGlsZSIsInRvX2giLCJhcnJheSIsInRyYW5zcG9zZSIsInJvdyIsIiRyZXRfb3JfNSIsIiE9IiwidGltZXMiLCJlbnRyeSIsIiRyZXRfb3JfNiIsImkiLCIkd3JpdGVyIiwidW5pb24iLCJ1bmlxIiwidmFsdWVzIiwidW5pcSEiLCJ1bnNoaWZ0IiwidmFsdWVzX2F0Iiwib3V0IiwiZWxlbSIsImlzX2E/IiwiZmluaXNoIiwidXB0byIsInppcCIsIiRyZXRfb3JfNyIsImluaGVyaXRlZCIsImluc3RhbmNlX3ZhcmlhYmxlcyIsIiRyZXRfb3Jf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QSw0REFBQTtBQUFBO0FBODJFVyxNQUFBLGtCQTkyRVg7QUFBQSxNQSsyRUksV0FBQXhMLE9BQUFBLENBQU0saUVBQU5BLENBLzJFSjtBQTgyRUV3TCxJQUFBQSxDQUFBQSw4QkFBQUEsQ0FBQUEsZ0JBdjJFQTtBQURGL0wsRUFBQUEsR0FBQUEsV0FBQUEsRUFBZSxLQUFmQSxXQUhBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTUyMTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2hhc2gucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG4jIC0tLVxuIyBJbnRlcm5hbCBwcm9wZXJ0aWVzOlxuI1xuIyAtICQkbWFwICAgICAgICAgW0pTOjpPYmplY3Q8U3RyaW5nID0+IGhhc2gtYnVja2V0Pl0gdGhlIGhhc2ggdGFibGUgZm9yIG9yZGluYXJ5IGtleXNcbiMgLSAkJHNtYXAgICAgICAgIFtKUzo6T2JqZWN0PFN0cmluZyA9PiBoYXNoLWJ1Y2tldD5dIHRoZSBoYXNoIHRhYmxlIGZvciBzdHJpbmcga2V5c1xuIyAtICQka2V5cyAgICAgICAgW0FycmF5PGhhc2gtYnVja2V0Pl0gdGhlIGxpc3Qgb2YgYWxsIGtleXNcbiMgLSAkJHByb2MgICAgICAgIFtQcm9jLG51bGwsbmlsXSB0aGUgZGVmYXVsdCBwcm9jIHVzZWQgZm9yIG1pc3Npbmcga2V5c1xuIyAtIGhhc2gtYnVja2V0ICAgW0pTOjpPYmplY3RdIGFuIGVsZW1lbnQgb2YgYSBsaW5rZWQgbGlzdCB0aGF0IGhvbGRzIGhhc2ggdmFsdWVzLCBrZXlzIGFyZSBge2tleTosa2V5X2hhc2g6LHZhbHVlOixuZXh0On1gXG5jbGFzcyBIYXNoXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gICMgTWFyayBhbGwgaGFzaCBpbnN0YW5jZXMgYXMgdmFsaWQgaGFzaGVzICh1c2VkIHRvIGNoZWNrIGtleXdvcmQgYXJncywgZXRjKVxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX2hhc2ggPSB0cnVlYFxuXG4gIGRlZiBzZWxmLltdKCphcmd2KVxuICAgICV4e1xuICAgICAgdmFyIGhhc2gsIGFyZ2MgPSBhcmd2Lmxlbmd0aCwgaTtcblxuICAgICAgaWYgKGFyZ2MgPT09IDEpIHtcbiAgICAgICAgaGFzaCA9ICN7T3BhbC5jb2VyY2VfdG8/KGFyZ3ZbMF0sIEhhc2gsIDp0b19oYXNoKX07XG4gICAgICAgIGlmIChoYXNoICE9PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gI3thbGxvY2F0ZS5tZXJnZSEoYGhhc2hgKX07XG4gICAgICAgIH1cblxuICAgICAgICBhcmd2ID0gI3tPcGFsLmNvZXJjZV90bz8oYXJndlswXSwgQXJyYXksIDp0b19hcnkpfTtcbiAgICAgICAgaWYgKGFyZ3YgPT09IG5pbCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ2MgPSBhcmd2Lmxlbmd0aDtcbiAgICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmdjOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWFyZ3ZbaV0uJCRpc19hcnJheSkgY29udGludWU7XG4gICAgICAgICAgc3dpdGNoKGFyZ3ZbaV0ubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaGFzaC4kc3RvcmUoYXJndltpXVswXSwgbmlsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV1bMF0sIGFyZ3ZbaV1bMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIG51bWJlciBvZiBlbGVtZW50cyAoI3tgYXJndltpXS5sZW5ndGhgfSBmb3IgMS4uMilcIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ2MgJSAyICE9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ29kZCBudW1iZXIgb2YgYXJndW1lbnRzIGZvciBIYXNoJ31cbiAgICAgIH1cblxuICAgICAgaGFzaCA9ICN7YWxsb2NhdGV9O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgaSArPSAyKSB7XG4gICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV0sIGFyZ3ZbaSArIDFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5hbGxvY2F0ZVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBuZXcgc2VsZi4kJGNvbnN0cnVjdG9yKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuXG4gICAgICBoYXNoLiQkbm9uZSA9IG5pbDtcbiAgICAgIGhhc2guJCRwcm9jID0gbmlsO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iailcbiAgICBPcGFsLmNvZXJjZV90bz8ob2JqLCBIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoZGVmYXVsdHMgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMSBmb3IgMCknfVxuICAgICAgfVxuICAgICAgc2VsZi4kJG5vbmUgPSAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCA/IG5pbCA6IGRlZmF1bHRzKTtcbiAgICAgIHNlbGYuJCRwcm9jID0gYmxvY2s7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW90aGVyLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggIT09IG90aGVyLiQka2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBvdGhlci4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9IE9wYWwuaGFzaF9nZXQob3RoZXIsIGtleS5rZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG90aGVyX3ZhbHVlID09PSB1bmRlZmluZWQgfHwgIXZhbHVlWyckZXFsPyddKG90aGVyX3ZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA+PShvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPCBvdGhlci4kJGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdCA9IHRydWVcblxuICAgIG90aGVyLmVhY2ggZG8gfG90aGVyX2tleSwgb3RoZXJfdmFsfFxuICAgICAgdmFsID0gZmV0Y2gob3RoZXJfa2V5LCBgbnVsbGApXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAodmFsID09IG51bGwgfHwgdmFsICE9PSBvdGhlcl92YWwpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQka2V5cy5sZW5ndGggPD0gb3RoZXIuJCRrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmID49IG90aGVyXG4gIGVuZFxuXG4gIGRlZiA8KG90aGVyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8hKG90aGVyLCBIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+IHNlbGZcbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8hKG90aGVyLCBIYXNoLCA6dG9faGFzaClcbiAgICBvdGhlciA+PSBzZWxmXG4gIGVuZFxuXG4gIGRlZiBbXShrZXkpXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJGRlZmF1bHQoa2V5KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcbiAgICAleHtcbiAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIGlmICgje2BrZXlgID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBba2V5LCBzZWxmLiQkc21hcFtrZXldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCN7YGtleS5rZXlgID09IG9iamVjdH0pIHtcbiAgICAgICAgICAgIHJldHVybiBba2V5LmtleSwga2V5LnZhbHVlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbGVhclxuICAgICV4e1xuICAgICAgT3BhbC5oYXNoX2luaXQoc2VsZik7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjbG9uZVxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBuZXcgc2VsZi4kJGNsYXNzKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuICAgICAgT3BhbC5oYXNoX2Nsb25lKHNlbGYsIGhhc2gpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYWN0XG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgIT09IG5pbCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFjdCFcbiAgICAleHtcbiAgICAgIHZhciBjaGFuZ2VzX3dlcmVfbWFkZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlc193ZXJlX21hZGUgPSB0cnVlO1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VzX3dlcmVfbWFkZSA/IHNlbGYgOiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFyZV9ieV9pZGVudGl0eVxuICAgICV4e1xuICAgICAgdmFyIGksIGlpLCBrZXksIGtleXMgPSBzZWxmLiQka2V5cywgaWRlbnRpdHlfaGFzaDtcblxuICAgICAgaWYgKHNlbGYuJCRieV9pZGVudGl0eSkgcmV0dXJuIHNlbGY7XG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNlbGYuJCRieV9pZGVudGl0eSA9IHRydWVcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGlkZW50aXR5X2hhc2ggPSAjeyB7fS5jb21wYXJlX2J5X2lkZW50aXR5IH07XG4gICAgICBmb3IoaSA9IDAsIGlpID0ga2V5cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICgha2V5LiQkaXNfc3RyaW5nKSBrZXkgPSBrZXkua2V5O1xuICAgICAgICBPcGFsLmhhc2hfcHV0KGlkZW50aXR5X2hhc2gsIGtleSwgT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kJGJ5X2lkZW50aXR5ID0gdHJ1ZTtcbiAgICAgIHNlbGYuJCRtYXAgPSBpZGVudGl0eV9oYXNoLiQkbWFwO1xuICAgICAgc2VsZi4kJHNtYXAgPSBpZGVudGl0eV9oYXNoLiQkc21hcDtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhcmVfYnlfaWRlbnRpdHk/XG4gICAgYHNlbGYuJCRieV9pZGVudGl0eSA9PT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHQoa2V5ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkICYmIHNlbGYuJCRwcm9jICE9PSBuaWwgJiYgc2VsZi4kJHByb2MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHByb2MuJGNhbGwoc2VsZiwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLiQkbm9uZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJG5vbmU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdD0ob2JqZWN0KVxuICAgICV4e1xuICAgICAgc2VsZi4kJHByb2MgPSBuaWw7XG4gICAgICBzZWxmLiQkbm9uZSA9IG9iamVjdDtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0X3Byb2NcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkcHJvYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkcHJvYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdF9wcm9jPShkZWZhdWx0X3Byb2MpXG4gICAgJXh7XG4gICAgICB2YXIgcHJvYyA9IGRlZmF1bHRfcHJvYztcblxuICAgICAgaWYgKHByb2MgIT09IG5pbCkge1xuICAgICAgICBwcm9jID0gI3tPcGFsLmNvZXJjZV90byEoYHByb2NgLCBQcm9jLCA6dG9fcHJvYyl9O1xuXG4gICAgICAgIGlmICgje2Bwcm9jYC5sYW1iZGE/fSAmJiAje2Bwcm9jYC5hcml0eS5hYnN9ICE9PSAyKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdkZWZhdWx0X3Byb2MgdGFrZXMgdHdvIGFyZ3VtZW50cyd9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJCRub25lID0gbmlsO1xuICAgICAgc2VsZi4kJHByb2MgPSBwcm9jO1xuXG4gICAgICByZXR1cm4gZGVmYXVsdF9wcm9jO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShrZXksICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9IE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICByZXR1cm4gI3t5aWVsZCBrZXl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZV9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpkZWxldGVfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZHVwIGNsb25lXG5cbiAgZGVmIGRpZyhrZXksICprZXlzKVxuICAgIGl0ZW0gPSBzZWxmW2tleV1cblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgW2tleSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9rZXkoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9rZXkpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBibG9jayhrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBlYWNoX3BhaXIgZWFjaFxuXG4gIGRlZiBlYWNoX3ZhbHVlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfdmFsdWUpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBibG9jayhrZXkuJCRpc19zdHJpbmcgPyBzZWxmLiQkc21hcFtrZXldIDoga2V5LnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZW1wdHk/XG4gICAgYHNlbGYuJCRrZXlzLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgYWxpYXMgZXFsPyA9PVxuXG4gIGRlZiBleGNlcHQoKmtleXMpXG4gICAgZHVwLmV4Y2VwdCEoKmtleXMpXG4gIGVuZFxuXG4gIGRlZiBleGNlcHQhKCprZXlzKVxuICAgIGtleXMuZWFjaCB7IHxrZXl8IGRlbGV0ZShrZXkpIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmZXRjaChrZXksIGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrKGtleSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByYWlzZSBLZXlFcnJvci5uZXcoXCJrZXkgbm90IGZvdW5kOiAje2tleS5pbnNwZWN0fVwiLCBrZXk6IGtleSwgcmVjZWl2ZXI6IHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBmZXRjaF92YWx1ZXMoKmtleXMsICZibG9jaylcbiAgICBrZXlzLm1hcCB7IHxrZXl8IGZldGNoKGtleSwgJmJsb2NrKSB9XG4gIGVuZFxuXG4gIGRlZiBmbGF0dGVuKGxldmVsID0gMSlcbiAgICBsZXZlbCA9IE9wYWwuY29lcmNlX3RvIShsZXZlbCwgSW50ZWdlciwgOnRvX2ludClcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcblxuICAgICAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgIGlmIChsZXZlbCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCgje2B2YWx1ZWAuZmxhdHRlbihgbGV2ZWwgLSAyYCl9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoYXNfa2V5PyhrZXkpXG4gICAgYE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkYFxuICBlbmRcblxuICBkZWYgaGFzX3ZhbHVlPyh2YWx1ZSlcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmICgje2Aoa2V5LiQkaXNfc3RyaW5nID8gc2VsZi4kJHNtYXBba2V5XSA6IGtleS52YWx1ZSlgID09IHZhbHVlfSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKE9wYWwuaGFzaF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFsnSGFzaCddLFxuICAgICAgICAgIGtleSwgaXRlbTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9wYWxbaGFzaF9pZF0pIHtcbiAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gT3BhbC5oYXNoX2lkcykge1xuICAgICAgICAgIGl0ZW0gPSBPcGFsLmhhc2hfaWRzW2tleV07XG4gICAgICAgICAgaWYgKCN7ZXFsPyhgaXRlbWApfSkge1xuICAgICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLmhhc2hfaWRzW2hhc2hfaWRdID0gc2VsZjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHNlbGYuJCRzbWFwW2tleV0uJGhhc2goKV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChba2V5LmtleV9oYXNoLCBrZXkudmFsdWUuJGhhc2goKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQuc29ydCgpLmpvaW4oKTtcblxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluY2x1ZGU/IGhhc19rZXk/XG5cbiAgZGVmIGluZGV4KG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5kZXhlcygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gYXJnc1tpXTtcbiAgICAgICAgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgje2RlZmF1bHR9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluZGljZXMgaW5kZXhlc1xuXG4gIGB2YXIgaW5zcGVjdF9pZHNgXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoaW5zcGVjdF9pZHMgPT09IHVuZGVmaW5lZCksXG4gICAgICAgICAgaGFzaF9pZCA9IHNlbGYuJG9iamVjdF9pZCgpLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgaW5zcGVjdF9pZHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnNwZWN0X2lkcy5oYXNPd25Qcm9wZXJ0eShoYXNoX2lkKSkge1xuICAgICAgICAgIHJldHVybiAney4uLn0nO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zcGVjdF9pZHNbaGFzaF9pZF0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5LiRpbnNwZWN0KCkgKyAnPT4nICsgdmFsdWUuJGluc3BlY3QoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ3snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnfSc7XG5cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBpbnNwZWN0X2lkcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGludmVydFxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwgdmFsdWUsIGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGtlZXBfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6a2VlcF9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgaWYgKE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBrZXkgaW5kZXhcblxuICBhbGlhcyBrZXk/IGhhc19rZXk/XG5cbiAgZGVmIGtleXNcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5LmtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi4kJGtleXMubGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBtZW1iZXI/IGhhc19rZXk/XG5cbiAgZGVmIG1lcmdlKCpvdGhlcnMsICZibG9jaylcbiAgICBkdXAubWVyZ2UhKCpvdGhlcnMsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIG1lcmdlISgqb3RoZXJzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgaiwgb3RoZXIsIG90aGVyX2tleXMsIGxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgb3RoZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG90aGVyID0gI3tPcGFsLmNvZXJjZV90byEoYG90aGVyc1tpXWAsIEhhc2gsIDp0b19oYXNoKX07XG4gICAgICAgIG90aGVyX2tleXMgPSBvdGhlci4kJGtleXMsIGxlbmd0aCA9IG90aGVyX2tleXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChibG9jayA9PT0gbmlsKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2pdO1xuXG4gICAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBrZXksIG90aGVyX3ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2pdO1xuXG4gICAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPcGFsLmhhc2hfcHV0KHNlbGYsIGtleSwgYmxvY2soa2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVoYXNoXG4gICAgJXh7XG4gICAgICBPcGFsLmhhc2hfcmVoYXNoKHNlbGYpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlamVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgY2hhbmdlc193ZXJlX21hZGUgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gZmFsc2UgJiYgb2JqICE9PSBuaWwpIHtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXNfd2VyZV9tYWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbmdlc193ZXJlX21hZGUgPyBzZWxmIDogbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlcGxhY2Uob3RoZXIpXG4gICAgb3RoZXIgPSBPcGFsLmNvZXJjZV90byEob3RoZXIsIEhhc2gsIDp0b19oYXNoKVxuXG4gICAgJXh7XG4gICAgICBPcGFsLmhhc2hfaW5pdChzZWxmKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG90aGVyX2tleXMgPSBvdGhlci4kJGtleXMsIGxlbmd0aCA9IG90aGVyX2tleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvdGhlcl92YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IG90aGVyX2tleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgb3RoZXIuZGVmYXVsdF9wcm9jXG4gICAgICBzZWxmLmRlZmF1bHRfcHJvYyA9IG90aGVyLmRlZmF1bHRfcHJvY1xuICAgIGVsc2VcbiAgICAgIHNlbGYuZGVmYXVsdCA9IG90aGVyLmRlZmF1bHRcbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqICE9PSBmYWxzZSAmJiBvYmogIT09IG5pbCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpzZWxlY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5pbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiA9PT0gZmFsc2UgfHwgb2JqID09PSBuaWwpIHtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBzZWxmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBmaWx0ZXIgc2VsZWN0XG4gIGFsaWFzIGZpbHRlciEgc2VsZWN0IVxuXG4gIGRlZiBzaGlmdFxuICAgICV4e1xuICAgICAgdmFyIGtleXMgPSBzZWxmLiQka2V5cyxcbiAgICAgICAgICBrZXk7XG5cbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAga2V5ID0ga2V5c1swXTtcblxuICAgICAgICBrZXkgPSBrZXkuJCRpc19zdHJpbmcgPyBrZXkgOiBrZXkua2V5O1xuXG4gICAgICAgIHJldHVybiBba2V5LCBPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kZGVmYXVsdChuaWwpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcblxuICBkZWYgc2xpY2UoKmtleXMpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldLCB2YWx1ZSA9IE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgc3RvcmUgW109XG5cbiAgZGVmIHRvX2FcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faCgmYmxvY2spXG4gICAgcmV0dXJuIG1hcCgmYmxvY2spLnRvX2ggaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuSGFzaCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc2ggPSBuZXcgT3BhbC5IYXNoKCk7XG5cbiAgICAgIE9wYWwuaGFzaF9pbml0KGhhc2gpO1xuICAgICAgT3BhbC5oYXNoX2Nsb25lKHNlbGYsIGhhc2gpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19oYXNoXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgIHByb2MgZG8gfGtleSA9IHVuZGVmaW5lZHxcbiAgICAgICV4e1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBrZXkgZ2l2ZW4nfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGZba2V5XVxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICBkZWYgdHJhbnNmb3JtX2tleXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX2tleXMpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBrZXkgPSBPcGFsLnlpZWxkMShibG9jaywga2V5KTtcblxuICAgICAgICBPcGFsLmhhc2hfcHV0KHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJhbnNmb3JtX2tleXMhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV9rZXlzISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBrZXlzID0gT3BhbC5zbGljZS5jYWxsKHNlbGYuJCRrZXlzKSxcbiAgICAgICAgICBpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgbmV3X2tleTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3X2tleSA9IE9wYWwueWllbGQxKGJsb2NrLCBrZXkpO1xuXG4gICAgICAgIE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KTtcbiAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBuZXdfa2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV92YWx1ZXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX3ZhbHVlcykgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHZhbHVlKTtcblxuICAgICAgICBPcGFsLmhhc2hfcHV0KHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJhbnNmb3JtX3ZhbHVlcyEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dHJhbnNmb3JtX3ZhbHVlcyEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgdmFsdWUpO1xuXG4gICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgdXBkYXRlIG1lcmdlIVxuXG4gIGFsaWFzIHZhbHVlPyBoYXNfdmFsdWU/XG5cbiAgYWxpYXMgdmFsdWVzX2F0IGluZGV4ZXNcblxuICBkZWYgdmFsdWVzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzZWxmLiQkc21hcFtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJjbGFzcyIsImluY2x1ZGUiLCJbXSIsInNlbGYiLCJjb2VyY2VfdG8/IiwiYXJndiIsIjAiLCJhbGxvY2F0ZSIsIm1lcmdlISIsInJhaXNlIiwidHJ5X2NvbnZlcnQiLCJvYmoiLCJpbml0aWFsaXplIiwiPT0iLCI+PSIsIm90aGVyIiwiY29lcmNlX3RvISIsInJlc3VsdCIsImVhY2giLCJ2YWwiLCJmZXRjaCIsIm90aGVyX2tleSIsIj4iLCI8IiwiPD0iLCJbXT0iLCJhc3NvYyIsIm9iamVjdCIsImNsZWFyIiwiY2xvbmUiLCJjb21wYWN0IiwiY29tcGFjdCEiLCJjb21wYXJlX2J5X2lkZW50aXR5IiwiY29tcGFyZV9ieV9pZGVudGl0eT8iLCJkZWZhdWx0IiwiZGVmYXVsdD0iLCJkZWZhdWx0X3Byb2MiLCJkZWZhdWx0X3Byb2M9IiwibGFtYmRhPyIsImFyaXR5IiwiYWJzIiwiZGVsZXRlIiwia2V5IiwiZGVsZXRlX2lmIiwiYmxvY2siLCJlbnVtX2ZvciIsInNpemUiLCJkaWciLCJpdGVtIiwicmVzcG9uZF90bz8iLCJrZXlzIiwiZWFjaF9rZXkiLCJlYWNoX3ZhbHVlIiwiZW1wdHk/IiwiZXhjZXB0IiwiZXhjZXB0ISIsImR1cCIsIm5ldyIsImluc3BlY3QiLCJmZXRjaF92YWx1ZXMiLCJtYXAiLCJmbGF0dGVuIiwiMSIsImxldmVsIiwiaGFzX2tleT8iLCJoYXNfdmFsdWU/IiwidmFsdWUiLCJoYXNoIiwiZXFsPyIsImluZGV4IiwiaW5kZXhlcyIsImludmVydCIsImtlZXBfaWYiLCJsZW5ndGgiLCJtZXJnZSIsIm90aGVycyIsInJhc3NvYyIsInJlaGFzaCIsInJlamVjdCIsInJlamVjdCEiLCJyZXBsYWNlIiwiJHdyaXRlciIsIi0iLCJzZWxlY3QiLCJzZWxlY3QhIiwic2hpZnQiLCJzbGljZSIsInRvX2EiLCJ0b19oIiwiYmxvY2tfZ2l2ZW4/IiwidG9faGFzaCIsInRvX3Byb2MiLCJwcm9jIiwidHJhbnNmb3JtX2tleXMiLCJ0cmFuc2Zvcm1fa2V5cyEiLCJ0cmFuc2Zvcm1fdmFsdWVzIiwidHJhbnNmb3JtX3ZhbHVlcyEiLCJ2YWx1ZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsb0JBQVJBLENBQUE7QUFBQSxFQVVBLE9BQUFDO0FBQUFBLEVBQUFB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QUFBLENBdm9DQTtBQUFBLElBOHBDQSxpQkFBTSxRQUFOLEVBQWEsUUFBYixDQTlwQ0E7QUFBQSxJQWdxQ0EsaUJBQU0sUUFBTixFQUFhLFlBQWIsQ0FocUNBO0FBQUEsSUFrcUNBLGlCQUFNLFdBQU4sRUFBZ0IsU0FBaEIsQ0FscUNBO0FBQUEsSUFvcUNBLE9BQUFDLENBQUFBLDBCQUFBQSxrQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFmRUEsSUFBQUEsQ0FBQUEsNkJBQUFBLENBQUFBLGtCQXBxQ0E7QUFERmpHLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBVkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNjc1MywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbnVtYmVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcblxuY2xhc3MgTnVtYmVyIDwgTnVtZXJpY1xuICBPcGFsLmJyaWRnZShgTnVtYmVyYCwgc2VsZilcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfbnVtYmVyJywgdHJ1ZSlgXG4gIGBzZWxmLiQkaXNfbnVtYmVyX2NsYXNzID0gdHJ1ZWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG4gIGVuZFxuXG4gIGRlZiBjb2VyY2Uob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIgPT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7b3RoZXIuY2xhc3N9IGludG8gRmxvYXRcIn07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvdGhlci4kJGlzX3N0cmluZykge1xuICAgICAgICByZXR1cm4gWyN7RmxvYXQob3RoZXIpfSwgc2VsZl07XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgje290aGVyLnJlc3BvbmRfdG8/KDp0b19mKX0pIHtcbiAgICAgICAgcmV0dXJuIFsje09wYWwuY29lcmNlX3RvIShvdGhlciwgRmxvYXQsIDp0b19mKX0sIHNlbGZdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIFtvdGhlciwgc2VsZl07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCAje290aGVyLmNsYXNzfSBpbnRvIEZsb2F0XCJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIF9faWRfX1xuICAgIGAoc2VsZiAqIDIpICsgMWBcbiAgZW5kXG5cbiAgYWxpYXMgb2JqZWN0X2lkIF9faWRfX1xuXG4gIGRlZiArKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmICsgb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOissIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIC0gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOi0sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAqKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmICogb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOiosIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAvKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIC8gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOi8sIG90aGVyfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGZkaXYgL1xuXG4gIGRlZiAlKG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3RoZXIgPT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgWmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlciA8IDAgfHwgc2VsZiA8IDApIHtcbiAgICAgICAgICByZXR1cm4gKHNlbGYgJSBvdGhlciArIG90aGVyKSAlIG90aGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZWxmICUgb3RoZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6JSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgJiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Jiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgfCBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6fCwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIF4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgXiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Xiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPCBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PCwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw9KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmIDw9IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo8PSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmID4ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Piwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmID49IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo+PSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgIyBDb21wdXRlIHRoZSByZXN1bHQgb2YgdGhlIHNwYWNlc2hpcCBvcGVyYXRvciBpbnNpZGUgaXRzIG93biBmdW5jdGlvbiBzbyBpdFxuICAjIGNhbiBiZSBvcHRpbWl6ZWQgZGVzcGl0ZSBhIHRyeS9maW5hbGx5IGNvbnN0cnVjdC5cbiAgJXh7XG4gICAgdmFyIHNwYWNlc2hpcF9vcGVyYXRvciA9IGZ1bmN0aW9uKHNlbGYsIG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKGlzTmFOKHNlbGYpIHx8IGlzTmFOKG90aGVyKSkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZiA+IG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZiA8IG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOjw9PiwgYG90aGVyYH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBgc3BhY2VzaGlwX29wZXJhdG9yKHNlbGYsIG90aGVyKWBcbiAgcmVzY3VlIEFyZ3VtZW50RXJyb3JcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIDw8KGNvdW50KVxuICAgIGNvdW50ID0gT3BhbC5jb2VyY2VfdG8hIGNvdW50LCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBgI3tjb3VudH0gPiAwID8gc2VsZiA8PCAje2NvdW50fSA6IHNlbGYgPj4gLSN7Y291bnR9YFxuICBlbmRcblxuICBkZWYgPj4oY291bnQpXG4gICAgY291bnQgPSBPcGFsLmNvZXJjZV90byEgY291bnQsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGAje2NvdW50fSA+IDAgPyBzZWxmID4+ICN7Y291bnR9IDogc2VsZiA8PCAtI3tjb3VudH1gXG4gIGVuZFxuXG4gIGRlZiBbXShiaXQpXG4gICAgYml0ID0gT3BhbC5jb2VyY2VfdG8hIGJpdCwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgJXh7XG4gICAgICBpZiAoI3tiaXR9IDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmICgje2JpdH0gPj0gMzIpIHtcbiAgICAgICAgcmV0dXJuICN7IHNlbGYgfSA8IDAgPyAxIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc2VsZiA+PiAje2JpdH0pICYgMTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiArQFxuICAgIGArc2VsZmBcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgYC1zZWxmYFxuICBlbmRcblxuICBkZWYgflxuICAgIGB+c2VsZmBcbiAgZW5kXG5cbiAgZGVmICoqKG90aGVyKVxuICAgIGlmIEludGVnZXIgPT09IG90aGVyXG4gICAgICBpZiAhKEludGVnZXIgPT09IHNlbGYpIHx8IG90aGVyID4gMFxuICAgICAgICBgTWF0aC5wb3coc2VsZiwgb3RoZXIpYFxuICAgICAgZWxzZVxuICAgICAgICBSYXRpb25hbC5uZXcoc2VsZiwgMSkqKm90aGVyXG4gICAgICBlbmRcbiAgICBlbHNpZiBzZWxmIDwgMCAmJiAoRmxvYXQgPT09IG90aGVyIHx8IFJhdGlvbmFsID09PSBvdGhlcilcbiAgICAgIENvbXBsZXgubmV3KHNlbGYsIDApKipvdGhlci50b19mXG4gICAgZWxzaWYgYG90aGVyLiQkaXNfbnVtYmVyICE9IG51bGxgXG4gICAgICBgTWF0aC5wb3coc2VsZiwgb3RoZXIpYFxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZi52YWx1ZU9mKCkgPT09IG90aGVyLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7b3RoZXIucmVzcG9uZF90bz8gOj09fSkge1xuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudmFsdWVPZigpID09PSBvdGhlci52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgje290aGVyLnJlc3BvbmRfdG8/IDo9PX0pIHtcbiAgICAgICAgcmV0dXJuICN7b3RoZXIgPT0gc2VsZn07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIGBNYXRoLmFicyhzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGFiczJcbiAgICBgTWF0aC5hYnMoc2VsZiAqIHNlbGYpYFxuICBlbmRcblxuICBkZWYgYWxsYml0cz8obWFzaylcbiAgICBtYXNrID0gT3BhbC5jb2VyY2VfdG8hIG1hc2ssIEludGVnZXIsIDp0b19pbnRcbiAgICBgKHNlbGYgJiBtYXNrKSA9PSBtYXNrYFxuICBlbmRcblxuICBkZWYgYW55Yml0cz8obWFzaylcbiAgICBtYXNrID0gT3BhbC5jb2VyY2VfdG8hIG1hc2ssIEludGVnZXIsIDp0b19pbnRcbiAgICBgKHNlbGYgJiBtYXNrKSAhPT0gMGBcbiAgZW5kXG5cbiAgZGVmIGFuZ2xlXG4gICAgcmV0dXJuIHNlbGYgaWYgbmFuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSAwKSB7XG4gICAgICAgIGlmICgxIC8gc2VsZiA+IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VsZiA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcbiAgYWxpYXMgcGhhc2UgYW5nbGVcblxuICBkZWYgYml0X2xlbmd0aFxuICAgIHVubGVzcyBJbnRlZ2VyID09PSBzZWxmXG4gICAgICByYWlzZSBOb01ldGhvZEVycm9yLm5ldyhcInVuZGVmaW5lZCBtZXRob2QgYGJpdF9sZW5ndGhgIGZvciAje3NlbGZ9OkZsb2F0XCIsICdiaXRfbGVuZ3RoJylcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT09IDAgfHwgc2VsZiA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAwLFxuICAgICAgICAgIHZhbHVlICA9IHNlbGYgPCAwID8gfnNlbGYgOiBzZWxmO1xuXG4gICAgICB3aGlsZSAodmFsdWUgIT0gMCkge1xuICAgICAgICByZXN1bHQgICArPSAxO1xuICAgICAgICB2YWx1ZSAgPj4+PSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNlaWwobmRpZ2l0cyA9IDApXG4gICAgJXh7XG4gICAgICB2YXIgZiA9ICN7dG9fZn07XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCAmJiBuZGlnaXRzID49IDApIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgcmVzdWx0ID0gTWF0aC5jZWlsKGYgKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNocihlbmNvZGluZyA9IHVuZGVmaW5lZClcbiAgICBgT3BhbC5lbmMoU3RyaW5nLmZyb21DaGFyQ29kZShzZWxmKSwgZW5jb2RpbmcgfHwgXCJCSU5BUllcIilgXG4gIGVuZFxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIGlmIG5hbj8gfHwgaW5maW5pdGU/XG4gICAgICAxXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGRvd250byhzdG9wLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpkb3dudG8sIHN0b3ApIGRvXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIiB1bmxlc3MgTnVtZXJpYyA9PT0gc3RvcFxuICAgICAgICBzdG9wID4gc2VsZiA/IDAgOiBzZWxmIC0gc3RvcCArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIXN0b3AuJCRpc19udW1iZXIpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCJ9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc2VsZjsgaSA+PSBzdG9wOyBpLS0pIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIGVxdWFsPyhvdGhlcilcbiAgICBzZWxmID09IG90aGVyIHx8IGBpc05hTihzZWxmKSAmJiBpc05hTihvdGhlcilgXG4gIGVuZFxuXG4gIGRlZiBldmVuP1xuICAgIGBzZWxmICUgMiA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGZsb29yKG5kaWdpdHMgPSAwKVxuICAgICV4e1xuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgIHJlc3VsdCA9IE1hdGguZmxvb3IoZiAqIGZhY3RvcikgLyBmYWN0b3I7XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2NkKG90aGVyKVxuICAgIHVubGVzcyBJbnRlZ2VyID09PSBvdGhlclxuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnbm90IGFuIGludGVnZXInXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBtaW4gPSBNYXRoLmFicyhzZWxmKSxcbiAgICAgICAgICBtYXggPSBNYXRoLmFicyhvdGhlcik7XG5cbiAgICAgIHdoaWxlIChtaW4gPiAwKSB7XG4gICAgICAgIHZhciB0bXAgPSBtaW47XG5cbiAgICAgICAgbWluID0gbWF4ICUgbWluO1xuICAgICAgICBtYXggPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2NkbGNtKG90aGVyKVxuICAgIFtnY2Qob3RoZXIpLCBsY20ob3RoZXIpXVxuICBlbmRcblxuICBkZWYgaW50ZWdlcj9cbiAgICBgc2VsZiAlIDEgPT09IDBgXG4gIGVuZFxuXG4gIGRlZiBpc19hPyhrbGFzcylcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSBJbnRlZ2VyICYmIEludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSBJbnRlZ2VyICYmIEludGVnZXIgPT09IHNlbGZcbiAgICByZXR1cm4gdHJ1ZSBpZiBrbGFzcyA9PSBGbG9hdCAmJiBGbG9hdCA9PT0gc2VsZlxuXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgYWxpYXMga2luZF9vZj8gaXNfYT9cblxuICBkZWYgaW5zdGFuY2Vfb2Y/KGtsYXNzKVxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEludGVnZXIgJiYgSW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEludGVnZXIgJiYgSW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEZsb2F0ICYmIEZsb2F0ID09PSBzZWxmXG5cbiAgICBzdXBlclxuICBlbmRcblxuICBkZWYgbGNtKG90aGVyKVxuICAgIHVubGVzcyBJbnRlZ2VyID09PSBvdGhlclxuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnbm90IGFuIGludGVnZXInXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDAgfHwgb3RoZXIgPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoc2VsZiAqIG90aGVyIC8gI3tnY2Qob3RoZXIpfSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBtYWduaXR1ZGUgYWJzXG5cbiAgYWxpYXMgbW9kdWxvICVcblxuICBkZWYgbmV4dFxuICAgIGBzZWxmICsgMWBcbiAgZW5kXG5cbiAgZGVmIG5vYml0cz8obWFzaylcbiAgICBtYXNrID0gT3BhbC5jb2VyY2VfdG8hIG1hc2ssIEludGVnZXIsIDp0b19pbnRcbiAgICBgKHNlbGYgJiBtYXNrKSA9PSAwYFxuICBlbmRcblxuICBkZWYgbm9uemVybz9cbiAgICBgc2VsZiA9PSAwID8gbmlsIDogc2VsZmBcbiAgZW5kXG5cbiAgZGVmIG51bWVyYXRvclxuICAgIGlmIG5hbj8gfHwgaW5maW5pdGU/XG4gICAgICBzZWxmXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIG9kZD9cbiAgICBgc2VsZiAlIDIgIT09IDBgXG4gIGVuZFxuXG4gIGRlZiBvcmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwb3coYiwgbSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDApIHtcbiAgICAgICAgI3tyYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICN7c2VsZioqYn07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoISgje0ludGVnZXIgPT09IGJ9KSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnSW50ZWdlciNwb3coKSAybmQgYXJndW1lbnQgbm90IGFsbG93ZWQgdW5sZXNzIGEgMXN0IGFyZ3VtZW50IGlzIGludGVnZXInfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGIgPCAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDFzdCBhcmd1bWVudCBjYW5ub3QgYmUgbmVnYXRpdmUgd2hlbiAybmQgYXJndW1lbnQgc3BlY2lmaWVkJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKCN7SW50ZWdlciA9PT0gbX0pKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDJuZCBhcmd1bWVudCBub3QgYWxsb3dlZCB1bmxlc3MgYWxsIGFyZ3VtZW50cyBhcmUgaW50ZWdlcnMnfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG0gPT09IDApIHtcbiAgICAgICAgICAje3JhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAjeyhzZWxmKipiKSAlIG19XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgcHJlZFxuICAgIGBzZWxmIC0gMWBcbiAgZW5kXG5cbiAgZGVmIHF1byhvdGhlcilcbiAgICBpZiBJbnRlZ2VyID09PSBzZWxmXG4gICAgICBzdXBlclxuICAgIGVsc2VcbiAgICAgIHNlbGYgLyBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmF0aW9uYWxpemUoZXBzID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZm9yIDAuLjEpXCJ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIEludGVnZXIgPT09IHNlbGZcbiAgICAgIFJhdGlvbmFsLm5ldyhzZWxmLCAxKVxuICAgIGVsc2lmIGluZmluaXRlP1xuICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ0luZmluaXR5J1xuICAgIGVsc2lmIG5hbj9cbiAgICAgIHJhaXNlIEZsb2F0RG9tYWluRXJyb3IsICdOYU4nXG4gICAgZWxzaWYgYGVwcyA9PSBudWxsYFxuICAgICAgZiwgbiAgPSBNYXRoLmZyZXhwIHNlbGZcbiAgICAgIGYgICAgID0gTWF0aC5sZGV4cChmLCBGbG9hdDo6TUFOVF9ESUcpLnRvX2lcbiAgICAgIG4gICAgLT0gRmxvYXQ6Ok1BTlRfRElHXG5cbiAgICAgIFJhdGlvbmFsLm5ldygyICogZiwgMSA8PCAoMSAtIG4pKS5yYXRpb25hbGl6ZShSYXRpb25hbC5uZXcoMSwgMSA8PCAoMSAtIG4pKSlcbiAgICBlbHNlXG4gICAgICB0b19yLnJhdGlvbmFsaXplKGVwcylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHJlbWFpbmRlcih5KVxuICAgIHNlbGYgLSB5ICogKHNlbGYgLyB5KS50cnVuY2F0ZVxuICBlbmRcblxuICBkZWYgcm91bmQobmRpZ2l0cyA9IHVuZGVmaW5lZClcbiAgICBpZiBJbnRlZ2VyID09PSBzZWxmXG4gICAgICBpZiBgbmRpZ2l0cyA9PSBudWxsYFxuICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgZW5kXG5cbiAgICAgIGlmIEZsb2F0ID09PSBuZGlnaXRzICYmIG5kaWdpdHMuaW5maW5pdGU/XG4gICAgICAgIHJhaXNlIFJhbmdlRXJyb3IsICdJbmZpbml0eSdcbiAgICAgIGVuZFxuXG4gICAgICBuZGlnaXRzID0gT3BhbC5jb2VyY2VfdG8hKG5kaWdpdHMsIEludGVnZXIsIDp0b19pbnQpXG5cbiAgICAgIGlmIG5kaWdpdHMgPCBJbnRlZ2VyOjpNSU5cbiAgICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ291dCBvZiBib3VuZHMnXG4gICAgICBlbmRcblxuICAgICAgaWYgYG5kaWdpdHMgPj0gMGBcbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBuZGlnaXRzID0gLW5kaWdpdHNcblxuICAgICAgJXh7XG4gICAgICAgIGlmICgwLjQxNTI0MSAqIG5kaWdpdHMgLSAwLjEyNSA+ICN7c2l6ZX0pIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgICAgeCA9IE1hdGguZmxvb3IoKE1hdGguYWJzKHNlbGYpICsgZiAvIDIpIC8gZikgKiBmO1xuXG4gICAgICAgIHJldHVybiBzZWxmIDwgMCA/IC14IDogeDtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBpZiBuYW4/ICYmIGBuZGlnaXRzID09IG51bGxgXG4gICAgICAgIHJhaXNlIEZsb2F0RG9tYWluRXJyb3IsICdOYU4nXG4gICAgICBlbmRcblxuICAgICAgbmRpZ2l0cyA9IE9wYWwuY29lcmNlX3RvIShgbmRpZ2l0cyB8fCAwYCwgSW50ZWdlciwgOnRvX2ludClcblxuICAgICAgaWYgbmRpZ2l0cyA8PSAwXG4gICAgICAgIGlmIG5hbj9cbiAgICAgICAgICByYWlzZSBSYW5nZUVycm9yLCAnTmFOJ1xuICAgICAgICBlbHNpZiBpbmZpbml0ZT9cbiAgICAgICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXG4gICAgICAgIGVuZFxuICAgICAgZWxzaWYgbmRpZ2l0cyA9PSAwXG4gICAgICAgIHJldHVybiBgTWF0aC5yb3VuZChzZWxmKWBcbiAgICAgIGVsc2lmIG5hbj8gfHwgaW5maW5pdGU/XG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgXywgZXhwID0gTWF0aC5mcmV4cChzZWxmKVxuXG4gICAgICBpZiBuZGlnaXRzID49IChGbG9hdDo6RElHICsgMikgLSAoZXhwID4gMCA/IGV4cCAvIDQgOiBleHAgLyAzIC0gMSlcbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuZGlnaXRzIDwgLShleHAgPiAwID8gZXhwIC8gMyArIDEgOiBleHAgLyA0KVxuICAgICAgICByZXR1cm4gMFxuICAgICAgZW5kXG5cbiAgICAgIGBNYXRoLnJvdW5kKHNlbGYgKiBNYXRoLnBvdygxMCwgbmRpZ2l0cykpIC8gTWF0aC5wb3coMTAsIG5kaWdpdHMpYFxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBzdWNjIG5leHRcblxuICBkZWYgdGltZXMoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6dGltZXMpIHsgc2VsZiB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGY7IGkrKykge1xuICAgICAgICBibG9jayhpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIGBzZWxmIDwgMCA/IE1hdGguY2VpbChzZWxmKSA6IE1hdGguZmxvb3Ioc2VsZilgXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2ludCB0b19pXG5cbiAgZGVmIHRvX3JcbiAgICBpZiBJbnRlZ2VyID09PSBzZWxmXG4gICAgICBSYXRpb25hbC5uZXcoc2VsZiwgMSlcbiAgICBlbHNlXG4gICAgICBmLCBlICA9IE1hdGguZnJleHAoc2VsZilcbiAgICAgIGYgICAgID0gTWF0aC5sZGV4cChmLCBGbG9hdDo6TUFOVF9ESUcpLnRvX2lcbiAgICAgIGUgICAgLT0gRmxvYXQ6Ok1BTlRfRElHXG5cbiAgICAgIChmICogKEZsb2F0OjpSQURJWCoqZSkpLnRvX3JcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX3MoYmFzZSA9IDEwKVxuICAgIGJhc2UgPSBPcGFsLmNvZXJjZV90byEgYmFzZSwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYmFzZSA8IDIgfHwgYmFzZSA+IDM2XG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwiXG4gICAgZW5kXG5cbiAgICBgc2VsZi50b1N0cmluZyhiYXNlKWBcbiAgZW5kXG5cbiAgZGVmIHRydW5jYXRlKG5kaWdpdHMgPSAwKVxuICAgICV4e1xuICAgICAgdmFyIGYgPSAje3RvX2Z9O1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDAgJiYgbmRpZ2l0cyA+PSAwKSB7XG4gICAgICAgIHJldHVybiBmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIG5kaWdpdHMpLFxuICAgICAgICAgIHJlc3VsdCA9IHBhcnNlSW50KGYgKiBmYWN0b3IsIDEwKSAvIGZhY3RvcjtcblxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgucm91bmQocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGluc3BlY3QgdG9fc1xuXG4gIGRlZiBkaWdpdHMoYmFzZSA9IDEwKVxuICAgIGlmIHNlbGYgPCAwXG4gICAgICByYWlzZSBNYXRoOjpEb21haW5FcnJvciwgJ291dCBvZiBkb21haW4nXG4gICAgZW5kXG5cbiAgICBiYXNlID0gT3BhbC5jb2VyY2VfdG8hIGJhc2UsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGlmIGJhc2UgPCAyXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFkaXggI3tiYXNlfVwiXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciB2YWx1ZSA9IHNlbGYsIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAodmFsdWUgIT09IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUgJSBiYXNlKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUludCh2YWx1ZSAvIGJhc2UsIDEwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkaXZtb2Qob3RoZXIpXG4gICAgaWYgbmFuPyB8fCBvdGhlci5uYW4/XG4gICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnTmFOJ1xuICAgIGVsc2lmIGluZmluaXRlP1xuICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ0luZmluaXR5J1xuICAgIGVsc2VcbiAgICAgIHN1cGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB1cHRvKHN0b3AsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnVwdG8sIHN0b3ApIGRvXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIiB1bmxlc3MgTnVtZXJpYyA9PT0gc3RvcFxuICAgICAgICBzdG9wIDwgc2VsZiA/IDAgOiBzdG9wIC0gc2VsZiArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIXN0b3AuJCRpc19udW1iZXIpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tzZWxmLmNsYXNzfSB3aXRoICN7c3RvcC5jbGFzc30gZmFpbGVkXCJ9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gc2VsZjsgaSA8PSBzdG9wOyBpKyspIHtcbiAgICAgICAgYmxvY2soaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgemVybz9cbiAgICBgc2VsZiA9PSAwYFxuICBlbmRcblxuICAjIFNpbmNlIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcmUgMzIgYml0LCBkZWNsYXJlIGl0IHRvIGJlIHNvLlxuICBkZWYgc2l6ZVxuICAgIDRcbiAgZW5kXG5cbiAgZGVmIG5hbj9cbiAgICBgaXNOYU4oc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBmaW5pdGU/XG4gICAgYHNlbGYgIT0gSW5maW5pdHkgJiYgc2VsZiAhPSAtSW5maW5pdHkgJiYgIWlzTmFOKHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5maW5pdGU/XG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gKzE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmID09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwb3NpdGl2ZT9cbiAgICBgc2VsZiAhPSAwICYmIChzZWxmID09IEluZmluaXR5IHx8IDEgLyBzZWxmID4gMClgXG4gIGVuZFxuXG4gIGRlZiBuZWdhdGl2ZT9cbiAgICBgc2VsZiA9PSAtSW5maW5pdHkgfHwgMSAvIHNlbGYgPCAwYFxuICBlbmRcbmVuZFxuXG5GaXhudW0gPSBOdW1iZXJcblxuY2xhc3MgSW50ZWdlciA8IE51bWVyaWNcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuICBgc2VsZi4kJGlzX2ludGVnZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcblxuICAgIGRlZiBzcXJ0KG4pXG4gICAgICBuID0gT3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpXG4gICAgICAleHtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBNYXRoOjpEb21haW5FcnJvciwgJ051bWVyaWNhbCBhcmd1bWVudCBpcyBvdXQgb2YgZG9tYWluIC0gXCJpc3FydFwiJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUludChNYXRoLnNxcnQobiksIDEwKTtcbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgTUFYID0gYE1hdGgucG93KDIsIDMwKSAtIDFgXG4gIE1JTiA9IGAtTWF0aC5wb3coMiwgMzApYFxuZW5kXG5cbmNsYXNzIEZsb2F0IDwgTnVtZXJpY1xuICBgc2VsZi4kJGlzX251bWJlcl9jbGFzcyA9IHRydWVgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuXG4gICAgZGVmID09PShvdGhlcilcbiAgICAgIGAhIW90aGVyLiQkaXNfbnVtYmVyYFxuICAgIGVuZFxuICBlbmRcblxuICBJTkZJTklUWSA9IGBJbmZpbml0eWBcbiAgTUFYICAgICAgPSBgTnVtYmVyLk1BWF9WQUxVRWBcbiAgTUlOICAgICAgPSBgTnVtYmVyLk1JTl9WQUxVRWBcbiAgTkFOICAgICAgPSBgTmFOYFxuXG4gIERJRyAgICAgID0gMTVcbiAgTUFOVF9ESUcgPSA1M1xuICBSQURJWCAgICA9IDJcblxuICBFUFNJTE9OID0gYE51bWJlci5FUFNJTE9OIHx8IDIuMjIwNDQ2MDQ5MjUwMzEzMDgwODQ3MjYzMzM2MTgxNkUtMTZgXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJicmlkZ2UiLCJzZWxmIiwiYWxsb2NhdGUiLCJyYWlzZSIsIm5hbWUiLCJjb2VyY2UiLCJvdGhlciIsIkZsb2F0IiwicmVzcG9uZF90bz8iLCJjb2VyY2VfdG8hIiwiX19pZF9fIiwiKyIsIl9fY29lcmNlZF9fIiwiLSIsIioiLCIvIiwiJSIsIiYiLCJ8IiwiXiIsIjwiLCI8PSIsIj4iLCI+PSIsIjw9PiIsIjw8IiwiY291bnQiLCI+PiIsIltdIiwiYml0IiwiK0AiLCItQCIsIn4iLCIqKiIsIj09PSIsIiRyZXRfb3JfMSIsIiEiLCIwIiwibmV3IiwiMSIsIiRyZXRfb3JfMiIsIiRyZXRfb3JfMyIsInRvX2YiLCI9PSIsImFicyIsImFiczIiLCJhbGxiaXRzPyIsIm1hc2siLCJhbnliaXRzPyIsImFuZ2xlIiwibmFuPyIsImJpdF9sZW5ndGgiLCJjZWlsIiwiY2hyIiwiZGVub21pbmF0b3IiLCIkcmV0X29yXzQiLCJpbmZpbml0ZT8iLCJkb3dudG8iLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsInN0b3AiLCJlcXVhbD8iLCIkcmV0X29yXzUiLCJldmVuPyIsImZsb29yIiwiZ2NkIiwiZ2NkbGNtIiwibGNtIiwiaW50ZWdlcj8iLCJpc19hPyIsIiRyZXRfb3JfNiIsImtsYXNzIiwiJHJldF9vcl83IiwiJHJldF9vcl84IiwiaW5zdGFuY2Vfb2Y/IiwiJHJldF9vcl85IiwiJHJldF9vcl8xMCIsIiRyZXRfb3JfMTEiLCJuZXh0Iiwibm9iaXRzPyIsIm5vbnplcm8/IiwibnVtZXJhdG9yIiwiJHJldF9vcl8xMiIsIm9kZD8iLCJvcmQiLCJwb3ciLCJiIiwibSIsInByZWQiLCJxdW8iLCJyYXRpb25hbGl6ZSIsImZyZXhwIiwiZiIsIm4iLCJsZGV4cCIsInRvX2kiLCIyIiwidG9fciIsImVwcyIsInJlbWFpbmRlciIsInkiLCJ0cnVuY2F0ZSIsInJvdW5kIiwiJHJldF9vcl8xMyIsIm5kaWdpdHMiLCJzaXplIiwiJHJldF9vcl8xNCIsIiRyZXRfb3JfMTUiLCJfIiwiZXhwIiwiNCIsIjMiLCJ0aW1lcyIsImJsb2NrIiwiZSIsInRvX3MiLCIxMCIsImJhc2UiLCIkcmV0X29yXzE2IiwiMzYiLCJkaWdpdHMiLCJkaXZtb2QiLCIkcmV0X29yXzE3IiwidXB0byIsInplcm8/IiwiZmluaXRlPyIsInBvc2l0aXZlPyIsIm5lZ2F0aXZlPyIsInNxcnQiLCIxNSIsIjUzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQUFBO0FBQUEsRUFFQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUEsb0JBQUFDLFFBQUFBLENBQWEsUUFBU0MsSUFBdEJELENBQUE7QUFBQSxJQUNDLDBEQUREO0FBQUEsSUFFQyw2QkFGRDtBQUFBLElBSUE7QUFBQSxNQUFBOztBQUFBO0FBQ0U7QUFBQUUsTUFBQUEsNEJBQUFBLGNBQUFBLG9CQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxXQUFBQyxPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSwwQkFBQSxHQUFBLEtBQTJCQyxNQUFBQSxDQUFBQSxDQUEzQixDQUFqQkQ7QUFERkQsTUFBQUEsQ0FBQUEseUJBQUFBLENBQUE7QUFBQTs7QUFJQSxNQUFBLHNCQUFNLEtBQU47aUJB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QUFBLFFBQUFBOztBQUFBQSxRQUNFLFdBQUFDLE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLDBCQUFBLEdBQUEsS0FBMkJDLE1BQUFBLENBQUFBLENBQTNCLENBQWpCRDtBQURGRCxNQUFBQSxDQUFBQSwwQkFBQUEsQ0FBQTtBQUFBO0FBSUEsTUFBQSxzQkFBTSxLQUFOLEVBSkE7QUFBQSxNQU1BLE9BQUFnQyxDQUFBQSx1QkFBQUEsZUFBQUEsU0FBUSxLQUFSQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxPQUFDLG1CQUFEO0FBREZBLE1BQUFBLENBQUFBLDBCQUFBQSxDQUFBQSxlQU5BO0FBREYsSUFBQSw0QkFBU2pDLElBQVQsWUFGQTtBQUFBLElBY0Esd0NBQVksUUFBWixDQWRBO0FBQUEsSUFlQSxtQ0FBWSxnQkFBWixDQWZBO0FBQUEsSUFnQkEsbUNBQVksZ0JBQVosQ0FoQkE7QUFBQSxJQWlCQSxtQ0FBWSxHQUFaLENBakJBO0FBQUEsSUFtQkEsbUNBQVdnSSxFQUFYLENBbkJBO0FBQUEsSUFvQkEsd0NBQVdDLEVBQVgsQ0FwQkE7QUFBQSxJQXFCQSxxQ0FBV2xDLENBQVgsQ0FyQkE7QUFBQSxJQXVCQSxPQUFBLHVDQUFXLHVEQUFYLENBdkJBO0FBREZqRyxFQUFBQSxHQUFBQSxXQUFBQSxFQUFjLHVCQUFkQSxXQTMxQkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxNzk4NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZ2UucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG5jbGFzcyBSYW5nZVxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICBgc2VsZi4kJHByb3RvdHlwZS4kJGlzX3JhbmdlID0gdHJ1ZWBcblxuICBhdHRyX3JlYWRlciA6YmVnaW4sIDplbmRcblxuICBkZWYgaW5pdGlhbGl6ZShmaXJzdCwgbGFzdCwgZXhjbHVkZSA9IGZhbHNlKVxuICAgIHJhaXNlIE5hbWVFcnJvciwgXCInaW5pdGlhbGl6ZScgY2FsbGVkIHR3aWNlXCIgaWYgQGJlZ2luXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2JhZCB2YWx1ZSBmb3IgcmFuZ2UnIHVubGVzcyBmaXJzdCA8PT4gbGFzdCB8fCBmaXJzdC5uaWw/IHx8IGxhc3QubmlsP1xuXG4gICAgQGJlZ2luID0gZmlyc3RcbiAgICBAZW5kICAgPSBsYXN0XG4gICAgQGV4Y2wgID0gZXhjbHVkZVxuICBlbmRcblxuICBkZWYgPT09KHZhbHVlKVxuICAgIGluY2x1ZGU/IHZhbHVlXG4gIGVuZFxuXG4gICV4e1xuICAgIGZ1bmN0aW9uIGlzX2luZmluaXRlKHNlbGYpIHtcbiAgICAgIGlmIChzZWxmLmJlZ2luID09PSBuaWwgfHwgc2VsZi5lbmQgPT09IG5pbCB8fFxuICAgICAgICAgIHNlbGYuYmVnaW4gPT09IC1JbmZpbml0eSB8fCBzZWxmLmVuZCA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICBzZWxmLmJlZ2luID09PSBJbmZpbml0eSB8fCBzZWxmLmVuZCA9PT0gLUluZmluaXR5KSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBkZWYgY291bnQoJmJsb2NrKVxuICAgIGlmICFibG9ja19naXZlbj8gJiYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgICAgcmV0dXJuIEZsb2F0OjpJTkZJTklUWVxuICAgIGVuZFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiB0b19hXG4gICAgcmFpc2UgVHlwZUVycm9yLCAnY2Fubm90IGNvbnZlcnQgZW5kbGVzcyByYW5nZSB0byBhbiBhcnJheScgaWYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBjb3Zlcj8odmFsdWUpXG4gICAgYmVnX2NtcCA9IChAYmVnaW4ubmlsPyAmJiAtMSkgfHwgKEBiZWdpbiA8PT4gdmFsdWUpIHx8IGZhbHNlXG4gICAgZW5kX2NtcCA9IChAZW5kLm5pbD8gJiYgLTEpIHx8ICh2YWx1ZSA8PT4gQGVuZCkgfHwgZmFsc2VcbiAgICBpZiBAZXhjbFxuICAgICAgZW5kX2NtcCAmJiBlbmRfY21wIDwgMFxuICAgIGVsc2VcbiAgICAgIGVuZF9jbXAgJiYgZW5kX2NtcCA8PSAwXG4gICAgZW5kICYmIGJlZ19jbXAgJiYgYmVnX2NtcCA8PSAwXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIGksIGxpbWl0O1xuXG4gICAgICBpZiAoI3tAYmVnaW59LiQkaXNfbnVtYmVyICYmICN7QGVuZH0uJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKCN7QGJlZ2lufSAlIDEgIT09IDAgfHwgI3tAZW5kfSAlIDEgIT09IDApIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBpdGVyYXRlIGZyb20gRmxvYXRcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9ICN7QGJlZ2lufSwgbGltaXQgPSAje0BlbmR9ICsgI3tAZXhjbCA/IDAgOiAxfTsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICBibG9jayhpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZiAoI3tAYmVnaW59LiQkaXNfc3RyaW5nICYmICN7QGVuZH0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgI3tAYmVnaW4udXB0byhAZW5kLCBAZXhjbCwgJmJsb2NrKX1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudCA9IEBiZWdpblxuICAgIGxhc3QgICAgPSBAZW5kXG5cbiAgICB1bmxlc3MgY3VycmVudC5yZXNwb25kX3RvPyg6c3VjYylcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBpdGVyYXRlIGZyb20gI3tjdXJyZW50LmNsYXNzfVwiXG4gICAgZW5kXG5cbiAgICB3aGlsZSBAZW5kLm5pbD8gfHwgKGN1cnJlbnQgPD0+IGxhc3QpIDwgMFxuICAgICAgeWllbGQgY3VycmVudFxuXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5zdWNjXG4gICAgZW5kXG5cbiAgICB5aWVsZCBjdXJyZW50IGlmICFAZXhjbCAmJiBjdXJyZW50ID09IGxhc3RcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBSYW5nZSA9PT0gb3RoZXJcblxuICAgIEBleGNsID09PSBvdGhlci5leGNsdWRlX2VuZD8gJiZcbiAgICAgIEBiZWdpbi5lcWw/KG90aGVyLmJlZ2luKSAmJlxuICAgICAgQGVuZC5lcWw/KG90aGVyLmVuZClcbiAgZW5kXG5cbiAgYWxpYXMgPT0gZXFsP1xuXG4gIGRlZiBleGNsdWRlX2VuZD9cbiAgICBAZXhjbFxuICBlbmRcblxuICBkZWYgZmlyc3QobiA9IHVuZGVmaW5lZClcbiAgICByYWlzZSBSYW5nZUVycm9yLCAnY2Fubm90IGdldCB0aGUgbWluaW11bSBvZiBiZWdpbmxlc3MgcmFuZ2UnIGlmIEBiZWdpbi5uaWw/XG4gICAgcmV0dXJuIEBiZWdpbiBpZiBgbiA9PSBudWxsYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGFsaWFzIGluY2x1ZGU/IGNvdmVyP1xuXG4gIGRlZiBsYXN0KG4gPSB1bmRlZmluZWQpXG4gICAgcmFpc2UgUmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1heGltdW0gb2YgZW5kbGVzcyByYW5nZScgaWYgQGVuZC5uaWw/XG4gICAgcmV0dXJuIEBlbmQgaWYgYG4gPT0gbnVsbGBcbiAgICB0b19hLmxhc3QobilcbiAgZW5kXG5cbiAgIyBGSVhNRTogY3VycmVudGx5IGhhcmRjb2RlZCB0byBhc3N1bWUgcmFuZ2UgaG9sZHMgbnVtZXJpY3NcbiAgZGVmIG1heFxuICAgIGlmIEBlbmQubmlsP1xuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1heGltdW0gb2YgZW5kbGVzcyByYW5nZSdcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgIUBiZWdpbi5uaWw/ICYmIChAYmVnaW4gPiBAZW5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBAZXhjbCAmJiBAYmVnaW4gPT0gQGVuZClcbiAgICAgIG5pbFxuICAgIGVsc2VcbiAgICAgIGAje0BleGNsfSA/ICN7QGVuZH0gLSAxIDogI3tAZW5kfWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgbWVtYmVyPyBjb3Zlcj9cblxuICBkZWYgbWluXG4gICAgaWYgQGJlZ2luLm5pbD9cbiAgICAgIHJhaXNlIFJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBtaW5pbXVtIG9mIGJlZ2lubGVzcyByYW5nZSdcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIHN1cGVyXG4gICAgZWxzaWYgIUBlbmQubmlsPyAmJiAoQGJlZ2luID4gQGVuZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIEBleGNsICYmIEBiZWdpbiA9PSBAZW5kKVxuICAgICAgbmlsXG4gICAgZWxzZVxuICAgICAgQGJlZ2luXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzaXplXG4gICAgaW5maW5pdHkgPSBGbG9hdDo6SU5GSU5JVFlcblxuICAgIHJldHVybiAwIGlmIChAYmVnaW4gPT0gaW5maW5pdHkgJiYgIUBlbmQubmlsPykgfHwgKEBlbmQgPT0gLWluZmluaXR5ICYmICFAYmVnaW4ubmlsPylcbiAgICByZXR1cm4gaW5maW5pdHkgaWYgYGlzX2luZmluaXRlKHNlbGYpYFxuICAgIHJldHVybiBuaWwgdW5sZXNzIE51bWVyaWMgPT09IEBiZWdpbiAmJiBOdW1lcmljID09PSBAZW5kXG5cbiAgICByYW5nZV9iZWdpbiA9IEBiZWdpblxuICAgIHJhbmdlX2VuZCAgID0gQGVuZFxuICAgIHJhbmdlX2VuZCAgLT0gMSBpZiBAZXhjbFxuXG4gICAgcmV0dXJuIDAgaWYgcmFuZ2VfZW5kIDwgcmFuZ2VfYmVnaW5cblxuICAgIGBNYXRoLmFicyhyYW5nZV9lbmQgLSByYW5nZV9iZWdpbikgKyAxYC50b19pXG4gIGVuZFxuXG4gIGRlZiBzdGVwKG4gPSAxKVxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gY29lcmNlU3RlcFNpemUoKSB7XG4gICAgICAgIGlmICghbi4kJGlzX251bWJlcikge1xuICAgICAgICAgIG4gPSAje09wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KX1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIG5lZ2F0aXZlXCJ9XG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJzdGVwIGNhbid0IGJlIDBcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBlbnVtZXJhdG9yU2l6ZSgpIHtcbiAgICAgICAgaWYgKCEje0BiZWdpbi5yZXNwb25kX3RvPyg6c3VjYyl9KSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiAlIDEgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gI3soc2l6ZSAvIG4pLmNlaWx9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG4gaXMgYSBmbG9hdFxuICAgICAgICAgIHZhciBiZWdpbiA9IHNlbGYuYmVnaW4sIGVuZCA9IHNlbGYuZW5kLFxuICAgICAgICAgICAgICBhYnMgPSBNYXRoLmFicywgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICAgICAgICBlcnIgPSAoYWJzKGJlZ2luKSArIGFicyhlbmQpICsgYWJzKGVuZCAtIGJlZ2luKSkgLyBhYnMobikgKiAje0Zsb2F0OjpFUFNJTE9OfSxcbiAgICAgICAgICAgICAgc2l6ZTtcblxuICAgICAgICAgIGlmIChlcnIgPiAwLjUpIHtcbiAgICAgICAgICAgIGVyciA9IDAuNTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VsZi5leGNsKSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gLSBlcnIpO1xuICAgICAgICAgICAgaWYgKHNpemUgKiBuICsgYmVnaW4gPCBlbmQpIHtcbiAgICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gZmxvb3IoKGVuZCAtIGJlZ2luKSAvIG4gKyBlcnIpICsgMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpzdGVwLCBuKSBkb1xuICAgICAgICAleHtcbiAgICAgICAgICBjb2VyY2VTdGVwU2l6ZSgpO1xuICAgICAgICAgIHJldHVybiBlbnVtZXJhdG9yU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGBjb2VyY2VTdGVwU2l6ZSgpYFxuXG4gICAgaWYgYHNlbGYuYmVnaW4uJCRpc19udW1iZXIgJiYgc2VsZi5lbmQuJCRpc19udW1iZXJgXG4gICAgICBpID0gMFxuICAgICAgbG9vcCBkb1xuICAgICAgICBjdXJyZW50ID0gQGJlZ2luICsgaSAqIG5cbiAgICAgICAgaWYgQGV4Y2xcbiAgICAgICAgICBicmVhayBpZiBjdXJyZW50ID49IEBlbmRcbiAgICAgICAgZWxzaWYgY3VycmVudCA+IEBlbmRcbiAgICAgICAgICBicmVha1xuICAgICAgICBlbmRcbiAgICAgICAgeWllbGQoY3VycmVudClcbiAgICAgICAgaSArPSAxXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICAleHtcbiAgICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX3N0cmluZyAmJiAje0BlbmR9LiQkaXNfc3RyaW5nICYmIG4gJSAxICE9PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdubyBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIGZsb2F0IGZyb20gc3RyaW5nJ31cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWFjaF93aXRoX2luZGV4IGRvIHx2YWx1ZSwgaWR4fFxuICAgICAgICB5aWVsZCh2YWx1ZSkgaWYgaWR4ICUgbiA9PSAwXG4gICAgICBlbmRcbiAgICBlbmRcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBic2VhcmNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmJzZWFyY2gpIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIGlmIGBpc19pbmZpbml0ZShzZWxmKSAmJiAoc2VsZi5iZWdpbi4kJGlzX251bWJlciB8fCBzZWxmLmVuZC4kJGlzX251bWJlcilgXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBcIkNhbid0ICNic2VhcmNoIGFuIGluZmluaXRlIHJhbmdlXCJcbiAgICBlbmRcblxuICAgIHVubGVzcyBgc2VsZi5iZWdpbi4kJGlzX251bWJlciAmJiBzZWxmLmVuZC4kJGlzX251bWJlcmBcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBkbyBiaW5hcnkgc2VhcmNoIGZvciAje0BiZWdpbi5jbGFzc31cIlxuICAgIGVuZFxuXG4gICAgdG9fYS5ic2VhcmNoKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiN7QGJlZ2luIHx8ICcnfSN7QGV4Y2wgPyAnLi4uJyA6ICcuLid9I3tAZW5kIHx8ICcnfVwiXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIje0BiZWdpbiAmJiBAYmVnaW4uaW5zcGVjdH0je0BleGNsID8gJy4uLicgOiAnLi4nfSN7QGVuZCAmJiBAZW5kLmluc3BlY3R9XCJcbiAgZW5kXG5cbiAgZGVmIG1hcnNoYWxfbG9hZChhcmdzKVxuICAgIEBiZWdpbiA9IGFyZ3NbOmJlZ2luXVxuICAgIEBlbmQgPSBhcmdzWzplbmRdXG4gICAgQGV4Y2wgPSBhcmdzWzpleGNsXVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFtAYmVnaW4sIEBlbmQsIEBleGNsXS5oYXNoXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsIkBiZWdpbiIsInJhaXNlIiwiJHJldF9vcl8xIiwiJHJldF9vcl8yIiwiZmlyc3QiLCI8PT4iLCJsYXN0IiwibmlsPyIsIkBlbmQiLCJAZXhjbCIsImV4Y2x1ZGUiLCI9PT0iLCJpbmNsdWRlPyIsInZhbHVlIiwiY291bnQiLCIkcmV0X29yXzMiLCJibG9ja19naXZlbj8iLCIhIiwidG9fYSIsImNvdmVyPyIsImJlZ19jbXAiLCIkcmV0X29yXzQiLCIkcmV0X29yXzUiLCIkcmV0X29yXzYiLCItMSIsImVuZF9jbXAiLCIkcmV0X29yXzciLCIkcmV0X29yXzgiLCIkcmV0X29yXzkiLCIkcmV0X29yXzEwIiwiJHJldF9vcl8xMSIsIiRyZXRfb3JfMTIiLCI8IiwiMCIsIiRyZXRfb3JfMTMiLCI8PSIsImVhY2giLCJlbnVtX2ZvciIsInNpemUiLCIxIiwidXB0byIsImJsb2NrIiwiY3VycmVudCIsInJlc3BvbmRfdG8/IiwiJHJldF9vcl8xNCIsInN1Y2MiLCIkcmV0X29yXzE1IiwiPT0iLCJzZWxmIiwiZXFsPyIsIm90aGVyIiwiJHJldF9vcl8xNiIsIiRyZXRfb3JfMTciLCJleGNsdWRlX2VuZD8iLCJiZWdpbiIsImVuZCIsIm4iLCJtYXgiLCIkcmV0X29yXzE4IiwiJHJldF9vcl8xOSIsIj4iLCIkcmV0X29yXzIwIiwibWluIiwiJHJldF9vcl8yMSIsIiRyZXRfb3JfMjIiLCIkcmV0X29yXzIzIiwiaW5maW5pdHkiLCIkcmV0X29yXzI0IiwiJHJldF9vcl8yNSIsIiRyZXRfb3JfMjYiLCItQCIsIiRyZXRfb3JfMjciLCJyYW5nZV9iZWdpbiIsInJhbmdlX2VuZCIsIi0iLCJ0b19pIiwic3RlcCIsImNvZXJjZV90byEiLCIvIiwiY2VpbCIsImkiLCJsb29wIiwiKyIsIioiLCI+PSIsImVhY2hfd2l0aF9pbmRleCIsImlkeCIsIiUiLCJic2VhcmNoIiwidG9fcyIsIiRyZXRfb3JfMjgiLCIkcmV0X29yXzI5IiwiaW5zcGVjdCIsIiRyZXRfb3JfMzAiLCIkcmV0X29yXzMxIiwibWFyc2hhbF9sb2FkIiwiYXJncyIsIltdIiwiaGFzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsMEJBQVJBLENBQUE7QUFBQSxJQUVDLGtDQUZEO0FBQUEsUUFJQUMsYUFBQUEsQ0FBWSxTQUFRLEtBQXBCQSxDQUpBO0FBQUE7QUFNQUMsSUFBQUEsOEJBQUFBLHNCQUFBQSxzQkFBZSxLQUFELEVBQVEsSUFBUixFQUFjLE9BQTVCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFWRjtBQVU4QixNQUFBO0FBQUEsTUFBQSxZQUFVLEtBQVY7QUFBQSxNQUFBLENBVjlCO0FBQUEsTUFXSSxJQUFBLFFBQWdEQyxVQUFoRCxDQUFBO0FBQUEsWUFBQUMsT0FBQUEsQ0FBTSwyQkFBVywyQkFBakJBLENBQUEsQ0FYSjtBQUFBLE1BWUksSUFBQSxRQUFrRCxhQUFBLElBQUEsUUFadERDLENBQUFBLFlBWXNELGFBQUEsSUFBQSxRQVp0REMsQ0FBQUEsWUFZc0RDLEtBQUFDLFFBQUFBLENBQVVDLElBQVZELENBWnRERixDQVlzRCxDQUFBO0FBQUEsUUFadEQsT0FBQTtBQVlzRCxNQUFBO0FBQUEsUUFBa0IsT0FBQUMsS0FBQUcsU0FBQUEsQ0FBQUE7QUFBbEIsTUFBQSxDQUFBLGtCQVp0REwsQ0FZc0QsQ0FBQTtBQUFBLFFBWnRELE9BQUE7QUFZc0QsTUFBQTtBQUFBLFFBQWdDLE9BQUFJLElBQUFDLFNBQUFBLENBQUFBO0FBQWhDLE1BQUEsQ0FBQSxrQkFBbEQsQ0FBQTtBQUFBLE1BQUE7QUFBQSxZQUFBTixPQUFBQSxDQUFNLCtCQUFlLHFCQUFyQkE7QUFBQSxNQUFBLENBWko7QUFBQSxNQWNJRCxhQUFTSSxLQWRiO0FBQUEsTUFlSUksV0FBU0YsSUFmYjtBQUFBLE1BZ0JJLE9BQUFHLENBQUFBLFlBQVNDLE9BQVRELENBaEJKO0FBVUVWLElBQUFBLENBQUFBLGtDQUFBQSxDQU5BO0FBQUE7QUFlQVksSUFBQUEsdUJBQUFBLHFCQUFBQSxTQUFRLEtBQVJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLFdBQUFDLGFBQUFBLENBQVNDLEtBQVREO0FBREZELElBQUFBLENBQUFBLGdDQUFBQSxDQWZBO0FBQUE7QUFvQkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUExQkU7QUFBQTtBQTRCQUcsSUFBQUEseUJBQUFBLGlCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBLE1BQUFBO0FBQUFBLE1BQUFBO0FBQUFBLE1BQUFBO0FBQUFBLE1BQUFBO0FBQUFBO0FBaENGO0FBZ0NZLE1BQUEscUNBaENaO0FBQUEsTUFpQ0ksSUFBQSxRQUFHLGFBQUEsSUFBQSxRQWpDUEMsQ0FBQUEsWUFpQ1FDLGVBQURDLE1BQUFBLENBQUFBLENBakNQRixDQWlDTyxDQUFBO0FBQUEsUUFBaUIsT0FBQyxpQkFBRDtBQUFqQixNQUFBO0FBQUEsUUFqQ1AsT0FBQTtBQWlDTyxNQUFBLENBQUEsa0JBQUgsQ0FBQTtBQUFBLFFBQ0UsT0FBTyxJQUFBLHFCQUFBLGFBRFQsQ0FqQ0o7QUFBQSxNQW9DSSxPQUFBLFdBQUEsRUFBQSxzRUFBQSxTQUFBLFFBQUEsT0FBQSxDQXBDSjtBQWdDRUQsSUFBQUEsQ0FBQUEsNEJBQUFBLENBNUJBO0FBQUE7QUFtQ0FJLElBQUFBLHdCQUFBQSxnQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQSxNQUFBQTtBQUFBQSxNQUFBQTtBQUFBQSxNQUFBQTtBQUFBQSxNQUFBQTtBQUFBQTtBQUNFLE1BQUEsSUFBQSxRQUFnRSxpQkFBaEUsQ0FBQTtBQUFBLFlBQUFqQixPQUFBQSxDQUFNLDJCQUFXLDBDQUFqQkEsQ0FBQSxDQUFBO0FBQUEsTUFDQSxPQUFBLFdBQUEsRUFBQSxvRUFBQSxRQUFBLFFBQUEsT0FBQSxDQURBO0FBREZpQixJQUFBQSxDQUFBQSwyQkFBQUEsQ0FuQ0E7QUFBQTtBQXdDQUMsSUFBQUEsMEJBQUFBLHNCQUFBQSxTQUFXLEtBQVhBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLFVBQVUsYUFBQSxJQUFBLFFBN0NkQyxDQUFBQSxZQTZDYyxhQUFBLElBQUEsUUE3Q2RDLENBQUFBLFlBNkNlLGFBQUEsSUFBQSxRQTdDZkMsQ0FBQUEsWUE2Q2V2QixVQUFBTyxTQUFBQSxDQUFBQSxDQTdDZmdCLENBNkNlLENBQUE7QUFBQSxRQUFlLE9BQUFDO0FBQWYsTUFBQTtBQUFBLFFBN0NmLE9BQUE7QUE2Q2UsTUFBQSxDQUFBLGtCQTdDZkYsQ0E2Q2MsQ0FBQTtBQUFBLFFBN0NkLE9BQUE7QUE2Q2MsTUFBQTtBQUFBO0FBQXVCLFFBQUMsT0FBQXRCLFVBQUFLLFFBQUFBLENBQVdRLEtBQVhSLENBQUQ7QUFBdkIsTUFBQSxDQUFBLGtCQTdDZGdCLENBNkNjLENBQUE7QUFBQSxRQTdDZCxPQUFBO0FBNkNjLE1BQUE7QUFBQSxRQUE2QyxPQUFBO0FBQTdDLE1BQUEsQ0FBQSxrQkFBVjtBQUFBLE1BQ0FJLFVBQVUsYUFBQSxJQUFBLFFBOUNkQyxDQUFBQSxZQThDYyxhQUFBLElBQUEsUUE5Q2RDLENBQUFBLFlBOENlLGFBQUEsSUFBQSxRQTlDZkMsQ0FBQUEsWUE4Q2VwQixRQUFBRCxTQUFBQSxDQUFBQSxDQTlDZnFCLENBOENlLENBQUE7QUFBQSxRQUFhLE9BQUFKO0FBQWIsTUFBQTtBQUFBLFFBOUNmLE9BQUE7QUE4Q2UsTUFBQSxDQUFBLGtCQTlDZkcsQ0E4Q2MsQ0FBQTtBQUFBLFFBOUNkLE9BQUE7QUE4Q2MsTUFBQTtBQUFBO0FBQXFCLFFBQUMsT0FBQWQsS0FBQVIsUUFBQUEsQ0FBVUcsUUFBVkgsQ0FBRDtBQUFyQixNQUFBLENBQUEsa0JBOUNkcUIsQ0E4Q2MsQ0FBQTtBQUFBLFFBOUNkLE9BQUE7QUE4Q2MsTUFBQTtBQUFBLFFBQXlDLE9BQUE7QUFBekMsTUFBQSxDQUFBLGtCQURWO0FBQUEsTUFFQSxJQUFBLFFBL0NKRyxDQUFBQSxhQStDSSxhQUFBLElBQUEsUUEvQ0pDLENBQUFBLGFBK0NJLGFBQUEsSUFBQSxRQUFHckIsU0FBSCxDQUFBO0FBQUEsUUFDRSxJQUFBLFFBaEROc0IsQ0FBQUEsYUFnRE1OLE9BaEROTSxDQWdETSxDQUFBO0FBQUEsVUFBVyxPQUFBQyxPQUFBUCxPQUFBTyxFQUFVQyxDQUFWRDtBQUFYLFFBQUE7QUFBQSxVQWhETixPQUFBO0FBZ0RNLFFBQUE7QUFERixNQUFBLE9BR0UsSUFBQSxRQWxETkUsQ0FBQUEsYUFrRE1ULE9BbEROUyxDQWtETSxDQUFBO0FBQUEsUUFBVyxPQUFBQyxPQUFBVixPQUFBVSxFQUFXRixDQUFYRTtBQUFYLE1BQUE7QUFBQSxRQWxETixPQUFBO0FBa0RNLE1BQUEsQ0FIRixrQkEvQ0pMLENBK0NJLENBQUE7QUFBQSxRQUlPLE9BQUFWO0FBSlAsTUFBQTtBQUFBLFFBL0NKLE9BQUE7QUErQ0ksTUFBQSxDQUFBLGtCQS9DSlMsQ0ErQ0ksQ0FBQTtBQUFBLFFBSWtCLE9BQUFNLE9BQUFmLE9BQUFlLEVBQVdGLENBQVhFO0FBSmxCLE1BQUE7QUFBQSxRQS9DSixPQUFBO0FBK0NJLE1BQUEsQ0FGQTtBQURGaEIsSUFBQUEsQ0FBQUEsaUNBQUFBLENBeENBO0FBQUE7QUFrREFpQixJQUFBQSx3QkFBQUEsZ0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUF0REY7QUFzRFcsTUFBQSxvQ0F0RFg7QUFBQSxNQXVESSxJQUF1Q3BCLGVBQXZDO0FBQUEsTUFBQTtBQUFBLFFBQUEsT0FBT3FCLFVBQUFBLFlBQUFBLEVBQUFBLENBQVMsTUFBVEEsQ0FBQUEsRUF2RFgsZ0JBQUEsRUFBQTs7QUFBQSxRQXVENkIsV0FBQUMsTUFBQUEsQ0FBQUEsQ0F2RDdCLGtCQUFBLGlCQUFBLEtBdURXRDtBQUFQLE1BQUEsQ0F2REo7QUFBQTtBQTBEQTs7QUFFQSxVQUFZckMsVUFBTyxnQkFBa0JRLFFBQUs7QUFDMUMsWUFBY1IsVUFBTyxjQUFnQlEsUUFBSztBQUMxQyxjQUFZUCxPQUFBQSxDQUFNLDJCQUFXLDBCQUFqQkE7QUFDWjs7QUFFQSxpQkFBbUJELFVBQU8sVUFBWVEsUUFBSyxHQUFLLGFBQUEsSUFBQSxRQUFBQyxTQUFBLENBQUE7QUFBQSxRQUFRLE9BQUF3QjtBQUFSLE1BQUE7QUFBQSxRQUFZLE9BQUFNO0FBQVosTUFBQSxDQUFBLGtCQUFjO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFZdkMsVUFBTyxnQkFBa0JRLFFBQUs7QUFDMUMsUUFBVWdDLE1BQUF4QyxVQUFBd0MsUUFBQUEsRUFBQUEsQ0FBWWhDLFVBQU1DLFNBQWxCK0IsQ0FBQUEsRUFBMEJDLGdCQUExQkQ7QUFDVjtBQUNBO0FBQ0EsSUE1RUE7QUFBQSxNQThFSUUsVUFBVTFDLFVBOUVkO0FBQUEsTUErRUlNLE9BQVVFLFFBL0VkO0FBQUEsTUFpRkksSUFBQSxRQUFPa0MsT0FBQUMsZ0JBQUFBLENBQW9CLE1BQXBCQSxDQUFQLENBQUE7QUFBQSxNQUFBO0FBQUEsWUFDRTFDLE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLHFCQUFBLEdBQUEsQ0FBc0J5QyxPQUFBOUMsT0FBQUEsQ0FBQUEsQ0FBdEIsQ0FBakJLO0FBREYsTUFBQSxDQWpGSjtBQUFBLE1BcUZJLE9BQUEsUUFBTSxhQUFBLElBQUEsUUFyRlYyQyxDQUFBQSxhQXFGVXBDLFFBQUFELFNBQUFBLENBQUFBLENBckZWcUMsQ0FxRlUsQ0FBQTtBQUFBLFFBckZWLE9BQUE7QUFxRlUsTUFBQTtBQUFBLFFBQWEsT0FBQVosT0FBQ1UsT0FBQXJDLFFBQUFBLENBQVlDLElBQVpELENBQUQyQixFQUFxQkMsQ0FBckJEO0FBQWIsTUFBQSxDQUFBLGtCQUFOLENBQUE7QUFBQTtBQUNFLFFBQUEsbUJBQU1VLE9BQU4sQ0FBQTtBQUFBLFFBRUFBLFVBQVVBLE9BQUFHLE1BQUFBLENBQUFBLENBRlY7QUFERixNQUFBLENBckZKO0FBQUEsTUEyRkksSUFBQSxRQUFpQixhQUFBLElBQUEsUUEzRnJCQyxDQUFBQSxhQTJGc0JyQyxTQUFEUSxNQUFBQSxDQUFBQSxDQTNGckI2QixDQTJGcUIsQ0FBQTtBQUFBLFFBQVUsT0FBQUosT0FBQUssT0FBQUEsQ0FBV3pDLElBQVh5QztBQUFWLE1BQUE7QUFBQSxRQTNGckIsT0FBQTtBQTJGcUIsTUFBQSxDQUFBLGtCQUFqQixDQUFBO0FBQUEsUUFBQSxtQkFBTUwsT0FBTixDQUFBLENBM0ZKO0FBQUEsTUE2RkksT0FBQU0sSUE3Rko7QUFzREVaLElBQUFBLENBQUFBLDJCQUFBQSxDQWxEQTtBQUFBO0FBNEZBYSxJQUFBQSx3QkFBQUEsb0JBQUFBLFNBQVMsS0FBVEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQSxJQUFBLFFBQW9CLHFCQUFBdEMsUUFBQUEsQ0FBVXVDLEtBQVZ2QyxDQUFwQixDQUFBO0FBQUEsTUFBQTtBQUFBLFFBQUEsT0FBTztBQUFQLE1BQUEsQ0FBQTtBQUFBLE1BRUEsSUFBQSxRQW5HSndDLENBQUFBLGFBbUdJLGFBQUEsSUFBQSxRQW5HSkMsQ0FBQUEsYUFtR0kzQyxTQUFBRSxRQUFBQSxDQUFVdUMsS0FBQUcsaUJBQUFBLENBQUFBLENBQVYxQyxDQW5HSnlDLENBbUdJLENBQUE7QUFBQSxRQUNFLE9BQUFwRCxVQUFBaUQsU0FBQUEsQ0FBWUMsS0FBQUksT0FBQUEsQ0FBQUEsQ0FBWkw7QUFERixNQUFBO0FBQUEsUUFuR0osT0FBQTtBQW1HSSxNQUFBLENBQUEsa0JBbkdKRSxDQW1HSSxDQUFBO0FBQUEsUUFFRSxPQUFBM0MsUUFBQXlDLFNBQUFBLENBQVVDLEtBQUFLLEtBQUFBLENBQUFBLENBQVZOO0FBRkYsTUFBQTtBQUFBLFFBbkdKLE9BQUE7QUFtR0ksTUFBQSxDQUZBO0FBREZBLElBQUFBLENBQUFBLCtCQUFBQSxDQTVGQTtBQUFBLElBb0dBLGlCQUFNLElBQU4sRUFBUyxNQUFULENBcEdBO0FBQUE7QUFzR0FJLElBQUFBLGdDQUFBQSw0QkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQTVDO0FBREY0QyxJQUFBQSxDQUFBQSx1Q0FBQUEsQ0F0R0E7QUFBQTtBQTBHQWpELElBQUFBLHlCQUFBQSxrQkFBQUEsaUJBQVUsQ0FBVkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBLE1BQUFBO0FBQUFBLE1BQUFBO0FBQUFBLE1BQUFBO0FBQUFBLE1BQUFBO0FBQUFBO0FBOUdGLE1BQUE7QUFBQSxNQStHSSxJQUFBLFFBQWlFSixVQUFBTyxTQUFBQSxDQUFBQSxDQUFqRSxDQUFBO0FBQUEsWUFBQU4sT0FBQUEsQ0FBTSw0QkFBWSwyQ0FBbEJBLENBQUEsQ0EvR0o7QUFBQSxNQWdISSxJQUFBLFFBQWtCLFNBQWxCLENBQUE7QUFBQSxRQUFBLE9BQU9ELFVBQVAsQ0FoSEo7QUFBQSxNQWlISSxPQUFBLFdBQUEsRUFBQSx1RUFBQSxTQUFBLFFBQUEsT0FBQSxDQWpISjtBQThHRUksSUFBQUEsQ0FBQUEsOEJBQUFBLENBMUdBO0FBQUEsSUFnSEEsaUJBQU0sVUFBTixFQUFlLFFBQWYsQ0FoSEE7QUFBQTtBQWtIQUUsSUFBQUEsd0JBQUFBLGlCQUFBQSxnQkFBUyxDQUFUQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUF0SEYsTUFBQTtBQUFBLE1BdUhJLElBQUEsUUFBK0RFLFFBQUFELFNBQUFBLENBQUFBLENBQS9ELENBQUE7QUFBQSxZQUFBTixPQUFBQSxDQUFNLDRCQUFZLHlDQUFsQkEsQ0FBQSxDQXZISjtBQUFBLE1Bd0hJLElBQUEsUUFBZ0IsU0FBaEIsQ0FBQTtBQUFBLFFBQUEsT0FBT08sUUFBUCxDQXhISjtBQUFBLE1BeUhJLFdBQUFVLE1BQUFBLENBQUFBLENBQUFaLE1BQUFBLENBQVVrRCxDQUFWbEQsQ0F6SEo7QUFzSEVBLElBQUFBLENBQUFBLDZCQUFBQSxDQWxIQTtBQUFBO0FBeUhBbUQsSUFBQUEsdUJBQUFBLGdCQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUEsTUFBQUE7QUFBQUEsTUFBQUE7QUFBQUEsTUFBQUE7QUFBQUEsTUFBQUE7QUFBQUEsTUFDRSxJQUFBLFFBQUdqRCxRQUFBRCxTQUFBQSxDQUFBQSxDQUFILENBQUE7QUFBQSxRQUNFLFdBQUFOLE9BQUFBLENBQU0sNEJBQVkseUNBQWxCQTtBQURGLE1BQUEsT0FFQSxJQUFNZSxnQkFBTjtBQUFBLFFBQ0UsT0FBQSxXQUFBLEVBQUEsbUVBQUEsT0FBQSxRQUFBLE9BQUE7QUFERixNQUFBLE9BRUEsSUFBQSxRQUFNLGFBQUEsSUFBQSxRQWxJVjBDLENBQUFBLGFBa0lXMUQsVUFBQU8sU0FBQUEsQ0FBQUEsQ0FBRFUsTUFBQUEsQ0FBQUEsQ0FsSVZ5QyxDQWtJVSxDQUFBO0FBQUE7QUFBZ0IsUUFBQyxJQUFBLFFBbEkzQkMsQ0FBQUEsYUFrSTJCQyxPQUFBNUQsVUFBQTRELEVBQVNwRCxRQUFUb0QsQ0FsSTNCRCxDQWtJMkIsQ0FBQTtBQUFBLFVBbEkzQixPQUFBO0FBa0kyQixRQUFBLE9BQ0EsSUFBQSxRQW5JM0JFLENBQUFBLGFBbUkyQnBELFNBbkkzQm9ELENBbUkyQixDQUFBO0FBQUEsVUFBUyxPQUFBN0QsVUFBQStDLE9BQUFBLENBQVV2QyxRQUFWdUM7QUFBVCxRQUFBO0FBQUEsVUFuSTNCLE9BQUE7QUFtSTJCLFFBQUEsQ0FERDtBQUFoQixNQUFBO0FBQUEsUUFsSVYsT0FBQTtBQWtJVSxNQUFBLENBQUEsa0JBQU4sQ0FBQTtBQUFBLFFBRUUsT0FBQTtBQUZGLE1BQUE7QUFBQSxRQUlFLE9BQUd0QyxTQUFNLEdBQUtELFFBQUssT0FBU0E7QUFKOUIsTUFBQTtBQUxGaUQsSUFBQUEsQ0FBQUEsMkJBQUFBLENBekhBO0FBQUEsSUFzSUEsaUJBQU0sU0FBTixFQUFjLFFBQWQsQ0F0SUE7QUFBQTtBQXdJQUssSUFBQUEsdUJBQUFBLGdCQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUEsTUFBQUE7QUFBQUEsTUFBQUE7QUFBQUEsTUFBQUE7QUFBQUEsTUFBQUE7QUFBQUEsTUFDRSxJQUFBLFFBQUc5RCxVQUFBTyxTQUFBQSxDQUFBQSxDQUFILENBQUE7QUFBQSxRQUNFLFdBQUFOLE9BQUFBLENBQU0sNEJBQVksMkNBQWxCQTtBQURGLE1BQUEsT0FFQSxJQUFNZSxnQkFBTjtBQUFBLFFBQ0UsT0FBQSxXQUFBLEVBQUEsbUVBQUEsT0FBQSxRQUFBLE9BQUE7QUFERixNQUFBLE9BRUEsSUFBQSxRQUFNLGFBQUEsSUFBQSxRQWpKVitDLENBQUFBLGFBaUpXdkQsUUFBQUQsU0FBQUEsQ0FBQUEsQ0FBRFUsTUFBQUEsQ0FBQUEsQ0FqSlY4QyxDQWlKVSxDQUFBO0FBQUE7QUFBYyxRQUFDLElBQUEsUUFqSnpCQyxDQUFBQSxhQWlKeUJKLE9BQUE1RCxVQUFBNEQsRUFBU3BELFFBQVRvRCxDQWpKekJJLENBaUp5QixDQUFBO0FBQUEsVUFqSnpCLE9BQUE7QUFpSnlCLFFBQUEsT0FDQSxJQUFBLFFBbEp6QkMsQ0FBQUEsYUFrSnlCeEQsU0FsSnpCd0QsQ0FrSnlCLENBQUE7QUFBQSxVQUFTLE9BQUFqRSxVQUFBK0MsT0FBQUEsQ0FBVXZDLFFBQVZ1QztBQUFULFFBQUE7QUFBQSxVQWxKekIsT0FBQTtBQWtKeUIsUUFBQSxDQUREO0FBQWQsTUFBQTtBQUFBLFFBakpWLE9BQUE7QUFpSlUsTUFBQSxDQUFBLGtCQUFOLENBQUE7QUFBQSxRQUVFLE9BQUE7QUFGRixNQUFBO0FBQUEsUUFJRSxPQUFBL0M7QUFKRixNQUFBO0FBTEY4RCxJQUFBQSxDQUFBQSwyQkFBQUEsQ0F4SUE7QUFBQTtBQXFKQXhCLElBQUFBLHdCQUFBQSxpQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUE0QixXQUFXLElBQUEscUJBQUEsYUFBWDtBQUFBLE1BRUEsSUFBQSxRQUFZLGFBQUEsSUFBQSxRQTVKaEJDLENBQUFBLGFBNEppQixhQUFBLElBQUEsUUE1SmpCQyxDQUFBQSxhQTRKaUJwRSxVQUFBK0MsT0FBQUEsQ0FBVW1CLFFBQVZuQixDQTVKakJxQixDQTRKaUIsQ0FBQTtBQUFBLFFBQXNCLE9BQUM1RCxRQUFBRCxTQUFBQSxDQUFBQSxDQUFEVSxNQUFBQSxDQUFBQTtBQUF0QixNQUFBO0FBQUEsUUE1SmpCLE9BQUE7QUE0SmlCLE1BQUEsQ0FBQSxrQkE1SmpCa0QsQ0E0SmdCLENBQUE7QUFBQSxRQTVKaEIsT0FBQTtBQTRKZ0IsTUFBQTtBQUFBO0FBQXNDLFFBQUMsSUFBQSxRQTVKdkRFLENBQUFBLGFBNEp1RDdELFFBQUF1QyxPQUFBQSxDQUFTbUIsUUFBREksT0FBQUEsQ0FBQUEsQ0FBUnZCLENBNUp2RHNCLENBNEp1RCxDQUFBO0FBQUEsVUFBcUIsT0FBQ3JFLFVBQUFPLFNBQUFBLENBQUFBLENBQURVLE1BQUFBLENBQUFBO0FBQXJCLFFBQUE7QUFBQSxVQTVKdkQsT0FBQTtBQTRKdUQsUUFBQSxDQUFEO0FBQXRDLE1BQUEsQ0FBQSxrQkFBWixDQUFBO0FBQUEsUUFBQSxPQUFPZ0IsQ0FBUCxDQUZBO0FBQUEsTUFHQSxJQUFBLFFBQW9CLGlCQUFwQixDQUFBO0FBQUEsUUFBQSxPQUFPaUMsUUFBUCxDQUhBO0FBQUEsTUFJQSxJQUFBLFFBQWtCLGFBQUEsSUFBQSxRQTlKdEJLLENBQUFBLGFBOEpzQix1QkFBQTVELFFBQUFBLENBQVlYLFVBQVpXLENBOUp0QjRELENBOEpzQixDQUFBO0FBQUEsUUFBc0IsT0FBQSx1QkFBQTVELFFBQUFBLENBQVlILFFBQVpHO0FBQXRCLE1BQUE7QUFBQSxRQTlKdEIsT0FBQTtBQThKc0IsTUFBQSxDQUFBLGtCQUFsQixDQUFBO0FBQUEsTUFBQTtBQUFBLFFBQUEsT0FBTztBQUFQLE1BQUEsQ0FKQTtBQUFBLE1BTUE2RCxjQUFjeEUsVUFOZDtBQUFBLE1BT0F5RSxZQUFjakUsUUFQZDtBQUFBLE1BUUEsSUFBQSxRQUFtQkMsU0FBbkIsQ0FBQTtBQUFBLFFBQUFnRSxZQWxLSkMsVUFrS0lELFNBbEtKQyxFQWtLa0JuQyxDQWxLbEJtQyxDQWtLSSxDQVJBO0FBQUEsTUFVQSxJQUFBLFFBQVkxQyxPQUFBeUMsU0FBQXpDLEVBQVl3QyxXQUFaeEMsQ0FBWixDQUFBO0FBQUEsUUFBQSxPQUFPQyxDQUFQLENBVkE7QUFBQSxNQVlBLE9BQUEsQ0FBQyxxQ0FBRCxDQUFBMEMsTUFBQUEsQ0FBQUEsQ0FaQTtBQURGckMsSUFBQUEsQ0FBQUEsNEJBQUFBLENBckpBO0FBQUE7QUFxS0FzQyxJQUFBQSx3QkFBQUEsaUJBQUFBLGdCQUFTLENBQVRBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQXpLRjtBQXlLVyxNQUFBO0FBQUEsTUFBQSxNQUFJckMsQ0FBSjtBQUFBLE1BQUEsQ0F6S1g7QUFBQTtBQTJLQTtBQUNBO0FBQ0EsY0FBZ0Isb0JBQUFzQyxlQUFBQSxDQUFnQnJCLEdBQUcseUJBQVMsUUFBNUJxQjtBQUNoQjs7QUFFQTtBQUNBLGNBQVk1RSxPQUFBQSxDQUFNLCtCQUFlLHdCQUFyQkE7QUFDWjtBQUNBLGNBQVlBLE9BQUFBLENBQU0sK0JBQWUsaUJBQXJCQTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxhQUFlRCxVQUFBMkMsZ0JBQUFBLENBQW1CLE1BQW5CQSxDQUEwQjtBQUN6QztBQUNBOztBQUVBLFlBQWMzQyxVQUFPLGdCQUFrQlEsUUFBSztBQUM1QztBQUNBOztBQUVBO0FBQ0EsaUJBQW9Cc0UsZUFBQXhDLE1BQUFBLENBQUFBLENBQUF3QyxFQUFPdEIsQ0FBUHNCLENBQURDLE1BQUFBLENBQUFBLENBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTRFLElBQUEscUJBQUEsWUFBZTtBQUMzRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQXpOQTtBQUFBLE1BMk5JLElBQU8vRCxnQkFBUDtBQUFBLE1BQUE7QUFBQSxRQUNFLE9BQU9xQixVQUFBQSxZQUFBQSxFQUFBQSxDQUFTLFFBQU9tQixDQUFoQm5CLENBQUFBLEVBNU5iLGlCQUFBLEVBQUE7O0FBQUE7QUE4TkE7QUFDQTtBQUNBLFFBaE9BLG1CQUFBLGtCQUFBLE1BNE5hQTtBQURULE1BQUEsQ0EzTko7QUFBQSxNQW9PSyxnQkFwT0w7QUFBQSxNQXNPSSxJQUFBLFFBQUksOENBQUosQ0FBQTtBQUFBO0FBQ0UsUUFBQTJDLElBQUkvQyxDQUFKO0FBQUEsUUFDQWdELDRDQUFBQSxPQUFBQSxVQUFBQSxRQUFBQSxFQUFBQSxFQUFBQSxFQXhPTixpQkFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBeU9RLFVBQUF2QyxVQUFVd0MsU0FBQWxGLFVBQUFrRixFQUFTQyxVQUFBSCxDQUFBRyxFQUFJM0IsQ0FBSjJCLENBQVRELENBQVY7QUFBQSxVQUNBLElBQUEsUUFBR3pFLFNBQUgsQ0FBQTtBQUFBLFlBQ0UsSUFBQSxRQUFTMkUsT0FBQTFDLE9BQUEwQyxFQUFXNUUsUUFBWDRFLENBQVQsQ0FBQTtBQUFBO0FBQUEsY0FBQSxZQUFBLE9BQUE7QUFERixVQUFBLE9BRUEsSUFBQSxRQUFNeEIsT0FBQWxCLE9BQUFrQixFQUFVcEQsUUFBVm9ELENBQU4sQ0FBQTtBQUFBO0FBQ0UsWUFBQSxZQUFBLE9BREYsQ0FIQTtBQUFBLFVBTUEsb0JBQU1sQixPQUFOLENBTkE7QUFBQSxVQU9BLE9BQUFzQyxDQUFBQSxJQWhQUkUsU0FnUFFGLENBaFBSRSxFQWdQYTNDLENBaFBiMkMsQ0FnUFFGLENBUEEsQ0F6T1IsbUJBQUEsbUJBQUEsa0JBQUEsTUF3T01DO0FBQUFBLFFBQUFBLDRFQURBO0FBREYsTUFBQTtBQUFBO0FBYUU7QUFDTixZQUFjakYsVUFBTyxnQkFBa0JRLFFBQUs7QUFDNUMsY0FBWVAsT0FBQUEsQ0FBTSwyQkFBVyw2Q0FBakJBO0FBQ1o7QUFDQSxNQUpNO0FBQUEsUUFLQW9GLFVBQUFBLG1CQUFBQSxFQUFBQSxFQUFBQSxFQXhQTixpQkF3UDBCLEtBQUQsRUFBUSxHQXhQakMsRUFBQTs7QUFBQTtBQUFBO0FBd1AwQixVQUFBO0FBQUEsVUFBQTtBQUFBLFVBQUEsQ0F4UDFCO0FBQUE7QUF3UGlDLFVBQUE7QUFBQSxVQUFBO0FBQUEsVUFBQSxDQXhQakM7QUFBQSxVQXlQUSxJQUFnQkMsR0FBQUMsTUFBQUEsQ0FBTS9CLENBQU4rQixDQUFBeEMsT0FBQUEsQ0FBV2QsQ0FBWGMsQ0FBaEI7QUFBQSxZQUFBLE9BQUEsb0JBQU1sQyxLQUFOLENBQUE7QUFBQSxVQUFBO0FBQUE7QUFBQSxVQUFBLENBelBSLENBQUEsbUJBQUEsa0JBQUEsTUF3UE13RSxDQUxBO0FBYkYsTUFBQSxDQXRPSjtBQUFBLE1BNFBJLE9BQUFyQyxJQTVQSjtBQXlLRTRCLElBQUFBLENBQUFBLDZCQUFBQSxDQXJLQTtBQUFBO0FBMlBBWSxJQUFBQSwyQkFBQUEsb0JBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUEvUEY7QUErUGMsTUFBQSx3Q0EvUGQ7QUFBQSxNQWdRSSxJQUFpQ3hFLGVBQWpDO0FBQUEsTUFBQTtBQUFBLFFBQUEsV0FBT3FCLFVBQUFBLENBQVMsU0FBVEE7QUFBUCxNQUFBLENBaFFKO0FBQUEsTUFrUUksSUFBQSxRQUFJLHFFQUFKLENBQUE7QUFBQSxZQUNFcEMsT0FBQUEsQ0FBTSxxQ0FBcUIsa0NBQTNCQSxDQURGLENBbFFKO0FBQUEsTUFzUUksSUFBQSxRQUFRLDhDQUFSLENBQUE7QUFBQSxNQUFBO0FBQUEsWUFDRUEsT0FBQUEsQ0FBTSwyQkFBVyxFQUFBLEdBQUEsNkJBQUEsR0FBQSxDQUE4QkQsVUFBQUosT0FBQUEsQ0FBQUEsQ0FBOUIsQ0FBakJLO0FBREYsTUFBQSxDQXRRSjtBQUFBLE1BMFFJLE9BQUF1RixVQUFBdEUsTUFBQUEsQ0FBQUEsQ0FBQXNFLFdBQUFBLEVBQUFBLEVBQUFBLEVBQWMvQyxnQkFBZCtDLENBMVFKO0FBK1BFQSxJQUFBQSxDQUFBQSwrQkFBQUEsQ0EzUEE7QUFBQTtBQXlRQUMsSUFBQUEsd0JBQUFBLGlCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxFQUFBLEdBQUEsQ0FBRyxhQUFBLElBQUEsUUE5UVBDLENBQUFBLGFBOFFPMUYsVUE5UVAwRixDQThRTyxDQUFBO0FBQUEsUUE5UVAsT0FBQTtBQThRTyxNQUFBO0FBQUEsUUFBVSxPQUFBO0FBQVYsTUFBQSxDQUFBLGtCQUFILENBQUEsR0FBQSxDQUFrQixhQUFBLElBQUEsUUFBQWpGLFNBQUEsQ0FBQTtBQUFBLFFBQVEsT0FBQTtBQUFSLE1BQUE7QUFBQSxRQUFnQixPQUFBO0FBQWhCLE1BQUEsQ0FBQSxrQkFBbEIsQ0FBQSxHQUFBLENBQXlDLGFBQUEsSUFBQSxRQTlRN0NrRixDQUFBQSxhQThRNkNuRixRQTlRN0NtRixDQThRNkMsQ0FBQTtBQUFBLFFBOVE3QyxPQUFBO0FBOFE2QyxNQUFBO0FBQUEsUUFBUSxPQUFBO0FBQVIsTUFBQSxDQUFBLGtCQUF6QztBQURGRixJQUFBQSxDQUFBQSw0QkFBQUEsQ0F6UUE7QUFBQTtBQTZRQUcsSUFBQUEsMkJBQUFBLG9CQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxFQUFBLEdBQUEsQ0FBRyxhQUFBLElBQUEsUUFsUlBDLENBQUFBLGFBa1JPN0YsVUFsUlA2RixDQWtSTyxDQUFBO0FBQUEsUUFBVSxPQUFBN0YsVUFBQTRGLFNBQUFBLENBQUFBO0FBQVYsTUFBQTtBQUFBLFFBbFJQLE9BQUE7QUFrUk8sTUFBQSxDQUFBLGtCQUFILENBQUEsR0FBQSxDQUE4QixhQUFBLElBQUEsUUFBQW5GLFNBQUEsQ0FBQTtBQUFBLFFBQVEsT0FBQTtBQUFSLE1BQUE7QUFBQSxRQUFnQixPQUFBO0FBQWhCLE1BQUEsQ0FBQSxrQkFBOUIsQ0FBQSxHQUFBLENBQXFELGFBQUEsSUFBQSxRQWxSekRxRixDQUFBQSxhQWtSeUR0RixRQWxSekRzRixDQWtSeUQsQ0FBQTtBQUFBLFFBQVEsT0FBQXRGLFFBQUFvRixTQUFBQSxDQUFBQTtBQUFSLE1BQUE7QUFBQSxRQWxSekQsT0FBQTtBQWtSeUQsTUFBQSxDQUFBLGtCQUFyRDtBQURGQSxJQUFBQSxDQUFBQSwrQkFBQUEsQ0E3UUE7QUFBQTtBQWlSQUcsSUFBQUEsZ0NBQUFBLHlCQUFBQSx3QkFBaUIsSUFBakJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUEvRixhQUFTZ0csSUFBQUMsT0FBQUEsQ0FBSyxPQUFMQSxDQUFUO0FBQUEsTUFDQXpGLFdBQU93RixJQUFBQyxPQUFBQSxDQUFLLEtBQUxBLENBRFA7QUFBQSxNQUVBLE9BQUF4RixDQUFBQSxZQUFRdUYsSUFBQUMsT0FBQUEsQ0FBSyxNQUFMQSxDQUFSeEYsQ0FGQTtBQURGc0YsSUFBQUEsQ0FBQUEsb0NBQUFBLENBalJBO0FBQUEsSUF1UkEsT0FBQUcsQ0FBQUEsd0JBQUFBLGlCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxDQUFDbEcsVUFBRCxFQUFTUSxRQUFULEVBQWVDLFNBQWYsQ0FBQXlGLE1BQUFBLENBQUFBO0FBREZBLElBQUFBLENBQUFBLDRCQUFBQSxDQUFBQSxnQkF2UkE7QUFERnRHLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBRkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxODU1NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvYy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHNsaWNlXG5cbmNsYXNzIFByb2MgPCBgRnVuY3Rpb25gXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3Byb2MnLCB0cnVlKWBcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfbGFtYmRhJywgZmFsc2UpYFxuXG4gIGRlZiBzZWxmLm5ldygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIGEgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIGNhbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHNlbGYuJCRwID0gYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQsICRicmsgPSBzZWxmLiQkYnJrO1xuXG4gICAgICBpZiAoJGJyaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZWxmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IE9wYWwueWllbGRYKHNlbGYsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciA9PT0gJGJyaykge1xuICAgICAgICAgICAgcmV0dXJuICRicmsuJHZcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSkge1xuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gT3BhbC55aWVsZFgoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIFtdIGNhbGxcbiAgYWxpYXMgPT09IGNhbGxcbiAgYWxpYXMgeWllbGQgY2FsbFxuXG4gIGRlZiA+PihvdGhlcilcbiAgICBwcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgb3V0ID0gY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICAgb3RoZXIuY2FsbChvdXQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PChvdGhlcilcbiAgICBwcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgb3V0ID0gb3RoZXIuY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICAgY2FsbChvdXQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFtYmRhP1xuICAgICMgVGhpcyBtZXRob2Qgc2hvdWxkIHRlbGwgdGhlIHVzZXIgaWYgdGhlIHByb2MgdHJpY2tzIGFyZSB1bmF2YWlsYWJsZSxcbiAgICAjIChzZWUgUHJvYyNsYW1iZGE/IG9uIHJ1YnkgZG9jcyB0byBmaW5kIG91dCBtb3JlKS5cbiAgICBgISFzZWxmLiQkaXNfbGFtYmRhYFxuICBlbmRcblxuICBkZWYgYXJpdHlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGFyaXR5O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGBpZiAoc2VsZi4kJGlzX2N1cnJpZWQpIHsgcmV0dXJuIG5pbDsgfWBcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGJpbmRpbmdcbiAgICBgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJDYW4ndCBjcmVhdGUgQmluZGluZ1wifSB9YFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgIHJldHVybiAje1tbOnJlc3RdXX07XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuJCRwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuJCRwYXJhbWV0ZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi4kJHBhcmFtZXRlcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXIgPSBzZWxmLiQkcGFyYW1ldGVyc1tpXTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlclswXSA9PT0gJ3JlcScpIHtcbiAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgYXJndW1lbnRzIGFsd2F5cyBoYXZlIG5hbWVcbiAgICAgICAgICAgICAgcGFyYW1ldGVyID0gWydvcHQnLCBwYXJhbWV0ZXJbMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbWV0ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjdXJyeShhcml0eSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyaXR5ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYXJpdHkgPSAje09wYWwuY29lcmNlX3RvIShhcml0eSwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSAmJiBhcml0eSAhPT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJpdHlgfSBmb3IgI3tgc2VsZi5sZW5ndGhgfSlcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXJyaWVkICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IGFyaXR5ICYmIHNlbGYuJCRpc19sYW1iZGEgJiYgIXNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGxlbmd0aGB9IGZvciAje2Bhcml0eWB9KVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiRjYWxsLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyaWVkLmFwcGx5KG51bGwsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdCgkc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LiQkaXNfbGFtYmRhID0gc2VsZi4kJGlzX2xhbWJkYTtcbiAgICAgICAgcmVzdWx0LiQkaXNfY3VycmllZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIGN1cnJpZWQuJCRpc19sYW1iZGEgPSBzZWxmLiQkaXNfbGFtYmRhO1xuICAgICAgY3VycmllZC4kJGlzX2N1cnJpZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGN1cnJpZWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWxfcHJvYyA9IHNlbGYuJCRvcmlnaW5hbF9wcm9jIHx8IHNlbGYsXG4gICAgICAgICAgcHJvYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbF9wcm9jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgcHJvY1twcm9wXSA9IHNlbGZbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBjbG9uZSBkdXBcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwibmV3Iiwic2VsZiIsImJsb2NrIiwicmFpc2UiLCJjYWxsIiwiPj4iLCJwcm9jIiwib3V0IiwiYXJncyIsIm90aGVyIiwiPDwiLCJ0b19wcm9jIiwibGFtYmRhPyIsImFyaXR5Iiwic291cmNlX2xvY2F0aW9uIiwiYmluZGluZyIsInBhcmFtZXRlcnMiLCJjdXJyeSIsImNvZXJjZV90byEiLCJkdXAiXSwibWFwcGluZ3MiOiI7Ozs7O0VBRUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUMsd0RBQUQ7QUFBQSxJQUNDLDJEQUREO0FBQUEsSUFHQUMsVUFBSUMsSUFBSkQsVUFBQUEsY0FBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBUEY7QUFPZSxNQUFBLGtDQVBmO0FBQUEsTUFRSSxJQUFBLFFBQU9FLEtBQVAsQ0FBQTtBQUFBLE1BQUE7QUFBQSxZQUNFQyxPQUFBQSxDQUFNLCtCQUFlLCtDQUFyQkE7QUFERixNQUFBLENBUko7QUFBQSxNQVlJLE9BQUFELEtBWko7QUFPRUYsSUFBQUEsQ0FBQUEseUJBQUFBLENBSEE7QUFB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O0FBQ0E7QUFkRUEsSUFBQUEsQ0FBQUEsMEJBQUFBLENBdktBO0FBQUEsSUF3TEEsT0FBQSxpQkFBTSxPQUFOLEVBQVksS0FBWixDQXhMQTtBQURGcEIsRUFBQUEsR0FBQUEsV0FBQUEsRUFBYyxRQUFkQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE4ODA3LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tZXRob2QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTWV0aG9kXG4gIGF0dHJfcmVhZGVyIDpvd25lciwgOnJlY2VpdmVyLCA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKHJlY2VpdmVyLCBvd25lciwgbWV0aG9kLCBuYW1lKVxuICAgIEByZWNlaXZlciA9IHJlY2VpdmVyXG4gICAgQG93bmVyICAgID0gb3duZXJcbiAgICBAbmFtZSAgICAgPSBuYW1lXG4gICAgQG1ldGhvZCAgID0gbWV0aG9kXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgIEBtZXRob2QuYXJpdHlcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICBgI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnNgXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxuICBlbmRcblxuICBkZWYgY29tbWVudHNcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxuICBlbmRcblxuICBkZWYgY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgI3tAbWV0aG9kfS4kJHAgPSBibG9jaztcblxuICAgICAgcmV0dXJuICN7QG1ldGhvZH0uYXBwbHkoI3tAcmVjZWl2ZXJ9LCBhcmdzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIFtdIGNhbGxcblxuICBkZWYgPj4ob3RoZXIpXG4gICAgQG1ldGhvZCA+PiBvdGhlclxuICBlbmRcblxuICBkZWYgPDwob3RoZXIpXG4gICAgQG1ldGhvZCA8PCBvdGhlclxuICBlbmRcblxuICBkZWYgdW5iaW5kXG4gICAgVW5ib3VuZE1ldGhvZC5uZXcoQHJlY2VpdmVyLmNsYXNzLCBAb3duZXIsIEBtZXRob2QsIEBuYW1lKVxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgICV4e1xuICAgICAgdmFyIHByb2MgPSBzZWxmLiRjYWxsLmJpbmQoc2VsZik7XG4gICAgICBwcm9jLiQkdW5ib3VuZCA9ICN7QG1ldGhvZH07XG4gICAgICBwcm9jLiQkaXNfbGFtYmRhID0gdHJ1ZTtcbiAgICAgIHByb2MuJCRhcml0eSA9ICN7QG1ldGhvZH0uJCRhcml0eTtcbiAgICAgIHByb2MuJCRwYXJhbWV0ZXJzID0gI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnM7XG4gICAgICByZXR1cm4gcHJvYztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPCN7c2VsZi5jbGFzc306ICN7QHJlY2VpdmVyLmNsYXNzfSMje0BuYW1lfSAoZGVmaW5lZCBpbiAje0Bvd25lcn0gaW4gI3tzb3VyY2VfbG9jYXRpb24uam9pbignOicpfSk+XCJcbiAgZW5kXG5lbmRcblxuY2xhc3MgVW5ib3VuZE1ldGhvZFxuICBhdHRyX3JlYWRlciA6c291cmNlLCA6b3duZXIsIDpuYW1lXG5cbiAgZGVmIGluaXRpYWxpemUoc291cmNlLCBvd25lciwgbWV0aG9kLCBuYW1lKVxuICAgIEBzb3VyY2UgPSBzb3VyY2VcbiAgICBAb3duZXIgID0gb3duZXJcbiAgICBAbWV0aG9kID0gbWV0aG9kXG4gICAgQG5hbWUgICA9IG5hbWVcbiAgZW5kXG5cbiAgZGVmIGFyaXR5XG4gICAgQG1ldGhvZC5hcml0eVxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgIGAje0BtZXRob2R9LiQkcGFyYW1ldGVyc2BcbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGAje0BtZXRob2R9LiQkc291cmNlX2xvY2F0aW9uYCB8fCBbJyhldmFsKScsIDBdXG4gIGVuZFxuXG4gIGRlZiBjb21tZW50c1xuICAgIGAje0BtZXRob2R9LiQkY29tbWVudHNgIHx8IFtdXG4gIGVuZFxuXG4gIGRlZiBiaW5kKG9iamVjdClcbiAgICAleHtcbiAgICAgIGlmICgje0Bvd25lcn0uJCRpc19tb2R1bGUgfHwgT3BhbC5pc19hKCN7b2JqZWN0fSwgI3tAb3duZXJ9KSkge1xuICAgICAgICByZXR1cm4gI3tNZXRob2QubmV3KG9iamVjdCwgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGJpbmQgc2luZ2xldG9uIG1ldGhvZCB0byBhIGRpZmZlcmVudCBjbGFzcyAoZXhwZWN0ZWQgI3tvYmplY3R9LmtpbmRfb2Y/KCN7QG93bmVyfSB0byBiZSB0cnVlKVwifTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPCN7c2VsZi5jbGFzc306ICN7QHNvdXJjZX0jI3tAbmFtZX0gKGRlZmluZWQgaW4gI3tAb3duZXJ9IGluICN7c291cmNlX2xvY2F0aW9uLmpvaW4oJzonKX0pPlwiXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJAcmVjZWl2ZXIiLCJyZWNlaXZlciIsIkBvd25lciIsIm93bmVyIiwiQG5hbWUiLCJuYW1lIiwiQG1ldGhvZCIsIm1ldGhvZCIsImFyaXR5IiwicGFyYW1ldGVycyIsInNvdXJjZV9sb2NhdGlvbiIsIiRyZXRfb3JfMSIsIjAiLCJjb21tZW50cyIsIiRyZXRfb3JfMiIsImNhbGwiLCI+PiIsIm90aGVyIiwiPDwiLCJ1bmJpbmQiLCJuZXciLCJ0b19wcm9jIiwiaW5zcGVjdCIsInNlbGYiLCJqb2luIiwiQHNvdXJjZSIsInNvdXJjZSIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsImJpbmQiLCJvYmplY3QiLCJyYWlzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFFBQUFDLGFBQUFBLENBQVksU0FBUSxZQUFXLE1BQS9CQSxDQUFBO0FBQUE7QUFFQUMsSUFBQUEsOEJBQUFBLHVCQUFBQSxzQkFBZSxRQUFELEVBQVcsS0FBWCxFQUFrQixNQUFsQixFQUEwQixJQUF4Q0E7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQUMsZ0JBQVlDLFFBQVo7QUFBQSxNQUNBQyxhQUFZQyxLQURaO0FBQUEsTUFFQUMsWUFBWUMsSUFGWjtBQUFBLE1BR0EsT0FBQUMsQ0FBQUEsY0FBWUMsTUFBWkQsQ0FIQTtBQURGUCxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0FGQTtBQUFBO0FBU0FTLElBQUFBLHlCQUFBQSxrQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFGLFdBQUFFLE9BQUFBLENBQUFBO0FBREZBLElBQUFBLENBQUFBLDZCQUFBQSxDQVRBO0FBQUE7QUFhQUMsSUFBQUEsOEJBQUFBLHVCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBR0gsV0FBUTtBQURiRyxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0FiQTtBQUFBO0FBaUJBQyxJQUFBQSxtQ0FBQUEsNEJBQUFBLDJCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxJQUFBLFFBcEJKQyxDQUFBQSxZQW9CT0wsV0FBUSxrQkFwQmZLLENBb0JJLENBQUE7QUFBQSxRQXBCSixPQUFBO0FBb0JJLE1BQUE7QUFBQSxRQUFrQyxPQUFBLENBQUMsUUFBRCxFQUFXQyxDQUFYO0FBQWxDLE1BQUE7QUFERkYsSUFBQUEsQ0FBQUEsdUNBQUFBLENBakJBO0FBQUE7QUFxQkFHLElBQUFBLDRCQUFBQSxxQkFBQUEsb0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLElBQUEsUUF4QkpDLENBQUFBLFlBd0JPUixXQUFRLFdBeEJmUSxDQXdCSSxDQUFBO0FBQUEsUUF4QkosT0FBQTtBQXdCSSxNQUFBO0FBQUEsUUFBMkIsT0FBQTtBQUEzQixNQUFBO0FBREZELElBQUFBLENBQUFBLGdDQUFBQSxDQXJCQTtBQUFBO0FBeUJBRSxJQUFBQSx3QkFBQUEsaUJBQUFBLGdCQTNCRixFQTJCRUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBM0JGO0FBMkJrQixNQUFBLHFDQTNCbEI7QUFBQTtBQUFBLE1BQUEsNERBQUE7QUFBQTtBQTJCVyxNQUFBLGtCQTNCWDtBQUFBO0FBNkJBLE1BQVFULFdBQVE7O0FBRWhCLGFBQWVBLFdBQVEsT0FBU04sYUFBVTtBQUMxQyxJQWhDQTtBQTJCRWUsSUFBQUEsQ0FBQUEsNkJBQUFBLENBekJBO0FBQUEsSUFpQ0EsaUJBQU0sSUFBTixFQUFTLE1BQVQsQ0FqQ0E7QUFBQTtBQW1DQUMsSUFBQUEsc0JBQUFBLG1CQUFBQSxTQUFPLEtBQVBBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFWLFdBQUFVLE9BQUFBLENBQVdDLEtBQVhEO0FBREZBLElBQUFBLENBQUFBLDhCQUFBQSxDQW5DQTtBQUFBO0FBdUNBRSxJQUFBQSxzQkFBQUEsbUJBQUFBLFNBQU8sS0FBUEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQVosV0FBQVksT0FBQUEsQ0FBV0QsS0FBWEM7QUFERkEsSUFBQUEsQ0FBQUEsOEJBQUFBLENBdkNBO0FBQUE7QUEyQ0FDLElBQUFBLDBCQUFBQSxtQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsNkJBQUFDLEtBQUFBLENBQWtCcEIsYUFBQUgsT0FBQUEsQ0FBQUEsR0FBaUJLLFlBQVFJLGFBQVNGLFNBQXBEZ0I7QUFERkQsSUFBQUEsQ0FBQUEsOEJBQUFBLENBM0NBO0FBQUE7QUErQ0FFLElBQUFBLDJCQUFBQSxxQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0EsdUJBQXlCZixXQUFRO0FBQ2pDO0FBQ0EscUJBQXVCQSxXQUFRO0FBQy9CLDBCQUE0QkEsV0FBUTtBQUNwQztBQUNBO0FBUkVlLElBQUFBLENBQUFBLGdDQUFBQSxDQS9DQTtBQUFBLElBMERBLE9BQUFDLENBQUFBLDJCQUFBQSxxQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsRUFBQSxHQUFBLElBQUEsR0FBQSxDQUFLQyxJQUFBMUIsT0FBQUEsQ0FBQUEsQ0FBTCxDQUFBLEdBQUEsSUFBQSxHQUFBLENBQW9CRyxhQUFBSCxPQUFBQSxDQUFBQSxDQUFwQixDQUFBLEdBQUEsR0FBQSxHQUFBLENBQXVDTyxTQUF2QyxDQUFBLEdBQUEsZUFBQSxHQUFBLENBQTRERixVQUE1RCxDQUFBLEdBQUEsTUFBQSxHQUFBLEtBQXlFUSxpQkFBQUEsQ0FBQUEsQ0FBQWMsTUFBQUEsQ0FBcUIsR0FBckJBLENBQXpFLENBQUEsR0FBQTtBQURGRixJQUFBQSxDQUFBQSxnQ0FBQUEsQ0FBQUEsbUJBMURBO0FBREZ6QixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQUFBO0FBQUEsRUFnRUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUFBQTtBQUNFLFFBQUFDLGFBQUFBLENBQVksVUFBUyxTQUFRLE1BQTdCQSxDQUFBO0FBQUE7QUFFQUMsSUFBQUEsOEJBQUFBLCtCQUFBQSxzQkFBZSxNQUFELEVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF0Q0E7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQTBCLGNBQVVDLE1BQVY7QUFBQSxNQUNBeEIsYUFBVUMsS0FEVjtBQUFBLE1BRUFHLGNBQVVDLE1BRlY7QUFBQSxNQUdBLE9BQUFILENBQUFBLFlBQVVDLElBQVZELENBSEE7QUFERkwsSUFBQUEsQ0FBQUEsMENBQUFBLENBRkE7QUFBQTtBQVNBUyxJQUFBQSx5QkFBQUEsMEJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBRixXQUFBRSxPQUFBQSxDQUFBQTtBQURGQSxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0FUQTtBQUFBO0FBYUFDLElBQUFBLDhCQUFBQSwrQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUdILFdBQVE7QUFEYkcsSUFBQUEsQ0FBQUEsMENBQUFBLENBYkE7QUFBQTtBQWlCQUMsSUFBQUEsbUNBQUFBLG9DQUFBQSwyQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsSUFBQSxRQXBGSmlCLENBQUFBLFlBb0ZPckIsV0FBUSxrQkFwRmZxQixDQW9GSSxDQUFBO0FBQUEsUUFwRkosT0FBQTtBQW9GSSxNQUFBO0FBQUEsUUFBa0MsT0FBQSxDQUFDLFFBQUQsRUFBV2YsQ0FBWDtBQUFsQyxNQUFBO0FBREZGLElBQUFBLENBQUFBLCtDQUFBQSxDQWpCQTtBQUFBO0FBcUJBRyxJQUFBQSw0QkFBQUEsNkJBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxJQUFBLFFBeEZKZSxDQUFBQSxZQXdGT3RCLFdBQVEsV0F4RmZzQixDQXdGSSxDQUFBO0FBQUEsUUF4RkosT0FBQTtBQXdGSSxNQUFBO0FBQUEsUUFBMkIsT0FBQTtBQUEzQixNQUFBO0FBREZmLElBQUFBLENBQUFBLHdDQUFBQSxDQXJCQTtBQUFBO0FBeUJBZ0IsSUFBQUEsd0JBQUFBLHlCQUFBQSxnQkFBUyxNQUFUQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRixVQUFZM0IsVUFBTywwQkFBNEI0QixNQUFPLEVBQUk1QixVQUFPO0FBQ2pFLGVBQWlCLHNCQUFBa0IsS0FBQUEsQ0FBV1UsUUFBUTVCLFlBQVFJLGFBQVNGLFNBQXBDZ0IsQ0FBMkM7QUFDNUQ7QUFDQTtBQUNBLFlBQVVXLE9BQUFBLENBQU0sMkJBQVcsRUFBQSxHQUFBLDZEQUFBLEdBQUEsQ0FBOERELE1BQTlELENBQUEsR0FBQSxZQUFBLEdBQUEsQ0FBaUY1QixVQUFqRixDQUFBLEdBQUEsY0FBakI2QixDQUF1SDtBQUNqSTtBQUNBO0FBUkVGLElBQUFBLENBQUFBLG9DQUFBQSxDQXpCQTtBQUFBLElBb0NBLE9BQUFQLENBQUFBLDJCQUFBQSw0QkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsRUFBQSxHQUFBLElBQUEsR0FBQSxDQUFLQyxJQUFBMUIsT0FBQUEsQ0FBQUEsQ0FBTCxDQUFBLEdBQUEsSUFBQSxHQUFBLENBQW9CNEIsV0FBcEIsQ0FBQSxHQUFBLEdBQUEsR0FBQSxDQUErQnJCLFNBQS9CLENBQUEsR0FBQSxlQUFBLEdBQUEsQ0FBb0RGLFVBQXBELENBQUEsR0FBQSxNQUFBLEdBQUEsS0FBaUVRLGlCQUFBQSxDQUFBQSxDQUFBYyxNQUFBQSxDQUFxQixHQUFyQkEsQ0FBakUsQ0FBQSxHQUFBO0FBREZGLElBQUFBLENBQUFBLHVDQUFBQSxDQUFBQSxtQkFwQ0E7QUFERnpCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBaEVBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTg5OTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3ZhcmlhYmxlcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIHJlZ2V4cCBtYXRjaGVzXG4leHskZ3ZhcnNbJyYnXSA9ICRndmFyc1snfiddID0gJGd2YXJzWydgJ10gPSAkZ3ZhcnNbXCInXCJdID0gbmlsfVxuXG4jIHJlcXVpcmVzXG4kTE9BREVEX0ZFQVRVUkVTID0gJFwiID0gYE9wYWwubG9hZGVkX2ZlYXR1cmVzYFxuJExPQURfUEFUSCAgICAgICA9ICQ6ID0gW11cblxuIyBzcGxpdCBsaW5lc1xuJC8gPSBcIlxcblwiXG4kLCA9IG5pbFxuXG5BUkdWID0gW11cbkFSR0YgPSBPYmplY3QubmV3XG5FTlYgID0ge31cblxuJFZFUkJPU0UgPSBmYWxzZVxuJERFQlVHICAgPSBmYWxzZVxuJFNBRkUgICAgPSAwXG4iXSwibmFtZXMiOlsiJExPQURFRF9GRUFUVVJFUyIsIiRcIiIsIiRMT0FEX1BBVEgiLCIkOiIsIiQvIiwiJCwiLCJuZXciLCIkVkVSQk9TRSIsIiRERUJVRyIsIiRTQUZFIiwiMCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsRUFBRywyREFBSDtBQUFBLEVBR0FBLHlCQUFtQkMsQ0FBQUEsZUFBTSxvQkFBTkEsQ0FIbkI7QUFBQSxFQUlBQyxtQkFBbUJDLENBQUFBLGNBQUssRUFBTEEsQ0FKbkI7QUFBQSxFQU9BQyxjQUFLLElBUEw7QUFBQSxFQVFBQyxjQUFLLEdBUkw7QUFBQSxFQVVBLG9DQUFPLEVBQVAsQ0FWQTtBQUFBLEVBV0Esb0NBQU8sc0JBQUFDLEtBQUFBLENBQUFBLENBQVAsQ0FYQTtBQUFBLEVBWUEsbUNBQU8sWUFBQSxFQUFQLENBWkE7QUFBQSxFQWNBQyxpQkFBVyxLQWRYO0FBQUEsRUFlQUMsZUFBVyxLQWZYO0FBQUEsRUFnQkEsT0FBQUMsQ0FBQUEsY0FBV0MsQ0FBWEQsQ0FoQkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxOTAwOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvaW8ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgSU9cbiAgU0VFS19TRVQgPSAwXG4gIFNFRUtfQ1VSID0gMVxuICBTRUVLX0VORCA9IDJcblxuICBkZWYgdHR5P1xuICAgIEB0dHlcbiAgZW5kXG5cbiAgZGVmIGNsb3NlZD9cbiAgICBAY2xvc2VkXG4gIGVuZFxuXG4gIGF0dHJfYWNjZXNzb3IgOndyaXRlX3Byb2NcblxuICBkZWYgd3JpdGUoc3RyaW5nKVxuICAgIGBzZWxmLndyaXRlX3Byb2Moc3RyaW5nKWBcbiAgICBzdHJpbmcuc2l6ZVxuICBlbmRcblxuICBhdHRyX2FjY2Vzc29yIDpzeW5jLCA6dHR5XG5cbiAgZGVmIGZsdXNoXG4gICAgIyBub29wXG4gIGVuZFxuXG4gIG1vZHVsZSBXcml0YWJsZVxuICAgIGRlZiA8PChzdHJpbmcpXG4gICAgICB3cml0ZShzdHJpbmcpXG4gICAgICBzZWxmXG4gICAgZW5kXG5cbiAgICBkZWYgcHJpbnQoKmFyZ3MpXG4gICAgICAleHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJncy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9ICN7U3RyaW5nKGBhcmdzW2ldYCl9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi4kd3JpdGUoYXJncy5qb2luKCN7JCx9KSk7XG4gICAgICB9XG4gICAgICBuaWxcbiAgICBlbmRcblxuICAgIGRlZiBwdXRzKCphcmdzKVxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSAje1N0cmluZyhgYXJnc1tpXWApLmNob21wfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuJHdyaXRlKGFyZ3MuY29uY2F0KFtuaWxdKS5qb2luKCN7JC99KSk7XG4gICAgICB9XG4gICAgICBuaWxcbiAgICBlbmRcbiAgZW5kXG5cbiAgbW9kdWxlIFJlYWRhYmxlXG4gICAgZGVmIHJlYWRieXRlXG4gICAgICBnZXRieXRlXG4gICAgZW5kXG5cbiAgICBkZWYgcmVhZGNoYXJcbiAgICAgIGdldGNcbiAgICBlbmRcblxuICAgIGRlZiByZWFkbGluZShzZXAgPSAkLylcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3JcbiAgICBlbmRcblxuICAgIGRlZiByZWFkcGFydGlhbChpbnRlZ2VyLCBvdXRidWYgPSBuaWwpXG4gICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cblNUREVSUiA9ICRzdGRlcnIgPSBJTy5uZXdcblNURElOICA9ICRzdGRpbiAgPSBJTy5uZXdcblNURE9VVCA9ICRzdGRvdXQgPSBJTy5uZXdcblxuYHZhciBjb25zb2xlID0gT3BhbC5nbG9iYWwuY29uc29sZWBcblNURE9VVC53cml0ZV9wcm9jID0gYHR5cGVvZihwcm9jZXNzKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mKHByb2Nlc3Muc3Rkb3V0KSA9PT0gJ29iamVjdCcgPyBmdW5jdGlvbihzKXtwcm9jZXNzLnN0ZG91dC53cml0ZShzKX0gOiBmdW5jdGlvbihzKXtjb25zb2xlLmxvZyhzKX1gXG5TVERFUlIud3JpdGVfcHJvYyA9IGB0eXBlb2YocHJvY2VzcykgPT09ICdvYmplY3QnICYmIHR5cGVvZihwcm9jZXNzLnN0ZGVycikgPT09ICdvYmplY3QnID8gZnVuY3Rpb24ocyl7cHJvY2Vzcy5zdGRlcnIud3JpdGUocyl9IDogZnVuY3Rpb24ocyl7Y29uc29sZS53YXJuKHMpfWBcblxuU1RET1VULmV4dGVuZChJTzo6V3JpdGFibGUpXG5TVERFUlIuZXh0ZW5kKElPOjpXcml0YWJsZSlcbiJdLCJuYW1lcyI6WyJjbGFzcyIsIjAiLCIxIiwiMiIsInR0eT8iLCJAdHR5IiwiY2xvc2VkPyIsIkBjbG9zZWQiLCJhdHRyX2FjY2Vzc29yIiwid3JpdGUiLCJzdHJpbmciLCJzaXplIiwiZmx1c2giLCJtb2R1bGUiLCI8PCIsInNlbGYiLCJwcmludCIsIlN0cmluZyIsIiQsIiwicHV0cyIsImNob21wIiwiJC8iLCJyZWFkYnl0ZSIsImdldGJ5dGUiLCJyZWFkY2hhciIsImdldGMiLCJyZWFkbGluZSIsInJhaXNlIiwicmVhZHBhcnRpYWwiLCIkc3RkZXJyIiwibmV3IiwiJHN0ZGluIiwiJHN0ZG91dCIsIiR3cml0ZXIiLCJ3cml0ZV9wcm9jPSIsIi0iLCJleHRlbmQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLEVBQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxJQUFBLHdDQUFXQyxDQUFYLENBQUE7QUFBQSxJQUNBLHdDQUFXQyxDQUFYLENBREE7QUFBQSxJQUVBLHdDQUFXQyxDQUFYLENBRkE7QUFBQTtBQUlBQyxJQUFBQSx3QkFBQUEsaUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFDO0FBREZELElBQUFBLENBQUFBLDRCQUFBQSxDQUpBO0FBQUE7QUFRQUUsSUFBQUEsMkJBQUFBLG9CQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFB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V0FBQUEsV0FwREE7QUFERmIsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FBQTtBQUFBLEVBd0VBLHNDQUFTNkIsQ0FBQUEsZ0JBQVUsa0JBQUFDLEtBQUFBLENBQUFBLENBQVZELENBQVQsQ0F4RUE7QUFBQSxFQXlFQSxxQ0FBU0UsQ0FBQUEsZUFBVSxrQkFBQUQsS0FBQUEsQ0FBQUEsQ0FBVkMsQ0FBVCxDQXpFQTtBQUFBLEVBMEVBLHNDQUFTQyxDQUFBQSxnQkFBVSxrQkFBQUYsS0FBQUEsQ0FBQUEsQ0FBVkUsQ0FBVCxDQTFFQTtBQUFBLEVBNEVDLGlDQTVFRDtBQUFBO0FBREEsRUFBQUMsVUFBQSxDQThFcUIsd0lBOUVyQixDQUFBO0FBQUEsRUE4RUFDLE1BQUEsc0JBQUFBLGVBQUFBLEVBOUVBLFVBQUFELE9BQUEsQ0E4RUFDLENBOUVBO0FBQUEsRUFBQUQsT0FBQSxDQUFBRSxVQUFBRixPQUFBLENBQUEsUUFBQSxDQUFBRSxFQUFBakMsQ0FBQWlDLENBQUEsQ0FBQSxDQUNBO0FBQUE7QUFEQSxFQUFBRixVQUFBLENBK0VxQix5SUEvRXJCLENBQUE7QUFBQSxFQStFQUMsTUFBQSxzQkFBQUEsZUFBQUEsRUEvRUEsVUFBQUQsT0FBQSxDQStFQUMsQ0EvRUE7QUFBQSxFQUFBRCxPQUFBLENBQUFFLFVBQUFGLE9BQUEsQ0FBQSxRQUFBLENBQUFFLEVBQUFqQyxDQUFBaUMsQ0FBQSxDQUFBLENBQ0E7QUFBQSxFQWdGQSxzQkFBQUMsUUFBQUEsQ0FBYyxJQUFBLGtCQUFBLGFBQWRBLENBaEZBO0FBQUEsRUFpRkEsT0FBQSxzQkFBQUEsUUFBQUEsQ0FBYyxJQUFBLGtCQUFBLGFBQWRBLENBakZBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTkxNjQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL3JlZ2V4cF9hbmNob3JzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgZnJvemVuX3N0cmluZ19saXRlcmFsOiB0cnVlXG5cbm1vZHVsZSBPcGFsXG4gIFJFR0VYUF9TVEFSVCA9IFJVQllfRU5HSU5FID09ICdvcGFsJyA/ICdeJyA6ICdcXEEnXG4gIFJFR0VYUF9FTkQgPSBSVUJZX0VOR0lORSA9PSAnb3BhbCcgPyAnJCcgOiAnXFx6J1xuXG4gICMgVW5pY29kZSBjaGFyYWN0ZXJzIGluIHJhbmdlc1xuICAjIFxcdTAwMDEgLSBcXHUwMDJGIChibGFuayB1bmljb2RlIGNoYXJhY3RlcnMgKyBzcGFjZSArICFcIiMkJSYnKCkqKywtLi8gY2hhcnMpXG4gICMgXFx1MDAzQSAtIFxcdTAwNDAgKDo7PD0+P0AgY2hhcnMpXG4gICMgXFx1MDA1QiAtIFxcdTAwNUUgKFtcXF1eIGNoYXJzKVxuICAjIFxcdTAwNjAgICAgICAgICAgKGAgY2hhcilcbiAgIyBcXHUwMDdCIC0gXFx1MDA3RiAoe3x9fiBjaGFyc30pXG4gICMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gaWRlbnRpZmllciBpbiB0aGUgYmVnZ2luaW5nIG9yIG1pZGRsZSBvZiBpdHMgbmFtZVxuICBGT1JCSURERU5fU1RBUlRJTkdfSURFTlRJRklFUl9DSEFSUyA9ICdcXHUwMDAxLVxcdTAwMkZcXHUwMDNBLVxcdTAwNDBcXHUwMDVCLVxcdTAwNUVcXHUwMDYwXFx1MDA3Qi1cXHUwMDdGJ1xuXG4gICMgVW5pY29kZSBjaGFyYWN0ZXJzIGluIHJhbmdlc1xuICAjIFxcdTAwMDEgLSBcXHUwMDIwIChibGFuayB1bmljb2RlIGNoYXJhY3RlcnMgKyBzcGFjZSlcbiAgIyBcXHUwMDIyIC0gXFx1MDAyRiAoXCIjJCUmJygpKissLS4vIGNoYXJzKVxuICAjIFxcdTAwM0EgLSBcXHUwMDNFICg6Ozw9PiBjaGFycylcbiAgIyBcXHUwMDQwICAgICAgICAgIChAIGNoYXIpXG4gICMgXFx1MDA1QiAtIFxcdTAwNUUgKFtcXF1eIGNoYXJzKVxuICAjIFxcdTAwNjAgICAgICAgICAgKGAgY2hhcilcbiAgIyBcXHUwMDdCIC0gXFx1MDA3RiAoe3x9fiBjaGFyc30pXG4gICMgYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gaWRlbnRpZmllciBpbiB0aGUgZW5kIG9mIGl0cyBuYW1lXG4gICMgSW4gZmFjdCwgRk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMgPSBGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlMgKyBcXHUwMDIxICgnPycpICsgXFx1MDAzRiAoJyEnKVxuICBGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlMgICA9ICdcXHUwMDAxLVxcdTAwMjBcXHUwMDIyLVxcdTAwMkZcXHUwMDNBLVxcdTAwM0VcXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcbiAgSU5MSU5FX0lERU5USUZJRVJfUkVHRVhQID0gUmVnZXhwLm5ldyhcIlteI3tGT1JCSURERU5fU1RBUlRJTkdfSURFTlRJRklFUl9DSEFSU31dKlteI3tGT1JCSURERU5fRU5ESU5HX0lERU5USUZJRVJfQ0hBUlN9XVwiKVxuXG4gICMgRm9yIGNvbnN0YW50cyBydWxlcyBhcmUgcHJldHR5IG11Y2ggdGhlIHNhbWUsIGJ1dCAnOicgaXMgYWxsb3dlZCBhbmQgJz8hJyBhcmUgbm90LlxuICAjIFBsdXMgaXQgbWF5IHN0YXJ0IHdpdGggYSAnOjonIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZSBjb25zdGFudCBjb21lcyBmcm9tIHRvcGxldmVsLlxuICBGT1JCSURERU5fQ09OU1RfTkFNRV9DSEFSUyA9ICdcXHUwMDAxLVxcdTAwMjBcXHUwMDIxLVxcdTAwMkZcXHUwMDNCLVxcdTAwM0ZcXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcbiAgQ09OU1RfTkFNRV9SRUdFWFAgPSBSZWdleHAubmV3KFwiI3tSRUdFWFBfU1RBUlR9KDo6KT9bQS1aXVteI3tGT1JCSURERU5fQ09OU1RfTkFNRV9DSEFSU31dKiN7UkVHRVhQX0VORH1cIilcbmVuZFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsIm5ldyJdLCJtYXBwaW5ncyI6Ijs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQSw0Q0FBdUMsR0FBdkMsQ0FBQTtBQUFBLElBQ0EsMENBQXFDLEdBQXJDLENBREE7QUFBQSxJQVVBLG1FQUFzQyxxRUFBdEMsQ0FWQTtBQUFBLElBc0JBLGlFQUFzQywyRkFBdEMsQ0F0QkE7QUFBQSxJQXVCQSx3REFBMkIsc0JBQUFDLEtBQUFBLENBQVcsRUFBQSxHQUFBLElBQUEsR0FBQSxDQUFLLG1EQUFMLENBQUEsR0FBQSxNQUFBLEdBQUEsQ0FBK0MsaURBQS9DLENBQUEsR0FBQSxHQUFYQSxDQUEzQixDQXZCQTtBQUFBLElBMkJBLDBEQUE2QiwyRkFBN0IsQ0EzQkE7QUFBQSxJQTRCQSxPQUFBLGlEQUFvQixzQkFBQUEsS0FBQUEsQ0FBVyxFQUFBLEdBQUEsQ0FBRyw0QkFBSCxDQUFBLEdBQUEsY0FBQSxHQUFBLENBQThCLDBDQUE5QixDQUFBLEdBQUEsSUFBQSxHQUFBLENBQTZELDBCQUE3RCxDQUFYQSxDQUFwQixDQTVCQTtBQURGRCxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5MTg1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9taW5pLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ29wYWwvYmFzZSdcblxucmVxdWlyZSAnY29yZWxpYi9uaWwnXG5yZXF1aXJlICdjb3JlbGliL2Jvb2xlYW4nXG5yZXF1aXJlICdjb3JlbGliL3N0cmluZydcbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYXRvcidcbnJlcXVpcmUgJ2NvcmVsaWIvYXJyYXknXG5yZXF1aXJlICdjb3JlbGliL2hhc2gnXG5yZXF1aXJlICdjb3JlbGliL251bWJlcidcbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZ2UnXG5yZXF1aXJlICdjb3JlbGliL3Byb2MnXG5yZXF1aXJlICdjb3JlbGliL21ldGhvZCdcbnJlcXVpcmUgJ2NvcmVsaWIvcmVnZXhwJ1xucmVxdWlyZSAnY29yZWxpYi92YXJpYWJsZXMnXG5yZXF1aXJlICdjb3JlbGliL2lvJ1xucmVxdWlyZSAnb3BhbC9yZWdleHBfYW5jaG9ycydcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLFdBQVJBLENBQUE7QUFBQSxNQUVBQSxTQUFBQSxDQUFRLGFBQVJBLENBRkE7QUFBQSxNQUdBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQUhBO0FBQUEsTUFJQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FKQTtBQUFBLE1BS0FBLFNBQUFBLENBQVEsb0JBQVJBLENBTEE7QUFBQSxNQU1BQSxTQUFBQSxDQUFRLG9CQUFSQSxDQU5BO0FBQUEsTUFPQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FQQTtBQUFBLE1BUUFBLFNBQUFBLENBQVEsZUFBUkEsQ0FSQTtBQUFBLE1BU0FBLFNBQUFBLENBQVEsY0FBUkEsQ0FUQTtBQUFBLE1BVUFBLFNBQUFBLENBQVEsZ0JBQVJBLENBVkE7QUFBQSxNQVdBQSxTQUFBQSxDQUFRLGVBQVJBLENBWEE7QUFBQSxNQVlBQSxTQUFBQSxDQUFRLGNBQVJBLENBWkE7QUFBQSxNQWFBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQWJBO0FBQUEsTUFjQUEsU0FBQUEsQ0FBUSxnQkFBUkEsQ0FkQTtBQUFBLE1BZUFBLFNBQUFBLENBQVEsbUJBQVJBLENBZkE7QUFBQSxNQWdCQUEsU0FBQUEsQ0FBUSxZQUFSQSxDQWhCQTtBQUFBLEVBaUJBLFdBQUFBLFNBQUFBLENBQVEscUJBQVJBLENBakJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MTkyMTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2tlcm5lbC9mb3JtYXQucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBjb2VyY2VfdG9cblxubW9kdWxlIEtlcm5lbFxuICBkZWYgZm9ybWF0KGZvcm1hdF9zdHJpbmcsICphcmdzKVxuICAgIGlmIGFyZ3MubGVuZ3RoID09IDEgJiYgYXJnc1swXS5yZXNwb25kX3RvPyg6dG9fYXJ5KVxuICAgICAgYXJ5ID0gT3BhbC5jb2VyY2VfdG8/KGFyZ3NbMF0sIEFycmF5LCA6dG9fYXJ5KVxuICAgICAgYXJncyA9IGFyeS50b19hIHVubGVzcyBhcnkubmlsP1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gJycsXG4gICAgICAgICAgLy91c2VkIGZvciBzbGljaW5nOlxuICAgICAgICAgIGJlZ2luX3NsaWNlID0gMCxcbiAgICAgICAgICBlbmRfc2xpY2UsXG4gICAgICAgICAgLy91c2VkIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgZm9ybWF0IHN0cmluZzpcbiAgICAgICAgICBpLFxuICAgICAgICAgIGxlbiA9IGZvcm1hdF9zdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyBmaWVsZCB2YWx1ZXM6XG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHN0cixcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJWcgYW5kICVHIGZpZWxkczpcbiAgICAgICAgICBleHBvbmVudCxcbiAgICAgICAgICAvL3VzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2Ygd2lkdGggYW5kIHByZWNpc2lvbjpcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgICAgLy91c2VkIGZvciBob2xkaW5nIHRlbXBvcmFyeSB2YWx1ZXM6XG4gICAgICAgICAgdG1wX251bSxcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJXt9IGFuZCAlPD4gZmlsZWRzOlxuICAgICAgICAgIGhhc2hfcGFyYW1ldGVyX2tleSxcbiAgICAgICAgICBjbG9zaW5nX2JyYWNlX2NoYXIsXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nICViLCAlQiwgJW8sICV4LCBhbmQgJVggZmllbGRzOlxuICAgICAgICAgIGJhc2VfbnVtYmVyLFxuICAgICAgICAgIGJhc2VfcHJlZml4LFxuICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXgsXG4gICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCxcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgIG5leHRfYXJnLFxuICAgICAgICAgIHNlcV9hcmdfbnVtID0gMSxcbiAgICAgICAgICBwb3NfYXJnX251bSA9IDAsXG4gICAgICAgICAgLy91c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGZsYWdzOlxuICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgIEZOT05FICA9IDAsXG4gICAgICAgICAgRlNIQVJQID0gMSxcbiAgICAgICAgICBGTUlOVVMgPSAyLFxuICAgICAgICAgIEZQTFVTICA9IDQsXG4gICAgICAgICAgRlpFUk8gID0gOCxcbiAgICAgICAgICBGU1BBQ0UgPSAxNixcbiAgICAgICAgICBGV0lEVEggPSAzMixcbiAgICAgICAgICBGUFJFQyAgPSA2NCxcbiAgICAgICAgICBGUFJFQzAgPSAxMjg7XG5cbiAgICAgIGZ1bmN0aW9uIENIRUNLX0ZPUl9GTEFHUygpIHtcbiAgICAgICAgaWYgKGZsYWdzJkZXSURUSCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdmbGFnIGFmdGVyIHdpZHRoJ30gfVxuICAgICAgICBpZiAoZmxhZ3MmRlBSRUMwKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2ZsYWcgYWZ0ZXIgcHJlY2lzaW9uJ30gfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBDSEVDS19GT1JfV0lEVEgoKSB7XG4gICAgICAgIGlmIChmbGFncyZGV0lEVEgpIHsgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd2lkdGggZ2l2ZW4gdHdpY2UnfSB9XG4gICAgICAgIGlmIChmbGFncyZGUFJFQzApIHsgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd2lkdGggYWZ0ZXIgcHJlY2lzaW9uJ30gfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfTlRIX0FSRyhudW0pIHtcbiAgICAgICAgaWYgKG51bSA+PSBhcmdzLmxlbmd0aCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd0b28gZmV3IGFyZ3VtZW50cyd9IH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbbnVtXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX05FWFRfQVJHKCkge1xuICAgICAgICBzd2l0Y2ggKHBvc19hcmdfbnVtKSB7XG4gICAgICAgIGNhc2UgLTE6ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bm51bWJlcmVkKCN7YHNlcV9hcmdfbnVtYH0pIG1peGVkIHdpdGggbnVtYmVyZWRcIn1cbiAgICAgICAgY2FzZSAtMjogI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInVubnVtYmVyZWQoI3tgc2VxX2FyZ19udW1gfSkgbWl4ZWQgd2l0aCBuYW1lZFwifVxuICAgICAgICB9XG4gICAgICAgIHBvc19hcmdfbnVtID0gc2VxX2FyZ19udW0rKztcbiAgICAgICAgcmV0dXJuIEdFVF9OVEhfQVJHKHBvc19hcmdfbnVtIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9QT1NfQVJHKG51bSkge1xuICAgICAgICBpZiAocG9zX2FyZ19udW0gPiAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm51bWJlcmVkKCN7YG51bWB9KSBhZnRlciB1bm51bWJlcmVkKCN7YHBvc19hcmdfbnVtYH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc19hcmdfbnVtID09PSAtMikge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJudW1iZXJlZCgje2BudW1gfSkgYWZ0ZXIgbmFtZWRcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtIDwgMSkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGluZGV4IC0gI3tgbnVtYH0kXCJ9XG4gICAgICAgIH1cbiAgICAgICAgcG9zX2FyZ19udW0gPSAtMTtcbiAgICAgICAgcmV0dXJuIEdFVF9OVEhfQVJHKG51bSAtIDEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfQVJHKCkge1xuICAgICAgICByZXR1cm4gKG5leHRfYXJnID09PSB1bmRlZmluZWQgPyBHRVRfTkVYVF9BUkcoKSA6IG5leHRfYXJnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gUkVBRF9OVU0obGFiZWwpIHtcbiAgICAgICAgdmFyIG51bSwgc3RyID0gJyc7XG4gICAgICAgIGZvciAoOzsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgPT09IGxlbikge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIGZvcm1hdCBzdHJpbmcgLSAlKlswLTldJ31cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckNvZGVBdChpKSA8IDQ4IHx8IGZvcm1hdF9zdHJpbmcuY2hhckNvZGVBdChpKSA+IDU3KSB7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICBudW0gPSBwYXJzZUludChzdHIsIDEwKSB8fCAwO1xuICAgICAgICAgICAgaWYgKG51bSA+IDIxNDc0ODM2NDcpIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7YGxhYmVsYH0gdG9vIGJpZ1wifVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyICs9IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIFJFQURfTlVNX0FGVEVSX0FTVEVSKGxhYmVsKSB7XG4gICAgICAgIHZhciBhcmcsIG51bSA9IFJFQURfTlVNKGxhYmVsKTtcbiAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkgKyAxKSA9PT0gJyQnKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGFyZyA9IEdFVF9QT1NfQVJHKG51bSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJnID0gR0VUX05FWFRfQVJHKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICN7YGFyZ2AudG9faW50fTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gZm9ybWF0X3N0cmluZy5pbmRleE9mKCclJyk7IGkgIT09IC0xOyBpID0gZm9ybWF0X3N0cmluZy5pbmRleE9mKCclJywgaSkpIHtcbiAgICAgICAgc3RyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGZsYWdzID0gRk5PTkU7XG4gICAgICAgIHdpZHRoID0gLTE7XG4gICAgICAgIHByZWNpc2lvbiA9IC0xO1xuICAgICAgICBuZXh0X2FyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgICBlbmRfc2xpY2UgPSBpO1xuXG4gICAgICAgIGkrKztcblxuICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgIGJlZ2luX3NsaWNlID0gaTtcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgY2FzZSAnXFwwJzpcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXRfc2VxdWVuY2U6IGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG5cbiAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlNQQUNFO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZTSEFSUDtcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGUExVUztcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGTUlOVVM7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlpFUk87XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICBjYXNlICcyJzpcbiAgICAgICAgICBjYXNlICczJzpcbiAgICAgICAgICBjYXNlICc0JzpcbiAgICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgICBjYXNlICc2JzpcbiAgICAgICAgICBjYXNlICc3JzpcbiAgICAgICAgICBjYXNlICc4JzpcbiAgICAgICAgICBjYXNlICc5JzpcbiAgICAgICAgICAgIHRtcF9udW0gPSBSRUFEX05VTSgnd2lkdGgnKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpICsgMSkgPT09ICckJykge1xuICAgICAgICAgICAgICBpZiAoaSArIDIgPT09IGxlbikge1xuICAgICAgICAgICAgICAgIHN0ciA9ICclJztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZXh0X2FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInZhbHVlIGdpdmVuIHR3aWNlIC0gJSN7YHRtcF9udW1gfSRcIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZXh0X2FyZyA9IEdFVF9QT1NfQVJHKHRtcF9udW0pO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBDSEVDS19GT1JfV0lEVEgoKTtcbiAgICAgICAgICAgICAgZmxhZ3MgfD0gRldJRFRIO1xuICAgICAgICAgICAgICB3aWR0aCA9IHRtcF9udW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBjYXNlICdcXHsnOlxuICAgICAgICAgICAgY2xvc2luZ19icmFjZV9jaGFyID0gKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSAnPCcgPyAnPicgOiAnXFx9Jyk7XG4gICAgICAgICAgICBoYXNoX3BhcmFtZXRlcl9rZXkgPSAnJztcblxuICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICBmb3IgKDs7IGkrKykge1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbWFsZm9ybWVkIG5hbWUgLSB1bm1hdGNoZWQgcGFyZW50aGVzaXMnfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gY2xvc2luZ19icmFjZV9jaGFyKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zX2FyZ19udW0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibmFtZWQgI3tgaGFzaF9wYXJhbWV0ZXJfa2V5YH0gYWZ0ZXIgdW5udW1iZXJlZCgje2Bwb3NfYXJnX251bWB9KVwifVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zX2FyZ19udW0gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibmFtZWQgI3tgaGFzaF9wYXJhbWV0ZXJfa2V5YH0gYWZ0ZXIgbnVtYmVyZWRcIn1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zX2FyZ19udW0gPSAtMjtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdID09PSB1bmRlZmluZWQgfHwgIWFyZ3NbMF0uJCRpc19oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdvbmUgaGFzaCByZXF1aXJlZCd9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV4dF9hcmcgPSAje2BhcmdzWzBdYC5mZXRjaChgaGFzaF9wYXJhbWV0ZXJfa2V5YCl9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGNsb3NpbmdfYnJhY2VfY2hhciA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ciA9IG5leHRfYXJnLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkgeyBzdHIgPSBzdHIuc2xpY2UoMCwgcHJlY2lzaW9uKTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5ICs9IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBDSEVDS19GT1JfV0lEVEgoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZXSURUSDtcbiAgICAgICAgICAgIHdpZHRoID0gUkVBRF9OVU1fQUZURVJfQVNURVIoJ3dpZHRoJyk7XG4gICAgICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgIGZsYWdzIHw9IEZNSU5VUztcbiAgICAgICAgICAgICAgd2lkdGggPSAtd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIGlmIChmbGFncyZGUFJFQzApIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAncHJlY2lzaW9uIGdpdmVuIHR3aWNlJ31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsYWdzIHw9IEZQUkVDfEZQUkVDMDtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IDA7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09ICcqJykge1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIHByZWNpc2lvbiA9IFJFQURfTlVNX0FGVEVSX0FTVEVSKCdwcmVjaXNpb24nKTtcbiAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA8IDApIHtcbiAgICAgICAgICAgICAgICBmbGFncyAmPSB+RlBSRUM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlY2lzaW9uID0gUkVBRF9OVU0oJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICBhcmcgPSAje0ludGVnZXIoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCkge1xuICAgICAgICAgICAgICBzdHIgPSBhcmcudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gKChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpID8gMSA6IDApKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSAyO1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcwYic7XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXggPSAvXjErLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICcxJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSA4O1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcwJztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCA9IC9eMz83Ky87XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnNyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgICAgYmFzZV9udW1iZXIgPSAxNjtcbiAgICAgICAgICAgICAgYmFzZV9wcmVmaXggPSAnMHgnO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL15mKy87XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fZGlnaXQgPSAnZic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnID0gI3tJbnRlZ2VyKGBHRVRfQVJHKClgKX07XG4gICAgICAgICAgICBpZiAoYXJnID49IDApIHtcbiAgICAgICAgICAgICAgc3RyID0gYXJnLnRvU3RyaW5nKGJhc2VfbnVtYmVyKTtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24pIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkgLSAoKGZsYWdzJkZTSEFSUCAmJiBhcmcgIT09IDApID8gYmFzZV9wcmVmaXgubGVuZ3RoIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvU3RyaW5nKGJhc2VfbnVtYmVyKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSAtIChmbGFncyZGU0hBUlAgPyAyIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciA9IChhcmcgPj4+IDApLnRvU3RyaW5nKGJhc2VfbnVtYmVyKS5yZXBsYWNlKGJhc2VfbmVnX3plcm9fcmVnZXgsIGJhc2VfbmVnX3plcm9fZGlnaXQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uIC0gMikgeyBzdHIgPSBiYXNlX25lZ196ZXJvX2RpZ2l0ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAyIC0gKGZsYWdzJkZTSEFSUCA/IGJhc2VfcHJlZml4Lmxlbmd0aCA6IDApKSB7IHN0ciA9IGJhc2VfbmVnX3plcm9fZGlnaXQgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJy4uJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICBhcmcgPSAje0Zsb2F0KGBHRVRfQVJHKClgKX07XG4gICAgICAgICAgICBpZiAoYXJnID49IDAgfHwgaXNOYU4oYXJnKSkge1xuICAgICAgICAgICAgICBpZiAoYXJnID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHN0ciA9ICdJbmYnO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b0ZpeGVkKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvRXhwb25lbnRpYWwocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRyc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9FeHBvbmVudGlhbCgpO1xuICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBwYXJzZUludChzdHIuc3BsaXQoJ2UnKVsxXSwgMTApO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoZXhwb25lbnQgPCAtNCB8fCBleHBvbmVudCA+PSAocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9QcmVjaXNpb24ocHJlY2lzaW9uID09PSAtMSA/IChmbGFncyZGU0hBUlAgPyA2IDogdW5kZWZpbmVkKSA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIGFyZyAhPT0gSW5maW5pdHkgJiYgIWlzTmFOKGFyZykpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJ0luZic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvRml4ZWQocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9FeHBvbmVudGlhbChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b0V4cG9uZW50aWFsKCk7XG4gICAgICAgICAgICAgICAgICBleHBvbmVudCA9IHBhcnNlSW50KHN0ci5zcGxpdCgnZScpWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShleHBvbmVudCA8IC00IHx8IGV4cG9uZW50ID49IChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b1ByZWNpc2lvbihwcmVjaXNpb24gPT09IC0xID8gKGZsYWdzJkZTSEFSUCA/IDYgOiB1bmRlZmluZWQpIDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIGFyZyAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoIC0gMSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkudG9VcHBlckNhc2UoKSAmJiBhcmcgIT09IEluZmluaXR5ICYmIGFyZyAhPT0gLUluZmluaXR5ICYmICFpc05hTihhcmcpKSB7XG4gICAgICAgICAgICAgIHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhbZUVdWy0rXT8pKFswLTldKSQvLCAnJDEwJDInKTtcbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgLy8gTm90IGltcGxlbWVudGVkIGJlY2F1c2UgdGhlcmUgYXJlIG5vIHNwZWNzIGZvciB0aGlzIGZpZWxkIHR5cGUuXG4gICAgICAgICAgICAje3JhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsICdgQWAgYW5kIGBhYCBmb3JtYXQgZmllbGQgdHlwZXMgYXJlIG5vdCBpbXBsZW1lbnRlZCBpbiBPcGFsIHlldCd9XG5cbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIGFyZyA9IEdFVF9BUkcoKTtcbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19hcnkpfSkgeyBhcmcgPSAje2BhcmdgLnRvX2FyeX1bMF07IH1cbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xuICAgICAgICAgICAgICBzdHIgPSAje2BhcmdgLnRvX3N0cn07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCRjb2VyY2VfdG8oYXJnLCAje0ludGVnZXJ9LCAndG9faW50JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnJWMgcmVxdWlyZXMgYSBjaGFyYWN0ZXInfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgc3RyID0gI3tgR0VUX0FSRygpYC5pbnNwZWN0fTtcbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24gIT09IC0xKSB7IHN0ciA9IHN0ci5zbGljZSgwLCBwcmVjaXNpb24pOyB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBzdHIgPSAje2BHRVRfQVJHKClgLnRvX3N9O1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cbiAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm1hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSN7YGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpYH1cIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdtYWxmb3JtZWQgZm9ybWF0IHN0cmluZyAtICUnfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IGZvcm1hdF9zdHJpbmcuc2xpY2UoYmVnaW5fc2xpY2UsIGVuZF9zbGljZSkgKyBzdHI7XG4gICAgICAgIGJlZ2luX3NsaWNlID0gaSArIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICgjeyRERUJVR30gJiYgcG9zX2FyZ19udW0gPj0gMCAmJiBzZXFfYXJnX251bSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3RvbyBtYW55IGFyZ3VtZW50cyBmb3IgZm9ybWF0IHN0cmluZyd9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgKyBmb3JtYXRfc3RyaW5nLnNsaWNlKGJlZ2luX3NsaWNlKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNwcmludGYgZm9ybWF0XG5lbmRcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJmb3JtYXQiLCIkcmV0X29yXzEiLCJhcmdzIiwibGVuZ3RoIiwiPT0iLCIxIiwiW10iLCIwIiwicmVzcG9uZF90bz8iLCJhcnkiLCJjb2VyY2VfdG8/IiwibmlsPyIsInRvX2EiLCJyYWlzZSIsInRvX2ludCIsImZldGNoIiwiSW50ZWdlciIsIkZsb2F0IiwidG9fYXJ5IiwidG9fc3RyIiwiaW5zcGVjdCIsInRvX3MiLCIkREVCVUciXSwibWFwcGluZ3MiOiI7Ozs7O0VBRUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFO0FBQUFDLElBQUFBLDBCQUFBQSxtQkFBQUEsa0JBQVcsYUFBRCxFQUpaLEVBSUVBO0FBQUFBLE1BQUFBO0FBQUFBOztBQUFBQTtBQUpGO0FBQUEsTUFBQSw0REFBQTtBQUFBO0FBSTRCLE1BQUEsa0JBSjVCO0FBQUEsTUFLSSxJQUFBLFFBQUcsYUFBQSxJQUFBLFFBTFBDLENBQUFBLFlBS09DLElBQUFDLFFBQUFBLENBQUFBLENBQUFDLE9BQUFBLENBQWVDLENBQWZELENBTFBILENBS08sQ0FBQTtBQUFBLFFBQW9CLE9BQUFDLElBQUFJLE9BQUFBLENBQUtDLENBQUxELENBQUFFLGdCQUFBQSxDQUFvQixRQUFwQkE7QUFBcEIsTUFBQTtBQUFBLFFBTFAsT0FBQTtBQUtPLE1BQUEsQ0FBQSxrQkFBSCxDQUFBO0FBQUE7QUFDRSxRQUFBQyxNQUFNLG9CQUFBQyxlQUFBQSxDQUFnQlIsSUFBQUksT0FBQUEsQ0FBS0MsQ0FBTEQsR0FBUyx1QkFBTyxRQUFoQ0ksQ0FBTjtBQUFBLFFBQ0EsSUFBQSxRQUF1QkQsR0FBQUUsU0FBQUEsQ0FBQUEsQ0FBdkIsQ0FBQTtBQUFBLFFBQUE7QUFBQSxVQUFBVCxPQUFPTyxHQUFBRyxNQUFBQSxDQUFBQTtBQUFQLFFBQUEsQ0FEQSxDQURGLENBTEo7QUFBQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQThCQyxPQUFBQSxDQUFNLCtCQUFlLGtCQUFyQkEsQ0FBd0M7QUFDdEUsZ0NBQThCQSxPQUFBQSxDQUFNLCtCQUFlLHNCQUFyQkEsQ0FBNEM7QUFDMUU7O0FBRUE7QUFDQSxnQ0FBOEJBLE9BQUFBLENBQU0sK0JBQWUsbUJBQXJCQSxDQUF5QztBQUN2RSxnQ0FBOEJBLE9BQUFBLENBQU0sK0JBQWUsdUJBQXJCQSxDQUE2QztBQUMzRTs7QUFFQTtBQUNBLHNDQUFvQ0EsT0FBQUEsQ0FBTSwrQkFBZSxtQkFBckJBLENBQXlDO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFtQkEsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsYUFBQSxHQUFBLENBQWUsV0FBZixDQUFBLEdBQUEsdUJBQXJCQTtBQUNuQixxQkFBbUJBLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLGFBQUEsR0FBQSxDQUFlLFdBQWYsQ0FBQSxHQUFBLG9CQUFyQkE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQVlBLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLFdBQUEsR0FBQSxDQUFhLEdBQWIsQ0FBQSxHQUFBLHFCQUFBLEdBQUEsQ0FBd0MsV0FBeEMsQ0FBQSxHQUFBLEdBQXJCQTtBQUNaO0FBQ0E7QUFDQSxjQUFZQSxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSxXQUFBLEdBQUEsQ0FBYSxHQUFiLENBQUEsR0FBQSxlQUFyQkE7QUFDWjtBQUNBO0FBQ0EsY0FBWUEsT0FBQUEsQ0FBTSwrQkFBZSxFQUFBLEdBQUEsa0JBQUEsR0FBQSxDQUFvQixHQUFwQixDQUFBLEdBQUEsR0FBckJBO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWNBLE9BQUFBLENBQU0sK0JBQWUsbUNBQXJCQTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZ0JBLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLENBQUksS0FBSixDQUFBLEdBQUEsVUFBckJBO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBaUIsQ0FBQyxHQUFELENBQUFDLFFBQUFBLENBQUFBLENBQWE7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQWtCRCxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSx1QkFBQSxHQUFBLENBQXlCLE9BQXpCLENBQUEsR0FBQSxHQUFyQkE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBa0JBLE9BQUFBLENBQU0sK0JBQWUsd0NBQXJCQTtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esc0JBQW9CQSxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSxRQUFBLEdBQUEsQ0FBVSxrQkFBVixDQUFBLEdBQUEsb0JBQUEsR0FBQSxDQUFtRCxXQUFuRCxDQUFBLEdBQUEsR0FBckJBO0FBQ3BCO0FBQ0E7QUFDQSxzQkFBb0JBLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLFFBQUEsR0FBQSxDQUFVLGtCQUFWLENBQUEsR0FBQSxpQkFBckJBO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBb0JBLE9BQUFBLENBQU0sK0JBQWUsbUJBQXJCQTtBQUNwQjs7QUFFQSwyQkFBNkIsQ0FBQyxPQUFELENBQUFFLE9BQUFBLENBQWlCLGtCQUFqQkEsQ0FBc0M7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWdCRixPQUFBQSxDQUFNLCtCQUFlLHVCQUFyQkE7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBb0JHLFNBQUFBLENBQVMsU0FBVEEsQ0FBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBb0JBLFNBQUFBLENBQVMsU0FBVEEsQ0FBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFvQkMsT0FBQUEsQ0FBTyxTQUFQQSxDQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFjSixPQUFBQSxDQUFNLHFDQUFxQixnRUFBM0JBOztBQUVkO0FBQ0E7QUFDQSxnQkFBa0IsQ0FBQyxHQUFELENBQUFMLGdCQUFBQSxDQUFrQixRQUFsQkEsQ0FBMkIsVUFBWSxDQUFDLEdBQUQsQ0FBQVUsUUFBQUEsQ0FBQUEsQ0FBYTtBQUN0RSxnQkFBa0IsQ0FBQyxHQUFELENBQUFWLGdCQUFBQSxDQUFrQixRQUFsQkEsQ0FBMkI7QUFDN0Msb0JBQXNCLENBQUMsR0FBRCxDQUFBVyxRQUFBQSxDQUFBQSxDQUFhO0FBQ25DO0FBQ0Esd0RBQTBELHVCQUFRO0FBQ2xFO0FBQ0E7QUFDQSxrQkFBZ0JOLE9BQUFBLENBQU0sK0JBQWUseUJBQXJCQTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFvQixDQUFDLFNBQUQsQ0FBQU8sU0FBQUEsQ0FBQUEsQ0FBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBb0IsQ0FBQyxTQUFELENBQUFDLE1BQUFBLENBQUFBLENBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWNSLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLDZCQUFBLEdBQUEsQ0FBK0IsdUJBQS9CLENBQXJCQTtBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFZQSxPQUFBQSxDQUFNLCtCQUFlLDZCQUFyQkE7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBWVMsWUFBTztBQUNuQixZQUFVVCxPQUFBQSxDQUFNLCtCQUFlLHNDQUFyQkE7QUFDVjs7QUFFQTtBQUNBLElBOWhCQTtBQUlFYixJQUFBQSxDQUFBQSwrQkFBQUEsQ0FBQTtBQUFBLElBNmhCQSxPQUFBLGlCQUFNLFNBQU4sRUFBYyxRQUFkLENBN2hCQTtBQURGRCxFQUFBQSxHQUFBQSxXQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5NzgwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9zdHJpbmcnXG5cbmNsYXNzIEVuY29kaW5nXG4gIGRlZiBzZWxmLnJlZ2lzdGVyKG5hbWUsIG9wdGlvbnMgPSB7fSwgJmJsb2NrKVxuICAgIG5hbWVzID0gW25hbWVdICsgKG9wdGlvbnNbOmFsaWFzZXNdIHx8IFtdKVxuICAgIGFzY2lpID0gb3B0aW9uc1s6YXNjaWldIHx8IGZhbHNlXG4gICAgZHVtbXkgPSBvcHRpb25zWzpkdW1teV0gfHwgZmFsc2VcblxuICAgIGlmIG9wdGlvbnNbOmluaGVyaXRzXVxuICAgICAgZW5jb2RpbmcgPSBvcHRpb25zWzppbmhlcml0c10uY2xvbmVcbiAgICAgIGVuY29kaW5nLmluaXRpYWxpemUobmFtZSwgbmFtZXMsIGFzY2lpLCBkdW1teSlcbiAgICBlbHNlXG4gICAgICBlbmNvZGluZyA9IG5ldyhuYW1lLCBuYW1lcywgYXNjaWksIGR1bW15KVxuICAgIGVuZFxuICAgIGVuY29kaW5nLmluc3RhbmNlX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cblxuICAgIHJlZ2lzdGVyID0gYE9wYWwuZW5jb2RpbmdzYFxuICAgIG5hbWVzLmVhY2ggZG8gfGVuY29kaW5nX25hbWV8XG4gICAgICBjb25zdF9zZXQgZW5jb2RpbmdfbmFtZS50cignLScsICdfJyksIGVuY29kaW5nXG4gICAgICByZWdpc3Rlci5KU1tlbmNvZGluZ19uYW1lXSA9IGVuY29kaW5nXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZpbmQobmFtZSlcbiAgICByZXR1cm4gZGVmYXVsdF9leHRlcm5hbCBpZiBuYW1lID09IDpkZWZhdWx0X2V4dGVybmFsXG4gICAgYHJldHVybiBPcGFsLmZpbmRfZW5jb2RpbmcobmFtZSlgXG4gIGVuZFxuXG4gIHNpbmdsZXRvbl9jbGFzcy5hdHRyX2FjY2Vzc29yIDpkZWZhdWx0X2V4dGVybmFsXG5cbiAgYXR0cl9yZWFkZXIgOm5hbWUsIDpuYW1lc1xuXG4gIGRlZiBpbml0aWFsaXplKG5hbWUsIG5hbWVzLCBhc2NpaSwgZHVtbXkpXG4gICAgQG5hbWUgID0gbmFtZVxuICAgIEBuYW1lcyA9IG5hbWVzXG4gICAgQGFzY2lpID0gYXNjaWlcbiAgICBAZHVtbXkgPSBkdW1teVxuICBlbmRcblxuICBkZWYgYXNjaWlfY29tcGF0aWJsZT9cbiAgICBAYXNjaWlcbiAgZW5kXG5cbiAgZGVmIGR1bW15P1xuICAgIEBkdW1teVxuICBlbmRcblxuICBkZWYgYmluYXJ5P1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgQG5hbWVcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8RW5jb2Rpbmc6I3tAbmFtZX0jeycgKGR1bW15KScgaWYgQGR1bW15fT5cIlxuICBlbmRcblxuICAjIG1ldGhvZHMgdG8gaW1wbGVtZW50IHBlciBlbmNvZGluZ1xuICBkZWYgY2hhcnNpemUoc3RyaW5nKVxuICAgICV4e1xuICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoIShjaGFyY29kZSA+PSAweEQ4MDAgJiYgY2hhcmNvZGUgPD0gMHhEQkZGKSkge1xuICAgICAgICAgIGxlbisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfY2hhcihzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBsb3dfc3Vycm9nYXRlID0gXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBjaHIgPSBzdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICBpZiAoY2hhcmNvZGUgPj0gMHhEQzAwICYmIGNoYXJjb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgIGxvd19zdXJyb2dhdGUgPSBjaHI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcmNvZGUgPj0gMHhEODAwICYmIGNoYXJjb2RlIDw9IDB4REJGRikge1xuICAgICAgICAgIGNociA9IGxvd19zdXJyb2dhdGUgKyBjaHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmluZy5lbmNvZGluZy5uYW1lICE9IFwiVVRGLThcIikge1xuICAgICAgICAgIGNociA9IG5ldyBTdHJpbmcoY2hyKTtcbiAgICAgICAgICBjaHIuZW5jb2RpbmcgPSBzdHJpbmcuZW5jb2Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIGNocik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGNsYXNzIEVuY29kaW5nRXJyb3IgPCBTdGFuZGFyZEVycm9yOyBlbmRcbiAgY2xhc3MgQ29tcGF0aWJpbGl0eUVycm9yIDwgRW5jb2RpbmdFcnJvcjsgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi04JywgYWxpYXNlczogWydDUDY1MDAxJ10sIGFzY2lpOiB0cnVlIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAvLyBUYWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iL2Y1MmRmZmQ5ZGYwNDQ1YjkzYzBjOTA2NWMyZjhmMGY0NmIyYzcyOWEvaW5kZXguanMjTDE5NTQtTDIwMzJcbiAgICAgIHZhciB1bml0cyA9IEluZmluaXR5XG4gICAgICB2YXIgY29kZVBvaW50XG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICAgICAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgICAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhFRmB9O1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4QkZgfTtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4RUZgfTtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEJGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICN7eWllbGQgYDB4RUZgfTtcbiAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgICAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAje3lpZWxkIGAweEJGYH07XG4gICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgICAgICAvLyBlbmNvZGUgdXRmOFxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4NiB8IDB4QzBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCAmIDB4M0YgfCAweDgwYH07XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEludmFsaWQgY29kZSBwb2ludFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIHN0cmluZy5ieXRlcy5sZW5ndGhcbiAgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0xNkxFJyBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aCAqIDJgXG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMTZCRScsIGluaGVyaXRzOiBFbmNvZGluZzo6VVRGXzE2TEUgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMzJMRScgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZShzdHJpbmcpXG4gICAgYHN0cmluZy5sZW5ndGggKiA0YFxuICBlbmRcbmVuZFxuXG5FbmNvZGluZy5yZWdpc3RlciAnVVRGLTMyQkUnLCBpbmhlcml0czogRW5jb2Rpbmc6OlVURl8zMkxFIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgICAgI3t5aWVsZCAwfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcbmVuZFxuXG5FbmNvZGluZy5yZWdpc3RlciAnQVNDSUktOEJJVCcsIGFsaWFzZXM6IFsnQklOQVJZJ10sIGFzY2lpOiB0cnVlIGRvXG4gIGRlZiBlYWNoX2NoYXIoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaHIgPSBuZXcgU3RyaW5nKHN0cmluZy5jaGFyQXQoaSkpO1xuICAgICAgICBjaHIuZW5jb2RpbmcgPSBzdHJpbmcuZW5jb2Rpbmc7XG4gICAgICAgICN7eWllbGQgYGNocmB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNoYXJzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZShzdHJpbmcpXG4gICAgYHN0cmluZy5sZW5ndGhgXG4gIGVuZFxuXG4gIGRlZiBiaW5hcnk/XG4gICAgdHJ1ZVxuICBlbmRcbmVuZFxuXG5FbmNvZGluZy5yZWdpc3RlciAnSVNPLTg4NTktMScsIGFsaWFzZXM6IFsnSVNPODg1OS0xJ10sIGFzY2lpOiB0cnVlLCBpbmhlcml0czogRW5jb2Rpbmc6OkFTQ0lJXzhCSVRcbkVuY29kaW5nLnJlZ2lzdGVyICdVUy1BU0NJSScsIGFsaWFzZXM6IFsnQVNDSUknXSwgYXNjaWk6IHRydWUsIGluaGVyaXRzOiBFbmNvZGluZzo6QVNDSUlfOEJJVFxuXG5jbGFzcyBTdHJpbmdcbiAgYXR0cl9yZWFkZXIgOmVuY29kaW5nXG4gIGF0dHJfcmVhZGVyIDppbnRlcm5hbF9lbmNvZGluZ1xuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCAnYnl0ZXMnLCBuaWwpYFxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCAnZW5jb2RpbmcnLCAje0VuY29kaW5nOjpVVEZfOH0pYFxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCAnaW50ZXJuYWxfZW5jb2RpbmcnLCAje0VuY29kaW5nOjpVVEZfOH0pYFxuXG4gIGRlZiBiXG4gICAgZHVwLmZvcmNlX2VuY29kaW5nKCdiaW5hcnknKVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemVcbiAgICBAaW50ZXJuYWxfZW5jb2RpbmcuYnl0ZXNpemUoc2VsZilcbiAgZW5kXG5cbiAgZGVmIGVhY2hfYnl0ZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2J5dGUpIHsgYnl0ZXNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBAaW50ZXJuYWxfZW5jb2RpbmcuZWFjaF9ieXRlKHNlbGYsICZibG9jaylcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGJ5dGVzXG4gICAgIyBSRU1JTkQ6IHJlcXVpcmVkIHdoZW4gcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgb3RoZXJ3aXNlIHRoZSBmb2xsb3dpbmcgZXJyb3Igd2lsbCBiZSB0aHJvd246XG4gICAgIyBDYW5ub3QgY3JlYXRlIHByb3BlcnR5ICdieXRlcycgb24gc3RyaW5nICdhYmMnXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiAje2BuZXcgU3RyaW5nKHNlbGYpYC5lYWNoX2J5dGUudG9fYX07XG4gICAgICB9XG4gICAgfVxuXG4gICAgQGJ5dGVzIHx8PSBlYWNoX2J5dGUudG9fYVxuICAgIEBieXRlcy5kdXBcbiAgZW5kXG5cbiAgZGVmIGVhY2hfY2hhcigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX2NoYXIpIHsgbGVuZ3RoIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgQGVuY29kaW5nLmVhY2hfY2hhcihzZWxmLCAmYmxvY2spXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjaGFycygmYmxvY2spXG4gICAgcmV0dXJuIGVhY2hfY2hhci50b19hIHVubGVzcyBibG9ja1xuXG4gICAgZWFjaF9jaGFyKCZibG9jaylcbiAgZW5kXG5cbiAgZGVmIGVhY2hfY29kZXBvaW50KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfY29kZXBvaW50IHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICN7eWllbGQgYHNlbGYuY29kZVBvaW50QXQoaSlgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY29kZXBvaW50cygmYmxvY2spXG4gICAgIyBJZiBhIGJsb2NrIGlzIGdpdmVuLCB3aGljaCBpcyBhIGRlcHJlY2F0ZWQgZm9ybSwgd29ya3MgdGhlIHNhbWUgYXMgZWFjaF9jb2RlcG9pbnQuXG4gICAgcmV0dXJuIGVhY2hfY29kZXBvaW50KCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgZWFjaF9jb2RlcG9pbnQudG9fYVxuICBlbmRcblxuICBkZWYgZW5jb2RlKGVuY29kaW5nKVxuICAgIGBPcGFsLmVuYyhzZWxmLCBlbmNvZGluZylgXG4gIGVuZFxuXG4gIGRlZiBmb3JjZV9lbmNvZGluZyhlbmNvZGluZylcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzZWxmO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHN0ci5lbmNvZGluZykgeyByZXR1cm4gc3RyOyB9XG5cbiAgICAgIGVuY29kaW5nID0gI3tPcGFsLmNvZXJjZV90byEoZW5jb2RpbmcsIFN0cmluZywgOnRvX3MpfTtcbiAgICAgIGVuY29kaW5nID0gI3tFbmNvZGluZy5maW5kKGVuY29kaW5nKX07XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gc3RyLmVuY29kaW5nKSB7IHJldHVybiBzdHI7IH1cblxuICAgICAgc3RyID0gT3BhbC5zZXRfZW5jb2Rpbmcoc3RyLCBlbmNvZGluZyk7XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2V0Ynl0ZShpZHgpXG4gICAgc3RyaW5nX2J5dGVzID0gYnl0ZXNcbiAgICBpZHggPSBPcGFsLmNvZXJjZV90byEoaWR4LCBJbnRlZ2VyLCA6dG9faW50KVxuICAgIHJldHVybiBpZiBzdHJpbmdfYnl0ZXMubGVuZ3RoIDwgaWR4XG5cbiAgICBzdHJpbmdfYnl0ZXNbaWR4XVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9jb3B5KG90aGVyKVxuICAgICV7XG4gICAgICBzZWxmLmVuY29kaW5nID0gb3RoZXIuZW5jb2Rpbmc7XG4gICAgICBzZWxmLmludGVybmFsX2VuY29kaW5nID0gb3RoZXIuaW50ZXJuYWxfZW5jb2Rpbmc7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYHNlbGYubGVuZ3RoYFxuICBlbmRcblxuICBhbGlhcyBzaXplIGxlbmd0aFxuXG4gICMgc3R1YlxuICBkZWYgdmFsaWRfZW5jb2Rpbmc/XG4gICAgdHJ1ZVxuICBlbmRcbmVuZFxuXG5FbmNvZGluZy5kZWZhdWx0X2V4dGVybmFsID0gX19FTkNPRElOR19fXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwicmVnaXN0ZXIiLCJzZWxmIiwibmFtZXMiLCIrIiwibmFtZSIsIiRyZXRfb3JfMSIsIm9wdGlvbnMiLCJbXSIsImFzY2lpIiwiJHJldF9vcl8yIiwiZHVtbXkiLCIkcmV0X29yXzMiLCJlbmNvZGluZyIsImNsb25lIiwiaW5pdGlhbGl6ZSIsIm5ldyIsImJsb2NrX2dpdmVuPyIsImluc3RhbmNlX2V2YWwiLCJibG9jayIsImVhY2giLCJjb25zdF9zZXQiLCJlbmNvZGluZ19uYW1lIiwidHIiLCJmaW5kIiwiPT0iLCJkZWZhdWx0X2V4dGVybmFsIiwic2luZ2xldG9uX2NsYXNzIiwiYXR0cl9hY2Nlc3NvciIsImF0dHJfcmVhZGVyIiwiQG5hbWUiLCJAbmFtZXMiLCJAYXNjaWkiLCJAZHVtbXkiLCJhc2NpaV9jb21wYXRpYmxlPyIsImR1bW15PyIsImJpbmFyeT8iLCJ0b19zIiwiaW5zcGVjdCIsImNoYXJzaXplIiwiZWFjaF9jaGFyIiwiZWFjaF9ieXRlIiwicmFpc2UiLCJieXRlc2l6ZSIsInN0cmluZyIsImJ5dGVzIiwibGVuZ3RoIiwiMCIsImIiLCJkdXAiLCJmb3JjZV9lbmNvZGluZyIsIkBpbnRlcm5hbF9lbmNvZGluZyIsImVudW1fZm9yIiwidG9fYSIsIkBieXRlcyIsIiRyZXRfb3JfNCIsIkBlbmNvZGluZyIsImNoYXJzIiwiZWFjaF9jb2RlcG9pbnQiLCJjb2RlcG9pbnRzIiwiZW5jb2RlIiwiY29lcmNlX3RvISIsImdldGJ5dGUiLCJzdHJpbmdfYnl0ZXMiLCJpZHgiLCI8IiwiaW5pdGlhbGl6ZV9jb3B5IiwidmFsaWRfZW5jb2Rpbmc/IiwiJHdyaXRlciIsImRlZmF1bHRfZXh0ZXJuYWw9IiwiLSIsIjEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsZ0JBQVJBLENBQUE7QUFBQSxFQUVBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsSUFBQUMsVUFBSUMsSUFBSkQsZUFBQUEsdUJBQUFBLG9CQUFrQixJQUFELEVBQU8sT0FBeEJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQUpGO0FBSXdDLE1BQUEsMkNBSnhDO0FBQUE7QUFJMEIsTUFBQTtBQUFBLE1BQUEsWUFBVSxZQUFBLEVBQVY7QUFBQSxNQUFBLENBSjFCO0FBQUEsTUFLSUUsUUFBUUMsU0FBQSxDQUFDQyxJQUFELENBQUFELEVBQVUsYUFBQSxJQUFBLFFBTHRCRSxDQUFBQSxZQUtzQkMsT0FBQUMsT0FBQUEsQ0FBUSxTQUFSQSxDQUx0QkYsQ0FLc0IsQ0FBQTtBQUFBLFFBTHRCLE9BQUE7QUFLc0IsTUFBQTtBQUFBLFFBQXFCLE9BQUE7QUFBckIsTUFBQSxDQUFBLGtCQUFWRixDQUxaO0FBQUEsTUFNSUssUUFBUSxhQUFBLElBQUEsUUFOWkMsQ0FBQUEsWUFNWUgsT0FBQUMsT0FBQUEsQ0FBUSxPQUFSQSxDQU5aRSxDQU1ZLENBQUE7QUFBQSxRQU5aLE9BQUE7QUFNWSxNQUFBO0FBQUEsUUFBbUIsT0FBQTtBQUFuQixNQUFBLENBQUEsa0JBTlo7QUFBQSxNQU9JQyxRQUFRLGFBQUEsSUFBQSxRQVBaQyxDQUFBQSxZQU9ZTCxPQUFBQyxPQUFBQSxDQUFRLE9BQVJBLENBUFpJLENBT1ksQ0FBQTtBQUFBLFFBUFosT0FBQTtBQU9ZLE1BQUE7QUFBQSxRQUFtQixPQUFBO0FBQW5CLE1BQUEsQ0FBQSxrQkFQWjtBQUFBLE1BU0ksSUFBQSxRQUFHTCxPQUFBQyxPQUFBQSxDQUFRLFVBQVJBLENBQUgsQ0FBQTtBQUFBO0FBQ0UsUUFBQUssV0FBV04sT0FBQUMsT0FBQUEsQ0FBUSxVQUFSQSxDQUFBTSxPQUFBQSxDQUFBQSxDQUFYO0FBQUEsUUFDQUQsUUFBQUUsWUFBQUEsQ0FBb0JWLE1BQU1GLE9BQU9NLE9BQU9FLEtBQXhDSSxDQURBO0FBREYsTUFBQTtBQUFBLFFBSUVGLGVBQVdHLEtBQUFBLENBQUlYLE1BQU1GLE9BQU9NLE9BQU9FLEtBQXhCSztBQUpiLE1BQUEsQ0FUSjtBQUFBLE1BZUksSUFBa0NDLGVBQWxDO0FBQUEsUUFBQUMsTUFBQUwsUUFBQUssaUJBQUFBLEVBQUFBLEVBQUFBLEVBQXdCQyxnQkFBeEJELENBQUEsQ0FmSjtBQUFBLE1BaUJJakIsV0FBWSxjQWpCaEI7QUFBQSxNQWtCSSxPQUFBbUIsTUFBQWpCLEtBQUFpQixRQUFBQSxFQUFBQSxFQUFBQSxFQWxCSixnQkFrQm1CLGFBbEJuQixFQUFBOztBQUFBO0FBQUE7QUFrQm1CLFFBQUE7QUFBQSxRQUFBO0FBQUEsUUFBQSxDQWxCbkI7QUFBQSxZQW1CTUMsV0FBQUEsQ0FBVUMsYUFBQUMsSUFBQUEsQ0FBaUIsS0FBSyxHQUF0QkEsR0FBNEJWLFFBQXRDUSxDQW5CTjtBQUFBLFFBb0JNLE9BQUFwQixRQUFBLENBQVlxQixhQUFaLElBQTZCVCxRQXBCbkMsQ0FBQSxrQkFBQSxpQkFBQSxLQWtCSU8sQ0FsQko7QUFJRW5CLElBQUFBLENBQUFBLG1DQUFBQSxDQUFBO0FBQUEsSUFvQkF1QixVQUFJdEIsSUFBSnNCLFdBQUFBLG1CQUFBQSxnQkFBYyxJQUFkQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBLElBQTJCbkIsSUFBQW9CLE9BQUFBLENBQVEsa0JBQVJBLENBQTNCO0FBQUEsUUFBQSxXQUFPQyxrQkFBQUEsQ0FBQUEsQ0FBUCxDQUFBO0FBQUEsTUFDQywrQkFBRCxDQURBO0FBREZGLElBQUFBLENBQUFBLDhCQUFBQSxDQXBCQTtBQUFBLFFBeUJBRyxpQkFBQUEsQ0FBQUEsQ0FBQUMsZUFBQUEsQ0FBOEIsa0JBQTlCQSxDQXpCQTtBQUFBLFFBMkJBQyxhQUFBQSxDQUFZLFFBQU8sT0FBbkJBLENBM0JBO0FBQUE7QUE2QkFkLElBQUFBLDhCQUFBQSx5QkFBQUEsc0JBQWUsSUFBRCxFQUFPLEtBQVAsRUFBYyxLQUFkLEVBQXFCLEtBQW5DQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBZSxZQUFTekIsSUFBVDtBQUFBLE1BQ0EwQixhQUFTNUIsS0FEVDtBQUFBLE1BRUE2QixhQUFTdkIsS0FGVDtBQUFBLE1BR0EsT0FBQXdCLENBQUFBLGFBQVN0QixLQUFUc0IsQ0FIQTtBQURGbEIsSUFBQUEsQ0FBQUEsb0NBQUFBLENBN0JBO0FBQUE7QUFvQ0FtQixJQUFBQSxxQ0FBQUEsb0NBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFGO0FBREZFLElBQUFBLENBQUFBLCtDQUFBQSxDQXBDQTtBQUFBO0FBd0NBQyxJQUFBQSwwQkFBQUEseUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFGO0FBREZFLElBQUFBLENBQUFBLG9DQUFBQSxDQXhDQTtBQUFBO0FBNENBQyxJQUFBQSwyQkFBQUEsMEJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEscUNBQUFBLENBNUNBO0FBQUE7QUFnREFDLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFQO0FBREZPLElBQUFBLENBQUFBLDhCQUFBQSxDQWhEQTtBQUFBO0FBb0RBQyxJQUFBQSwyQkFBQUEsc0JBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLEVBQUEsR0FBQSxhQUFBLEdBQUEsQ0FBY1IsU0FBZCxDQUFBLEdBQUEsQ0FBc0IsYUFBQSxJQUFBLFFBQWNHLFVBQWQsQ0FBQTtBQUFBLFFBQUEsT0FBQTtBQUFBLE1BQUE7QUFBQTtBQUFBLE1BQUEsQ0FBQSxrQkFBdEIsQ0FBQSxHQUFBO0FBREZLLElBQUFBLENBQUFBLGlDQUFBQSxDQXBEQTtBQUFBO0FBeURBQyxJQUFBQSw0QkFBQUEsd0JBQUFBLG9CQUFhLE1BQWJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZFQSxJQUFBQSxDQUFBQSxtQ0FBQUEsQ0F6REE7QUFBQTtBQXNFQUMsSUFBQUEsNkJBQUFBLHlCQUFBQSxxQkFBYyxNQUFkQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUExRUY7QUEwRXdCLE1BQUEsNkNBMUV4QjtBQUFBO0FBNEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQTdGQTtBQTBFRUEsSUFBQUEsQ0FBQUEsb0NBQUFBLENBdEVBO0FBQUE7QUE0RkFDLElBQUFBLDZCQUFBQSx5QkFBQUEscUJBaEdGLEVBZ0dFQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFoR0Y7QUFBQSxNQUFBLDREQUFBO0FBQUEsTUFBQTtBQUFBLE1BaUdJLFdBQUFDLE9BQUFBLENBQU0sbUNBQU5BLENBakdKO0FBZ0dFRCxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0E1RkE7QUFBQTtBQWdHQUUsSUFBQUEsNEJBQUFBLHdCQUFBQSxvQkFwR0YsRUFvR0VBO0FBQUFBLE1BQUFBOztBQUFBQTtBQXBHRjtBQUFBLE1BQUEsNERBQUE7QUFBQSxNQUFBO0FBQUEsTUFxR0ksV0FBQUQsT0FBQUEsQ0FBTSxtQ0FBTkEsQ0FyR0o7QUFvR0VDLElBQUFBLENBQUFBLG9DQUFBQSxDQWhHQTtBQUFBLElBb0dBM0M7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQTtBQUFBQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUFzQiw2QkFBdEJBLFdBcEdBO0FBQUEsSUFxR0EsT0FBQUE7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQTtBQUFBQSxJQUFBQSxHQUFBQSxXQUFBQSxFQUEyQiw2QkFBM0JBLFdBckdBO0FBREZBLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBRkE7QUFBQSxFQTJHQUMsTUFBQSx3QkFBQUEsWUFBQUEsRUFBQUEsQ0FBa0IsU0FBUyw4QkFBQSxXQUFTLENBQUMsU0FBRCxDQUFULEVBQUEsU0FBNkIsSUFBN0IsRUFBM0JBLENBQUFBLEVBNUdBLGlCQUFBLEVBQUE7O0FBQUE7QUE2R0U7QUFBQXdDLElBQUFBLDZCQUFBQSxnQkFBQUEscUJBQWMsTUFBZEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBN0dGO0FBNkd3QixNQUFBLG9DQTdHeEI7QUFBQTtBQStHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFrQixtQkFBTyxJQUFQLENBQWE7QUFDL0IsZ0JBQWtCLG1CQUFPLElBQVAsQ0FBYTtBQUMvQixnQkFBa0IsbUJBQU8sSUFBUCxDQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBa0IsbUJBQU8sSUFBUCxDQUFhO0FBQy9CLGdCQUFrQixtQkFBTyxJQUFQLENBQWE7QUFDL0IsZ0JBQWtCLG1CQUFPLElBQVAsQ0FBYTtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWdCLG1CQUFPLElBQVAsQ0FBYTtBQUM3QixjQUFnQixtQkFBTyxJQUFQLENBQWE7QUFDN0IsY0FBZ0IsbUJBQU8sSUFBUCxDQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFjLG1CQUFPLElBQVAsQ0FBYTtBQUMzQixZQUFjLG1CQUFPLElBQVAsQ0FBYTtBQUMzQixZQUFjLG1CQUFPLElBQVAsQ0FBYTtBQUMzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVksbUJBQU8sU0FBUCxDQUFrQjtBQUM5QjtBQUNBO0FBQ0EsVUFBWSxtQkFBTyx1QkFBUCxDQUFnQztBQUM1QyxVQUFZLG1CQUFPLHVCQUFQLENBQWdDO0FBQzVDO0FBQ0E7QUFDQSxVQUFZLG1CQUFPLHVCQUFQLENBQWdDO0FBQzVDLFVBQVksbUJBQU8sOEJBQVAsQ0FBdUM7QUFDbkQsVUFBWSxtQkFBTyx1QkFBUCxDQUFnQztBQUM1QztBQUNBO0FBQ0EsVUFBWSxtQkFBTyx3QkFBUCxDQUFpQztBQUM3QyxVQUFZLG1CQUFPLDhCQUFQLENBQXVDO0FBQ25ELFVBQVksbUJBQU8sOEJBQVAsQ0FBdUM7QUFDbkQsVUFBWSxtQkFBTyx1QkFBUCxDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBcE1BO0FBNkdFQSxJQUFBQSxDQUFBQSwyQkFBQUEsQ0FBQTtBQUFBLElBMEZBLE9BQUFFLENBQUFBLDRCQUFBQSxlQUFBQSxvQkFBYSxNQUFiQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBQyxNQUFBQyxPQUFBQSxDQUFBQSxDQUFBQyxRQUFBQSxDQUFBQTtBQURGSCxJQUFBQSxDQUFBQSwwQkFBQUEsQ0FBQUEsb0JBMUZBLENBN0dGLG1CQUFBLGtCQUFBLE1BNEdBMUMsQ0EzR0E7QUFBQSxFQTJNQUEsTUFBQSx3QkFBQUEsWUFBQUEsRUFBQUEsQ0FBa0IsVUFBbEJBLENBQUFBLEVBNU1BLGlCQUFBLEVBQUE7O0FBQUE7QUE2TUU7QUFBQXdDLElBQUFBLDZCQUFBQSxnQkFBQUEscUJBQWMsTUFBZEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBN01GO0FBNk13QixNQUFBLG9DQTdNeEI7QUFBQTtBQStNQTtBQUNBOztBQUVBLFFBQVUsbUJBQU8sV0FBUCxDQUFvQjtBQUM5QixRQUFVLG1CQUFPLFNBQVAsQ0FBa0I7QUFDNUI7QUFDQSxJQXJOQTtBQTZNRUEsSUFBQUEsQ0FBQUEsMkJBQUFBLENBQUE7QUFBQSxJQVdBLE9BQUFFLENBQUFBLDRCQUFBQSxlQUFBQSxvQkFBYSxNQUFiQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLGlCQUFEO0FBREZBLElBQUFBLENBQUFBLDBCQUFBQSxDQUFBQSxvQkFYQSxDQTdNRixtQkFBQSxrQkFBQSxNQTRNQTFDLENBM01BO0FBQUEsRUE0TkFBLE1BQUEsd0JBQUFBLFlBQUFBLEVBQUFBLENBQWtCLFlBQVksc0JBQUEsWUFBVSxJQUFBLHdCQUFBLGFBQVYsRUFBOUJBLENBQUFBLEVBN05BLGlCQUFBLEVBQUE7O0FBQUEsRUE4TkUsT0FBQXdDLENBQUFBLDZCQUFBQSxnQkFBQUEscUJBQWMsTUFBZEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBOU5GO0FBOE53QixNQUFBLG9DQTlOeEI7QUFBQTtBQWdPQTtBQUNBOztBQUVBLFFBQVUsbUJBQU8sU0FBUCxDQUFrQjtBQUM1QixRQUFVLG1CQUFPLFdBQVAsQ0FBb0I7QUFDOUI7QUFDQSxJQXRPQTtBQThORUEsSUFBQUEsQ0FBQUEsMkJBQUFBLENBQUFBLHFCQTlORixtQkFBQSxrQkFBQSxNQTZOQXhDLENBNU5BO0FBQUEsRUF5T0FBLE1BQUEsd0JBQUFBLFlBQUFBLEVBQUFBLENBQWtCLFVBQWxCQSxDQUFBQSxFQTFPQSxpQkFBQSxFQUFBOztBQUFBO0FBMk9FO0FBQUF3QyxJQUFBQSw2QkFBQUEsZ0JBQUFBLHFCQUFjLE1BQWRBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQTNPRjtBQTJPd0IsTUFBQSxvQ0EzT3hCO0FBQUE7QUE2T0E7QUFDQTs7QUFFQSxRQUFVLG1CQUFPLFdBQVAsQ0FBb0I7QUFDOUIsUUFBVSxtQkFBTyxTQUFQLENBQWtCO0FBQzVCLFFBQVUsbUJBQU1NLENBQU4sQ0FBUTtBQUNsQixRQUFVLG1CQUFNQSxDQUFOLENBQVE7QUFDbEI7QUFDQSxJQXJQQTtBQTJPRU4sSUFBQUEsQ0FBQUEsMkJBQUFBLENBQUE7QUFBQSxJQWFBLE9BQUFFLENBQUFBLDRCQUFBQSxlQUFBQSxvQkFBYSxNQUFiQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLGlCQUFEO0FBREZBLElBQUFBLENBQUFBLDBCQUFBQSxDQUFBQSxvQkFiQSxDQTNPRixtQkFBQSxrQkFBQSxNQTBPQTFDLENBek9BO0FBQUEsRUE0UEFBLE1BQUEsd0JBQUFBLFlBQUFBLEVBQUFBLENBQWtCLFlBQVksc0JBQUEsWUFBVSxJQUFBLHdCQUFBLGFBQVYsRUFBOUJBLENBQUFBLEVBN1BBLGlCQUFBLEVBQUE7O0FBQUEsRUE4UEUsT0FBQXdDLENBQUFBLDZCQUFBQSxnQkFBQUEscUJBQWMsTUFBZEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBOVBGO0FBOFB3QixNQUFBLG9DQTlQeEI7QUFBQTtBQWdRQTtBQUNBOztBQUVBLFFBQVUsbUJBQU1NLENBQU4sQ0FBUTtBQUNsQixRQUFVLG1CQUFNQSxDQUFOLENBQVE7QUFDbEIsUUFBVSxtQkFBTyxTQUFQLENBQWtCO0FBQzVCLFFBQVUsbUJBQU8sV0FBUCxDQUFvQjtBQUM5QjtBQUNBLElBeFFBO0FBOFBFTixJQUFBQSxDQUFBQSwyQkFBQUEsQ0FBQUEscUJBOVBGLG1CQUFBLGtCQUFBLE1BNlBBeEMsQ0E1UEE7QUFBQSxFQTJRQUEsTUFBQSx3QkFBQUEsWUFBQUEsRUFBQUEsQ0FBa0IsY0FBYyw4QkFBQSxXQUFTLENBQUMsUUFBRCxDQUFULEVBQUEsU0FBNEIsSUFBNUIsRUFBaENBLENBQUFBLEVBNVFBLGlCQUFBLEVBQUE7O0FBQUE7QUE2UUU7QUFBQXVDLElBQUFBLDZCQUFBQSxnQkFBQUEscUJBQWMsTUFBZEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBN1FGO0FBNlF3QixNQUFBLG9DQTdReEI7QUFBQTtBQStRQTtBQUNBO0FBQ0E7QUFDQSxRQUFVLG1CQUFPLEdBQVAsQ0FBWTtBQUN0QjtBQUNBLElBcFJBO0FBNlFFQSxJQUFBQSxDQUFBQSwyQkFBQUEsQ0FBQTtBQUFBO0FBVUFELElBQUFBLDRCQUFBQSxlQUFBQSxvQkFBYSxNQUFiQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLGFBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsMEJBQUFBLENBVkE7QUFBQTtBQWNBRSxJQUFBQSw2QkFBQUEsZ0JBQUFBLHFCQUFjLE1BQWRBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQTNSRjtBQTJSd0IsTUFBQSxvQ0EzUnhCO0FBQUE7QUE2UkE7QUFDQTtBQUNBLFFBQVUsbUJBQU8sV0FBUCxDQUFvQjtBQUM5QjtBQUNBLElBalNBO0FBMlJFQSxJQUFBQSxDQUFBQSwyQkFBQUEsQ0FkQTtBQUFBO0FBdUJBRSxJQUFBQSw0QkFBQUEsZUFBQUEsb0JBQWEsTUFBYkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQyxhQUFEO0FBREZBLElBQUFBLENBQUFBLDBCQUFBQSxDQXZCQTtBQUFBLElBMkJBLE9BQUFQLENBQUFBLDJCQUFBQSxrQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQTtBQURGQSxJQUFBQSxDQUFBQSw2QkFBQUEsQ0FBQUEsbUJBM0JBLENBN1FGLG1CQUFBLGtCQUFBLE1BNFFBbkMsQ0EzUUE7QUFBQSxFQTRTQSx3QkFBQUEsVUFBQUEsQ0FBa0IsY0FBYywwQ0FBQSxXQUFTLENBQUMsV0FBRCxDQUFULEVBQUEsU0FBK0IsSUFBL0IsRUFBQSxZQUErQyxJQUFBLHdCQUFBLGVBQS9DLEVBQWhDQSxDQTVTQTtBQUFBLEVBNlNBLHdCQUFBQSxVQUFBQSxDQUFrQixZQUFZLDBDQUFBLFdBQVMsQ0FBQyxPQUFELENBQVQsRUFBQSxTQUEyQixJQUEzQixFQUFBLFlBQTJDLElBQUEsd0JBQUEsZUFBM0MsRUFBOUJBLENBN1NBO0FBQUEsRUErU0FEO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxRQUFBNkIsYUFBQUEsQ0FBWSxVQUFaQSxDQUFBO0FBQUEsUUFDQUEsYUFBQUEsQ0FBWSxtQkFBWkEsQ0FEQTtBQUFBLElBRUMsbURBRkQ7QUFBQSxJQUdDLGtEQUFvRCxJQUFBLHdCQUFBLFVBQWdCLENBSHJFO0FBQUEsSUFJQywyREFBNkQsSUFBQSx3QkFBQSxVQUFnQixDQUo5RTtBQUFBO0FBTUFtQixJQUFBQSxxQkFBQUEsZUFBQUEsYUFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsV0FBQUMsS0FBQUEsQ0FBQUEsQ0FBQUMsZ0JBQUFBLENBQW1CLFFBQW5CQTtBQURGRixJQUFBQSxDQUFBQSwwQkFBQUEsQ0FOQTtBQUFBO0FBVUFMLElBQUFBLDRCQUFBQSxzQkFBQUEsb0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFRLHNCQUFBUixVQUFBQSxDQUE0QnpDLElBQTVCeUM7QUFERkEsSUFBQUEsQ0FBQUEsaUNBQUFBLENBVkE7QUFBQTtBQWNBRixJQUFBQSw2QkFBQUEsdUJBQUFBLHFCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFBQUE7QUFBQUE7QUEvVEY7QUErVGdCLE1BQUEsMkNBL1RoQjtBQUFBLE1BZ1VJLElBQWdEeEIsZUFBaEQ7QUFBQSxNQUFBO0FBQUEsUUFBQSxPQUFPbUMsVUFBQUEsWUFBQUEsRUFBQUEsQ0FBUyxXQUFUQSxDQUFBQSxFQWhVWCxpQkFBQSxFQUFBOztBQUFBLFFBZ1VrQyxXQUFBVCxVQUFBQSxDQUFBQSxDQWhVbEMsbUJBQUEsa0JBQUEsTUFnVVdTO0FBQVAsTUFBQSxDQWhVSjtBQUFBLE1Ba1VJWCxNQUFBVSxzQkFBQVYsYUFBQUEsRUFBQUEsQ0FBNkJ2QyxJQUE3QnVDLENBQUFBLEVBQW9DdEIsZ0JBQXBDc0IsQ0FsVUo7QUFBQSxNQW9VSSxPQUFBdkMsSUFwVUo7QUErVEV1QyxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0FkQTtBQUFBO0FBc0JBSSxJQUFBQSx5QkFBQUEsbUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFHRTtBQUNKO0FBQ0EsZUFBaUIsQ0FBQyxnQkFBRCxDQUFBSixXQUFBQSxDQUFBQSxDQUFBWSxNQUFBQSxDQUFBQSxDQUFrQztBQUNuRDtBQUNBLElBSkk7QUFBQSxNQU1BQyxhQWhWSixhQUFBLElBQUEsUUFBQUMsQ0FBQUEsWUFnVklELFVBaFZKQyxDQUFBLENBQUE7QUFBQSxRQUFBLE9BQUE7QUFBQSxNQUFBO0FBQUEsUUFnVmUsV0FBQWQsV0FBQUEsQ0FBQUEsQ0FBQVksTUFBQUEsQ0FBQUE7QUFoVmYsTUFBQSxDQUFBLGtCQTBVSTtBQUFBLE1BT0EsT0FBQUMsVUFBQUwsS0FBQUEsQ0FBQUEsQ0FQQTtBQUhGSixJQUFBQSxDQUFBQSw4QkFBQUEsQ0F0QkE7QUFBQTtBQW1DQUwsSUFBQUEsNkJBQUFBLHVCQUFBQSxxQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBcFZGO0FBb1ZnQixNQUFBLDJDQXBWaEI7QUFBQSxNQXFWSSxJQUE4Q3ZCLGVBQTlDO0FBQUEsTUFBQTtBQUFBLFFBQUEsT0FBT21DLFVBQUFBLFlBQUFBLEVBQUFBLENBQVMsV0FBVEEsQ0FBQUEsRUFyVlgsaUJBQUEsRUFBQTs7QUFBQSxRQXFWa0MsV0FBQU4sUUFBQUEsQ0FBQUEsQ0FyVmxDLG1CQUFBLGtCQUFBLE1BcVZXTTtBQUFQLE1BQUEsQ0FyVko7QUFBQSxNQXVWSVosTUFBQWdCLGFBQUFoQixhQUFBQSxFQUFBQSxDQUFvQnRDLElBQXBCc0MsQ0FBQUEsRUFBMkJyQixnQkFBM0JxQixDQXZWSjtBQUFBLE1BeVZJLE9BQUF0QyxJQXpWSjtBQW9WRXNDLElBQUFBLENBQUFBLGtDQUFBQSxDQW5DQTtBQUFBO0FBMkNBaUIsSUFBQUEseUJBQUFBLG1CQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBNVZGO0FBNFZZLE1BQUEsdUNBNVZaO0FBQUEsTUE2VkksSUFBQSxRQUE2QnRDLEtBQTdCLENBQUE7QUFBQSxNQUFBO0FBQUEsUUFBQSxXQUFPcUIsV0FBQUEsQ0FBQUEsQ0FBQWEsTUFBQUEsQ0FBQUE7QUFBUCxNQUFBLENBN1ZKO0FBQUEsTUErVkksT0FBQWIsVUFBQUEsYUFBQUEsRUFBQUEsRUFBQUEsRUFBV3JCLGdCQUFYcUIsQ0EvVko7QUE0VkVpQixJQUFBQSxDQUFBQSw4QkFBQUEsQ0EzQ0E7QUFBQTtBQWlEQUMsSUFBQUEsa0NBQUFBLDRCQUFBQSwwQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQUFBO0FBQUFBO0FBbFdGO0FBa1dxQixNQUFBLGdEQWxXckI7QUFBQSxNQW1XSSxJQUF1Q3pDLGVBQXZDO0FBQUEsTUFBQTtBQUFBLFFBQUEsV0FBT21DLFVBQUFBLENBQVMsZ0JBQVRBO0FBQVAsTUFBQSxDQW5XSjtBQUFBO0FBcVdBO0FBQ0EsUUFBVSxtQkFBTyxtQkFBUCxDQUE0QjtBQUN0QztBQUNBLElBeFdBO0FBQUEsTUF5V0ksT0FBQWxELElBeldKO0FBa1dFd0QsSUFBQUEsQ0FBQUEsdUNBQUFBLENBakRBO0FBQUE7QUEyREFDLElBQUFBLDhCQUFBQSx3QkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQTVXRjtBQTRXaUIsTUFBQSw0Q0E1V2pCO0FBQUEsTUE4V0ksSUFBaUMxQyxlQUFqQztBQUFBLFFBQUEsT0FBT3lDLFVBQUFBLGtCQUFBQSxFQUFBQSxFQUFBQSxFQUFnQnZDLGdCQUFoQnVDLENBQVAsQ0E5V0o7QUFBQSxNQStXSSxXQUFBQSxnQkFBQUEsQ0FBQUEsQ0FBQUwsTUFBQUEsQ0FBQUEsQ0EvV0o7QUE0V0VNLElBQUFBLENBQUFBLG1DQUFBQSxDQTNEQTtBQUFBO0FBaUVBQyxJQUFBQSwwQkFBQUEsb0JBQUFBLGtCQUFXLFFBQVhBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUMsd0JBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBakVBO0FBQUE7QUFxRUFWLElBQUFBLGtDQUFBQSw0QkFBQUEsMEJBQW1CLFFBQW5CQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjs7QUFFQTs7QUFFQSxpQkFBbUIsb0JBQUFXLGVBQUFBLENBQWdCaEQsVUFBVSx3QkFBUSxNQUFsQ2dELENBQXlDO0FBQzVELGlCQUFtQix3QkFBQXJDLE1BQUFBLENBQWNYLFFBQWRXLENBQXdCOztBQUUzQzs7QUFFQTs7QUFFQTtBQUNBO0FBZEUwQixJQUFBQSxDQUFBQSx1Q0FBQUEsQ0FyRUE7QUFBQTtBQXNGQVksSUFBQUEsMkJBQUFBLHFCQUFBQSxtQkFBWSxHQUFaQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBQyxtQkFBZWxCLE9BQUFBLENBQUFBLENBQWY7QUFBQSxNQUNBbUIsTUFBTSxvQkFBQUgsZUFBQUEsQ0FBZ0JHLEtBQUsseUJBQVMsUUFBOUJILENBRE47QUFBQSxNQUVBLElBQUEsUUFBVUksT0FBQUYsWUFBQWpCLFFBQUFBLENBQUFBLENBQUFtQixFQUFzQkQsR0FBdEJDLENBQVYsQ0FBQTtBQUFBLFFBQUEsVUFBQSxDQUZBO0FBQUEsTUFJQSxPQUFBRixZQUFBdkQsT0FBQUEsQ0FBYXdELEdBQWJ4RCxDQUpBO0FBREZzRCxJQUFBQSxDQUFBQSxnQ0FBQUEsQ0F0RkE7QUFBQTtBQThGQUksSUFBQUEsbUNBQUFBLDZCQUFBQSwyQkFBb0IsS0FBcEJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsRUFBQSxHQUFBLElBQUEsR0FBQSx5Q0FBQSxHQUFBLDJEQUFBLEdBQUE7QUFERkEsSUFBQUEsQ0FBQUEsd0NBQUFBLENBOUZBO0FBQUE7QUFxR0FwQixJQUFBQSwwQkFBQUEsb0JBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFDLFdBQUQ7QUFERkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBckdBO0FBQUEsSUF5R0EsaUJBQU0sTUFBTixFQUFXLFFBQVgsQ0F6R0E7QUFBQSxJQTRHQSxPQUFBcUIsQ0FBQUEsbUNBQUFBLGlDQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBO0FBREZBLElBQUFBLENBQUFBLDRDQUFBQSxDQUFBQSwyQkE1R0E7QUFERm5FLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBL1NBO0FBQUE7QUFEQSxFQUFBb0UsVUFBQSxDQWthNEIsNEJBQUEsVUFsYTVCLENBQUE7QUFBQSxFQWthQUMsTUFBQSx3QkFBQUEscUJBQUFBLEVBbGFBLFVBQUFELE9BQUEsQ0FrYUFDLENBbGFBO0FBQUEsRUFBQSxPQUFBRCxPQUFBLENBQUFFLFVBQUFGLE9BQUEsQ0FBQSxRQUFBLENBQUFFLEVBQUFDLENBQUFELENBQUEsQ0FBQSxDQUNBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjA0MDksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL21hdGgucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0eXBlX2Vycm9yXG5cbm1vZHVsZSBNYXRoXG4gIEUgID0gYE1hdGguRWBcbiAgUEkgPSBgTWF0aC5QSWBcblxuICBEb21haW5FcnJvciA9IENsYXNzLm5ldyhTdGFuZGFyZEVycm9yKVxuXG4gIGRlZiBzZWxmLmNoZWNrZWQobWV0aG9kLCAqYXJncylcbiAgICAleHtcbiAgICAgIGlmIChpc05hTihhcmdzWzBdKSB8fCAoYXJncy5sZW5ndGggPT0gMiAmJiBpc05hTihhcmdzWzFdKSkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IE1hdGhbbWV0aG9kXS5hcHBseShudWxsLCBhcmdzKTtcblxuICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgI3tyYWlzZSBEb21haW5FcnJvciwgXCJOdW1lcmljYWwgYXJndW1lbnQgaXMgb3V0IG9mIGRvbWFpbiAtIFxcXCIje21ldGhvZH1cXFwiXCJ9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuZmxvYXQhKHZhbHVlKVxuICAgIEZsb2F0KHZhbHVlKVxuICByZXNjdWUgQXJndW1lbnRFcnJvclxuICAgIHJhaXNlIGAkdHlwZV9lcnJvcih2YWx1ZSwgI3tGbG9hdH0pYFxuICBlbmRcblxuICBkZWYgc2VsZi5pbnRlZ2VyISh2YWx1ZSlcbiAgICBJbnRlZ2VyKHZhbHVlKVxuICByZXNjdWUgQXJndW1lbnRFcnJvclxuICAgIHJhaXNlIGAkdHlwZV9lcnJvcih2YWx1ZSwgI3tJbnRlZ2VyfSlgXG4gIGVuZFxuXG4gIG1vZHVsZV9mdW5jdGlvblxuXG4gIGRlZiBhY29zKHgpXG4gICAgTWF0aC5jaGVja2VkIDphY29zLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguYWNvc2hgKVxuICAgICV4e1xuICAgICAgTWF0aC5hY29zaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCAqIHggLSAxKSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYWNvc2goeClcbiAgICBNYXRoLmNoZWNrZWQgOmFjb3NoLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgYXNpbih4KVxuICAgIE1hdGguY2hlY2tlZCA6YXNpbiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmFzaW5oYClcbiAgICAleHtcbiAgICAgIE1hdGguYXNpbmggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4ICsgTWF0aC5zcXJ0KHggKiB4ICsgMSkpXG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXNpbmgoeClcbiAgICBNYXRoLmNoZWNrZWQgOmFzaW5oLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgYXRhbih4KVxuICAgIE1hdGguY2hlY2tlZCA6YXRhbiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGF0YW4yKHksIHgpXG4gICAgTWF0aC5jaGVja2VkIDphdGFuMiwgTWF0aC5mbG9hdCEoeSksIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5hdGFuaGApXG4gICAgJXh7XG4gICAgICBNYXRoLmF0YW5oID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gMC41ICogTWF0aC5sb2coKDEgKyB4KSAvICgxIC0geCkpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF0YW5oKHgpXG4gICAgTWF0aC5jaGVja2VkIDphdGFuaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmNicnRgKVxuICAgICV4e1xuICAgICAgTWF0aC5jYnJ0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoeCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gLU1hdGguY2JydCgteCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgciAgPSB4LFxuICAgICAgICAgICAgZXggPSAwO1xuXG4gICAgICAgIHdoaWxlIChyIDwgMC4xMjUpIHtcbiAgICAgICAgICByICo9IDg7XG4gICAgICAgICAgZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChyID4gMS4wKSB7XG4gICAgICAgICAgciAqPSAwLjEyNTtcbiAgICAgICAgICBleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgciA9ICgtMC40Njk0NjExNiAqIHIgKyAxLjA3MjMwMikgKiByICsgMC4zODEyNTEzO1xuXG4gICAgICAgIHdoaWxlIChleCA8IDApIHtcbiAgICAgICAgICByICo9IDAuNTtcbiAgICAgICAgICBleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGV4ID4gMCkge1xuICAgICAgICAgIHIgKj0gMjtcbiAgICAgICAgICBleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgciA9ICgyLjAgLyAzLjApICogciArICgxLjAgLyAzLjApICogeCAvIChyICogcik7XG4gICAgICAgIHIgPSAoMi4wIC8gMy4wKSAqIHIgKyAoMS4wIC8gMy4wKSAqIHggLyAociAqIHIpO1xuICAgICAgICByID0gKDIuMCAvIDMuMCkgKiByICsgKDEuMCAvIDMuMCkgKiB4IC8gKHIgKiByKTtcbiAgICAgICAgciA9ICgyLjAgLyAzLjApICogciArICgxLjAgLyAzLjApICogeCAvIChyICogcik7XG5cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2JydCh4KVxuICAgIE1hdGguY2hlY2tlZCA6Y2JydCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGNvcyh4KVxuICAgIE1hdGguY2hlY2tlZCA6Y29zLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguY29zaGApXG4gICAgJXh7XG4gICAgICBNYXRoLmNvc2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb3NoKHgpXG4gICAgTWF0aC5jaGVja2VkIDpjb3NoLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguZXJmYClcbiAgICAleHtcbiAgICAgIE9wYWwuZGVmaW5lUHJvcGVydHkoTWF0aCwgJ2VyZicsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIEExID0gIDAuMjU0ODI5NTkyLFxuICAgICAgICAgICAgQTIgPSAtMC4yODQ0OTY3MzYsXG4gICAgICAgICAgICBBMyA9ICAxLjQyMTQxMzc0MSxcbiAgICAgICAgICAgIEE0ID0gLTEuNDUzMTUyMDI3LFxuICAgICAgICAgICAgQTUgPSAgMS4wNjE0MDU0MjksXG4gICAgICAgICAgICBQICA9ICAwLjMyNzU5MTE7XG5cbiAgICAgICAgdmFyIHNpZ24gPSAxO1xuXG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgeCA9IE1hdGguYWJzKHgpO1xuXG4gICAgICAgIHZhciB0ID0gMS4wIC8gKDEuMCArIFAgKiB4KTtcbiAgICAgICAgdmFyIHkgPSAxLjAgLSAoKCgoKEE1ICogdCArIEE0KSAqIHQpICsgQTMpICogdCArIEEyKSAqIHQgKyBBMSkgKiB0ICogTWF0aC5leHAoLXggKiB4KTtcblxuICAgICAgICByZXR1cm4gc2lnbiAqIHk7XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlcmYoeClcbiAgICBNYXRoLmNoZWNrZWQgOmVyZiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmVyZmNgKVxuICAgICV4e1xuICAgICAgT3BhbC5kZWZpbmVQcm9wZXJ0eShNYXRoLCAnZXJmYycsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIHogPSBNYXRoLmFicyh4KSxcbiAgICAgICAgICAgIHQgPSAxLjAgLyAoMC41ICogeiArIDEuMCk7XG5cbiAgICAgICAgdmFyIEExID0gdCAqIDAuMTcwODcyNzcgKyAtMC44MjIxNTIyMyxcbiAgICAgICAgICAgIEEyID0gdCAqIEExICsgMS40ODg1MTU4NyxcbiAgICAgICAgICAgIEEzID0gdCAqIEEyICsgLTEuMTM1MjAzOTgsXG4gICAgICAgICAgICBBNCA9IHQgKiBBMyArIDAuMjc4ODY4MDcsXG4gICAgICAgICAgICBBNSA9IHQgKiBBNCArIC0wLjE4NjI4ODA2LFxuICAgICAgICAgICAgQTYgPSB0ICogQTUgKyAwLjA5Njc4NDE4LFxuICAgICAgICAgICAgQTcgPSB0ICogQTYgKyAwLjM3NDA5MTk2LFxuICAgICAgICAgICAgQTggPSB0ICogQTcgKyAxLjAwMDAyMzY4LFxuICAgICAgICAgICAgQTkgPSB0ICogQTgsXG4gICAgICAgICAgICBBMTAgPSAteiAqIHogLSAxLjI2NTUxMjIzICsgQTk7XG5cbiAgICAgICAgdmFyIGEgPSB0ICogTWF0aC5leHAoQTEwKTtcblxuICAgICAgICBpZiAoeCA8IDAuMCkge1xuICAgICAgICAgIHJldHVybiAyLjAgLSBhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlcmZjKHgpXG4gICAgTWF0aC5jaGVja2VkIDplcmZjLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgZXhwKHgpXG4gICAgTWF0aC5jaGVja2VkIDpleHAsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBmcmV4cCh4KVxuICAgIHggPSBNYXRoLmZsb2F0ISh4KVxuXG4gICAgJXh7XG4gICAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgcmV0dXJuIFtOYU4sIDBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXggICA9IE1hdGguZmxvb3IoTWF0aC5sb2coTWF0aC5hYnMoeCkpIC8gTWF0aC5sb2coMikpICsgMSxcbiAgICAgICAgICBmcmFjID0geCAvIE1hdGgucG93KDIsIGV4KTtcblxuICAgICAgcmV0dXJuIFtmcmFjLCBleF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgZ2FtbWEobilcbiAgICBuID0gTWF0aC5mbG9hdCEobilcblxuICAgICV4e1xuICAgICAgdmFyIGksIHQsIHgsIHZhbHVlLCByZXN1bHQsIHR3b04sIHRocmVlTiwgZm91ck4sIGZpdmVOO1xuXG4gICAgICB2YXIgRyA9IDQuNzQyMTg3NTtcblxuICAgICAgdmFyIFAgPSBbXG4gICAgICAgICAwLjk5OTk5OTk5OTk5OTk5NzA5MTgyLFxuICAgICAgICAgNTcuMTU2MjM1NjY1ODYyOTIzNTE3LFxuICAgICAgICAtNTkuNTk3OTYwMzU1NDc1NDkxMjQ4LFxuICAgICAgICAgMTQuMTM2MDk3OTc0NzQxNzQ3MTc0LFxuICAgICAgICAtMC40OTE5MTM4MTYwOTc2MjAxOTk3OCxcbiAgICAgICAgIDAuMzM5OTQ2NDk5ODQ4MTE4ODg2OTllLTQsXG4gICAgICAgICAwLjQ2NTIzNjI4OTI3MDQ4NTc1NjY1ZS00LFxuICAgICAgICAtMC45ODM3NDQ3NTMwNDg3OTU2NDY3N2UtNCxcbiAgICAgICAgIDAuMTU4MDg4NzAzMjI0OTEyNDg4ODRlLTMsXG4gICAgICAgIC0wLjIxMDI2NDQ0MTcyNDEwNDg4MzE5ZS0zLFxuICAgICAgICAgMC4yMTc0Mzk2MTgxMTUyMTI2NDMyMGUtMyxcbiAgICAgICAgLTAuMTY0MzE4MTA2NTM2NzYzODkwMjJlLTMsXG4gICAgICAgICAwLjg0NDE4MjIzOTgzODUyNzQzMjkzZS00LFxuICAgICAgICAtMC4yNjE5MDgzODQwMTU4MTQwODY3MGUtNCxcbiAgICAgICAgIDAuMzY4OTkxODI2NTk1MzE2MjI3MDRlLTVcbiAgICAgIF07XG5cblxuICAgICAgaWYgKGlzTmFOKG4pKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgICB9XG5cbiAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xuICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAobiA9PT0gLTEgfHwgbiA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICN7cmFpc2UgRG9tYWluRXJyb3IsICdOdW1lcmljYWwgYXJndW1lbnQgaXMgb3V0IG9mIGRvbWFpbiAtIFwiZ2FtbWFcIid9O1xuICAgICAgfVxuXG4gICAgICBpZiAoI3tJbnRlZ2VyID09PSBufSkge1xuICAgICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGlzRmluaXRlKG4pID8gSW5maW5pdHkgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobiA+IDE3MSkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlICA9IG4gLSAyO1xuICAgICAgICByZXN1bHQgPSBuIC0gMTtcblxuICAgICAgICB3aGlsZSAodmFsdWUgPiAxKSB7XG4gICAgICAgICAgcmVzdWx0ICo9IHZhbHVlO1xuICAgICAgICAgIHZhbHVlLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0ID09IDApIHtcbiAgICAgICAgICByZXN1bHQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPCAwLjUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgLyAoTWF0aC5zaW4oTWF0aC5QSSAqIG4pICogI3tNYXRoLmdhbW1hKDEgLSBuKX0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA+PSAxNzEuMzUpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAobiA+IDg1LjApIHtcbiAgICAgICAgdHdvTiAgID0gbiAqIG47XG4gICAgICAgIHRocmVlTiA9IHR3b04gKiBuO1xuICAgICAgICBmb3VyTiAgPSB0aHJlZU4gKiBuO1xuICAgICAgICBmaXZlTiAgPSBmb3VyTiAqIG47XG5cbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgyICogTWF0aC5QSSAvIG4pICogTWF0aC5wb3coKG4gLyBNYXRoLkUpLCBuKSAqXG4gICAgICAgICAgKDEgKyAxIC8gKDEyICogbikgKyAxIC8gKDI4OCAqIHR3b04pIC0gMTM5IC8gKDUxODQwICogdGhyZWVOKSAtXG4gICAgICAgICAgNTcxIC8gKDI0ODgzMjAgKiBmb3VyTikgKyAxNjM4NzkgLyAoMjA5MDE4ODgwICogZml2ZU4pICtcbiAgICAgICAgICA1MjQ2ODE5IC8gKDc1MjQ2Nzk2ODAwICogZml2ZU4gKiBuKSk7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gMTtcbiAgICAgIHggID0gUFswXTtcblxuICAgICAgZm9yIChpID0gMTsgaSA8IFAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgeCArPSBQW2ldIC8gKG4gKyBpKTtcbiAgICAgIH1cblxuICAgICAgdCA9IG4gKyBHICsgMC41O1xuXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJKSAqIE1hdGgucG93KHQsIG4gKyAwLjUpICogTWF0aC5leHAoLXQpICogeDtcbiAgICB9XG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5oeXBvdGApXG4gICAgJXh7XG4gICAgICBNYXRoLmh5cG90ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpXG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaHlwb3QoeCwgeSlcbiAgICBNYXRoLmNoZWNrZWQgOmh5cG90LCBNYXRoLmZsb2F0ISh4KSwgTWF0aC5mbG9hdCEoeSlcbiAgZW5kXG5cbiAgZGVmIGxkZXhwKG1hbnRpc3NhLCBleHBvbmVudClcbiAgICBtYW50aXNzYSA9IE1hdGguZmxvYXQhKG1hbnRpc3NhKVxuICAgIGV4cG9uZW50ID0gTWF0aC5pbnRlZ2VyIShleHBvbmVudClcblxuICAgICV4e1xuICAgICAgaWYgKGlzTmFOKGV4cG9uZW50KSkge1xuICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsICdmbG9hdCBOYU4gb3V0IG9mIHJhbmdlIG9mIGludGVnZXInfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hbnRpc3NhICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxnYW1tYShuKVxuICAgICV4e1xuICAgICAgaWYgKG4gPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFtJbmZpbml0eSwgMV07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtNYXRoLmxvZyhNYXRoLmFicygje01hdGguZ2FtbWEobil9KSksICN7TWF0aC5nYW1tYShuKX0gPCAwID8gLTEgOiAxXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsb2coeCwgYmFzZSA9IHVuZGVmaW5lZClcbiAgICBpZiBTdHJpbmcgPT09IHhcbiAgICAgIHJhaXNlIGAkdHlwZV9lcnJvcih4LCAje0Zsb2F0fSlgXG4gICAgZW5kXG5cbiAgICBpZiBgYmFzZSA9PSBudWxsYFxuICAgICAgTWF0aC5jaGVja2VkIDpsb2csIE1hdGguZmxvYXQhKHgpXG4gICAgZWxzZVxuICAgICAgaWYgU3RyaW5nID09PSBiYXNlXG4gICAgICAgIHJhaXNlIGAkdHlwZV9lcnJvcihiYXNlLCAje0Zsb2F0fSlgXG4gICAgICBlbmRcblxuICAgICAgTWF0aC5jaGVja2VkKDpsb2csIE1hdGguZmxvYXQhKHgpKSAvIE1hdGguY2hlY2tlZCg6bG9nLCBNYXRoLmZsb2F0IShiYXNlKSlcbiAgICBlbmRcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmxvZzEwYClcbiAgICAleHtcbiAgICAgIE1hdGgubG9nMTAgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsb2cxMCh4KVxuICAgIGlmIFN0cmluZyA9PT0geFxuICAgICAgcmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7RmxvYXR9KWBcbiAgICBlbmRcblxuICAgIE1hdGguY2hlY2tlZCA6bG9nMTAsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5sb2cyYClcbiAgICAleHtcbiAgICAgIE1hdGgubG9nMiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjI7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbG9nMih4KVxuICAgIGlmIFN0cmluZyA9PT0geFxuICAgICAgcmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7RmxvYXR9KWBcbiAgICBlbmRcblxuICAgIE1hdGguY2hlY2tlZCA6bG9nMiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIHNpbih4KVxuICAgIE1hdGguY2hlY2tlZCA6c2luLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguc2luaGApXG4gICAgJXh7XG4gICAgICBNYXRoLnNpbmggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzaW5oKHgpXG4gICAgTWF0aC5jaGVja2VkIDpzaW5oLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgc3FydCh4KVxuICAgIE1hdGguY2hlY2tlZCA6c3FydCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIHRhbih4KVxuICAgIHggPSBNYXRoLmZsb2F0ISh4KVxuXG4gICAgaWYgeC5pbmZpbml0ZT9cbiAgICAgIHJldHVybiBGbG9hdDo6TkFOXG4gICAgZW5kXG5cbiAgICBNYXRoLmNoZWNrZWQgOnRhbiwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLnRhbmhgKVxuICAgICV4e1xuICAgICAgTWF0aC50YW5oID0gZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoeCA9PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHggPT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiAoTWF0aC5leHAoeCkgLSBNYXRoLmV4cCgteCkpIC8gKE1hdGguZXhwKHgpICsgTWF0aC5leHAoLXgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRhbmgoeClcbiAgICBNYXRoLmNoZWNrZWQgOnRhbmgsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsibW9kdWxlIiwibmV3IiwiY2hlY2tlZCIsInNlbGYiLCJyYWlzZSIsIm1ldGhvZCIsImZsb2F0ISIsIkZsb2F0IiwidmFsdWUiLCJpbnRlZ2VyISIsIkludGVnZXIiLCJtb2R1bGVfZnVuY3Rpb24iLCJhY29zIiwieCIsImFjb3NoIiwiYXNpbiIsImFzaW5oIiwiYXRhbiIsImF0YW4yIiwieSIsImF0YW5oIiwiY2JydCIsImNvcyIsImNvc2giLCJlcmYiLCJlcmZjIiwiZXhwIiwiZnJleHAiLCJnYW1tYSIsIm4iLCI9PT0iLCItIiwiMSIsImh5cG90IiwibGRleHAiLCJtYW50aXNzYSIsImV4cG9uZW50IiwibGdhbW1hIiwibG9nIiwiYmFzZSIsIi8iLCJsb2cxMCIsImxvZzIiLCJzaW4iLCJzaW5oIiwic3FydCIsInRhbiIs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiRSxJQUFBLENBN2JBO0FBQUEsSUE2Y0EsT0FBQUUsQ0FBQUEsd0JBQUFBLGdCQUFBQSxnQkFBUyxDQUFUQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLG9CQUFBOUMsU0FBQUEsQ0FBYSxRQUFPLG9CQUFBSSxXQUFBQSxDQUFZTyxDQUFaUCxDQUFwQko7QUFERjhDLElBQUFBLENBQUFBLDJCQUFBQSxDQUFBQSxnQkE3Y0E7QUFERmhELEVBQUFBLEdBQUFBLFdBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjA5NTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbXBsZXgucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyBDb21wbGV4IDwgTnVtZXJpY1xuICBkZWYgc2VsZi5yZWN0KHJlYWwsIGltYWcgPSAwKVxuICAgIHVubGVzcyBOdW1lcmljID09PSByZWFsICYmIHJlYWwucmVhbD8gJiYgTnVtZXJpYyA9PT0gaW1hZyAmJiBpbWFnLnJlYWw/XG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYSByZWFsJ1xuICAgIGVuZFxuXG4gICAgbmV3KHJlYWwsIGltYWcpXG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnBvbGFyKHIsIHRoZXRhID0gMClcbiAgICB1bmxlc3MgTnVtZXJpYyA9PT0gciAmJiByLnJlYWw/ICYmIE51bWVyaWMgPT09IHRoZXRhICYmIHRoZXRhLnJlYWw/XG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYSByZWFsJ1xuICAgIGVuZFxuXG4gICAgbmV3KHIgKiBNYXRoLmNvcyh0aGV0YSksIHIgKiBNYXRoLnNpbih0aGV0YSkpXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpyZWFsLCA6aW1hZ1xuXG4gIGRlZiBpbml0aWFsaXplKHJlYWwsIGltYWcgPSAwKVxuICAgIEByZWFsID0gcmVhbFxuICAgIEBpbWFnID0gaW1hZ1xuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBbb3RoZXIsIHNlbGZdXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIFtDb21wbGV4Lm5ldyhvdGhlciwgMCksIHNlbGZdXG4gICAgZWxzZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBDb21wbGV4XCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBAcmVhbCA9PSBvdGhlci5yZWFsICYmIEBpbWFnID09IG90aGVyLmltYWdcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQHJlYWwgPT0gb3RoZXIgJiYgQGltYWcgPT0gMFxuICAgIGVsc2VcbiAgICAgIG90aGVyID09IHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgQ29tcGxleCgtQHJlYWwsIC1AaW1hZylcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgaWYgQ29tcGxleCA9PT0gb3RoZXJcbiAgICAgIENvbXBsZXgoQHJlYWwgKyBvdGhlci5yZWFsLCBAaW1hZyArIG90aGVyLmltYWcpXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIENvbXBsZXgoQHJlYWwgKyBvdGhlciwgQGltYWcpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOissIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBDb21wbGV4KEByZWFsIC0gb3RoZXIucmVhbCwgQGltYWcgLSBvdGhlci5pbWFnKVxuICAgIGVsc2lmIE51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBDb21wbGV4KEByZWFsIC0gb3RoZXIsIEBpbWFnKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDotLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgQ29tcGxleChAcmVhbCAqIG90aGVyLnJlYWwgLSBAaW1hZyAqIG90aGVyLmltYWcsXG4gICAgICAgIEByZWFsICogb3RoZXIuaW1hZyArIEBpbWFnICogb3RoZXIucmVhbCxcbiAgICAgIClcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQ29tcGxleChAcmVhbCAqIG90aGVyLCBAaW1hZyAqIG90aGVyKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLyhvdGhlcilcbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgaWYgKE51bWJlciA9PT0gQHJlYWwgJiYgQHJlYWwubmFuPykgfHwgKE51bWJlciA9PT0gQGltYWcgJiYgQGltYWcubmFuPykgfHxcbiAgICAgICAgIChOdW1iZXIgPT09IG90aGVyLnJlYWwgJiYgb3RoZXIucmVhbC5uYW4/KSB8fCAoTnVtYmVyID09PSBvdGhlci5pbWFnICYmIG90aGVyLmltYWcubmFuPylcbiAgICAgICAgQ29tcGxleC5uZXcoRmxvYXQ6Ok5BTiwgRmxvYXQ6Ok5BTilcbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZiAqIG90aGVyLmNvbmogLyBvdGhlci5hYnMyXG4gICAgICBlbmRcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQ29tcGxleChAcmVhbC5xdW8ob3RoZXIpLCBAaW1hZy5xdW8ob3RoZXIpKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDovLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgaWYgb3RoZXIgPT0gMFxuICAgICAgcmV0dXJuIENvbXBsZXgubmV3KDEsIDApXG4gICAgZW5kXG5cbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgciwgdGhldGEgPSBwb2xhclxuICAgICAgb3JlICAgICAgPSBvdGhlci5yZWFsXG4gICAgICBvaW0gICAgICA9IG90aGVyLmltYWdcbiAgICAgIG5yICAgICAgID0gTWF0aC5leHAob3JlICogTWF0aC5sb2cocikgLSBvaW0gKiB0aGV0YSlcbiAgICAgIG50aGV0YSAgID0gdGhldGEgKiBvcmUgKyBvaW0gKiBNYXRoLmxvZyhyKVxuXG4gICAgICBDb21wbGV4LnBvbGFyKG5yLCBudGhldGEpXG4gICAgZWxzaWYgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIGlmIG90aGVyID4gMFxuICAgICAgICB4ID0gc2VsZlxuICAgICAgICB6ID0geFxuICAgICAgICBuID0gb3RoZXIgLSAxXG5cbiAgICAgICAgd2hpbGUgbiAhPSAwXG4gICAgICAgICAgZGl2LCBtb2QgPSBuLmRpdm1vZCgyKVxuICAgICAgICAgIHdoaWxlIG1vZCA9PSAwXG4gICAgICAgICAgICB4ID0gQ29tcGxleCh4LnJlYWwgKiB4LnJlYWwgLSB4LmltYWcgKiB4LmltYWcsIDIgKiB4LnJlYWwgKiB4LmltYWcpXG4gICAgICAgICAgICBuID0gZGl2XG4gICAgICAgICAgICBkaXYsIG1vZCA9IG4uZGl2bW9kKDIpXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgICB6ICo9IHhcbiAgICAgICAgICBuIC09IDFcbiAgICAgICAgZW5kXG5cbiAgICAgICAgelxuICAgICAgZWxzZVxuICAgICAgICAoUmF0aW9uYWwubmV3KDEsIDEpIC8gc2VsZikqKi1vdGhlclxuICAgICAgZW5kXG4gICAgZWxzaWYgRmxvYXQgPT09IG90aGVyIHx8IFJhdGlvbmFsID09PSBvdGhlclxuICAgICAgciwgdGhldGEgPSBwb2xhclxuXG4gICAgICBDb21wbGV4LnBvbGFyKHIqKm90aGVyLCB0aGV0YSAqIG90aGVyKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIE1hdGguaHlwb3QoQHJlYWwsIEBpbWFnKVxuICBlbmRcblxuICBkZWYgYWJzMlxuICAgIEByZWFsICogQHJlYWwgKyBAaW1hZyAqIEBpbWFnXG4gIGVuZFxuXG4gIGRlZiBhbmdsZVxuICAgIE1hdGguYXRhbjIoQGltYWcsIEByZWFsKVxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcblxuICBkZWYgY29ualxuICAgIENvbXBsZXgoQHJlYWwsIC1AaW1hZylcbiAgZW5kXG5cbiAgYWxpYXMgY29uanVnYXRlIGNvbmpcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBAcmVhbC5kZW5vbWluYXRvci5sY20oQGltYWcuZGVub21pbmF0b3IpXG4gIGVuZFxuXG4gIGFsaWFzIGRpdmlkZSAvXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgQ29tcGxleCA9PT0gb3RoZXIgJiYgQHJlYWwuY2xhc3MgPT0gQGltYWcuY2xhc3MgJiYgc2VsZiA9PSBvdGhlclxuICBlbmRcblxuICBkZWYgZmRpdihvdGhlcilcbiAgICB1bmxlc3MgTnVtZXJpYyA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gQ29tcGxleFwiXG4gICAgZW5kXG5cbiAgICBzZWxmIC8gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGZpbml0ZT9cbiAgICBAcmVhbC5maW5pdGU/ICYmIEBpbWFnLmZpbml0ZT9cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBcIkNvbXBsZXg6I3tAcmVhbH06I3tAaW1hZ31cIlxuICBlbmRcblxuICBhbGlhcyBpbWFnaW5hcnkgaW1hZ1xuXG4gIGRlZiBpbmZpbml0ZT9cbiAgICBAcmVhbC5pbmZpbml0ZT8gfHwgQGltYWcuaW5maW5pdGU/XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIoI3tzZWxmfSlcIlxuICBlbmRcblxuICBhbGlhcyBtYWduaXR1ZGUgYWJzXG5cbiAgdW5kZWYgbmVnYXRpdmU/XG5cbiAgZGVmIG51bWVyYXRvclxuICAgIGQgPSBkZW5vbWluYXRvclxuXG4gICAgQ29tcGxleChAcmVhbC5udW1lcmF0b3IgKiAoZCAvIEByZWFsLmRlbm9taW5hdG9yKSxcbiAgICAgIEBpbWFnLm51bWVyYXRvciAqIChkIC8gQGltYWcuZGVub21pbmF0b3IpLFxuICAgIClcbiAgZW5kXG5cbiAgYWxpYXMgcGhhc2UgYXJnXG5cbiAgZGVmIHBvbGFyXG4gICAgW2FicywgYXJnXVxuICBlbmRcblxuICB1bmRlZiBwb3NpdGl2ZT9cblxuICBhbGlhcyBxdW8gL1xuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMSlcIn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgQGltYWcgIT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCcgY29udmVydCAje3NlbGZ9IGludG8gUmF0aW9uYWxcIlxuICAgIGVuZFxuXG4gICAgcmVhbC5yYXRpb25hbGl6ZShlcHMpXG4gIGVuZFxuXG4gIGRlZiByZWFsP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiByZWN0XG4gICAgW0ByZWFsLCBAaW1hZ11cbiAgZW5kXG5cbiAgYWxpYXMgcmVjdGFuZ3VsYXIgcmVjdFxuXG4gIHVuZGVmIHN0ZXBcblxuICBkZWYgdG9fZlxuICAgIHVubGVzcyBAaW1hZyA9PSAwXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWxmfSBpbnRvIEZsb2F0XCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX2ZcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBJbnRlZ2VyXCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX2lcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBSYXRpb25hbFwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19yXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgcmVzdWx0ID0gQHJlYWwuaW5zcGVjdFxuXG4gICAgcmVzdWx0ICs9XG4gICAgICBpZiAoTnVtYmVyID09PSBAaW1hZyAmJiBAaW1hZy5uYW4/KSB8fCBAaW1hZy5wb3NpdGl2ZT8gfHwgQGltYWcuemVybz9cbiAgICAgICAgJysnXG4gICAgICBlbHNlXG4gICAgICAgICctJ1xuICAgICAgZW5kXG5cbiAgICByZXN1bHQgKz0gQGltYWcuYWJzLmluc3BlY3RcblxuICAgIGlmIE51bWJlciA9PT0gQGltYWcgJiYgKEBpbWFnLm5hbj8gfHwgQGltYWcuaW5maW5pdGU/KVxuICAgICAgcmVzdWx0ICs9ICcqJ1xuICAgIGVuZFxuXG4gICAgcmVzdWx0ICsgJ2knXG4gIGVuZFxuXG4gIEkgPSBuZXcoMCwgMSlcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBDb21wbGV4KHJlYWwsIGltYWcgPSBuaWwpXG4gICAgaWYgaW1hZ1xuICAgICAgQ29tcGxleC5uZXcocmVhbCwgaW1hZylcbiAgICBlbHNlXG4gICAgICBDb21wbGV4Lm5ldyhyZWFsLCAwKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgZGVmIHRvX2NcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzZWxmLFxuICAgICAgICAgIHJlID0gL1srLV0/W1xcZF9dKyhcXC5bXFxkX10rKT8oZVxcZCspPy8sXG4gICAgICAgICAgbWF0Y2ggPSBzdHIubWF0Y2gocmUpLFxuICAgICAgICAgIHJlYWwsIGltYWcsIGRlbm9taW5hdG9yO1xuXG4gICAgICBmdW5jdGlvbiBpc0Zsb2F0KCkge1xuICAgICAgICByZXR1cm4gcmUudGVzdChzdHIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXRGbG9hdCgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlKTtcbiAgICAgICAgdmFyIG51bWJlciA9IG1hdGNoWzBdO1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UobnVtYmVyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBudW1iZXIucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZXMgYm90aCBmbG9hdHMgYW5kIHJhdGlvbmFsc1xuICAgICAgZnVuY3Rpb24gY3V0TnVtYmVyKCkge1xuICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgdmFyIG51bWVyYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG5cbiAgICAgICAgICBpZiAoc3RyWzBdID09PSAnLycpIHtcbiAgICAgICAgICAgIC8vIHJhdGlvbmFsIHJlYWwgcGFydFxuICAgICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG4gICAgICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG4gICAgICAgICAgICAgIHJldHVybiAje1JhdGlvbmFsKGBudW1lcmF0b3JgLCBgZGVub21pbmF0b3JgKX07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZXZlcnRpbmcgJy8nXG4gICAgICAgICAgICAgIHN0ciA9ICcvJyArIHN0cjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bWVyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmxvYXQgcmVhbCBwYXJ0LCBubyBkZW5vbWluYXRvclxuICAgICAgICAgICAgcmV0dXJuIG51bWVyYXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVhbCA9IGN1dE51bWJlcigpO1xuXG4gICAgICBpZiAoIXJlYWwpIHtcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gaSA9PiBDb21wbGV4KDAsIDEpXG4gICAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCAxKX07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJy0nICYmIHN0clsxXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gLWkgPT4gQ29tcGxleCgwLCAtMSlcbiAgICAgICAgICByZXR1cm4gI3tDb21wbGV4KDAsIC0xKX07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJysnICYmIHN0clsxXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gK2kgPT4gQ29tcGxleCgwLCAxKVxuICAgICAgICAgIHJldHVybiAje0NvbXBsZXgoMCwgMSl9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFueXRoaW5nID0+IENvbXBsZXgoMCwgMClcbiAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCAwKX07XG4gICAgICB9XG5cbiAgICAgIGltYWcgPSBjdXROdW1iZXIoKTtcbiAgICAgIGlmICghaW1hZykge1xuICAgICAgICBpZiAoc3RyWzBdID09PSAnaScpIHtcbiAgICAgICAgICAvLyAzaSA9PiBDb21wbGV4KDAsIDMpXG4gICAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCBgcmVhbGApfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAzID0+IENvbXBsZXgoMywgMClcbiAgICAgICAgICByZXR1cm4gI3tDb21wbGV4KGByZWFsYCwgMCl9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAzKzJpID0+IENvbXBsZXgoMywgMilcbiAgICAgICAgcmV0dXJuICN7Q29tcGxleChgcmVhbGAsIGBpbWFnYCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJyZWN0Iiwic2VsZiIsIjAiLCIkcmV0X29yXzEiLCIkcmV0X29yXzIiLCIkcmV0X29yXzMiLCI9PT0iLCJyZWFsIiwicmVhbD8iLCJpbWFnIiwicmFpc2UiLCJuZXciLCJwb2xhciIsIiRyZXRfb3JfNCIsIiRyZXRfb3JfNSIsIiRyZXRfb3JfNiIsInIiLCJ0aGV0YSIsIioiLCJjb3MiLCJzaW4iLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJAcmVhbCIsIkBpbWFnIiwiY29lcmNlIiwib3RoZXIiLCIkcmV0X29yXzciLCI9PSIsIiRyZXRfb3JfOCIsIiRyZXRfb3JfOSIsIiRyZXRfb3JfMTAiLCItQCIsIkNvbXBsZXgiLCIrIiwiJHJldF9vcl8xMSIsIl9fY29lcmNlZF9fIiwiLSIsIiRyZXRfb3JfMTIiLCIkcmV0X29yXzEzIiwiLyIsIiRyZXRfb3JfMTQiLCIkcmV0X29yXzE1IiwiJHJldF9vcl8xNiIsIiRyZXRfb3JfMTciLCJuYW4/IiwiJHJldF9vcl8xOCIsIiRyZXRfb3JfMTkiLCIkcmV0X29yXzIwIiwiY29uaiIsImFiczIiLCIkcmV0X29yXzIxIiwicXVvIiwiKioiLCIxIiwib3JlIiwib2ltIiwibnIiLCJleHAiLCJsb2ciLCJudGhldGEiLCI+IiwieCIsInoiLCJuIiwiIT0iLCJkaXZtb2QiLCIyIiwiZGl2IiwibW9kIiwiJHJldF9vcl8yMiIsImFicyIsImh5cG90IiwiYW5nbGUiLCJhdGFuMiIsImRlbm9taW5hdG9yIiwibGNtIiwiZXFsPyIsIiRyZXRfb3JfMjMiLCIkcmV0X29yXzI0IiwiZmRpdiIsImZpbml0ZT8iLCIkcmV0X29yXzI1IiwiaGFzaCIsImluZmluaXRlPyIsIiRyZXRfb3JfMjYiLCJpbnNwZWN0IiwibnVtZXJhdG9yIiwiZCIsImFyZyIsInJhdGlvbmFsaXplIiwiZXBzIiwidG9fZiIsInRvX2kiLCJ0b19yIiwidG9fcyIsInJlc3VsdCIsIiRyZXRfb3JfMjciLCIkcmV0X29yXzI4IiwiJHJldF9vcl8yOSIsInBvc2l0aXZlPyIsInplcm8/IiwiJHJldF9vcl8zMCIsIiRyZXRfb3JfMzEiLCJtb2R1bGUiLCJ0b19jIiwiUmF0aW9uYWwiLCItMSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxpQkFBUkEsQ0FBQTtBQUFBLEVBRUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFBQUE7QUFDRSxJQUFBQyxVQUFJQyxJQUFKRCxXQUFBQSxrQkFBQUEsZ0JBQWMsSUFBRCxFQUFPLElBQXBCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFKRjtBQUlzQixNQUFBO0FBQUEsTUFBQSxTQUFPRSxDQUFQO0FBQUEsTUFBQSxDQUp0QjtBQUFBLE1BS0ksSUFBQSxRQUFPLGFBQUEsSUFBQSxRQUxYQyxDQUFBQSxZQUtXLGFBQUEsSUFBQSxRQUxYQyxDQUFBQSxZQUtXLGFBQUEsSUFBQSxRQUxYQyxDQUFBQSxZQUtXLHVCQUFBQyxRQUFBQSxDQUFZQyxJQUFaRCxDQUxYRCxDQUtXLENBQUE7QUFBQSxRQUFvQixPQUFBRSxJQUFBQyxVQUFBQSxDQUFBQTtBQUFwQixNQUFBO0FBQUEsUUFMWCxPQUFBO0FBS1csTUFBQSxDQUFBLGtCQUxYSixDQUtXLENBQUE7QUFBQSxRQUFrQyxPQUFBLHVCQUFBRSxRQUFBQSxDQUFZRyxJQUFaSDtBQUFsQyxNQUFBO0FBQUEsUUFMWCxPQUFBO0FBS1csTUFBQSxDQUFBLGtCQUxYSCxDQUtXLENBQUE7QUFBQSxRQUFzRCxPQUFBTSxJQUFBRCxVQUFBQSxDQUFBQTtBQUF0RCxNQUFBO0FBQUEsUUFMWCxPQUFBO0FBS1csTUFBQSxDQUFBLGtCQUFQLENBQUE7QUFBQSxNQUFBO0FBQUEsWUFDRUUsT0FBQUEsQ0FBTSwyQkFBVyxZQUFqQkE7QUFERixNQUFBLENBTEo7QUFBQSxNQVNJLFdBQUFDLEtBQUFBLENBQUlKLE1BQU1FLElBQVZFLENBVEo7QUFJRVgsSUFBQUEsQ0FBQUEsOEJBQUFBLENBQUE7QUFBQSxJQVFBO0FBQUEsTUFBQTs7QUFBQSxNQUNFLE9BQUEsaUJBQU0sYUFBTixFQUFrQixNQUFsQjtBQURGLElBQUEsNEJBQVNDLElBQVQsWUFSQTtBQUFBLElBWUFXLFVBQUlYLElBQUpXLFlBQUFBLG1CQUFBQSxpQkFBZSxDQUFELEVBQUksS0FBbEJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQWhCRjtBQWdCb0IsTUFBQTtBQUFBLE1BQUEsVUFBUVYsQ0FBUjtBQUFBLE1BQUEsQ0FoQnBCO0FBQUEsTUFpQkksSUFBQSxRQUFPLGFBQUEsSUFBQSxRQWpCWFcsQ0FBQUEsWUFpQlcsYUFBQSxJQUFBLFFBakJYQyxDQUFBQSxZQWlCVyxhQUFBLElBQUEsUUFqQlhDLENBQUFBLFlBaUJXLHVCQUFBVCxRQUFBQSxDQUFZVSxDQUFaVixDQWpCWFMsQ0FpQlcsQ0FBQTtBQUFBLFFBQWlCLE9BQUFDLENBQUFSLFVBQUFBLENBQUFBO0FBQWpCLE1BQUE7QUFBQSxRQWpCWCxPQUFBO0FBaUJXLE1BQUEsQ0FBQSxrQkFqQlhNLENBaUJXLENBQUE7QUFBQSxRQUE0QixPQUFBLHVCQUFBUixRQUFBQSxDQUFZVyxLQUFaWDtBQUE1QixNQUFBO0FBQUEsUUFqQlgsT0FBQTtBQWlCVyxNQUFBLENBQUEsa0JBakJYTyxDQWlCVyxDQUFBO0FBQUEsUUFBaUQsT0FBQUksS0FBQVQsVUFBQUEsQ0FBQUE7QUFBakQsTUFBQTtBQUFBLFFBakJYLE9BQUE7QUFpQlcsTUFBQSxDQUFBLGtCQUFQLENBQUE7QUFBQSxNQUFBO0FBQUEsWUFDRUUsT0FBQUEsQ0FBTSwyQkFBVyxZQUFqQkE7QUFERixNQUFBLENBakJKO0FBQUEsTUFxQkksV0FBQUMsS0FBQUEsQ0FBSU8sVUFBQUYsQ0FBQUUsRUFBSSxvQkFBQUMsS0FBQUEsQ0FBU0YsS0FBVEUsQ0FBSkQsR0FBcUJBLFVBQUFGLENBQUFFLEVBQUksb0JBQUFFLEtBQUFBLENBQVNILEtBQVRHLENBQUpGLENBQXpCUCxDQXJCSjtBQWdCRUMsSUFBQUEsQ0FBQUEsK0JBQUFBLENBWkE7QUFBQSxRQW9CQVMsYUFBQUEsQ0FBWSxRQUFPLE1BQW5CQSxDQXBCQTtBQUFBO0FBc0JBQyxJQUFBQSw4QkFBQUEsd0JBQUFBLHNCQUFlLElBQUQsRUFBTyxJQUFyQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBMUJGO0FBMEJ1QixNQUFBO0FBQUEsTUFBQSxTQUFPcEIsQ0FBUDtBQUFBLE1BQUEsQ0ExQnZCO0FBQUEsTUEyQklxQixZQUFRaEIsSUEzQlo7QUFBQSxNQTRCSSxPQUFBaUIsQ0FBQUEsWUFBUWYsSUFBUmUsQ0E1Qko7QUEwQkVGLElBQUFBLENBQUFBLG9DQUFBQSxDQXRCQTtBQUFBO0FBMkJBRyxJQUFBQSwwQkFBQUEsb0JBQUFBLGtCQUFXLEtBQVhBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLElBQUEsUUFBRyx1QkFBQW5CLFFBQUFBLENBQVlvQixLQUFacEIsQ0FBSCxDQUFBO0FBQUEsUUFDRSxPQUFBLENBQUNvQixLQUFELEVBQVF6QixJQUFSO0FBREYsTUFBQSxPQUVBLElBQUEsUUFBTSxhQUFBLElBQUEsUUFsQ1YwQixDQUFBQSxZQWtDVSx1QkFBQXJCLFFBQUFBLENBQVlvQixLQUFacEIsQ0FsQ1ZxQixDQWtDVSxDQUFBO0FBQUEsUUFBcUIsT0FBQUQsS0FBQWxCLFVBQUFBLENBQUFBO0FBQXJCLE1BQUE7QUFBQSxRQWxDVixPQUFBO0FBa0NVLE1BQUEsQ0FBQSxrQkFBTixDQUFBO0FBQUEsUUFDRSxPQUFBLENBQUMsdUJBQUFHLEtBQUFBLENBQVllLE9BQU94QixDQUFuQlMsQ0FBRCxFQUF3QlYsSUFBeEI7QUFERixNQUFBO0FBQUEsUUFHRSxXQUFBUyxPQUFBQSxDQUFNLDJCQUFXLEVBQUEsR0FBQSxDQUFHZ0IsS0FBQTNCLE9BQUFBLENBQUFBLENBQUgsQ0FBQSxHQUFBLGdDQUFqQlc7QUFIRixNQUFBO0FBSEZlLElBQUFBLENBQUFBLCtCQUFBQSxDQTNCQTtBQUFBO0FBcUNBRyxJQUFBQSxzQkFBQUEsb0JBQUFBLFNBQU8sS0FBUEE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsSUFBQSxRQUFHLHVCQUFBdEIsUUFBQUEsQ0FBWW9CLEtBQVpwQixDQUFILENBQUE7QUFBQSxRQUNFLElBQUEsUUEzQ051QixDQUFBQSxZQTJDTU4sU0FBQUssT0FBQUEsQ0FBU0YsS0FBQW5CLE1BQUFBLENBQUFBLENBQVRxQixDQTNDTkMsQ0EyQ00sQ0FBQTtBQUFBLFVBQXVCLE9BQUFMLFNBQUFJLE9BQUFBLENBQVNGLEtBQUFqQixNQUFBQSxDQUFBQSxDQUFUbUI7QUFBdkIsUUFBQTtBQUFBLFVBM0NOLE9BQUE7QUEyQ00sUUFBQTtBQURGLE1BQUEsT0FFQSxJQUFBLFFBQU0sYUFBQSxJQUFBLFFBNUNWRSxDQUFBQSxZQTRDVSx1QkFBQXhCLFFBQUFBLENBQVlvQixLQUFacEIsQ0E1Q1Z3QixDQTRDVSxDQUFBO0FBQUEsUUFBcUIsT0FBQUosS0FBQWxCLFVBQUFBLENBQUFBO0FBQXJCLE1BQUE7QUFBQSxRQTVDVixPQUFBO0FBNENVLE1BQUEsQ0FBQSxrQkFBTixDQUFBO0FBQUEsUUFDRSxJQUFBLFFBN0NOdUIsQ0FBQUEsYUE2Q01SLFNBQUFLLE9BQUFBLENBQVNGLEtBQVRFLENBN0NORyxDQTZDTSxDQUFBO0FBQUEsVUFBa0IsT0FBQVAsU0FBQUksT0FBQUEsQ0FBUzFCLENBQVQwQjtBQUFsQixRQUFBO0FBQUEsVUE3Q04sT0FBQTtBQTZDTSxRQUFBO0FBREYsTUFBQTtBQUFBLFFBR0UsT0FBQUYsS0FBQUUsT0FBQUEsQ0FBUzNCLElBQVQyQjtBQUhGLE1BQUE7QUFIRkEsSUFBQUEsQ0FBQUEsK0JBQUFBLENBckNBO0FBQUE7QUErQ0FJLElBQUFBLHNCQUFBQSxxQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsV0FBQUMsU0FBQUEsQ0FBU1YsU0FBRFMsT0FBQUEsQ0FBQUEsR0FBU1IsU0FBRFEsT0FBQUEsQ0FBQUEsQ0FBaEJDO0FBREZELElBQUFBLENBQUFBLGdDQUFBQSxDQS9DQTtBQUFBO0FBbURBRSxJQUFBQSxxQkFBQUEsbUJBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsSUFBQSxRQUFHLHVCQUFBNUIsUUFBQUEsQ0FBWW9CLEtBQVpwQixDQUFILENBQUE7QUFBQSxRQUNFLFdBQUEyQixTQUFBQSxDQUFRQyxTQUFBWCxTQUFBVyxFQUFRUixLQUFBbkIsTUFBQUEsQ0FBQUEsQ0FBUjJCLEdBQW9CQSxTQUFBVixTQUFBVSxFQUFRUixLQUFBakIsTUFBQUEsQ0FBQUEsQ0FBUnlCLENBQTVCRDtBQURGLE1BQUEsT0FFQSxJQUFBLFFBQU0sYUFBQSxJQUFBLFFBMURWRSxDQUFBQSxhQTBEVSx1QkFBQTdCLFFBQUFBLENBQVlvQixLQUFacEIsQ0ExRFY2QixDQTBEVSxDQUFBO0FBQUEsUUFBcUIsT0FBQVQsS0FBQWxCLFVBQUFBLENBQUFBO0FBQXJCLE1BQUE7QUFBQSxRQTFEVixPQUFBO0FBMERVLE1BQUEsQ0FBQSxrQkFBTixDQUFBO0FBQUEsUUFDRSxXQUFBeUIsU0FBQUEsQ0FBUUMsU0FBQVgsU0FBQVcsRUFBUVIsS0FBUlEsR0FBZVYsU0FBdkJTO0FBREYsTUFBQTtBQUFBLFFBR0UsV0FBQUcsYUFBQUEsQ0FBWSxLQUFJVixLQUFoQlU7QUFIRixNQUFBO0FBSEZGLElBQUFBLENBQUFBLDhCQUFBQSxDQW5EQTtBQUFBO0FBNkRBRyxJQUFBQSxxQkFBQUEsb0JBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsSUFBQSxRQUFHLHVCQUFBL0IsUUFBQUEsQ0FBWW9CLEtBQVpwQixDQUFILENBQUE7QUFBQSxRQUNFLFdBQUEyQixTQUFBQSxDQUFRSSxVQUFBZCxTQUFBYyxFQUFRWCxLQUFBbkIsTUFBQUEsQ0FBQUEsQ0FBUjhCLEdBQW9CQSxVQUFBYixTQUFBYSxFQUFRWCxLQUFBakIsTUFBQUEsQ0FBQUEsQ0FBUjRCLENBQTVCSjtBQURGLE1BQUEsT0FFQSxJQUFBLFFBQU0sYUFBQSxJQUFBLFFBcEVWSyxDQUFBQSxhQW9FVSx1QkFBQWhDLFFBQUFBLENBQVlvQixLQUFacEIsQ0FwRVZnQyxDQW9FVSxDQUFBO0FBQUEsUUFBcUIsT0FBQVosS0FBQWxCLFVBQUFBLENBQUFBO0FBQXJCLE1BQUE7QUFBQSxRQXBFVixPQUFBO0FBb0VVLE1BQUEsQ0FBQSxrQkFBTixDQUFBO0FBQUEsUUFDRSxXQUFBeUIsU0FBQUEsQ0FBUUksVUFBQWQsU0FBQWMsRUFBUVgsS0FBUlcsR0FBZWIsU0FBdkJTO0FBREYsTUFBQTtBQUFBLFFBR0UsV0FBQUcsYUFBQUEsQ0FBWSxLQUFJVixLQUFoQlU7QUFIRixNQUFBO0FBSEZDLElBQUFBLENBQUFBLCtCQUFBQSxDQTdEQTtBQUFBO0FBdUVBbkIsSUFBQUEscUJBQUFBLGVBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsSUFBQSxRQUFHLHVCQUFBWixRQUFBQSxDQUFZb0IsS0FBWnBCLENBQUgsQ0FBQTtBQUFBLFFBQ0UsV0FBQTJCLFNBQUFBLENBQVFJLFVBQUFuQixVQUFBSyxTQUFBTCxFQUFRUSxLQUFBbkIsTUFBQUEsQ0FBQUEsQ0FBUlcsQ0FBQW1CLEVBQXFCbkIsVUFBQU0sU0FBQU4sRUFBUVEsS0FBQWpCLE1BQUFBLENBQUFBLENBQVJTLENBQXJCbUIsR0FDTkgsU0FBQWhCLFVBQUFLLFNBQUFMLEVBQVFRLEtBQUFqQixNQUFBQSxDQUFBQSxDQUFSUyxDQUFBZ0IsRUFBcUJoQixVQUFBTSxTQUFBTixFQUFRUSxLQUFBbkIsTUFBQUEsQ0FBQUEsQ0FBUlcsQ0FBckJnQixDQURGRDtBQURGLE1BQUEsT0FJQSxJQUFBLFFBQU0sYUFBQSxJQUFBLFFBaEZWTSxDQUFBQSxhQWdGVSx1QkFBQWpDLFFBQUFBLENBQVlvQixLQUFacEIsQ0FoRlZpQyxDQWdGVSxDQUFBO0FBQUEsUUFBcUIsT0FBQWIsS0FBQWxCLFVBQUFBLENBQUFBO0FBQXJCLE1BQUE7QUFBQSxRQWhGVixPQUFBO0FBZ0ZVLE1BQUEsQ0FBQSxrQkFBTixDQUFBO0FBQUEsUUFDRSxXQUFBeUIsU0FBQUEsQ0FBUWYsVUFBQUssU0FBQUwsRUFBUVEsS0FBUlIsR0FBZUEsVUFBQU0sU0FBQU4sRUFBUVEsS0FBUlIsQ0FBdkJlO0FBREYsTUFBQTtBQUFBLFFBR0UsV0FBQUcsYUFBQUEsQ0FBWSxLQUFJVixLQUFoQlU7QUFIRixNQUFBO0FBTEZsQixJQUFBQSxDQUFBQSwwQkFBQUEsQ0F2RUE7QUFBQTtBQW1GQXNCLElBQUFBLHFCQUFBQSxxQkFBQUEsU0FBTSxLQUFOQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxJQUFBLFFBQUcsdUJBQUFsQyxRQUFBQSxDQUFZb0IsS0FBWnBCLENBQUgsQ0FBQTtBQUFBLFFBQ0UsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQXpGVG1DLENBQUFBLGFBeUZTLGFBQUEsSUFBQSxRQXpGVEMsQ0FBQUEsYUF5RlMsYUFBQSxJQUFBLFFBekZUQyxDQUFBQSxhQXlGVSxhQUFBLElBQUEsUUF6RlZDLENBQUFBLGFBeUZVLHNCQUFBdEMsUUFBQUEsQ0FBV2lCLFNBQVhqQixDQXpGVnNDLENBeUZVLENBQUE7QUFBQSxVQUFvQixPQUFBckIsU0FBQXNCLFNBQUFBLENBQUFBO0FBQXBCLFFBQUE7QUFBQSxVQXpGVixPQUFBO0FBeUZVLFFBQUEsQ0FBQSxrQkF6RlZGLENBeUZTLENBQUE7QUFBQSxVQXpGVCxPQUFBO0FBeUZTLFFBQUE7QUFBQTtBQUFvQyxVQUFDLElBQUEsUUF6RjlDRyxDQUFBQSxhQXlGOEMsc0JBQUF4QyxRQUFBQSxDQUFXa0IsU0FBWGxCLENBekY5Q3dDLENBeUY4QyxDQUFBO0FBQUEsWUFBb0IsT0FBQXRCLFNBQUFxQixTQUFBQSxDQUFBQTtBQUFwQixVQUFBO0FBQUEsWUF6RjlDLE9BQUE7QUF5RjhDLFVBQUEsQ0FBRDtBQUFwQyxRQUFBLENBQUEsa0JBekZUSCxDQXlGUyxDQUFBO0FBQUEsVUF6RlQsT0FBQTtBQXlGUyxRQUFBO0FBQUE7QUFDQSxVQUFDLElBQUEsUUExRlZLLENBQUFBLGFBMEZVLHNCQUFBekMsUUFBQUEsQ0FBV29CLEtBQUFuQixNQUFBQSxDQUFBQSxDQUFYRCxDQTFGVnlDLENBMEZVLENBQUE7QUFBQSxZQUF5QixPQUFBckIsS0FBQW5CLE1BQUFBLENBQUFBLENBQUFzQyxTQUFBQSxDQUFBQTtBQUF6QixVQUFBO0FBQUEsWUExRlYsT0FBQTtBQTBGVSxVQUFBLENBQUQ7QUFEQSxRQUFBLENBQUEsa0JBekZUSixDQXlGUyxDQUFBO0FBQUEsVUF6RlQsT0FBQTtBQXlGUyxRQUFBO0FBQUE7QUFDOEMsVUFBQyxJQUFBLFFBMUZ4RE8sQ0FBQUEsYUEwRndELHNCQUFBMUMsUUFBQUEsQ0FBV29CLEtBQUFqQixNQUFBQSxDQUFBQSxDQUFYSCxDQTFGeEQwQyxDQTBGd0QsQ0FBQTtBQUFBLFlBQXlCLE9BQUF0QixLQUFBakIsTUFBQUEsQ0FBQUEsQ0FBQW9DLFNBQUFBLENBQUFBO0FBQXpCLFVBQUE7QUFBQSxZQTFGeEQsT0FBQTtBQTBGd0QsVUFBQSxDQUFEO0FBRDlDLFFBQUEsQ0FBQSxrQkFBSCxDQUFBO0FBQUEsVUFFRSxPQUFBLHVCQUFBbEMsS0FBQUEsQ0FBWSxJQUFBLHFCQUFBLFVBQVksSUFBQSxxQkFBQSxRQUF4QkE7QUFGRixRQUFBO0FBQUEsVUFJRSxPQUFBNkIsV0FBQXRCLFVBQUFqQixJQUFBaUIsRUFBT1EsS0FBQXVCLE1BQUFBLENBQUFBLENBQVAvQixDQUFBc0IsRUFBb0JkLEtBQUF3QixNQUFBQSxDQUFBQSxDQUFwQlY7QUFKRixRQUFBO0FBREYsTUFBQSxPQU9BLElBQUEsUUFBTSxhQUFBLElBQUEsUUEvRlZXLENBQUFBLGFBK0ZVLHVCQUFBN0MsUUFBQUEsQ0FBWW9CLEtBQVpwQixDQS9GVjZDLENBK0ZVLENBQUE7QUFBQSxRQUFxQixPQUFBekIsS0FBQWxCLFVBQUFBLENBQUFBO0FBQXJCLE1BQUE7QUFBQSxRQS9GVixPQUFBO0FBK0ZVLE1BQUEsQ0FBQSxrQkFBTixDQUFBO0FBQUEsUUFDRSxXQUFBeUIsU0FBQUEsQ0FBUVYsU0FBQTZCLEtBQUFBLENBQVUxQixLQUFWMEIsR0FBa0I1QixTQUFBNEIsS0FBQUEsQ0FBVTFCLEtBQVYwQixDQUExQm5CO0FBREYsTUFBQTtBQUFBLFFBR0UsV0FBQUcsYUFBQUEsQ0FBWSxLQUFJVixLQUFoQlU7QUFIRixNQUFBO0FBUkZJLElBQUFBLENBQUFBLGdDQUFBQSxDQW5GQTtBQUFBO0FBa0dBYSxJQUFBQSxzQkFBQUEsaUJBQUFBLFNBQU8sS0FBUEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQSxJQUFHM0IsS0FBQUUsT0FBQUEsQ0FBUzFCLENBQVQwQixDQUFIO0FBQUEsUUFDRSxPQUFPLHVCQUFBakIsS0FBQUEsQ0FBWTJDLEdBQUdwRCxDQUFmUyxDQURULENBQUE7QUFBQSxNQUlBLElBQUEsUUFBRyx1QkFBQUwsUUFBQUEsQ0FBWW9CLEtBQVpwQixDQUFILENBQUE7QUFBQTtBQUNFLFFBQUEsU0FBV00sT0FBQUEsQ0FBQUEsQ0FBWCxzQkFBQSxFQUFBSSxDQUFBQSxpQ0FBQUEsQ0FBQSxFQUFHQyxDQUFBQSxxQ0FBQUEsQ0FBSCxJQUFBO0FBQUEsUUFDQXNDLE1BQVc3QixLQUFBbkIsTUFBQUEsQ0FBQUEsQ0FEWDtBQUFBLFFBRUFpRCxNQUFXOUIsS0FBQWpCLE1BQUFBLENBQUFBLENBRlg7QUFBQSxRQUdBZ0QsS0FBVyxvQkFBQUMsS0FBQUEsQ0FBU3JCLFVBQUFuQixVQUFBcUMsR0FBQXJDLEVBQU0sb0JBQUF5QyxLQUFBQSxDQUFTM0MsQ0FBVDJDLENBQU56QyxDQUFBbUIsRUFBb0JuQixVQUFBc0MsR0FBQXRDLEVBQU1ELEtBQU5DLENBQXBCbUIsQ0FBVHFCLENBSFg7QUFBQSxRQUlBRSxTQUFXMUIsU0FBQWhCLFVBQUFELEtBQUFDLEVBQVFxQyxHQUFSckMsQ0FBQWdCLEVBQWNoQixVQUFBc0MsR0FBQXRDLEVBQU0sb0JBQUF5QyxLQUFBQSxDQUFTM0MsQ0FBVDJDLENBQU56QyxDQUFkZ0IsQ0FKWDtBQUFBLFFBTUEsT0FBQSx1QkFBQXRCLE9BQUFBLENBQWM2QyxJQUFJRyxNQUFsQmhELENBTkE7QUFERixNQUFBLE9BUUEsSUFBQSxRQUFNLHVCQUFBTixRQUFBQSxDQUFZb0IsS0FBWnBCLENBQU4sQ0FBQTtBQUFBLFFBQ0UsSUFBQSxRQUFHdUQsT0FBQW5DLEtBQUFtQyxFQUFRM0QsQ0FBUjJELENBQUgsQ0FBQTtBQUFBO0FBQ0UsVUFBQUMsSUFBSTdELElBQUo7QUFBQSxVQUNBOEQsSUFBSUQsQ0FESjtBQUFBLFVBRUFFLElBQUkzQixVQUFBWCxLQUFBVyxFQUFRaUIsQ0FBUmpCLENBRko7QUFBQSxVQUlBLE9BQUEsUUFBTTJCLENBQUFDLE9BQUFBLENBQUsvRCxDQUFMK0QsQ0FBTixDQUFBO0FBQUE7QUFDRSxZQUFBLEtBQVdELENBQUFFLFFBQUFBLENBQVNDLENBQVRELENBQVgsc0JBQUEsRUFBQUUsQ0FBQUEsbUNBQUFBLENBQUEsRUFBS0MsQ0FBQUEsbUNBQUFBLENBQUwsSUFBQTtBQUFBLFlBQ0EsT0FBTUEsR0FBQXpDLE9BQUFBLENBQU8xQixDQUFQMEIsQ0FBTjtBQUFBO0FBQ0UsY0FBQWtDLFFBQUk3QixTQUFBQSxDQUFRSSxVQUFBbkIsVUFBQTRDLENBQUF2RCxNQUFBQSxDQUFBQSxDQUFBVyxFQUFTNEMsQ0FBQXZELE1BQUFBLENBQUFBLENBQVRXLENBQUFtQixFQUFrQm5CLFVBQUE0QyxDQUFBckQsTUFBQUEsQ0FBQUEsQ0FBQVMsRUFBUzRDLENBQUFyRCxNQUFBQSxDQUFBQSxDQUFUUyxDQUFsQm1CLEdBQW1DbkIsVUFBQUEsVUFBQWlELENBQUFqRCxFQUFJNEMsQ0FBQXZELE1BQUFBLENBQUFBLENBQUpXLENBQUFBLEVBQWE0QyxDQUFBckQsTUFBQUEsQ0FBQUEsQ0FBYlMsQ0FBM0NlLENBQUo7QUFBQSxjQUNBK0IsSUFBSUksR0FESjtBQUFBLGNBRUEsS0FBV0osQ0FBQUUsUUFBQUEsQ0FBU0MsQ0FBVEQsQ0FBWCxzQkFBQSxFQUFBRSxDQUFBQSxtQ0FBQUEsQ0FBQSxFQUFLQyxDQUFBQSxtQ0FBQUEsQ0FBTCxJQUZBO0FBREYsWUFBQSxDQURBO0FBQUEsWUFPQU4sSUFqSVY3QyxVQWlJVTZDLENBaklWN0MsRUFpSWU0QyxDQWpJZjVDLENBMEhVO0FBQUEsWUFRQThDLElBbElWM0IsVUFrSVUyQixDQWxJVjNCLEVBa0llaUIsQ0FsSWZqQixDQTBIVTtBQURGLFVBQUEsQ0FKQTtBQUFBLFVBZ0JBLE9BQUEwQixDQWhCQTtBQURGLFFBQUE7QUFBQSxVQW1CRSxPQUFDdkIsV0FBQSx3QkFBQTdCLEtBQUFBLENBQWEyQyxHQUFHQSxDQUFoQjNDLENBQUE2QixFQUFxQnZDLElBQXJCdUMsQ0FBRGEsT0FBQUEsQ0FBOEIzQixLQUFETSxPQUFBQSxDQUFBQSxDQUE3QnFCO0FBbkJGLFFBQUE7QUFERixNQUFBLE9Bc0JBLElBQUEsUUFBTSxhQUFBLElBQUEsUUF6SVZpQixDQUFBQSxhQXlJVSxxQkFBQWhFLFFBQUFBLENBQVVvQixLQUFWcEIsQ0F6SVZnRSxDQXlJVSxDQUFBO0FBQUEsUUF6SVYsT0FBQTtBQXlJVSxNQUFBO0FBQUEsUUFBbUIsT0FBQSx3QkFBQWhFLFFBQUFBLENBQWFvQixLQUFicEI7QUFBbkIsTUFBQSxDQUFBLGtCQUFOLENBQUE7QUFBQTtBQUNFLFFBQUEsU0FBV00sT0FBQUEsQ0FBQUEsQ0FBWCxzQkFBQSxFQUFBSSxDQUFBQSxpQ0FBQUEsQ0FBQSxFQUFHQyxDQUFBQSxxQ0FBQUEsQ0FBSCxJQUFBO0FBQUEsUUFFQSxPQUFBLHVCQUFBTCxPQUFBQSxDQUFjSSxDQUFBcUMsT0FBQUEsQ0FBRzNCLEtBQUgyQixHQUFVbkMsVUFBQUQsS0FBQUMsRUFBUVEsS0FBUlIsQ0FBeEJOLENBRkE7QUFERixNQUFBO0FBQUEsUUFLRSxXQUFBd0IsYUFBQUEsQ0FBWSxNQUFLVixLQUFqQlU7QUFMRixNQUFBLENBbENBO0FBREZpQixJQUFBQSxDQUFBQSw0QkFBQUEsQ0FsR0E7QUFBQTtBQThJQWtCLElBQUFBLHVCQUFBQSxrQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxvQkFBQUMsT0FBQUEsQ0FBV2pELFdBQU9DLFNBQWxCZ0Q7QUFERkQsSUFBQUEsQ0FBQUEsNkJBQUFBLENBOUlBO0FBQUE7QUFrSkFyQixJQUFBQSx3QkFBQUEsbUJBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBaEIsU0FBQWhCLFVBQUFLLFNBQUFMLEVBQVFLLFNBQVJMLENBQUFnQixFQUFnQmhCLFVBQUFNLFNBQUFOLEVBQVFNLFNBQVJOLENBQWhCZ0I7QUFERmdCLElBQUFBLENBQUFBLDhCQUFBQSxDQWxKQTtBQUFBO0FBc0pBdUIsSUFBQUEseUJBQUFBLG9CQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxvQkFBQUMsT0FBQUEsQ0FBV2xELFdBQU9ELFNBQWxCbUQ7QUFERkQsSUFBQUEsQ0FBQUEsK0JBQUFBLENBdEpBO0FBQUEsSUEwSkEsaUJBQU0sS0FBTixFQUFVLE9BQVYsQ0ExSkE7QUFBQTtBQTRKQXhCLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLFdBQUFoQixTQUFBQSxDQUFRVixXQUFRQyxTQUFEUSxPQUFBQSxDQUFBQSxDQUFmQztBQURGZ0IsSUFBQUEsQ0FBQUEsOEJBQUFBLENBNUpBO0FBQUEsSUFnS0EsaUJBQU0sV0FBTixFQUFnQixNQUFoQixDQWhLQTtBQUFBO0FBa0tBMEIsSUFBQUEsK0JBQUFBLDBCQUFBQSx1QkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQXBELFNBQUFvRCxhQUFBQSxDQUFBQSxDQUFBQyxLQUFBQSxDQUFzQnBELFNBQUFtRCxhQUFBQSxDQUFBQSxDQUF0QkM7QUFERkQsSUFBQUEsQ0FBQUEscUNBQUFBLENBbEtBO0FBQUEsSUFzS0EsaUJBQU0sUUFBTixFQUFhLEdBQWIsQ0F0S0E7QUFBQTtBQXdLQUUsSUFBQUEsd0JBQUFBLHVCQUFBQSxTQUFTLEtBQVRBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLElBQUEsUUE3S0pDLENBQUFBLGFBNktJLGFBQUEsSUFBQSxRQTdLSkMsQ0FBQUEsYUE2S0ksdUJBQUF6RSxRQUFBQSxDQUFZb0IsS0FBWnBCLENBN0tKeUUsQ0E2S0ksQ0FBQTtBQUFBLFFBQXFCLE9BQUF4RCxTQUFBeEIsT0FBQUEsQ0FBQUEsQ0FBQTZCLE9BQUFBLENBQWVKLFNBQUF6QixPQUFBQSxDQUFBQSxDQUFmNkI7QUFBckIsTUFBQTtBQUFBLFFBN0tKLE9BQUE7QUE2S0ksTUFBQSxDQUFBLGtCQTdLSmtELENBNktJLENBQUE7QUFBQSxRQUFtRCxPQUFBN0UsSUFBQTJCLE9BQUFBLENBQVFGLEtBQVJFO0FBQW5ELE1BQUE7QUFBQSxRQTdLSixPQUFBO0FBNktJLE1BQUE7QUFERmlELElBQUFBLENBQUFBLGtDQUFBQSxDQXhLQTtBQUFBO0FBNEtBRyxJQUFBQSx3QkFBQUEsbUJBQUFBLGdCQUFTLEtBQVRBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUEsSUFBQSxRQUFPLHVCQUFBMUUsUUFBQUEsQ0FBWW9CLEtBQVpwQixDQUFQLENBQUE7QUFBQSxNQUFBO0FBQUEsWUFDRUksT0FBQUEsQ0FBTSwyQkFBVyxFQUFBLEdBQUEsQ0FBR2dCLEtBQUEzQixPQUFBQSxDQUFBQSxDQUFILENBQUEsR0FBQSxnQ0FBakJXO0FBREYsTUFBQSxDQUFBO0FBQUEsTUFJQSxPQUFBOEIsV0FBQXZDLElBQUF1QyxFQUFPZCxLQUFQYyxDQUpBO0FBREZ3QyxJQUFBQSxDQUFBQSw4QkFBQUEsQ0E1S0E7QUFBQTtBQW9MQUMsSUFBQUEsMkJBQUFBLDBCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxJQUFBLFFBekxKQyxDQUFBQSxhQXlMSTNELFNBQUEwRCxZQUFBQSxDQUFBQSxDQXpMSkMsQ0F5TEksQ0FBQTtBQUFBLFFBQWlCLE9BQUExRCxTQUFBeUQsWUFBQUEsQ0FBQUE7QUFBakIsTUFBQTtBQUFBLFFBekxKLE9BQUE7QUF5TEksTUFBQTtBQURGQSxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0FwTEE7QUFBQTtBQXdMQUUsSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxFQUFBLEdBQUEsVUFBQSxHQUFBLENBQVc1RCxTQUFYLENBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBb0JDLFNBQXBCO0FBREYyRCxJQUFBQSxDQUFBQSw4QkFBQUEsQ0F4TEE7QUFBQSxJQTRMQSxpQkFBTSxXQUFOLEVBQWdCLE1BQWhCLENBNUxBO0FBQUE7QUE4TEFDLElBQUFBLDZCQUFBQSw0QkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsSUFBQSxRQW5NSkMsQ0FBQUEsYUFtTUk5RCxTQUFBNkQsY0FBQUEsQ0FBQUEsQ0FuTUpDLENBbU1JLENBQUE7QUFBQSxRQW5NSixPQUFBO0FBbU1JLE1BQUE7QUFBQSxRQUFtQixPQUFBN0QsU0FBQTRELGNBQUFBLENBQUFBO0FBQW5CLE1BQUE7QUFERkEsSUFBQUEsQ0FBQUEsdUNBQUFBLENBOUxBO0FBQUE7QUFrTUFFLElBQUFBLDJCQUFBQSxzQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsRUFBQSxHQUFBLEdBQUEsR0FBQSxDQUFJckYsSUFBSixDQUFBLEdBQUE7QUFERnFGLElBQUFBLENBQUFBLGlDQUFBQSxDQWxNQTtBQUFBLElBc01BLGlCQUFNLFdBQU4sRUFBZ0IsS0FBaEIsQ0F0TUE7QUFBQTtBQXdNQSxJQUFBLHNCQUFNLFdBQU4sRUF4TUE7QUFBQTtBQTBNQUMsSUFBQUEsNkJBQUFBLHdCQUFBQSxxQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQUMsUUFBSWIsYUFBQUEsQ0FBQUEsQ0FBSjtBQUFBLE1BRUEsV0FBQTFDLFNBQUFBLENBQVFmLFVBQUFLLFNBQUFnRSxXQUFBQSxDQUFBQSxDQUFBckUsRUFBbUJzQixXQUFBZ0QsQ0FBQWhELEVBQUlqQixTQUFBb0QsYUFBQUEsQ0FBQUEsQ0FBSm5DLENBQW5CdEIsR0FDTkEsVUFBQU0sU0FBQStELFdBQUFBLENBQUFBLENBQUFyRSxFQUFtQnNCLFdBQUFnRCxDQUFBaEQsRUFBSWhCLFNBQUFtRCxhQUFBQSxDQUFBQSxDQUFKbkMsQ0FBbkJ0QixDQURGZSxDQUZBO0FBREZzRCxJQUFBQSxDQUFBQSxtQ0FBQUEsQ0ExTUE7QUFBQSxJQWtOQSxpQkFBTSxPQUFOLEVBQVksS0FBWixDQWxOQTtBQUFBO0FBb05BM0UsSUFBQUEseUJBQUFBLG9CQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxLQUFDMkQsS0FBQUEsQ0FBQUEsQ0FBRCxNQUFNa0IsS0FBQUEsQ0FBQUEsQ0FBTjtBQURGN0UsSUFBQUEsQ0FBQUEsK0JBQUFBLENBcE5BO0FBQUE7QUF3TkEsSUFBQSxzQkFBTSxXQUFOLEVBeE5BO0FBQUEsSUEwTkEsaUJBQU0sS0FBTixFQUFVLEdBQVYsQ0ExTkE7QUFBQTtBQTROQThFLElBQUFBLCtCQUFBQSwwQkFBQUEsdUJBQWdCLEdBQWhCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFoT0YsTUFBQTtBQUFBO0FBa09BO0FBQ0EsWUFBVWhGLE9BQUFBLENBQU0sK0JBQWUsRUFBQSxHQUFBLDZCQUFBLEdBQUEsQ0FBK0IsZ0JBQS9CLENBQUEsR0FBQSxZQUFyQkEsQ0FBa0Y7QUFDNUY7QUFDQSxJQXJPQTtBQUFBLE1BdU9JLElBQUEsUUFBR2MsU0FBQXlDLE9BQUFBLENBQVMvRCxDQUFUK0QsQ0FBSCxDQUFBO0FBQUEsWUFDRXZELE9BQUFBLENBQU0sNEJBQVksRUFBQSxHQUFBLGlCQUFBLEdBQUEsQ0FBa0JULElBQWxCLENBQUEsR0FBQSxnQkFBbEJTLENBREYsQ0F2T0o7QUFBQSxNQTJPSSxXQUFBSCxNQUFBQSxDQUFBQSxDQUFBbUYsYUFBQUEsQ0FBaUJDLEdBQWpCRCxDQTNPSjtBQWdPRUEsSUFBQUEsQ0FBQUEsc0NBQUFBLENBNU5BO0FBQUE7QUEwT0FsRixJQUFBQSx5QkFBQUEsd0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUE7QUFERkEsSUFBQUEsQ0FBQUEsbUNBQUFBLENBMU9BO0FBQUE7QUE4T0FSLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsQ0FBQ3VCLFNBQUQsRUFBUUMsU0FBUjtBQURGeEIsSUFBQUEsQ0FBQUEsOEJBQUFBLENBOU9BO0FBQUEsSUFrUEEsaUJBQU0sYUFBTixFQUFrQixNQUFsQixDQWxQQTtBQUFBO0FBb1BBLElBQUEsc0JBQU0sTUFBTixFQXBQQTtBQUFBO0FBc1BBNEYsSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQSxJQUFPcEUsU0FBQUksT0FBQUEsQ0FBUzFCLENBQVQwQixDQUFQO0FBQUEsTUFBQTtBQUFBLFlBQ0VsQixPQUFBQSxDQUFNLDRCQUFZLEVBQUEsR0FBQSxnQkFBQSxHQUFBLENBQWlCVCxJQUFqQixDQUFBLEdBQUEsYUFBbEJTO0FBREYsTUFBQSxDQUFBO0FBQUEsTUFJQSxPQUFBYSxTQUFBcUUsTUFBQUEsQ0FBQUEsQ0FKQTtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0F0UEE7QUFBQTtBQThQQUMsSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQSxJQUFPckUsU0FBQUksT0FBQUEsQ0FBUzFCLENBQVQwQixDQUFQO0FBQUEsTUFBQTtBQUFBLFlBQ0VsQixPQUFBQSxDQUFNLDRCQUFZLEVBQUEsR0FBQSxnQkFBQSxHQUFBLENBQWlCVCxJQUFqQixDQUFBLEdBQUEsZUFBbEJTO0FBREYsTUFBQSxDQUFBO0FBQUEsTUFJQSxPQUFBYSxTQUFBc0UsTUFBQUEsQ0FBQUEsQ0FKQTtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0E5UEE7QUFBQTtBQXNRQUMsSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQSxJQUFPdEUsU0FBQUksT0FBQUEsQ0FBUzFCLENBQVQwQixDQUFQO0FBQUEsTUFBQTtBQUFBLFlBQ0VsQixPQUFBQSxDQUFNLDRCQUFZLEVBQUEsR0FBQSxnQkFBQSxHQUFBLENBQWlCVCxJQUFqQixDQUFBLEdBQUEsZ0JBQWxCUztBQURGLE1BQUEsQ0FBQTtBQUFBLE1BSUEsT0FBQWEsU0FBQXVFLE1BQUFBLENBQUFBLENBSkE7QUFERkEsSUFBQUEsQ0FBQUEsOEJBQUFBLENBdFFBO0FBQUE7QUE4UUFDLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFDLFNBQVN6RSxTQUFBK0QsU0FBQUEsQ0FBQUEsQ0FBVDtBQUFBLE1BRUFVLFNBclJKOUQsU0FxUkk4RCxNQXJSSjlELEVBc1JNLGFBQUEsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQXRSVCtELENBQUFBLGFBc1JTLGFBQUEsSUFBQSxRQXRSVEMsQ0FBQUEsYUFzUlUsYUFBQSxJQUFBLFFBdFJWQyxDQUFBQSxhQXNSVSxzQkFBQTdGLFFBQUFBLENBQVdrQixTQUFYbEIsQ0F0UlY2RixDQXNSVSxDQUFBO0FBQUEsUUFBb0IsT0FBQTNFLFNBQUFxQixTQUFBQSxDQUFBQTtBQUFwQixNQUFBO0FBQUEsUUF0UlYsT0FBQTtBQXNSVSxNQUFBLENBQUEsa0JBdFJWcUQsQ0FzUlMsQ0FBQTtBQUFBLFFBdFJULE9BQUE7QUFzUlMsTUFBQTtBQUFBLFFBQW9DLE9BQUExRSxTQUFBNEUsY0FBQUEsQ0FBQUE7QUFBcEMsTUFBQSxDQUFBLGtCQXRSVEgsQ0FzUlMsQ0FBQTtBQUFBLFFBdFJULE9BQUE7QUFzUlMsTUFBQTtBQUFBLFFBQXVELE9BQUF6RSxTQUFBNkUsVUFBQUEsQ0FBQUE7QUFBdkQsTUFBQSxDQUFBLGtCQUFILENBQUE7QUFBQSxRQUNFLE9BQUE7QUFERixNQUFBO0FBQUEsUUFHRSxPQUFBO0FBSEYsTUFBQSxDQUFBLGtCQXRSTm5FLENBbVJJO0FBQUEsTUFTQThELFNBNVJKOUQsU0E0Ukk4RCxNQTVSSjlELEVBNFJjVixTQUFBK0MsS0FBQUEsQ0FBQUEsQ0FBQWUsU0FBQUEsQ0FBQUEsQ0E1UmRwRCxDQW1SSTtBQUFBLE1BV0EsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQTlSUG9FLENBQUFBLGFBOFJPLHNCQUFBaEcsUUFBQUEsQ0FBV2tCLFNBQVhsQixDQTlSUGdHLENBOFJPLENBQUE7QUFBQTtBQUFvQixRQUFDLElBQUEsUUE5UjVCQyxDQUFBQSxhQThSNEIvRSxTQUFBcUIsU0FBQUEsQ0FBQUEsQ0E5UjVCMEQsQ0E4UjRCLENBQUE7QUFBQSxVQTlSNUIsT0FBQTtBQThSNEIsUUFBQTtBQUFBLFVBQWMsT0FBQS9FLFNBQUE0RCxjQUFBQSxDQUFBQTtBQUFkLFFBQUEsQ0FBRDtBQUFwQixNQUFBO0FBQUEsUUE5UlAsT0FBQTtBQThSTyxNQUFBLENBQUEsa0JBQUgsQ0FBQTtBQUFBLFFBQ0VZLFNBL1JOOUQsU0ErUk04RCxNQS9STjlELEVBK1JnQixHQS9SaEJBLENBOFJJLENBWEE7QUFBQSxNQWVBLE9BQUFBLFNBQUE4RCxNQUFBOUQsRUFBUyxHQUFUQSxDQWZBO0FBREY2RCxJQUFBQSxDQUFBQSw4QkFBQUEsQ0E5UUE7QUFBQSxJQWlTQSxPQUFBLHFDQUFJcEYsS0FBQUEsQ0FBSVQsR0FBR29ELENBQVAzQyxDQUFKLENBalNBO0FBREZaLEVBQUFBLEdBQUFBLFdBQUFBLEVBQWdCLHVCQUFoQkEsV0FGQTtBQUFBLEVBdVNBeUc7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUF2RSxDQUFBQSwyQkFBQUEscUJBQUFBLG1CQUFZLElBQUQsRUFBTyxJQUFsQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBelNGO0FBeVNvQixNQUFBO0FBQUEsTUFBQSxTQUFPLEdBQVA7QUFBQSxNQUFBLENBelNwQjtBQUFBLE1BMFNJLElBQUEsUUFBR3hCLElBQUgsQ0FBQTtBQUFBLFFBQ0UsT0FBQSx1QkFBQUUsS0FBQUEsQ0FBWUosTUFBTUUsSUFBbEJFO0FBREYsTUFBQTtBQUFBLFFBR0UsT0FBQSx1QkFBQUEsS0FBQUEsQ0FBWUosTUFBTUwsQ0FBbEJTO0FBSEYsTUFBQSxDQTFTSjtBQXlTRXNCLElBQUFBLENBQUFBLGlDQUFBQSxDQUFBQTtBQURGdUUsRUFBQUEsR0FBQUEsV0FBQUEsV0F2U0E7QUFBQSxFQWlUQSxPQUFBekc7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUEwRyxDQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXVCQyxVQUFBQSxDQUFVLFdBQWEsV0FBdkJBLENBQXFDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFtQnpFLFNBQUFBLENBQVEvQixHQUFHb0QsQ0FBWHJCLENBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0EscUJBQW1CQSxTQUFBQSxDQUFRL0IsR0FBR3lHLEVBQVgxRSxDQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHFCQUFtQkEsU0FBQUEsQ0FBUS9CLEdBQUdvRCxDQUFYckIsQ0FBYztBQUNqQztBQUNBO0FBQ0EsbUJBQWlCQSxTQUFBQSxDQUFRL0IsR0FBR0EsQ0FBWCtCLENBQWM7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBbUJBLFNBQUFBLENBQVEvQixHQUFJLElBQVorQixDQUFtQjtBQUN0QztBQUNBO0FBQ0EscUJBQW1CQSxTQUFBQSxDQUFTLE1BQU8vQixDQUFoQitCLENBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG1CQUFpQkEsU0FBQUEsQ0FBUyxNQUFRLElBQWpCQSxDQUF3QjtBQUN6QztBQUNBO0FBNUVFd0UsSUFBQUEsQ0FBQUEsNkJBQUFBLENBQUFBO0FBREYxRyxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQWpUQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIxNTcyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYXRpb25hbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL251bWVyaWMnXG5cbmNsYXNzIFJhdGlvbmFsIDwgTnVtZXJpY1xuICBkZWYgc2VsZi5yZWR1Y2UobnVtLCBkZW4pXG4gICAgbnVtID0gbnVtLnRvX2lcbiAgICBkZW4gPSBkZW4udG9faVxuXG4gICAgaWYgZGVuID09IDBcbiAgICAgIHJhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ1xuICAgIGVsc2lmIGRlbiA8IDBcbiAgICAgIG51bSA9IC1udW1cbiAgICAgIGRlbiA9IC1kZW5cbiAgICBlbHNpZiBkZW4gPT0gMVxuICAgICAgcmV0dXJuIG5ldyhudW0sIGRlbilcbiAgICBlbmRcblxuICAgIGdjZCA9IG51bS5nY2QoZGVuKVxuXG4gICAgbmV3KG51bSAvIGdjZCwgZGVuIC8gZ2NkKVxuICBlbmRcblxuICBkZWYgc2VsZi5jb252ZXJ0KG51bSwgZGVuKVxuICAgIGlmIG51bS5uaWw/IHx8IGRlbi5uaWw/XG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdjYW5ub3QgY29udmVydCBuaWwgaW50byBSYXRpb25hbCdcbiAgICBlbmRcblxuICAgIGlmIEludGVnZXIgPT09IG51bSAmJiBJbnRlZ2VyID09PSBkZW5cbiAgICAgIHJldHVybiByZWR1Y2UobnVtLCBkZW4pXG4gICAgZW5kXG5cbiAgICBpZiBGbG9hdCA9PT0gbnVtIHx8IFN0cmluZyA9PT0gbnVtIHx8IENvbXBsZXggPT09IG51bVxuICAgICAgbnVtID0gbnVtLnRvX3JcbiAgICBlbmRcblxuICAgIGlmIEZsb2F0ID09PSBkZW4gfHwgU3RyaW5nID09PSBkZW4gfHwgQ29tcGxleCA9PT0gZGVuXG4gICAgICBkZW4gPSBkZW4udG9fclxuICAgIGVuZFxuXG4gICAgaWYgZGVuLmVxdWFsPygxKSAmJiAhKEludGVnZXIgPT09IG51bSlcbiAgICAgIE9wYWwuY29lcmNlX3RvIShudW0sIFJhdGlvbmFsLCA6dG9fcilcbiAgICBlbHNpZiBOdW1lcmljID09PSBudW0gJiYgTnVtZXJpYyA9PT0gZGVuXG4gICAgICBudW0gLyBkZW5cbiAgICBlbHNlXG4gICAgICByZWR1Y2UobnVtLCBkZW4pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKG51bSwgZGVuKVxuICAgIEBudW0gPSBudW1cbiAgICBAZGVuID0gZGVuXG4gIGVuZFxuXG4gIGRlZiBudW1lcmF0b3JcbiAgICBAbnVtXG4gIGVuZFxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIEBkZW5cbiAgZW5kXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgW290aGVyLCBzZWxmXVxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBbb3RoZXIudG9fciwgc2VsZl1cblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIFtvdGhlciwgdG9fZl1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBAbnVtID09IG90aGVyLm51bWVyYXRvciAmJiBAZGVuID09IG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIEBudW0gPT0gb3RoZXIgJiYgQGRlbiA9PSAxXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mID09IG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBvdGhlciA9PSBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIEBudW0gKiBvdGhlci5kZW5vbWluYXRvciAtIEBkZW4gKiBvdGhlci5udW1lcmF0b3IgPD0+IDBcblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgQG51bSAtIEBkZW4gKiBvdGhlciA8PT4gMFxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiA8PT4gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDo8PT4sIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIuZGVub21pbmF0b3IgKyBAZGVuICogb3RoZXIubnVtZXJhdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcblxuICAgICAgUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIFJhdGlvbmFsKEBudW0gKyBvdGhlciAqIEBkZW4sIEBkZW4pXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mICsgb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDorLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLShvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yIC0gQGRlbiAqIG90aGVyLm51bWVyYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICAgIFJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBSYXRpb25hbChAbnVtIC0gb3RoZXIgKiBAZGVuLCBAZGVuKVxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiAtIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6LSwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5udW1lcmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgICBSYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgUmF0aW9uYWwoQG51bSAqIG90aGVyLCBAZGVuKVxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiAqIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Kiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5kZW5vbWluYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLm51bWVyYXRvclxuXG4gICAgICBSYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgaWYgb3RoZXIgPT0gMFxuICAgICAgICB0b19mIC8gMC4wXG4gICAgICBlbHNlXG4gICAgICAgIFJhdGlvbmFsKEBudW0sIEBkZW4gKiBvdGhlcilcbiAgICAgIGVuZFxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgdG9fZiAvIG90aGVyXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6Lywgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICoqKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIEludGVnZXJcbiAgICAgIGlmIHNlbGYgPT0gMCAmJiBvdGhlciA8IDBcbiAgICAgICAgRmxvYXQ6OklORklOSVRZXG4gICAgICBlbHNpZiBvdGhlciA+IDBcbiAgICAgICAgUmF0aW9uYWwoQG51bSoqb3RoZXIsIEBkZW4qKm90aGVyKVxuICAgICAgZWxzaWYgb3RoZXIgPCAwXG4gICAgICAgIFJhdGlvbmFsKEBkZW4qKi1vdGhlciwgQG51bSoqLW90aGVyKVxuICAgICAgZWxzZVxuICAgICAgICBSYXRpb25hbCgxLCAxKVxuICAgICAgZW5kXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mKipvdGhlclxuXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgaWYgb3RoZXIgPT0gMFxuICAgICAgICBSYXRpb25hbCgxLCAxKVxuICAgICAgZWxzaWYgb3RoZXIuZGVub21pbmF0b3IgPT0gMVxuICAgICAgICBpZiBvdGhlciA8IDBcbiAgICAgICAgICBSYXRpb25hbChAZGVuKipvdGhlci5udW1lcmF0b3IuYWJzLCBAbnVtKipvdGhlci5udW1lcmF0b3IuYWJzKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgUmF0aW9uYWwoQG51bSoqb3RoZXIubnVtZXJhdG9yLCBAZGVuKipvdGhlci5udW1lcmF0b3IpXG4gICAgICAgIGVuZFxuICAgICAgZWxzaWYgc2VsZiA9PSAwICYmIG90aGVyIDwgMFxuICAgICAgICByYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCdcbiAgICAgIGVsc2VcbiAgICAgICAgdG9fZioqb3RoZXJcbiAgICAgIGVuZFxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgUmF0aW9uYWwoQG51bS5hYnMsIEBkZW4uYWJzKVxuICBlbmRcblxuICBkZWYgY2VpbChwcmVjaXNpb24gPSAwKVxuICAgIGlmIHByZWNpc2lvbiA9PSAwXG4gICAgICAoLSgtQG51bSAvIEBkZW4pKS5jZWlsXG4gICAgZWxzZVxuICAgICAgd2l0aF9wcmVjaXNpb24oOmNlaWwsIHByZWNpc2lvbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgZGl2aWRlIC9cblxuICBkZWYgZmxvb3IocHJlY2lzaW9uID0gMClcbiAgICBpZiBwcmVjaXNpb24gPT0gMFxuICAgICAgKC0oLUBudW0gLyBAZGVuKSkuZmxvb3JcbiAgICBlbHNlXG4gICAgICB3aXRoX3ByZWNpc2lvbig6Zmxvb3IsIHByZWNpc2lvbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBcIlJhdGlvbmFsOiN7QG51bX06I3tAZGVufVwiXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIoI3tzZWxmfSlcIlxuICBlbmRcblxuICBhbGlhcyBxdW8gL1xuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMSlcIn07XG4gICAgICB9XG5cbiAgICAgIGlmIChlcHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGUgPSAje2Vwcy5hYnN9LFxuICAgICAgICAgIGEgPSAje3NlbGYgLSBgZWB9LFxuICAgICAgICAgIGIgPSAje3NlbGYgKyBgZWB9O1xuXG4gICAgICB2YXIgcDAgPSAwLFxuICAgICAgICAgIHAxID0gMSxcbiAgICAgICAgICBxMCA9IDEsXG4gICAgICAgICAgcTEgPSAwLFxuICAgICAgICAgIHAyLCBxMjtcblxuICAgICAgdmFyIGMsIGssIHQ7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGMgPSAje2BhYC5jZWlsfTtcblxuICAgICAgICBpZiAoI3tgY2AgPD0gYGJgfSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgayAgPSBjIC0gMTtcbiAgICAgICAgcDIgPSBrICogcDEgKyBwMDtcbiAgICAgICAgcTIgPSBrICogcTEgKyBxMDtcbiAgICAgICAgdCAgPSAjezEgLyAoYGJgIC0gYGtgKX07XG4gICAgICAgIGIgID0gI3sxIC8gKGBhYCAtIGBrYCl9O1xuICAgICAgICBhICA9IHQ7XG5cbiAgICAgICAgcDAgPSBwMTtcbiAgICAgICAgcTAgPSBxMTtcbiAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgcTEgPSBxMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7UmF0aW9uYWwoYGMgKiBwMSArIHAwYCwgYGMgKiBxMSArIHEwYCl9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdW5kKHByZWNpc2lvbiA9IDApXG4gICAgcmV0dXJuIHdpdGhfcHJlY2lzaW9uKDpyb3VuZCwgcHJlY2lzaW9uKSB1bmxlc3MgcHJlY2lzaW9uID09IDBcbiAgICByZXR1cm4gMCBpZiBAbnVtID09IDBcbiAgICByZXR1cm4gQG51bSBpZiBAZGVuID09IDFcblxuICAgIG51bSA9IEBudW0uYWJzICogMiArIEBkZW5cbiAgICBkZW4gPSBAZGVuICogMlxuXG4gICAgYXBwcm94ID0gKG51bSAvIGRlbikudHJ1bmNhdGVcblxuICAgIGlmIEBudW0gPCAwXG4gICAgICAtYXBwcm94XG4gICAgZWxzZVxuICAgICAgYXBwcm94XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19mXG4gICAgQG51bSAvIEBkZW5cbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICB0cnVuY2F0ZVxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3NcbiAgICBcIiN7QG51bX0vI3tAZGVufVwiXG4gIGVuZFxuXG4gIGRlZiB0cnVuY2F0ZShwcmVjaXNpb24gPSAwKVxuICAgIGlmIHByZWNpc2lvbiA9PSAwXG4gICAgICBAbnVtIDwgMCA/IGNlaWwgOiBmbG9vclxuICAgIGVsc2VcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDp0cnVuY2F0ZSwgcHJlY2lzaW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgd2l0aF9wcmVjaXNpb24obWV0aG9kLCBwcmVjaXNpb24pXG4gICAgcmFpc2UgVHlwZUVycm9yLCAnbm90IGFuIEludGVnZXInIHVubGVzcyBJbnRlZ2VyID09PSBwcmVjaXNpb25cblxuICAgIHAgPSAxMCoqcHJlY2lzaW9uXG4gICAgcyA9IHNlbGYgKiBwXG5cbiAgICBpZiBwcmVjaXNpb24gPCAxXG4gICAgICAocy5zZW5kKG1ldGhvZCkgLyBwKS50b19pXG4gICAgZWxzZVxuICAgICAgUmF0aW9uYWwocy5zZW5kKG1ldGhvZCksIHApXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgZGVmIFJhdGlvbmFsKG51bWVyYXRvciwgZGVub21pbmF0b3IgPSAxKVxuICAgIFJhdGlvbmFsLmNvbnZlcnQobnVtZXJhdG9yLCBkZW5vbWluYXRvcilcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RyaW5nXG4gIGRlZiB0b19yXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gc2VsZi50cmltTGVmdCgpLFxuICAgICAgICAgIHJlID0gL15bKy1dP1tcXGRfXSsoXFwuW1xcZF9dKyk/LyxcbiAgICAgICAgICBtYXRjaCA9IHN0ci5tYXRjaChyZSksXG4gICAgICAgICAgbnVtZXJhdG9yLCBkZW5vbWluYXRvcjtcblxuICAgICAgZnVuY3Rpb24gaXNGbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuIHJlLnRlc3Qoc3RyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY3V0RmxvYXQoKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZSk7XG4gICAgICAgIHZhciBudW1iZXIgPSBtYXRjaFswXTtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKG51bWJlci5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbnVtYmVyLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgIG51bWVyYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG5cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy8gcmF0aW9uYWwgcmVhbCBwYXJ0XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG4gICAgICAgICAgaWYgKGlzRmxvYXQoKSkge1xuICAgICAgICAgICAgZGVub21pbmF0b3IgPSBwYXJzZUZsb2F0KGN1dEZsb2F0KCkpO1xuICAgICAgICAgICAgcmV0dXJuICN7UmF0aW9uYWwoYG51bWVyYXRvcmAsIGBkZW5vbWluYXRvcmApfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICN7UmF0aW9uYWwoYG51bWVyYXRvcmAsIDEpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICN7UmF0aW9uYWwoYG51bWVyYXRvcmAsIDEpfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7UmF0aW9uYWwoMCwgMSl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJyZWR1Y2UiLCJzZWxmIiwibnVtIiwidG9faSIsImRlbiIsIj09IiwiMCIsInJhaXNlIiwiPCIsIi1AIiwiMSIsIm5ldyIsImdjZCIsIi8iLCJjb252ZXJ0IiwiJHJldF9vcl8xIiwibmlsPyIsIiRyZXRfb3JfMiIsIj09PSIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsInRvX3IiLCIkcmV0X29yXzUiLCIkcmV0X29yXzYiLCIkcmV0X29yXzciLCJlcXVhbD8iLCIhIiwiY29lcmNlX3RvISIsIiRyZXRfb3JfOCIsImluaXRpYWxpemUiLCJAbnVtIiwiQGRlbiIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwiY29lcmNlIiwib3RoZXIiLCJ0b19mIiwiJHJldF9vcl85IiwiJHJldF9vcl8xMCIsIjw9PiIsIi0iLCIqIiwiX19jb2VyY2VkX18iLCIrIiwiUmF0aW9uYWwiLCIqKiIsIiRyZXRfb3JfMTEiLCI+IiwiYWJzIiwiJHJldF9vcl8xMiIsImNlaWwiLCJwcmVjaXNpb24iLCJ3aXRoX3ByZWNpc2lvbiIsImZsb29yIiwiaGFzaCIsImluc3BlY3QiLCJyYXRpb25hbGl6ZSIsImVwcyIsIjw9Iiwicm91bmQiLCIyIiwiYXBwcm94IiwidHJ1bmNhdGUiLCJ0b19zIiwicCIsIjEwIiwicyIsInNlbmQiLCJtZXRob2QiLCJtb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQUFBLFNBQUFBLENBQVEsaUJBQVJBLENBQUE7QUFBQSxFQUVBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0UsSUFBQUMsVUFBSUMsSUFBSkQsYUFBQUEscUJBQUFBLGtCQUFnQixHQUFELEVBQU0sR0FBckJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUFFLE1BQU1BLEdBQUFDLE1BQUFBLENBQUFBLENBQU47QUFBQSxNQUNBQyxNQUFNQSxHQUFBRCxNQUFBQSxDQUFBQSxDQUROO0FBQUEsTUFHQSxJQUFHQyxHQUFBQyxPQUFBQSxDQUFPQyxDQUFQRCxDQUFIO0FBQUEsWUFDRUUsT0FBQUEsQ0FBTSxtQ0FBbUIsY0FBekJBO0FBREYsTUFBQSxPQUVBLElBQUEsUUFBTUMsT0FBQUosR0FBQUksRUFBTUYsQ0FBTkUsQ0FBTixDQUFBO0FBQUE7QUFDRSxRQUFBTixNQUFPQSxHQUFETyxPQUFBQSxDQUFBQSxDQUFOO0FBQUEsUUFDQUwsTUFBT0EsR0FBREssT0FBQUEsQ0FBQUEsQ0FETjtBQURGLE1BQUEsT0FHQSxJQUFNTCxHQUFBQyxPQUFBQSxDQUFPSyxDQUFQTCxDQUFOO0FBQUEsUUFDRSxXQUFPTSxLQUFBQSxDQUFJVCxLQUFLRSxHQUFUTyxDQURULENBUkE7QUFBQSxNQVlBQyxNQUFNVixHQUFBVSxLQUFBQSxDQUFRUixHQUFSUSxDQVpOO0FBQUEsTUFjQSxXQUFBRCxLQUFBQSxDQUFJRSxXQUFBWCxHQUFBVyxFQUFNRCxHQUFOQyxHQUFXQSxXQUFBVCxHQUFBUyxFQUFNRCxHQUFOQyxDQUFmRixDQWRBO0FBREZYLElBQUFBLENBQUFBLGdDQUFBQSxDQUFBO0FBQUEsSUFrQkFjLFVBQUliLElBQUphLGNBQUFBLHNCQUFBQSxtQkFBaUIsR0FBRCxFQUFNLEdBQXRCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFBLElBQUEsUUFBRyxhQUFBLElBQUEsUUF2QlBDLENBQUFBLFlBdUJPYixHQUFBYyxTQUFBQSxDQUFBQSxDQXZCUEQsQ0F1Qk8sQ0FBQTtBQUFBLFFBdkJQLE9BQUE7QUF1Qk8sTUFBQTtBQUFBLFFBQVksT0FBQVgsR0FBQVksU0FBQUEsQ0FBQUE7QUFBWixNQUFBLENBQUEsa0JBQUgsQ0FBQTtBQUFBLFlBQ0VULE9BQUFBLENBQU0sMkJBQVcsa0NBQWpCQSxDQURGLENBQUE7QUFBQSxNQUlBLElBQUEsUUFBRyxhQUFBLElBQUEsUUEzQlBVLENBQUFBLFlBMkJPLHVCQUFBQyxRQUFBQSxDQUFZaEIsR0FBWmdCLENBM0JQRCxDQTJCTyxDQUFBO0FBQUEsUUFBbUIsT0FBQSx1QkFBQUMsUUFBQUEsQ0FBWWQsR0FBWmM7QUFBbkIsTUFBQTtBQUFBLFFBM0JQLE9BQUE7QUEyQk8sTUFBQSxDQUFBLGtCQUFILENBQUE7QUFBQSxRQUNFLFdBQU9sQixRQUFBQSxDQUFPRSxLQUFLRSxHQUFaSixDQURULENBSkE7QUFBQSxNQVFBLElBQUEsUUFBRyxhQUFBLElBQUEsUUEvQlBtQixDQUFBQSxZQStCTyxhQUFBLElBQUEsUUEvQlBDLENBQUFBLFlBK0JPLHFCQUFBRixRQUFBQSxDQUFVaEIsR0FBVmdCLENBL0JQRSxDQStCTyxDQUFBO0FBQUEsUUEvQlAsT0FBQTtBQStCTyxNQUFBO0FBQUEsUUFBaUIsT0FBQSxzQkFBQUYsUUFBQUEsQ0FBV2hCLEdBQVhnQjtBQUFqQixNQUFBLENBQUEsa0JBL0JQQyxDQStCTyxDQUFBO0FBQUEsUUEvQlAsT0FBQTtBQStCTyxNQUFBO0FBQUEsUUFBbUMsT0FBQSx1QkFBQUQsUUFBQUEsQ0FBWWhCLEdBQVpnQjtBQUFuQyxNQUFBLENBQUEsa0JBQUgsQ0FBQTtBQUFBLFFBQ0VoQixNQUFNQSxHQUFBbUIsTUFBQUEsQ0FBQUEsQ0FEUixDQVJBO0FBQUEsTUFZQSxJQUFBLFFBQUcsYUFBQSxJQUFBLFFBbkNQQyxDQUFBQSxZQW1DTyxhQUFBLElBQUEsUUFuQ1BDLENBQUFBLFlBbUNPLHFCQUFBTCxRQUFBQSxDQUFVZCxHQUFWYyxDQW5DUEssQ0FtQ08sQ0FBQTtBQUFBLFFBbkNQLE9BQUE7QUFtQ08sTUFBQTtBQUFBLFFBQWlCLE9BQUEsc0JBQUFMLFFBQUFBLENBQVdkLEdBQVhjO0FBQWpCLE1BQUEsQ0FBQSxrQkFuQ1BJLENBbUNPLENBQUE7QUFBQSxRQW5DUCxPQUFBO0FBbUNPLE1BQUE7QUFBQSxRQUFtQyxPQUFBLHVCQUFBSixRQUFBQSxDQUFZZCxHQUFaYztBQUFuQyxNQUFBLENBQUEsa0JBQUgsQ0FBQTtBQUFBLFFBQ0VkLE1BQU1BLEdBQUFpQixNQUFBQSxDQUFBQSxDQURSLENBWkE7QUFBQSxNQWdCQSxJQUFBLFFBQUcsYUFBQSxJQUFBLFFBdkNQRyxDQUFBQSxZQXVDT3BCLEdBQUFxQixXQUFBQSxDQUFXZixDQUFYZSxDQXZDUEQsQ0F1Q08sQ0FBQTtBQUFBLFFBQWlCLE9BQUUsdUJBQUFOLFFBQUFBLENBQVloQixHQUFaZ0IsQ0FBRlEsTUFBQUEsQ0FBQUE7QUFBakIsTUFBQTtBQUFBLFFBdkNQLE9BQUE7QUF1Q08sTUFBQSxDQUFBLGtCQUFILENBQUE7QUFBQSxRQUNFLE9BQUEsb0JBQUFDLGVBQUFBLENBQWdCekIsS0FBSywwQkFBVSxNQUEvQnlCO0FBREYsTUFBQSxPQUVBLElBQUEsUUFBTSxhQUFBLElBQUEsUUF6Q1ZDLENBQUFBLFlBeUNVLHVCQUFBVixRQUFBQSxDQUFZaEIsR0FBWmdCLENBekNWVSxDQXlDVSxDQUFBO0FBQUEsUUFBbUIsT0FBQSx1QkFBQVYsUUFBQUEsQ0FBWWQsR0FBWmM7QUFBbkIsTUFBQTtBQUFBLFFBekNWLE9BQUE7QUF5Q1UsTUFBQSxDQUFBLGtCQUFOLENBQUE7QUFBQSxRQUNFLE9BQUFMLFdBQUFYLEdBQUFXLEVBQU1ULEdBQU5TO0FBREYsTUFBQTtBQUFBLFFBR0UsV0FBQWIsUUFBQUEsQ0FBT0UsS0FBS0UsR0FBWko7QUFIRixNQUFBLENBbEJBO0FBREZjLElBQUFBLENBQUFBLGlDQUFBQSxDQWxCQTtBQUFBO0FBNENBZSxJQUFBQSw4QkFBQUEseUJBQUFBLHNCQUFlLEdBQUQsRUFBTSxHQUFwQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBQ0UsTUFBQUMsV0FBTzVCLEdBQVA7QUFBQSxNQUNBLE9BQUE2QixDQUFBQSxXQUFPM0IsR0FBUDJCLENBREE7QUFERkYsSUFBQUEsQ0FBQUEsb0NBQUFBLENBNUNBO0FBQUE7QUFpREFHLElBQUFBLDZCQUFBQSx3QkFBQUEscUJBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUFGO0FBREZFLElBQUFBLENBQUFBLG1DQUFBQSxDQWpEQTtBQUFBO0FBcURBQyxJQUFBQSwrQkFBQUEsMEJBQUFBLHVCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBRjtBQURGRSxJQUFBQSxDQUFBQSxxQ0FBQUEsQ0FyREE7QUFBQTtBQXlEQUMsSUFBQUEsMEJBQUFBLHFCQUFBQSxrQkFBVyxLQUFYQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLGFBQUEsUUFBS0MsS0FBTDtBQUFBLE1BQ0EsSUFBSyx1Q0FBTCxHQUNFLE9BQUEsQ0FBQ0EsS0FBRCxFQUFRbEMsSUFBUixDQURGO0FBREEsTUFBQSxLQUlBLElBQUssc0NBQUwsR0FDRSxPQUFBLENBQUNrQyxLQUFBZCxNQUFBQSxDQUFBQSxDQUFELEVBQWFwQixJQUFiLENBREY7QUFKQSxNQUFBLEtBT0EsSUFBSyxvQ0FBTCxHQUNFLE9BQUEsQ0FBQ2tDLEtBQUQsTUFBUUMsTUFBQUEsQ0FBQUEsQ0FBUixDQURGO0FBUEEsTUFBQSxtQkFBQTtBQURGRixJQUFBQSxDQUFBQSxnQ0FBQUEsQ0F6REE7QUFBQTtBQXNFQTdCLElBQUFBLHNCQUFBQSxxQkFBQUEsU0FBTyxLQUFQQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLGFBQUEsUUFBSzhCLEtBQUw7QUFBQSxNQUNBLElBQUssdUNBQUwsR0FDRSxJQUFBLFFBN0VORSxDQUFBQSxZQTZFTVAsUUFBQXpCLE9BQUFBLENBQVE4QixLQUFBSCxXQUFBQSxDQUFBQSxDQUFSM0IsQ0E3RU5nQyxDQTZFTSxDQUFBO0FBQUEsUUFBMkIsT0FBQU4sUUFBQTFCLE9BQUFBLENBQVE4QixLQUFBRixhQUFBQSxDQUFBQSxDQUFSNUI7QUFBM0IsTUFBQTtBQUFBLFFBN0VOLE9BQUE7QUE2RU0sTUFBQSxDQURGO0FBREEsTUFBQSxLQUlBLElBQUssc0NBQUwsR0FDRSxJQUFBLFFBaEZOaUMsQ0FBQUEsYUFnRk1SLFFBQUF6QixPQUFBQSxDQUFROEIsS0FBUjlCLENBaEZOaUMsQ0FnRk0sQ0FBQTtBQUFBLFFBQWlCLE9BQUFQLFFBQUExQixPQUFBQSxDQUFRSyxDQUFSTDtBQUFqQixNQUFBO0FBQUEsUUFoRk4sT0FBQTtBQWdGTSxNQUFBLENBREY7QUFKQSxNQUFBLEtBT0EsSUFBSyxvQ0FBTCxHQUNFLFdBQUErQixNQUFBQSxDQUFBQSxDQUFBL0IsT0FBQUEsQ0FBUThCLEtBQVI5QixDQURGO0FBUEEsTUFBQSxNQVdFLE9BQUE4QixLQUFBOUIsT0FBQUEsQ0FBU0osSUFBVEksQ0FYRixDQUFBO0FBREZBLElBQUFBLENBQUFBLGdDQUFBQSxDQXRFQTtBQUFBO0FBc0ZBa0MsSUFBQUEsdUJBQUFBLHdCQUFBQSxTQUFRLEtBQVJBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsYUFBQSxRQUFLSixLQUFMO0FBQUEsTUFDQSxJQUFLLHVDQUFMLEdBQ0UsT0FBQUssVUFBQUMsVUFBQVgsUUFBQVcsRUFBT04sS0FBQUYsYUFBQUEsQ0FBQUEsQ0FBUFEsQ0FBQUQsRUFBMkJDLFVBQUFWLFFBQUFVLEVBQU9OLEtBQUFILFdBQUFBLENBQUFBLENBQVBTLENBQTNCRCxDQUFBRCxRQUFBQSxDQUFzRGpDLENBQXREaUMsQ0FERjtBQURBLE1BQUEsS0FJQSxJQUFLLHNDQUFMLEdBQ0UsT0FBQUMsVUFBQVYsUUFBQVUsRUFBT0MsVUFBQVYsUUFBQVUsRUFBT04sS0FBUE0sQ0FBUEQsQ0FBQUQsUUFBQUEsQ0FBd0JqQyxDQUF4QmlDLENBREY7QUFKQSxNQUFBLEtBT0EsSUFBSyxvQ0FBTCxHQUNFLFdBQUFILE1BQUFBLENBQUFBLENBQUFHLFFBQUFBLENBQVNKLEtBQVRJLENBREY7QUFQQSxNQUFBLE1BV0UsV0FBQUcsYUFBQUEsQ0FBWSxPQUFNUCxLQUFsQk8sQ0FYRixDQUFBO0FBREZILElBQUFBLENBQUFBLG1DQUFBQSxDQXRGQTtBQUFBO0FBc0dBSSxJQUFBQSxxQkFBQUEsb0JBQUFBLFNBQU0sS0FBTkE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSxhQUFBLFFBQUtSLEtBQUw7QUFBQSxNQUNBLElBQUssdUNBQUw7QUFDRSxNQUFBakMsTUFBTXlDLFNBQUFGLFVBQUFYLFFBQUFXLEVBQU9OLEtBQUFGLGFBQUFBLENBQUFBLENBQVBRLENBQUFFLEVBQTJCRixVQUFBVixRQUFBVSxFQUFPTixLQUFBSCxXQUFBQSxDQUFBQSxDQUFQUyxDQUEzQkUsQ0FBTjtBQUFBLE1BQ0F2QyxNQUFNcUMsVUFBQVYsUUFBQVUsRUFBT04sS0FBQUYsYUFBQUEsQ0FBQUEsQ0FBUFEsQ0FETjtBQUFBLE1BR0EsV0FBQUcsVUFBQUEsQ0FBUzFDLEtBQUtFLEdBQWR3QyxDQUhBLENBREY7QUFEQSxNQUFBLEtBT0EsSUFBSyxzQ0FBTCxHQUNFLFdBQUFBLFVBQUFBLENBQVNELFNBQUFiLFFBQUFhLEVBQU9GLFVBQUFOLEtBQUFNLEVBQVFWLFFBQVJVLENBQVBFLEdBQXFCWixRQUE5QmEsQ0FERjtBQVBBLE1BQUEsS0FVQSxJQUFLLG9DQUFMLEdBQ0UsT0FBQUQsYUFBQVAsTUFBQUEsQ0FBQUEsQ0FBQU8sRUFBT1IsS0FBUFEsQ0FERjtBQVZBLE1BQUEsTUFjRSxXQUFBRCxhQUFBQSxDQUFZLEtBQUlQLEtBQWhCTyxDQWRGLENBQUE7QUFERkMsSUFBQUEsQ0FBQUEsK0JBQUFBLENBdEdBO0FBQUE7QUF5SEFILElBQUFBLHFCQUFBQSxzQkFBQUEsU0FBTSxLQUFOQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLGFBQUEsUUFBS0wsS0FBTDtBQUFBLE1BQ0EsSUFBSyx1Q0FBTDtBQUNFLE1BQUFqQyxNQUFNc0MsVUFBQUMsVUFBQVgsUUFBQVcsRUFBT04sS0FBQUYsYUFBQUEsQ0FBQUEsQ0FBUFEsQ0FBQUQsRUFBMkJDLFVBQUFWLFFBQUFVLEVBQU9OLEtBQUFILFdBQUFBLENBQUFBLENBQVBTLENBQTNCRCxDQUFOO0FBQUEsTUFDQXBDLE1BQU1xQyxVQUFBVixRQUFBVSxFQUFPTixLQUFBRixhQUFBQSxDQUFBQSxDQUFQUSxDQUROO0FBQUEsTUFHQSxXQUFBRyxVQUFBQSxDQUFTMUMsS0FBS0UsR0FBZHdDLENBSEEsQ0FERjtBQURBLE1BQUEsS0FPQSxJQUFLLHNDQUFMLEdBQ0UsV0FBQUEsVUFBQUEsQ0FBU0osVUFBQVYsUUFBQVUsRUFBT0MsVUFBQU4sS0FBQU0sRUFBUVYsUUFBUlUsQ0FBUEQsR0FBcUJULFFBQTlCYSxDQURGO0FBUEEsTUFBQSxLQVVBLElBQUssb0NBQUwsR0FDRSxPQUFBSixjQUFBSixNQUFBQSxDQUFBQSxDQUFBSSxFQUFPTCxLQUFQSyxDQURGO0FBVkEsTUFBQSxNQWNFLFdBQUFFLGFBQUFBLENBQVksS0FBSVAsS0FBaEJPLENBZEYsQ0FBQTtBQURGRixJQUFBQSxDQUFBQSxpQ0FBQUEsQ0F6SEE7QUFBQTtBQTRJQUMsSUFBQUEscUJBQUFBLGlCQUFBQSxTQUFNLEtBQU5BO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsYUFBQSxRQUFLTixLQUFMO0FBQUEsTUFDQSxJQUFLLHVDQUFMO0FBQ0UsTUFBQWpDLE1BQU11QyxVQUFBWCxRQUFBVyxFQUFPTixLQUFBSCxXQUFBQSxDQUFBQSxDQUFQUyxDQUFOO0FBQUEsTUFDQXJDLE1BQU1xQyxVQUFBVixRQUFBVSxFQUFPTixLQUFBRixhQUFBQSxDQUFBQSxDQUFQUSxDQUROO0FBQUEsTUFHQSxXQUFBRyxVQUFBQSxDQUFTMUMsS0FBS0UsR0FBZHdDLENBSEEsQ0FERjtBQURBLE1BQUEsS0FPQSxJQUFLLHNDQUFMLEdBQ0UsV0FBQUEsVUFBQUEsQ0FBU0gsVUFBQVgsUUFBQVcsRUFBT04sS0FBUE0sR0FBY1YsUUFBdkJhLENBREY7QUFQQSxNQUFBLEtBVUEsSUFBSyxvQ0FBTCxHQUNFLE9BQUFILGNBQUFMLE1BQUFBLENBQUFBLENBQUFLLEVBQU9OLEtBQVBNLENBREY7QUFWQSxNQUFBLE1BY0UsV0FBQUMsYUFBQUEsQ0FBWSxLQUFJUCxLQUFoQk8sQ0FkRixDQUFBO0FBREZELElBQUFBLENBQUFBLDRCQUFBQSxDQTVJQTtBQUFBO0FBK0pBNUIsSUFBQUEscUJBQUFBLHNCQUFBQSxTQUFNLEtBQU5BO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsYUFBQSxRQUFLc0IsS0FBTDtBQUFBLE1BQ0EsSUFBSyx1Q0FBTDtBQUNFLE1BQUFqQyxNQUFNdUMsVUFBQVgsUUFBQVcsRUFBT04sS0FBQUYsYUFBQUEsQ0FBQUEsQ0FBUFEsQ0FBTjtBQUFBLE1BQ0FyQyxNQUFNcUMsVUFBQVYsUUFBQVUsRUFBT04sS0FBQUgsV0FBQUEsQ0FBQUEsQ0FBUFMsQ0FETjtBQUFBLE1BR0EsV0FBQUcsVUFBQUEsQ0FBUzFDLEtBQUtFLEdBQWR3QyxDQUhBLENBREY7QUFEQSxNQUFBLEtBT0EsSUFBSyxzQ0FBTCxHQUNFLElBQUdULEtBQUE5QixPQUFBQSxDQUFTQyxDQUFURCxDQUFIO0FBQUEsUUFDRSxPQUFBUSxlQUFBdUIsTUFBQUEsQ0FBQUEsQ0FBQXZCLEVBQU8sR0FBUEE7QUFERixNQUFBO0FBQUEsUUFHRSxXQUFBK0IsVUFBQUEsQ0FBU2QsVUFBTVcsVUFBQVYsUUFBQVUsRUFBT04sS0FBUE0sQ0FBZkc7QUFIRixNQUFBLENBREY7QUFQQSxNQUFBLEtBY0EsSUFBSyxvQ0FBTCxHQUNFLE9BQUEvQixlQUFBdUIsTUFBQUEsQ0FBQUEsQ0FBQXZCLEVBQU9zQixLQUFQdEIsQ0FERjtBQWRBLE1BQUEsTUFrQkUsV0FBQTZCLGFBQUFBLENBQVksS0FBSVAsS0FBaEJPLENBbEJGLENBQUE7QUFERjdCLElBQUFBLENBQUFBLGlDQUFBQSxDQS9KQTtBQUFBO0FBc0xBZ0MsSUFBQUEsc0JBQUFBLGtCQUFBQSxTQUFPLEtBQVBBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsYUFBQSxRQUFLVixLQUFMO0FBQUEsTUFDQSxJQUFLLHNDQUFMLEdBQ0UsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQTdMVFcsQ0FBQUEsYUE2TFM3QyxJQUFBSSxPQUFBQSxDQUFRQyxDQUFSRCxDQTdMVHlDLENBNkxTLENBQUE7QUFBQSxRQUFhLE9BQUF0QyxPQUFBMkIsS0FBQTNCLEVBQVFGLENBQVJFO0FBQWIsTUFBQTtBQUFBLFFBN0xULE9BQUE7QUE2TFMsTUFBQSxDQUFBLGtCQUFILENBQUE7QUFBQSxRQUNFLE9BQUEsSUFBQSxxQkFBQTtBQURGLE1BQUEsT0FFQSxJQUFBLFFBQU11QyxPQUFBWixLQUFBWSxFQUFRekMsQ0FBUnlDLENBQU4sQ0FBQTtBQUFBLFFBQ0UsV0FBQUgsVUFBQUEsQ0FBU2QsUUFBQWUsT0FBQUEsQ0FBTVYsS0FBTlUsR0FBYWQsUUFBQWMsT0FBQUEsQ0FBTVYsS0FBTlUsQ0FBdEJEO0FBREYsTUFBQSxPQUVBLElBQUEsUUFBTXBDLE9BQUEyQixLQUFBM0IsRUFBUUYsQ0FBUkUsQ0FBTixDQUFBO0FBQUEsUUFDRSxXQUFBb0MsVUFBQUEsQ0FBU2IsUUFBQWMsT0FBQUEsQ0FBT1YsS0FBRDFCLE9BQUFBLENBQUFBLENBQU5vQyxHQUFjZixRQUFBZSxPQUFBQSxDQUFPVixLQUFEMUIsT0FBQUEsQ0FBQUEsQ0FBTm9DLENBQXZCRDtBQURGLE1BQUE7QUFBQSxRQUdFLFdBQUFBLFVBQUFBLENBQVNsQyxHQUFHQSxDQUFaa0M7QUFIRixNQUFBLENBTEY7QUFEQSxNQUFBLEtBWUEsSUFBSyxvQ0FBTCxHQUNFLFdBQUFSLE1BQUFBLENBQUFBLENBQUFTLE9BQUFBLENBQU1WLEtBQU5VLENBREY7QUFaQSxNQUFBLEtBZUEsSUFBSyx1Q0FBTCxHQUNFLElBQUdWLEtBQUE5QixPQUFBQSxDQUFTQyxDQUFURCxDQUFIO0FBQUEsUUFDRSxXQUFBdUMsVUFBQUEsQ0FBU2xDLEdBQUdBLENBQVprQztBQURGLE1BQUEsT0FFQSxJQUFNVCxLQUFBRixhQUFBQSxDQUFBQSxDQUFBNUIsT0FBQUEsQ0FBcUJLLENBQXJCTCxDQUFOO0FBQUEsUUFDRSxJQUFBLFFBQUdHLE9BQUEyQixLQUFBM0IsRUFBUUYsQ0FBUkUsQ0FBSCxDQUFBO0FBQUEsVUFDRSxXQUFBb0MsVUFBQUEsQ0FBU2IsUUFBQWMsT0FBQUEsQ0FBTVYsS0FBQUgsV0FBQUEsQ0FBQUEsQ0FBQWdCLEtBQUFBLENBQUFBLENBQU5ILEdBQTJCZixRQUFBZSxPQUFBQSxDQUFNVixLQUFBSCxXQUFBQSxDQUFBQSxDQUFBZ0IsS0FBQUEsQ0FBQUEsQ0FBTkgsQ0FBcENEO0FBREYsUUFBQTtBQUFBLFVBR0UsV0FBQUEsVUFBQUEsQ0FBU2QsUUFBQWUsT0FBQUEsQ0FBTVYsS0FBQUgsV0FBQUEsQ0FBQUEsQ0FBTmEsR0FBdUJkLFFBQUFjLE9BQUFBLENBQU1WLEtBQUFILFdBQUFBLENBQUFBLENBQU5hLENBQWhDRDtBQUhGLFFBQUE7QUFERixNQUFBLE9BTUEsSUFBQSxRQUFNLGFBQUEsSUFBQSxRQW5OWkssQ0FBQUEsYUFtTlloRCxJQUFBSSxPQUFBQSxDQUFRQyxDQUFSRCxDQW5OWjRDLENBbU5ZLENBQUE7QUFBQSxRQUFhLE9BQUF6QyxPQUFBMkIsS0FBQTNCLEVBQVFGLENBQVJFO0FBQWIsTUFBQTtBQUFBLFFBbk5aLE9BQUE7QUFtTlksTUFBQSxDQUFBLGtCQUFOLENBQUE7QUFBQSxRQUNFLFdBQUFELE9BQUFBLENBQU0sbUNBQW1CLGNBQXpCQTtBQURGLE1BQUE7QUFBQSxRQUdFLFdBQUE2QixNQUFBQSxDQUFBQSxDQUFBUyxPQUFBQSxDQUFNVixLQUFOVTtBQUhGLE1BQUEsQ0FURjtBQWZBLE1BQUEsTUErQkUsV0FBQUgsYUFBQUEsQ0FBWSxNQUFLUCxLQUFqQk8sQ0EvQkYsQ0FBQTtBQURGRyxJQUFBQSxDQUFBQSw2QkFBQUEsQ0F0TEE7QUFBQTtBQTBOQUcsSUFBQUEsdUJBQUFBLG1CQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBSixVQUFBQSxDQUFTZCxRQUFBa0IsS0FBQUEsQ0FBQUEsR0FBVWpCLFFBQUFpQixLQUFBQSxDQUFBQSxDQUFuQko7QUFERkksSUFBQUEsQ0FBQUEsOEJBQUFBLENBMU5BO0FBQUE7QUE4TkFFLElBQUFBLHdCQUFBQSxvQkFBQUEsZ0JBQVMsU0FBVEE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBbE9GO0FBa09XLE1BQUE7QUFBQSxNQUFBLGNBQVk1QyxDQUFaO0FBQUEsTUFBQSxDQWxPWDtBQUFBLE1BbU9JLElBQUc2QyxTQUFBOUMsT0FBQUEsQ0FBYUMsQ0FBYkQsQ0FBSDtBQUFBLFFBQ0UsT0FBR1EsV0FBQ2lCLFFBQURyQixPQUFBQSxDQUFBQSxDQUFBSSxFQUFRa0IsUUFBUmxCLENBQUZKLE9BQUFBLENBQUFBLENBQUR5QyxNQUFBQSxDQUFBQTtBQURGLE1BQUE7QUFBQSxRQUdFLFdBQUFFLGdCQUFBQSxDQUFlLFFBQU9ELFNBQXRCQztBQUhGLE1BQUEsQ0FuT0o7QUFrT0VGLElBQUFBLENBQUFBLGdDQUFBQSxDQTlOQTtBQUFBLElBc09BLGlCQUFNLFFBQU4sRUFBYSxHQUFiLENBdE9BO0FBQUE7QUF3T0FHLElBQUFBLHlCQUFBQSxxQkFBQUEsaUJBQVUsU0FBVkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBNU9GO0FBNE9ZLE1BQUE7QUFBQSxNQUFBLGNBQVkvQyxDQUFaO0FBQUEsTUFBQSxDQTVPWjtBQUFBLE1BNk9JLElBQUc2QyxTQUFBOUMsT0FBQUEsQ0FBYUMsQ0FBYkQsQ0FBSDtBQUFBLFFBQ0UsT0FBR1EsV0FBQ2lCLFFBQURyQixPQUFBQSxDQUFBQSxDQUFBSSxFQUFRa0IsUUFBUmxCLENBQUZKLE9BQUFBLENBQUFBLENBQUQ0QyxPQUFBQSxDQUFBQTtBQURGLE1BQUE7QUFBQSxRQUdFLFdBQUFELGdCQUFBQSxDQUFlLFNBQVFELFNBQXZCQztBQUhGLE1BQUEsQ0E3T0o7QUE0T0VDLElBQUFBLENBQUFBLGlDQUFBQSxDQXhPQTtBQUFBO0FBZ1BBQyxJQUFBQSx3QkFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLEVBQUEsR0FBQSxXQUFBLEdBQUEsQ0FBWXhCLFFBQVosQ0FBQSxHQUFBLEdBQUEsR0FBQSxDQUFvQkMsUUFBcEI7QUFERnVCLElBQUFBLENBQUFBLCtCQUFBQSxDQWhQQTtBQUFBO0FBb1BBQyxJQUFBQSwyQkFBQUEsdUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxPQUFBLEVBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBSXRELElBQUosQ0FBQSxHQUFBO0FBREZzRCxJQUFBQSxDQUFBQSxrQ0FBQUEsQ0FwUEE7QUFBQSxJQXdQQSxpQkFBTSxLQUFOLEVBQVUsR0FBVixDQXhQQTtBQUFBO0FBMFBBQyxJQUFBQSwrQkFBQUEsMkJBQUFBLHVCQUFnQixHQUFoQkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBOVBGLE1BQUE7QUFBQTtBQWdRQTtBQUNBLFlBQVVqRCxPQUFBQSxDQUFNLCtCQUFlLEVBQUEsR0FBQSw2QkFBQSxHQUFBLENBQStCLGdCQUEvQixDQUFBLEdBQUEsWUFBckJBLENBQWtGO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFnQmtELEdBQUFULEtBQUFBLENBQUFBLENBQVE7QUFDeEIsY0FBZ0JSLFVBQUF2QyxJQUFBdUMsRUFBUSxDQUFSQSxDQUFXO0FBQzNCLGNBQWdCRyxTQUFBMUMsSUFBQTBDLEVBQVEsQ0FBUkEsQ0FBVzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQWMsQ0FBQyxDQUFELENBQUFPLE1BQUFBLENBQUFBLENBQVM7O0FBRXZCLFlBQWNRLE9BQUMsQ0FBREEsRUFBUSxDQUFSQSxDQUFXO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBZTdDLFdBQUFILENBQUFHLEVBQUsyQixVQUFDLENBQURBLEVBQU8sQ0FBUEEsQ0FBTDNCLENBQWdCO0FBQy9CLGFBQWVBLFdBQUFILENBQUFHLEVBQUsyQixVQUFDLENBQURBLEVBQU8sQ0FBUEEsQ0FBTDNCLENBQWdCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWUrQixVQUFBQSxDQUFVLGFBQWUsV0FBekJBLENBQXVDO0FBQ3RELElBelNBO0FBOFBFWSxJQUFBQSxDQUFBQSx1Q0FBQUEsQ0ExUEE7QUFBQTtBQXdTQUcsSUFBQUEseUJBQUFBLHFCQUFBQSxpQkFBVSxTQUFWQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUE1U0Y7QUE0U1ksTUFBQTtBQUFBLE1BQUEsY0FBWXJELENBQVo7QUFBQSxNQUFBLENBNVNaO0FBQUEsTUE2U0ksSUFBZ0Q2QyxTQUFBOUMsT0FBQUEsQ0FBYUMsQ0FBYkQsQ0FBaEQ7QUFBQSxNQUFBO0FBQUEsUUFBQSxXQUFPK0MsZ0JBQUFBLENBQWUsU0FBUUQsU0FBdkJDO0FBQVAsTUFBQSxDQTdTSjtBQUFBLE1BOFNJLElBQVl0QixRQUFBekIsT0FBQUEsQ0FBUUMsQ0FBUkQsQ0FBWjtBQUFBLFFBQUEsT0FBT0MsQ0FBUCxDQTlTSjtBQUFBLE1BK1NJLElBQWV5QixRQUFBMUIsT0FBQUEsQ0FBUUssQ0FBUkwsQ0FBZjtBQUFBLFFBQUEsT0FBT3lCLFFBQVAsQ0EvU0o7QUFBQSxNQWlUSTVCLE1BQU15QyxTQUFBRixVQUFBWCxRQUFBa0IsS0FBQUEsQ0FBQUEsQ0FBQVAsRUFBV21CLENBQVhuQixDQUFBRSxFQUFlWixRQUFmWSxDQWpUVjtBQUFBLE1Ba1RJdkMsTUFBTXFDLFVBQUFWLFFBQUFVLEVBQU9tQixDQUFQbkIsQ0FsVFY7QUFBQSxNQW9USW9CLFNBQVVoRCxXQUFBWCxHQUFBVyxFQUFNVCxHQUFOUyxDQUFEaUQsVUFBQUEsQ0FBQUEsQ0FwVGI7QUFBQSxNQXNUSSxJQUFBLFFBQUd0RCxPQUFBc0IsUUFBQXRCLEVBQU9GLENBQVBFLENBQUgsQ0FBQTtBQUFBLFFBQ0UsT0FBQ3FELE1BQURwRCxPQUFBQSxDQUFBQTtBQURGLE1BQUE7QUFBQSxRQUdFLE9BQUFvRDtBQUhGLE1BQUEsQ0F0VEo7QUE0U0VGLElBQUFBLENBQUFBLGlDQUFBQSxDQXhTQTtBQUFBO0FBeVRBdkIsSUFBQUEsd0JBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQXZCLFdBQUFpQixRQUFBakIsRUFBT2tCLFFBQVBsQjtBQURGdUIsSUFBQUEsQ0FBQUEsK0JBQUFBLENBelRBO0FBQUE7QUE2VEFqQyxJQUFBQSx3QkFBQUEsb0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUEsTUFDRSxXQUFBMkQsVUFBQUEsQ0FBQUE7QUFERjNELElBQUFBLENBQUFBLCtCQUFBQSxDQTdUQTtBQUFBO0FBaVVBa0IsSUFBQUEsd0JBQUFBLG9CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQXBCO0FBREZvQixJQUFBQSxDQUFBQSwrQkFBQUEsQ0FqVUE7QUFBQTtBQXFVQTBDLElBQUFBLHdCQUFBQSxvQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUNFLE9BQUEsRUFBQSxHQUFBLENBQUdqQyxRQUFILENBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBV0MsUUFBWDtBQURGZ0MsSUFBQUEsQ0FBQUEsK0JBQUFBLENBclVBO0FBQUE7QUF5VUFELElBQUFBLDRCQUFBQSx3QkFBQUEsb0JBQWEsU0FBYkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBN1VGO0FBNlVlLE1BQUE7QUFBQSxNQUFBLGNBQVl4RCxDQUFaO0FBQUEsTUFBQSxDQTdVZjtBQUFBLE1BOFVJLElBQUc2QyxTQUFBOUMsT0FBQUEsQ0FBYUMsQ0FBYkQsQ0FBSDtBQUFBLFFBQ0UsSUFBQSxRQUFBRyxPQUFBc0IsUUFBQXRCLEVBQU9GLENBQVBFLENBQUEsQ0FBQTtBQUFBLFVBQVcsV0FBQTBDLE1BQUFBLENBQUFBO0FBQVgsUUFBQTtBQUFBLFVBQWtCLFdBQUFHLE9BQUFBLENBQUFBO0FBQWxCLFFBQUE7QUFERixNQUFBO0FBQUEsUUFHRSxXQUFBRCxnQkFBQUEsQ0FBZSxZQUFXRCxTQUExQkM7QUFIRixNQUFBLENBOVVKO0FBNlVFVSxJQUFBQSxDQUFBQSxvQ0FBQUEsQ0F6VUE7QUFBQSxJQWlWQSxPQUFBVixDQUFBQSxrQ0FBQUEsOEJBQUFBLDBCQUFtQixNQUFELEVBQVMsU0FBM0JBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFLE1BQUEsSUFBQSxRQUF5Qyx1QkFBQWxDLFFBQUFBLENBQVlpQyxTQUFaakMsQ0FBekMsQ0FBQTtBQUFBLE1BQUE7QUFBQSxZQUFBWCxPQUFBQSxDQUFNLDJCQUFXLGdCQUFqQkE7QUFBQSxNQUFBLENBQUE7QUFBQSxNQUVBeUQsSUFBSUMsQ0FBQUEsRUFBQUEsQ0FBQXBCLE9BQUFBLENBQUlNLFNBQUpOLENBRko7QUFBQSxNQUdBcUIsSUFBSXpCLFVBQUF4QyxJQUFBd0MsRUFBT3VCLENBQVB2QixDQUhKO0FBQUEsTUFLQSxJQUFBLFFBQUdqQyxPQUFBMkMsU0FBQTNDLEVBQVlFLENBQVpGLENBQUgsQ0FBQTtBQUFBLFFBQ0UsT0FBQ0ssV0FBQXFELENBQUFDLE1BQUFBLENBQU9DLE1BQVBELENBQUF0RCxFQUFpQm1ELENBQWpCbkQsQ0FBRFYsTUFBQUEsQ0FBQUE7QUFERixNQUFBO0FBQUEsUUFHRSxXQUFBeUMsVUFBQUEsQ0FBU3NCLENBQUFDLE1BQUFBLENBQU9DLE1BQVBELEdBQWdCSCxDQUF6QnBCO0FBSEYsTUFBQSxDQUxBO0FBREZRLElBQUFBLENBQUFBLHlDQUFBQSxDQUFBQSwwQkFqVkE7QUFERnJELEVBQUFBLEdBQUFBLFdBQUFBLEVBQWlCLHVCQUFqQkEsV0FGQTtBQUFBLEVBa1dBc0U7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUF6QixDQUFBQSw0QkFBQUEsc0JBQUFBLG9CQUFhLFNBQUQsRUFBWSxXQUF4QkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBcFdGO0FBb1cwQixNQUFBO0FBQUEsTUFBQSxnQkFBY2xDLENBQWQ7QUFBQSxNQUFBLENBcFcxQjtBQUFBLE1BcVdJLE9BQUEsd0JBQUFJLFNBQUFBLENBQWlCa0IsV0FBV0MsV0FBNUJuQixDQXJXSjtBQW9XRThCLElBQUFBLENBQUFBLGtDQUFBQSxDQUFBQTtBQURGeUIsRUFBQUEsR0FBQUEsV0FBQUEsV0FsV0E7QUFBQSxFQXdXQSxPQUFBdEU7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUFzQixDQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBcUJ1QixVQUFBQSxDQUFVLFdBQWEsV0FBdkJBLENBQXFDO0FBQzFEO0FBQ0EsdUJBQXFCQSxVQUFBQSxDQUFVLFdBQVlsQyxDQUF0QmtDLENBQXlCO0FBQzlDO0FBQ0E7QUFDQSxxQkFBbUJBLFVBQUFBLENBQVUsV0FBWWxDLENBQXRCa0MsQ0FBeUI7QUFDNUM7QUFDQTtBQUNBLG1CQUFpQkEsVUFBQUEsQ0FBU3RDLEdBQUdJLENBQVprQyxDQUFlO0FBQ2hDO0FBQ0E7QUFyQ0V2QixJQUFBQSxDQUFBQSw2QkFBQUEsQ0FBQUE7QUFERnRCLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBeFdBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjIwNzksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3RpbWUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBzbGljZVxuXG5yZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXG5cbmNsYXNzIFRpbWUgPCBgRGF0ZWBcbiAgaW5jbHVkZSBDb21wYXJhYmxlXG5cbiAgJXh7XG4gICAgdmFyIGRheXNfb2Zfd2VlayA9ICN7JXdbU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXkgU3VuZGF5XX0sXG4gICAgICAgIHNob3J0X2RheXMgICA9ICN7JXdbU3VuIE1vbiBUdWUgV2VkIFRodSBGcmkgU2F0XX0sXG4gICAgICAgIHNob3J0X21vbnRocyA9ICN7JXdbSmFuIEZlYiBNYXIgQXByIE1heSBKdW4gSnVsIEF1ZyBTZXAgT2N0IE5vdiBEZWNdfSxcbiAgICAgICAgbG9uZ19tb250aHMgID0gI3sld1tKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXX07XG4gIH1cblxuICBkZWYgc2VsZi5hdChzZWNvbmRzLCBmcmFjID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKCN7VGltZSA9PT0gc2Vjb25kc30pIHtcbiAgICAgICAgaWYgKGZyYWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgVGltZSBpbnRvIGFuIGV4YWN0IG51bWJlclwifVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKHNlY29uZHMuZ2V0VGltZSgpKTtcbiAgICAgICAgcmVzdWx0LmlzX3V0YyA9IHNlY29uZHMuaXNfdXRjO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlY29uZHMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgc2Vjb25kcyA9ICN7T3BhbC5jb2VyY2VfdG8hKHNlY29uZHMsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyYWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoc2Vjb25kcyAqIDEwMDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZyYWMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgZnJhYyA9ICN7T3BhbC5jb2VyY2VfdG8hKGZyYWMsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEYXRlKHNlY29uZHMgKiAxMDAwICsgKGZyYWMgLyAxMDAwKSk7XG4gICAgfVxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYykge1xuICAgICAgaWYgKHllYXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgeWVhciA9IHBhcnNlSW50KHllYXIsIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHllYXIgPSAje09wYWwuY29lcmNlX3RvIShgeWVhcmAsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vbnRoID09PSBuaWwpIHtcbiAgICAgICAgbW9udGggPSAxO1xuICAgICAgfSBlbHNlIGlmICghbW9udGguJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKCN7YG1vbnRoYC5yZXNwb25kX3RvPyg6dG9fc3RyKX0pIHtcbiAgICAgICAgICBtb250aCA9ICN7YG1vbnRoYC50b19zdHJ9O1xuICAgICAgICAgIHN3aXRjaCAobW9udGgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgJ2phbic6IG1vbnRoID0gIDE7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2ZlYic6IG1vbnRoID0gIDI7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21hcic6IG1vbnRoID0gIDM7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Fwcic6IG1vbnRoID0gIDQ7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21heSc6IG1vbnRoID0gIDU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2p1bic6IG1vbnRoID0gIDY7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2p1bCc6IG1vbnRoID0gIDc7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2F1Zyc6IG1vbnRoID0gIDg7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NlcCc6IG1vbnRoID0gIDk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ29jdCc6IG1vbnRoID0gMTA7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ25vdic6IG1vbnRoID0gMTE7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2RlYyc6IG1vbnRoID0gMTI7IGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IG1vbnRoID0gI3tgbW9udGhgLnRvX2l9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb250aCA9ICN7T3BhbC5jb2VyY2VfdG8hKGBtb250aGAsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm1vbnRoIG91dCBvZiByYW5nZTogI3tgbW9udGhgfVwifVxuICAgICAgfVxuICAgICAgbW9udGggPSBtb250aCAtIDE7XG5cbiAgICAgIGlmIChkYXkgPT09IG5pbCkge1xuICAgICAgICBkYXkgPSAxO1xuICAgICAgfSBlbHNlIGlmIChkYXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgZGF5ID0gcGFyc2VJbnQoZGF5LCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXkgPSAje09wYWwuY29lcmNlX3RvIShgZGF5YCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF5IDwgMSB8fCBkYXkgPiAzMSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiZGF5IG91dCBvZiByYW5nZTogI3tgZGF5YH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKGhvdXIgPT09IG5pbCkge1xuICAgICAgICBob3VyID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoaG91ci4kJGlzX3N0cmluZykge1xuICAgICAgICBob3VyID0gcGFyc2VJbnQoaG91ciwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG91ciA9ICN7T3BhbC5jb2VyY2VfdG8hKGBob3VyYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaG91ciA8IDAgfHwgaG91ciA+IDI0KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJob3VyIG91dCBvZiByYW5nZTogI3tgaG91cmB9XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW4gPT09IG5pbCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfSBlbHNlIGlmIChtaW4uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgbWluID0gcGFyc2VJbnQobWluLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW4gPSAje09wYWwuY29lcmNlX3RvIShgbWluYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAobWluIDwgMCB8fCBtaW4gPiA1OSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibWluIG91dCBvZiByYW5nZTogI3tgbWluYH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYyA9PT0gbmlsKSB7XG4gICAgICAgIHNlYyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKCFzZWMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKHNlYy4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHNlYyA9IHBhcnNlSW50KHNlYywgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlYyA9ICN7T3BhbC5jb2VyY2VfdG8hKGBzZWNgLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYyA8IDAgfHwgc2VjID4gNjApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInNlYyBvdXQgb2YgcmFuZ2U6ICN7YHNlY2B9XCJ9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWNdO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBzZWxmLm5ldyh5ZWFyID0gdW5kZWZpbmVkLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgdXRjX29mZnNldCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG5cbiAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGNfb2Zmc2V0ICE9PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnT3BhbCBkb2VzIG5vdCBzdXBwb3J0IGV4cGxpY2l0bHkgc3BlY2lmeWluZyBVVEMgb2Zmc2V0IGZvciBUaW1lJ31cbiAgICAgIH1cblxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XG4gICAgICBtb250aCA9IGFyZ3NbMV07XG4gICAgICBkYXkgICA9IGFyZ3NbMl07XG4gICAgICBob3VyICA9IGFyZ3NbM107XG4gICAgICBtaW4gICA9IGFyZ3NbNF07XG4gICAgICBzZWMgICA9IGFyZ3NbNV07XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgMCwgc2VjICogMTAwMCk7XG4gICAgICBpZiAoeWVhciA8IDEwMCkge1xuICAgICAgICByZXN1bHQuc2V0RnVsbFllYXIoeWVhcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYubG9jYWwoeWVhciwgbW9udGggPSBuaWwsIGRheSA9IG5pbCwgaG91ciA9IG5pbCwgbWluID0gbmlsLCBzZWMgPSBuaWwsIG1pbGxpc2Vjb25kID0gbmlsLCBfZHVtbXkxID0gbmlsLCBfZHVtbXkyID0gbmlsLCBfZHVtbXkzID0gbmlsKVxuICAgICMgVGhlIF9kdW1teSBhcmdzIGFyZSB0aGVyZSBvbmx5IGJlY2F1c2UgdGhlIE1SSSB2ZXJzaW9uIGFjY2VwdHMgdXAgdG8gMTAgYXJndW1lbnRzXG4gICAgJXh7XG4gICAgICB2YXIgYXJncywgcmVzdWx0O1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgICAgYXJncyAgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB5ZWFyICA9IGFyZ3NbNV07XG4gICAgICAgIG1vbnRoID0gYXJnc1s0XTtcbiAgICAgICAgZGF5ICAgPSBhcmdzWzNdO1xuICAgICAgICBob3VyICA9IGFyZ3NbMl07XG4gICAgICAgIG1pbiAgID0gYXJnc1sxXTtcbiAgICAgICAgc2VjICAgPSBhcmdzWzBdO1xuICAgICAgfVxuXG4gICAgICBhcmdzICA9IHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKTtcbiAgICAgIHllYXIgID0gYXJnc1swXTtcbiAgICAgIG1vbnRoID0gYXJnc1sxXTtcbiAgICAgIGRheSAgID0gYXJnc1syXTtcbiAgICAgIGhvdXIgID0gYXJnc1szXTtcbiAgICAgIG1pbiAgID0gYXJnc1s0XTtcbiAgICAgIHNlYyAgID0gYXJnc1s1XTtcblxuICAgICAgcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHJlc3VsdC5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5nbSh5ZWFyLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgbWlsbGlzZWNvbmQgPSBuaWwsIF9kdW1teTEgPSBuaWwsIF9kdW1teTIgPSBuaWwsIF9kdW1teTMgPSBuaWwpXG4gICAgIyBUaGUgX2R1bW15IGFyZ3MgYXJlIHRoZXJlIG9ubHkgYmVjYXVzZSB0aGUgTVJJIHZlcnNpb24gYWNjZXB0cyB1cCB0byAxMCBhcmd1bWVudHNcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxMCkge1xuICAgICAgICBhcmdzICA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHllYXIgID0gYXJnc1s1XTtcbiAgICAgICAgbW9udGggPSBhcmdzWzRdO1xuICAgICAgICBkYXkgICA9IGFyZ3NbM107XG4gICAgICAgIGhvdXIgID0gYXJnc1syXTtcbiAgICAgICAgbWluICAgPSBhcmdzWzFdO1xuICAgICAgICBzZWMgICA9IGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgID0gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpO1xuICAgICAgeWVhciAgPSBhcmdzWzBdO1xuICAgICAgbW9udGggPSBhcmdzWzFdO1xuICAgICAgZGF5ICAgPSBhcmdzWzJdO1xuICAgICAgaG91ciAgPSBhcmdzWzNdO1xuICAgICAgbWluICAgPSBhcmdzWzRdO1xuICAgICAgc2VjICAgPSBhcmdzWzVdO1xuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHJlc3VsdC5zZXRVVENGdWxsWWVhcih5ZWFyKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5pc191dGMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhbGlhcyBta3RpbWUgbG9jYWxcbiAgICBhbGlhcyB1dGMgZ21cbiAgZW5kXG5cbiAgZGVmIHNlbGYubm93XG4gICAgbmV3XG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIGlmIFRpbWUgPT09IG90aGVyXG4gICAgICByYWlzZSBUeXBlRXJyb3IsICd0aW1lICsgdGltZT8nXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgb3RoZXIgPSAje09wYWwuY29lcmNlX3RvIShvdGhlciwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpICsgKG90aGVyICogMTAwMCkpO1xuICAgICAgcmVzdWx0LmlzX3V0YyA9IHNlbGYuaXNfdXRjO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIGlmIFRpbWUgPT09IG90aGVyXG4gICAgICByZXR1cm4gYChzZWxmLmdldFRpbWUoKSAtIG90aGVyLmdldFRpbWUoKSkgLyAxMDAwYFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIW90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIG90aGVyID0gI3tPcGFsLmNvZXJjZV90byEob3RoZXIsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSAtIChvdGhlciAqIDEwMDApKTtcbiAgICAgIHJlc3VsdC5pc191dGMgPSBzZWxmLmlzX3V0YztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIFRpbWUgPT09IG90aGVyXG4gICAgICB0b19mIDw9PiBvdGhlci50b19mXG4gICAgZWxzZVxuICAgICAgciA9IG90aGVyIDw9PiBzZWxmXG4gICAgICBpZiByLm5pbD9cbiAgICAgICAgbmlsXG4gICAgICBlbHNpZiByID4gMFxuICAgICAgICAtMVxuICAgICAgZWxzaWYgciA8IDBcbiAgICAgICAgMVxuICAgICAgZWxzZVxuICAgICAgICAwXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIFRpbWUgPT09IG90aGVyICYmIGAje3RvX2Z9ID09PSAje290aGVyLnRvX2Z9YFxuICBlbmRcblxuICBkZWYgYXNjdGltZVxuICAgIHN0cmZ0aW1lICclYSAlYiAlZSAlSDolTTolUyAlWSdcbiAgZW5kXG5cbiAgYWxpYXMgY3RpbWUgYXNjdGltZVxuXG4gIGRlZiBkYXlcbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ0RhdGUoKSA6IHNlbGYuZ2V0RGF0ZSgpYFxuICBlbmRcblxuICBkZWYgeWRheVxuICAgICMgaHR0cDovL2phdmFzY3JpcHQuYWJvdXQuY29tL2xpYnJhcnkvYmxkYXl5ZWFyLmh0bVxuICAgICMgYWxzbyBzZWUgbW9tZW50LmpzIGltcGxlbWVudGF0aW9uOiBodHRwOi8vZ2l0LmlvL3ZDS05FXG5cbiAgICBzdGFydF9vZl95ZWFyID0gVGltZS5uZXcoeWVhcikudG9faVxuICAgIHN0YXJ0X29mX2RheSAgPSBUaW1lLm5ldyh5ZWFyLCBtb250aCwgZGF5KS50b19pXG4gICAgb25lX2RheSAgICAgICA9IDg2XzQwMFxuXG4gICAgKChzdGFydF9vZl9kYXkgLSBzdGFydF9vZl95ZWFyKSAvIG9uZV9kYXkpLnJvdW5kICsgMVxuICBlbmRcblxuICBkZWYgaXNkc3RcbiAgICAleHtcbiAgICAgIHZhciBqYW4gPSBuZXcgRGF0ZShzZWxmLmdldEZ1bGxZZWFyKCksIDAsIDEpLFxuICAgICAgICAgIGp1bCA9IG5ldyBEYXRlKHNlbGYuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XG4gICAgICByZXR1cm4gc2VsZi5nZXRUaW1lem9uZU9mZnNldCgpIDwgTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGRzdD8gaXNkc3RcblxuICBkZWYgZHVwXG4gICAgY29weSA9IGBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSlgXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBvdGhlci5pc19hPyhUaW1lKSAmJiAoc2VsZiA8PT4gb3RoZXIpLnplcm8/XG4gIGVuZFxuXG4gIGRlZiBmcmlkYXk/XG4gICAgYCN7d2RheX0gPT0gNWBcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBgJ1RpbWU6JyArIHNlbGYuZ2V0VGltZSgpYFxuICBlbmRcblxuICBkZWYgaG91clxuICAgIGBzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDSG91cnMoKSA6IHNlbGYuZ2V0SG91cnMoKWBcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBpZiB1dGM/XG4gICAgICBzdHJmdGltZSAnJVktJW0tJWQgJUg6JU06JVMgVVRDJ1xuICAgIGVsc2VcbiAgICAgIHN0cmZ0aW1lICclWS0lbS0lZCAlSDolTTolUyAleidcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgbWRheSBkYXlcblxuICBkZWYgbWluXG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENNaW51dGVzKCkgOiBzZWxmLmdldE1pbnV0ZXMoKWBcbiAgZW5kXG5cbiAgZGVmIG1vblxuICAgIGAoc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ01vbnRoKCkgOiBzZWxmLmdldE1vbnRoKCkpICsgMWBcbiAgZW5kXG5cbiAgZGVmIG1vbmRheT9cbiAgICBgI3t3ZGF5fSA9PSAxYFxuICBlbmRcblxuICBhbGlhcyBtb250aCBtb25cblxuICBkZWYgc2F0dXJkYXk/XG4gICAgYCN7d2RheX0gPT0gNmBcbiAgZW5kXG5cbiAgZGVmIHNlY1xuICAgIGBzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDU2Vjb25kcygpIDogc2VsZi5nZXRTZWNvbmRzKClgXG4gIGVuZFxuXG4gIGRlZiBzdWNjXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyAxMDAwKTtcbiAgICAgIHJlc3VsdC5pc191dGMgPSBzZWxmLmlzX3V0YztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdXNlY1xuICAgIGBzZWxmLmdldE1pbGxpc2Vjb25kcygpICogMTAwMGBcbiAgZW5kXG5cbiAgZGVmIHpvbmVcbiAgICAleHtcbiAgICAgIHZhciBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCksXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJygnKSA9PSAtMSkge1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcubWF0Y2goL1tBLVpdezMsNH0vKVswXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcubWF0Y2goL1xcKCguKylcXCkoPzpcXHN8JCkvKVsxXVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ID09IFwiR01UXCIgJiYgLyhHTVRcXFcqXFxkezR9KS8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBSZWdFeHAuJDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnZXRnbVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpKTtcbiAgICAgIHJlc3VsdC5pc191dGMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGdldHV0YyBnZXRnbVxuXG4gIGRlZiBnbXRpbWVcbiAgICAleHtcbiAgICAgIHNlbGYuaXNfdXRjID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgdXRjIGdtdGltZVxuXG4gIGRlZiBnbXQ/XG4gICAgYHNlbGYuaXNfdXRjID09PSB0cnVlYFxuICBlbmRcblxuICBkZWYgZ210X29mZnNldFxuICAgIGBzZWxmLmlzX3V0YyA/IDAgOiAtc2VsZi5nZXRUaW1lem9uZU9mZnNldCgpICogNjBgXG4gIGVuZFxuXG4gIGRlZiBzdHJmdGltZShmb3JtYXQpXG4gICAgJXh7XG4gICAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoLyUoW1xcLV8jXjBdKjp7MCwyfSkoXFxkKyk/KFtFT10qKSguKS9nLCBmdW5jdGlvbihmdWxsLCBmbGFncywgd2lkdGgsIF8sIGNvbnYpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCIsXG4gICAgICAgICAgICB6ZXJvICAgPSBmbGFncy5pbmRleE9mKCcwJykgIT09IC0xLFxuICAgICAgICAgICAgcGFkICAgID0gZmxhZ3MuaW5kZXhPZignLScpID09PSAtMSxcbiAgICAgICAgICAgIGJsYW5rICA9IGZsYWdzLmluZGV4T2YoJ18nKSAhPT0gLTEsXG4gICAgICAgICAgICB1cGNhc2UgPSBmbGFncy5pbmRleE9mKCdeJykgIT09IC0xLFxuICAgICAgICAgICAgaW52ZXJ0ID0gZmxhZ3MuaW5kZXhPZignIycpICE9PSAtMSxcbiAgICAgICAgICAgIGNvbG9ucyA9IChmbGFncy5tYXRjaCgnOicpIHx8IFtdKS5sZW5ndGg7XG5cbiAgICAgICAgd2lkdGggPSBwYXJzZUludCh3aWR0aCwgMTApO1xuXG4gICAgICAgIGlmICh6ZXJvICYmIGJsYW5rKSB7XG4gICAgICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJzAnKSA8IGZsYWdzLmluZGV4T2YoJ18nKSkge1xuICAgICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsYW5rID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChjb252KSB7XG4gICAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t5ZWFyfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE1hdGgucm91bmQoI3t5ZWFyfSAvIDEwMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3t5ZWFyfSAlIDEwMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje21vbn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgcmVzdWx0ICs9IGxvbmdfbW9udGhzWyN7bW9ufSAtIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVybztcbiAgICAgICAgICAgIHJlc3VsdCArPSBzaG9ydF9tb250aHNbI3ttb259IC0gMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFua1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm9cbiAgICAgICAgICAgIHJlc3VsdCArPSAje2RheX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2onOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyAzIDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t5ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2snOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSAlIDEyIHx8IDEyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gJSAxMiB8fCAxMik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ID49IDEyID8gXCJwbVwiIDogXCJhbVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3ttaW59O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzZWN9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyAzIDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICB3aWR0aCAgID0gaXNOYU4od2lkdGgpID8gOSA6IHdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7YHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKWAucmp1c3QoMywgJzAnKX07XG4gICAgICAgICAgICByZXN1bHQgID0gI3tgcmVzdWx0YC5sanVzdChgd2lkdGhgLCAnMCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ICA9IHNlbGYuZ2V0VGltZXpvbmVPZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBob3VycyAgID0gTWF0aC5mbG9vcihNYXRoLmFicyhvZmZzZXQpIC8gNjApLFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLmFicyhvZmZzZXQpICUgNjA7XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSBvZmZzZXQgPCAwID8gXCIrXCIgOiBcIi1cIjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBob3VycyA8IDEwID8gXCIwXCIgOiBcIlwiO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGhvdXJzO1xuXG4gICAgICAgICAgICBpZiAoY29sb25zID4gMCkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gXCI6XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSBtaW51dGVzIDwgMTAgPyBcIjBcIiA6IFwiXCI7XG4gICAgICAgICAgICByZXN1bHQgKz0gbWludXRlcztcblxuICAgICAgICAgICAgaWYgKGNvbG9ucyA+IDEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiOjAwXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t6b25lfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gZGF5c19vZl93ZWVrWyN7d2RheX1dO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBzaG9ydF9kYXlzWyN7d2RheX1dO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3t3ZGF5fSArIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3dkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2N3ZWVrX2N5ZWFyWzBdLnRvX3Mucmp1c3QoMiwgJzAnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMV19O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2N3ZWVrX2N5ZWFyWzFdWy0yLi4tMV19O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3RvX2l9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcdFwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJWEgJWIgJWUgJVQgJVknKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVtLyVkLyV5Jyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdGJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclWS0lbS0lZCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJWUtJV5iLSU0WScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJUk6JU06JVMgJXAnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1InOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVIOiVNJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclSDolTTolUycpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmdWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwY2FzZSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludmVydCkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9bQS1aXS8sIGZ1bmN0aW9uKGMpIHsgYy50b0xvd2VyQ2FzZSgpIH0pLlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlKC9bYS16XS8sIGZ1bmN0aW9uKGMpIHsgYy50b1VwcGVyQ2FzZSgpIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhZCAmJiAoemVybyB8fCBibGFuaykpIHtcbiAgICAgICAgICByZXN1bHQgPSAje2ByZXN1bHRgLnJqdXN0KGBpc05hTih3aWR0aCkgPyAyIDogd2lkdGhgLCBgYmxhbmsgPyBcIiBcIiA6IFwiMFwiYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN1bmRheT9cbiAgICBgI3t3ZGF5fSA9PSAwYFxuICBlbmRcblxuICBkZWYgdGh1cnNkYXk/XG4gICAgYCN7d2RheX0gPT0gNGBcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBbc2VjLCBtaW4sIGhvdXIsIGRheSwgbW9udGgsIHllYXIsIHdkYXksIHlkYXksIGlzZHN0LCB6b25lXVxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIGBzZWxmLmdldFRpbWUoKSAvIDEwMDBgXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgYHBhcnNlSW50KHNlbGYuZ2V0VGltZSgpIC8gMTAwMCwgMTApYFxuICBlbmRcblxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICBkZWYgdHVlc2RheT9cbiAgICBgI3t3ZGF5fSA9PSAyYFxuICBlbmRcblxuICBhbGlhcyB0dl9zZWMgdG9faVxuXG4gIGFsaWFzIHR2X3VzZWMgdXNlY1xuXG4gIGFsaWFzIHV0Yz8gZ210P1xuXG4gIGFsaWFzIGdtdG9mZiBnbXRfb2Zmc2V0XG4gIGFsaWFzIHV0Y19vZmZzZXQgZ210X29mZnNldFxuXG4gIGRlZiB3ZGF5XG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENEYXkoKSA6IHNlbGYuZ2V0RGF5KClgXG4gIGVuZFxuXG4gIGRlZiB3ZWRuZXNkYXk/XG4gICAgYCN7d2RheX0gPT0gM2BcbiAgZW5kXG5cbiAgZGVmIHllYXJcbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ0Z1bGxZZWFyKCkgOiBzZWxmLmdldEZ1bGxZZWFyKClgXG4gIGVuZFxuXG4gIGRlZiBjd2Vla19jeWVhclxuICAgIGphbjAxID0gVGltZS5uZXcoeWVhciwgMSwgMSlcbiAgICBqYW4wMV93ZGF5ID0gamFuMDEud2RheVxuICAgIGZpcnN0X21vbmRheSA9IDBcbiAgICB5ZWFyID0gc2VsZi55ZWFyXG4gICAgaWYgamFuMDFfd2RheSA8PSA0ICYmIGphbjAxX3dkYXkgIT0gMFxuICAgICAgIyBKYW4gMDEgaXMgaW4gdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXJcbiAgICAgIG9mZnNldCA9IGphbjAxX3dkYXkgLSAxXG4gICAgZWxzZVxuICAgICAgIyBKYW4gMDEgaXMgaW4gdGhlIGxhc3Qgd2VlayBvZiB0aGUgcHJldmlvdXMgeWVhclxuICAgICAgb2Zmc2V0ID0gamFuMDFfd2RheSAtIDcgLSAxXG4gICAgICBvZmZzZXQgPSAtMSBpZiBvZmZzZXQgPT0gLTggIyBBZGp1c3QgaWYgSmFuIDAxIGlzIGEgU3VuZGF5XG4gICAgZW5kXG5cbiAgICB3ZWVrID0gKCh5ZGF5ICsgb2Zmc2V0KSAvIDcuMDApLmNlaWxcblxuICAgIGlmIHdlZWsgPD0gMFxuICAgICAgIyBHZXQgdGhlIGxhc3Qgd2VlayBvZiB0aGUgcHJldmlvdXMgeWVhclxuICAgICAgcmV0dXJuIFRpbWUubmV3KHNlbGYueWVhciAtIDEsIDEyLCAzMSkuY3dlZWtfY3llYXJcbiAgICBlbHNpZiB3ZWVrID09IDUzXG4gICAgICAjIEZpbmQgb3V0IHdoZXRoZXIgdGhpcyBpcyBhY3R1YWxseSB3ZWVrIDUzIG9yIGFscmVhZHkgd2VlayAwMSBvZiB0aGUgZm9sbG93aW5nIHllYXJcbiAgICAgIGRlYzMxID0gVGltZS5uZXcoc2VsZi55ZWFyLCAxMiwgMzEpXG4gICAgICBkZWMzMV93ZGF5ID0gZGVjMzEud2RheVxuICAgICAgaWYgZGVjMzFfd2RheSA8PSAzICYmIGRlYzMxX3dkYXkgIT0gMFxuICAgICAgICB3ZWVrID0gMVxuICAgICAgICB5ZWFyICs9IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgW3dlZWssIHllYXJdXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsicmVxdWlyZSIsImNsYXNzIiwiaW5jbHVkZSIsImF0Iiwic2VsZiIsIj09PSIsInNlY29uZHMiLCJyYWlzZSIsImNvZXJjZV90byEiLCJmcmFjIiwicmVzcG9uZF90bz8iLCJ0b19zdHIiLCJ0b19pIiwibmV3IiwibG9jYWwiLCJnbSIsIm5vdyIsIisiLCJvdGhlciIsIi0iLCI8PT4iLCJ0b19mIiwiciIsIm5pbD8iLCI+IiwiMCIsIi0xIiwiPCIsIjEiLCI9PSIsIiRyZXRfb3JfMSIsImFzY3RpbWUiLCJzdHJmdGltZSIsImRheSIsInlkYXkiLCJzdGFydF9vZl95ZWFyIiwieWVhciIsInN0YXJ0X29mX2RheSIsIm1vbnRoIiwib25lX2RheSIsIjg2NDAwIiwiLyIsInJvdW5kIiwiaXNkc3QiLCJkdXAiLCJjb3B5IiwiY29weV9pbnN0YW5jZV92YXJpYWJsZXMiLCJpbml0aWFsaXplX2R1cCIsImVxbD8iLCIkcmV0X29yXzIiLCJpc19hPyIsInplcm8/IiwiZnJpZGF5PyIsIndkYXkiLCJoYXNoIiwiaG91ciIsImluc3BlY3QiLCJ1dGM/IiwibWluIiwibW9uIiwibW9uZGF5PyIsInNhdHVyZGF5PyIsInNlYyIsInN1Y2MiLCJ1c2VjIiwiem9uZSIsImdldGdtIiwiZ210aW1lIiwiZ210PyIsImdtdF9vZmZzZXQiLCJyanVzdCIsIjMiLCJsanVzdCIsImN3ZWVrX2N5ZWFyIiwiW10iLCJ0b19zIiwiMiIsIi0yIiwic3VuZGF5PyIsInRodXJzZGF5PyIsInRvX2EiLCJ0dWVzZGF5PyIsIndlZG5lc2RheT8iLCJqYW4wMSIsImphbjAxX3dkYXkiLCJmaXJzdF9tb25kYXkiLCIkcmV0X29yXzMiLCI8PSIsIjQiLCIhPSIsIm9mZnNldCIsIjciLCItOCIsIndlZWsiLCJjZWlsIiwiMTIiLCIzMSIsIjUzIiwiZGVjMzEiLCJkZWMzMV93ZGF5IiwiJHJldF9vcl80Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxNQUFBQSxTQUFBQSxDQUFRLG9CQUFSQSxDQUFBO0FBQUEsRUFFQSxPQUFBQztBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsUUFBQUMsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FBQTtBQUFBO0FBR0YsdUJBQXlCLENBQUcsUUFBSCxFQUFVLFFBQVYsRUFBaUIsU0FBakIsRUFBeUIsV0FBekIsRUFBbUMsVUFBbkMsRUFBNEMsUUFBNUMsRUFBbUQsVUFBbkQsRUFBNEQsUUFBNUQsQ0FBb0U7QUFDN0YsdUJBQXlCLENBQUcsS0FBSCxFQUFPLEtBQVAsRUFBVyxLQUFYLEVBQWUsS0FBZixFQUFtQixLQUFuQixFQUF1QixLQUF2QixFQUEyQixLQUEzQixDQUFnQztBQUN6RCx1QkFBeUIsQ0FBRyxLQUFILEVBQU8sS0FBUCxFQUFXLEtBQVgsRUFBZSxLQUFmLEVBQW1CLEtBQW5CLEVBQXVCLEtBQXZCLEVBQTJCLEtBQTNCLEVBQStCLEtBQS9CLEVBQW1DLEtBQW5DLEVBQXVDLEtBQXZDLEVBQTJDLEtBQTNDLEVBQStDLEtBQS9DLENBQW9EO0FBQzdFLHVCQUF5QixDQUFHLFNBQUgsRUFBVyxVQUFYLEVBQW9CLE9BQXBCLEVBQTBCLE9BQTFCLEVBQWdDLEtBQWhDLEVBQW9DLE1BQXBDLEVBQXlDLE1BQXpDLEVBQThDLFFBQTlDLEVBQXFELFdBQXJELEVBQStELFNBQS9ELEVBQXVFLFVBQXZFLEVBQWdGLFVBQWhGLENBQTBGO0FBQ25ILEVBUEU7QUFBQSxJQVNBQyxVQUFJQyxJQUFKRCxTQUFBQSxhQUFB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T0FBTyxvQkFBQTFFLEtBQUFBLENBQVNNLFVBQUFmLElBQUFnQyxNQUFBQSxDQUFBQSxDQUFBakIsRUFBWVMsQ0FBWlQsR0FBZTRFLElBQUlDLEVBQTVCbkYsQ0FBQTRELGFBQUFBLENBQUFBO0FBRlQsTUFBQSxPQUdBLElBQU1vQixJQUFBaEUsT0FBQUEsQ0FBUW9FLEVBQVJwRSxDQUFOO0FBQUE7QUFFRSxRQUFBcUUsUUFBUSxvQkFBQXJGLEtBQUFBLENBQVNULElBQUFnQyxNQUFBQSxDQUFBQSxHQUFXMkQsSUFBSUMsRUFBeEJuRixDQUFSO0FBQUEsUUFDQXNGLGFBQWFELEtBQUE3QyxNQUFBQSxDQUFBQSxDQURiO0FBQUEsUUFFQSxJQUFBLFFBQUcsYUFBQSxJQUFBLFFBenVCVCtDLENBQUFBLFlBeXVCU2IsT0FBQVksVUFBQVosRUFBY2hCLENBQWRnQixDQXp1QlRhLENBeXVCUyxDQUFBO0FBQUEsVUFBbUIsT0FBQUQsVUFBQVYsT0FBQUEsQ0FBY2hFLENBQWRnRTtBQUFuQixRQUFBO0FBQUEsVUF6dUJULE9BQUE7QUF5dUJTLFFBQUEsQ0FBQSxrQkFBSCxDQUFBO0FBQUE7QUFDRSxVQUFBSSxPQUFPakUsQ0FBUDtBQUFBLFVBQ0FRLE9BM3VCUm5CLFNBMnVCUW1CLElBM3VCUm5CLEVBMnVCZ0JXLENBM3VCaEJYLENBMHVCUSxDQURGLENBRkEsQ0FGRixDQWxCQTtBQUFBLE1BNEJBLE9BQUEsQ0FBQzRFLElBQUQsRUFBT3pELElBQVAsQ0E1QkE7QUFERnFDLElBQUFBLENBQUFBLGtDQUFBQSxDQUFBQSx1QkE1c0JBO0FBREZ4RSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFjLElBQWRBLFdBRkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzAzNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvc3RydWN0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuY2xhc3MgU3RydWN0XG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gIGRlZiBzZWxmLm5ldyhjb25zdF9uYW1lLCAqYXJncywga2V5d29yZF9pbml0OiBmYWxzZSwgJmJsb2NrKVxuICAgIGlmIGNvbnN0X25hbWVcbiAgICAgIGJlZ2luXG4gICAgICAgIGNvbnN0X25hbWUgPSBPcGFsLmNvbnN0X25hbWUhKGNvbnN0X25hbWUpXG4gICAgICByZXNjdWUgVHlwZUVycm9yLCBOYW1lRXJyb3JcbiAgICAgICAgYXJncy51bnNoaWZ0KGNvbnN0X25hbWUpXG4gICAgICAgIGNvbnN0X25hbWUgPSBuaWxcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYXJncy5tYXAgZG8gfGFyZ3xcbiAgICAgIE9wYWwuY29lcmNlX3RvIShhcmcsIFN0cmluZywgOnRvX3N0cilcbiAgICBlbmRcblxuICAgIGtsYXNzID0gQ2xhc3MubmV3KHNlbGYpIGRvXG4gICAgICBhcmdzLmVhY2ggeyB8YXJnfCBkZWZpbmVfc3RydWN0X2F0dHJpYnV0ZShhcmcpIH1cblxuICAgICAgY2xhc3MgPDwgc2VsZlxuICAgICAgICBkZWYgbmV3KCphcmdzKVxuICAgICAgICAgIGluc3RhbmNlID0gYWxsb2NhdGVcbiAgICAgICAgICBgI3tpbnN0YW5jZX0uJCRkYXRhID0ge31gXG4gICAgICAgICAgaW5zdGFuY2UuaW5pdGlhbGl6ZSgqYXJncylcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICBlbmRcblxuICAgICAgICBhbGlhc19tZXRob2QgOltdLCA6bmV3XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGtsYXNzLm1vZHVsZV9ldmFsKCZibG9jaykgaWYgYmxvY2tcbiAgICBga2xhc3MuJCRrZXl3b3JkX2luaXQgPSBrZXl3b3JkX2luaXRgXG5cbiAgICBpZiBjb25zdF9uYW1lXG4gICAgICBTdHJ1Y3QuY29uc3Rfc2V0KGNvbnN0X25hbWUsIGtsYXNzKVxuICAgIGVuZFxuXG4gICAga2xhc3NcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUobmFtZSlcbiAgICBpZiBzZWxmID09IFN0cnVjdFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3lvdSBjYW5ub3QgZGVmaW5lIGF0dHJpYnV0ZXMgdG8gdGhlIFN0cnVjdCBjbGFzcydcbiAgICBlbmRcblxuICAgIG1lbWJlcnMgPDwgbmFtZVxuXG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICBgc2VsZi4kJGRhdGFbbmFtZV1gXG4gICAgZW5kXG5cbiAgICBkZWZpbmVfbWV0aG9kIFwiI3tuYW1lfT1cIiBkbyB8dmFsdWV8XG4gICAgICBgc2VsZi4kJGRhdGFbbmFtZV0gPSB2YWx1ZWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYubWVtYmVyc1xuICAgIGlmIHNlbGYgPT0gU3RydWN0XG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndGhlIFN0cnVjdCBjbGFzcyBoYXMgbm8gbWVtYmVycydcbiAgICBlbmRcblxuICAgIEBtZW1iZXJzIHx8PSBbXVxuICBlbmRcblxuICBkZWYgc2VsZi5pbmhlcml0ZWQoa2xhc3MpXG4gICAgbWVtYmVycyA9IEBtZW1iZXJzXG5cbiAgICBrbGFzcy5pbnN0YW5jZV9ldmFsIGRvXG4gICAgICBAbWVtYmVycyA9IG1lbWJlcnNcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoKmFyZ3MpXG4gICAgaWYgYCN7c2VsZi5jbGFzc30uJCRrZXl3b3JkX2luaXRgXG4gICAgICBrd2FyZ3MgPSBhcmdzLmxhc3QgfHwge31cblxuICAgICAgaWYgYXJncy5sZW5ndGggPiAxIHx8IGAoYXJncy5sZW5ndGggPT09IDEgJiYgIWt3YXJncy4kJGlzX2hhc2gpYFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuICN7YXJncy5sZW5ndGh9LCBleHBlY3RlZCAwKVwiXG4gICAgICBlbmRcblxuICAgICAgZXh0cmEgPSBrd2FyZ3Mua2V5cyAtIHNlbGYuY2xhc3MubWVtYmVyc1xuICAgICAgaWYgZXh0cmEuYW55P1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcInVua25vd24ga2V5d29yZHM6ICN7ZXh0cmEuam9pbignLCAnKX1cIlxuICAgICAgZW5kXG5cbiAgICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIGRvIHxuYW1lfFxuICAgICAgICBzZWxmW25hbWVdID0ga3dhcmdzW25hbWVdXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBpZiBhcmdzLmxlbmd0aCA+IHNlbGYuY2xhc3MubWVtYmVycy5sZW5ndGhcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3N0cnVjdCBzaXplIGRpZmZlcnMnXG4gICAgICBlbmRcblxuICAgICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2hfd2l0aF9pbmRleCBkbyB8bmFtZSwgaW5kZXh8XG4gICAgICAgIHNlbGZbbmFtZV0gPSBhcmdzW2luZGV4XVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkoZnJvbSlcbiAgICAleHtcbiAgICAgIHNlbGYuJCRkYXRhID0ge31cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbS4kJGRhdGEpLCBpLCBtYXgsIG5hbWU7XG4gICAgICBmb3IgKGkgPSAwLCBtYXggPSBrZXlzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBrZXlzW2ldO1xuICAgICAgICBzZWxmLiQkZGF0YVtuYW1lXSA9IGZyb20uJCRkYXRhW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1lbWJlcnNcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnNcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBIYXNoLm5ldyhgc2VsZi4kJGRhdGFgKS5oYXNoXG4gIGVuZFxuXG4gIGRlZiBbXShuYW1lKVxuICAgIGlmIEludGVnZXIgPT09IG5hbWVcbiAgICAgIHJhaXNlIEluZGV4RXJyb3IsIFwib2Zmc2V0ICN7bmFtZX0gdG9vIHNtYWxsIGZvciBzdHJ1Y3Qoc2l6ZToje3NlbGYuY2xhc3MubWVtYmVycy5zaXplfSlcIiBpZiBuYW1lIDwgLXNlbGYuY2xhc3MubWVtYmVycy5zaXplXG4gICAgICByYWlzZSBJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBsYXJnZSBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA+PSBzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuXG4gICAgICBuYW1lID0gc2VsZi5jbGFzcy5tZW1iZXJzW25hbWVdXG4gICAgZWxzaWYgU3RyaW5nID09PSBuYW1lXG4gICAgICAleHtcbiAgICAgICAgaWYoIXNlbGYuJCRkYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgI3tyYWlzZSBOYW1lRXJyb3IubmV3KFwibm8gbWVtYmVyICcje25hbWV9JyBpbiBzdHJ1Y3RcIiwgbmFtZSl9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje25hbWUuY2xhc3N9IGludG8gSW50ZWdlclwiXG4gICAgZW5kXG5cbiAgICBuYW1lID0gT3BhbC5jb2VyY2VfdG8hKG5hbWUsIFN0cmluZywgOnRvX3N0cilcbiAgICBgc2VsZi4kJGRhdGFbbmFtZV1gXG4gIGVuZFxuXG4gIGRlZiBbXT0obmFtZSwgdmFsdWUpXG4gICAgaWYgSW50ZWdlciA9PT0gbmFtZVxuICAgICAgcmFpc2UgSW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gc21hbGwgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPCAtc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcbiAgICAgIHJhaXNlIEluZGV4RXJyb3IsIFwib2Zmc2V0ICN7bmFtZX0gdG9vIGxhcmdlIGZvciBzdHJ1Y3Qoc2l6ZToje3NlbGYuY2xhc3MubWVtYmVycy5zaXplfSlcIiBpZiBuYW1lID49IHNlbGYuY2xhc3MubWVtYmVycy5zaXplXG5cbiAgICAgIG5hbWUgPSBzZWxmLmNsYXNzLm1lbWJlcnNbbmFtZV1cbiAgICBlbHNpZiBTdHJpbmcgPT09IG5hbWVcbiAgICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKSB1bmxlc3Mgc2VsZi5jbGFzcy5tZW1iZXJzLmluY2x1ZGU/KG5hbWUudG9fc3ltKVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7bmFtZS5jbGFzc30gaW50byBJbnRlZ2VyXCJcbiAgICBlbmRcblxuICAgIG5hbWUgPSBPcGFsLmNvZXJjZV90byEobmFtZSwgU3RyaW5nLCA6dG9fc3RyKVxuICAgIGBzZWxmLiQkZGF0YVtuYW1lXSA9IHZhbHVlYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pbnN0YW5jZV9vZj8oc2VsZi5jbGFzcylcblxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkMSA9IHt9LCByZWN1cnNlZDIgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xuICAgICAgICB2YXIga2V5LCBhLCBiO1xuXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcbiAgICAgICAgcmVjdXJzZWQyWyN7YG90aGVyYC5fX2lkX199XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xuICAgICAgICAgIGEgPSBzdHJ1Y3QuJCRkYXRhW2tleV07XG4gICAgICAgICAgYiA9IG90aGVyLiQkZGF0YVtrZXldO1xuXG4gICAgICAgICAgaWYgKCN7U3RydWN0ID09PSBgYWB9KSB7XG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2VkMS5oYXNPd25Qcm9wZXJ0eSgje2BhYC5fX2lkX199KSB8fCAhcmVjdXJzZWQyLmhhc093blByb3BlcnR5KCN7YGJgLl9faWRfX30pKSB7XG4gICAgICAgICAgICAgIGlmICghX2VxZXEoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYCA9PSBgYmB9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWVxKHNlbGYsIG90aGVyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb3RoZXIuaW5zdGFuY2Vfb2Y/KHNlbGYuY2xhc3MpXG5cbiAgICAleHtcbiAgICAgIHZhciByZWN1cnNlZDEgPSB7fSwgcmVjdXJzZWQyID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIF9lcWVxKHN0cnVjdCwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGtleSwgYSwgYjtcblxuICAgICAgICByZWN1cnNlZDFbI3tgc3RydWN0YC5fX2lkX199XSA9IHRydWU7XG4gICAgICAgIHJlY3Vyc2VkMlsje2BvdGhlcmAuX19pZF9ffV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAoa2V5IGluIHN0cnVjdC4kJGRhdGEpIHtcbiAgICAgICAgICBhID0gc3RydWN0LiQkZGF0YVtrZXldO1xuICAgICAgICAgIGIgPSBvdGhlci4kJGRhdGFba2V5XTtcblxuICAgICAgICAgIGlmICgje1N0cnVjdCA9PT0gYGFgfSkge1xuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZDEuaGFzT3duUHJvcGVydHkoI3tgYWAuX19pZF9ffSkgfHwgIXJlY3Vyc2VkMi5oYXNPd25Qcm9wZXJ0eSgje2BiYC5fX2lkX199KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWVxKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAuZXFsPyhgYmApfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFlcShzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaFxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2ggeyB8bmFtZXwgeWllbGQgc2VsZltuYW1lXSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9wYWlyXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3BhaXIpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIHsgfG5hbWV8IHlpZWxkIFtuYW1lLCBzZWxmW25hbWVdXSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmxlbmd0aFxuICBlbmRcblxuICBhbGlhcyBzaXplIGxlbmd0aFxuXG4gIGRlZiB0b19hXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLm1hcCB7IHxuYW1lfCBzZWxmW25hbWVdIH1cbiAgZW5kXG5cbiAgYWxpYXMgdmFsdWVzIHRvX2FcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9ICcjPHN0cnVjdCAnXG5cbiAgICBpZiBTdHJ1Y3QgPT09IHNlbGYgJiYgc2VsZi5jbGFzcy5uYW1lXG4gICAgICByZXN1bHQgKz0gXCIje3NlbGYuY2xhc3N9IFwiXG4gICAgZW5kXG5cbiAgICByZXN1bHQgKz0gZWFjaF9wYWlyLm1hcCBkbyB8bmFtZSwgdmFsdWV8XG4gICAgICBcIiN7bmFtZX09I3t2YWx1ZS5pbnNwZWN0fVwiXG4gICAgZW5kLmpvaW4gJywgJ1xuXG4gICAgcmVzdWx0ICs9ICc+J1xuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuXG4gIGRlZiB0b19oKCZibG9jaylcbiAgICByZXR1cm4gbWFwKCZibG9jaykudG9faCgqYXJncykgaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX29iamVjdCh7fSkgeyB8bmFtZSwgaHwgaFtuYW1lXSA9IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBkZWYgdmFsdWVzX2F0KCphcmdzKVxuICAgIGFyZ3MgPSBhcmdzLm1hcCB7IHxhcmd8IGBhcmcuJCRpc19yYW5nZSA/ICN7YXJnLnRvX2F9IDogYXJnYCB9LmZsYXR0ZW5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghYXJnc1tpXS4kJGlzX251bWJlcikge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tgYXJnc1tpXWAuY2xhc3N9IGludG8gSW50ZWdlclwifVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKCN7c2VsZltgYXJnc1tpXWBdfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpZyhrZXksICprZXlzKVxuICAgIGl0ZW0gPSBpZiBga2V5LiQkaXNfc3RyaW5nICYmIHNlbGYuJCRkYXRhLmhhc093blByb3BlcnR5KGtleSlgXG4gICAgICAgICAgICAgYHNlbGYuJCRkYXRhW2tleV0gfHwgbmlsYFxuICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiY2xhc3MiLCJpbmNsdWRlIiwibmV3Iiwic2VsZiIsImNvbnN0X25hbWUiLCJjb25zdF9uYW1lISIsImFyZ3MiLCJ1bnNoaWZ0IiwibWFwIiwiY29lcmNlX3RvISIsImFyZyIsImtsYXNzIiwiZWFjaCIsImRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwiaW5zdGFuY2UiLCJhbGxvY2F0ZSIsImluaXRpYWxpemUiLCJhbGlhc19tZXRob2QiLCJibG9jayIsIm1vZHVsZV9ldmFsIiwiY29uc3Rfc2V0IiwiPT0iLCJyYWlzZSIsIm1lbWJlcnMiLCI8PCIsIm5hbWUiLCJkZWZpbmVfbWV0aG9kIiwiQG1lbWJlcnMiLCIkcmV0X29yXzEiLCJpbmhlcml0ZWQiLCJpbnN0YW5jZV9ldmFsIiwia3dhcmdzIiwiJHJldF9vcl8yIiwibGFzdCIsIiRyZXRfb3JfMyIsIj4iLCJsZW5ndGgiLCIxIiwiZXh0cmEiLCItIiwia2V5cyIsImFueT8iLCJqb2luIiwiJHdyaXRlciIsIltdIiwiW109IiwiZWFjaF93aXRoX2luZGV4IiwiaW5kZXgiLCJpbml0aWFsaXplX2NvcHkiLCJoYXNoIiwiPT09IiwiPCIsInNpemUiLCItQCIsIj49IiwiaW5jbHVkZT8iLCJ0b19zeW0iLCJvdGhlciIsImluc3RhbmNlX29mPyIsIl9faWRfXyIsImVxbD8iLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImVhY2hfcGFpciIsInRvX2EiLCJpbnNwZWN0IiwicmVzdWx0IiwiJHJldF9vcl80IiwiKyIsInZhbHVlIiwidG9faCIsImVhY2hfd2l0aF9vYmplY3QiLCJoIiwidmFsdWVzX2F0IiwiZmxhdHRlbiIsImRpZyIsIml0ZW0iLCJyZXNwb25kX3RvPyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxvQkFBUkEsQ0FBQTtBQUFBLEVBRUEsT0FBQUM7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLFFBQUFDLFNBQUFBLENBQVEsMEJBQVJBLENBQUE7QUFBQSxJQUVBQyxVQUFJQyxJQUFKRCxVQUFBQSxnQkFBQUEsU0FBYSxVQUFELEVBTmQsRUFNYyxFQU5kLEVBTUVBO0FBQUFBLE1BQUFBOztBQUFBQSxNQUFBQTtBQUFBQTtBQU5GO0FBTXVELE1BQUEsb0NBTnZEO0FBQUE7QUFBQSxNQUFBLDREQUFBO0FBQUE7QUFBQSxNQUFBLHlDQUFBO0FBQUE7QUFBQSxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUE7QUFBQSxNQUFBO0FBQUEsTUFBQSxDQUFBO0FBQUE7QUFNMkIsTUFBQSxrQkFOM0I7QUFBQTtBQU1rQyxNQUFBO0FBQUEsTUFBQTtBQUFBLE1BQUEsaUJBQWM7QUFBZCxNQUFBLENBTmxDO0FBQUEsTUFPSSxJQUFBLFFBQUdFLFVBQUgsQ0FBQTtBQUFBO0FBQ0UsUUFDRTtBQUFBLFVBQUFBLGFBQWEsb0JBQUFDLGdCQUFBQSxDQUFpQkQsVUFBakJDO0FBQWIsUUFBQTtBQUFBLFVBQ0Ysc0JBQU8sQ0FBQSx5QkFBQSxFQUFXLHlCQUFYLENBQVA7QUFBQSxZQUFBO0FBQUE7QUFDRSxjQUFBQyxJQUFBQyxTQUFBQSxDQUFhSCxVQUFiRyxDQUFBO0FBQUEsY0FDQUgsYUFBYSxHQURiO0FBREYsWUFBQTtBQUFBLFVBQUEsQ0FERTtBQUFBLFFBQUEsQ0FERixDQURGLENBUEo7QUFBQSxNQWdCSUksTUFB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QUF1U2UsTUFBQSxrQkF2U2Y7QUFBQSxNQXdTSUMsT0FBTyxhQUFBLElBQUEsUUFBSSxrREFBSixDQUFBO0FBQUEsUUFDRSxPQUFDLHVCQUFEO0FBREYsTUFBQTtBQUFBO0FBQUEsTUFBQSxDQUFBLGtCQXhTWDtBQUFBO0FBNlNBO0FBQ0E7QUFDQTtBQUNBLElBaFRBO0FBQUEsTUFrVEksSUFBQSxRQUFPQSxJQUFBQyxnQkFBQUEsQ0FBaUIsS0FBakJBLENBQVAsQ0FBQTtBQUFBLE1BQUE7QUFBQSxZQUNFdkQsT0FBQUEsQ0FBTSwyQkFBVyxFQUFBLEdBQUEsQ0FBR3NELElBQUE1RSxPQUFBQSxDQUFBQSxDQUFILENBQUEsR0FBQSw0QkFBakJzQjtBQURGLE1BQUEsQ0FsVEo7QUFBQSxNQXNUSSxPQUFBcUQsTUFBQUMsSUFBQUQsT0FBQUEsRUFBUyxVQUFDbkMsSUFBRCxDQUFUbUMsQ0F0VEo7QUF1U0VBLElBQUFBLENBQUFBLDZCQUFBQSxDQUFBQSxlQW5TQTtBQURGM0UsRUFBQUEsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUEsV0FGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNTcwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tYWluLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImRlZiBzZWxmLnRvX3NcbiAgJ21haW4nXG5lbmRcblxuZGVmIHNlbGYuaW5jbHVkZShtb2QpXG4gIE9iamVjdC5pbmNsdWRlIG1vZFxuZW5kXG4iXSwibmFtZXMiOlsidG9fcyIsInNlbGYiLCJpbmNsdWRlIiwibW9kIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxFQUFBQSxVQUFJQyxJQUFKRCxXQUFBQSxVQUFBQSxnQkFBQUE7QUFBQUEsSUFBQUE7O0FBQUFBLElBQ0UsT0FBQTtBQURGQSxFQUFBQSxDQUFBQSxxQkFBQUEsQ0FBQTtBQUFBLEVBSUEsT0FBQUUsQ0FBQUEsVUFBSUQsSUFBSkMsY0FBQUEsYUFBQUEsbUJBQWlCLEdBQWpCQTtBQUFBQSxJQUFBQTs7QUFBQUEsSUFDRSxPQUFBLHNCQUFBQSxTQUFBQSxDQUFlQyxHQUFmRDtBQURGQSxFQUFBQSxDQUFBQSx3QkFBQUEsQ0FBQUEsbUJBSkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzU4OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZGlyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIERpclxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGNoZGlyKGRpcilcbiAgICAgIHByZXZfY3dkID0gYE9wYWwuY3VycmVudF9kaXJgXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciA9ICN7ZGlyfWBcbiAgICAgIHlpZWxkXG4gICAgZW5zdXJlXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciA9ICN7cHJldl9jd2R9YFxuICAgIGVuZFxuXG4gICAgZGVmIHB3ZFxuICAgICAgYE9wYWwuY3VycmVudF9kaXIgfHwgJy4nYFxuICAgIGVuZFxuICAgIGFsaWFzIGdldHdkIHB3ZFxuXG4gICAgZGVmIGhvbWVcbiAgICAgIEVOVlsnSE9NRSddIHx8ICcuJ1xuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbImNsYXNzIiwiY2hkaXIiLCJwcmV2X2N3ZCIsImRpciIsInB3ZCIsImhvbWUiLCIkcmV0X29yXzEiLCJbXSIsInNlbGYiXSwibWFwcGluZ3MiOiI7Ozs7O0VBQUEsT0FBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQSxJQUNFLE9BQUE7QUFBQSxNQUFBOztBQUFBO0FBQ0U7QUFBQUMsTUFBQUEseUJBQUFBLFdBQUFBLGlCQUFVLEdBQVZBO0FBQUFBLFFBQUFBOztBQUFBQSxRQUFBQTtBQUFBQSxlQUNFLGNBQUE7QUFBQTtBQUFBLFFBQUFDLFdBQVksZ0JBQVo7QUFBQSxRQUNDLG1CQUFxQkMsR0FEdEI7QUFBQSxRQUVBLE9BQUEscUJBQUEsRUFBQSxDQUZBO0FBQUEsUUFBQTtBQUFBLFVBSUMsbUJBQXFCRDtBQUp0QixRQUFBLENBQUE7QUFERkQsTUFBQUEsQ0FBQUEsc0JBQUFBLENBQUE7QUFBQTtBQVFBRyxNQUFBQSx1QkFBQUEsU0FBQUEsZUFBQUE7QUFBQUEsUUFBQUE7O0FBQUFBLFFBQ0UsT0FBQyx1QkFBRDtBQURGQSxNQUFBQSxDQUFBQSxvQkFBQUEsQ0FSQTtBQUFBLE1BV0EsaUJBQU0sT0FBTixFQUFZLEtBQVosQ0FYQTtBQUFBLE1BYUEsT0FBQUMsQ0FBQUEsd0JBQUFBLFVBQUFBLGdCQUFBQTtBQUFBQSxRQUFBQTs7QUFBQUEsUUFDRSxJQUFBLFFBakJOQyxDQUFBQSxZQWlCTSxtQkFBQUMsT0FBQUEsQ0FBSSxNQUFKQSxDQWpCTkQsQ0FpQk0sQ0FBQTtBQUFBLFVBakJOLE9BQUE7QUFpQk0sUUFBQTtBQUFBLFVBQWUsT0FBQTtBQUFmLFFBQUE7QUFERkQsTUFBQUEsQ0FBQUEscUJBQUFBLENBQUFBLGdCQWJBO0FBREYsSUFBQSw0QkFBU0csSUFBVDtBQURGUixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzNjM2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9maWxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5XG5cbmNsYXNzIEZpbGUgPCBJT1xuICBTZXBhcmF0b3IgPSBTRVBBUkFUT1IgPSAnLydcbiAgQUxUX1NFUEFSQVRPUiA9IG5pbFxuICBQQVRIX1NFUEFSQVRPUiA9ICc6J1xuICAjIEFzc3VtaW5nIGNhc2UgaW5zZW5zdGl2ZSBmaWxlc3lzdGVtXG4gIEZOTV9TWVNDQVNFID0gMFxuICB3aW5kb3dzX3Jvb3RfcnggPSAlcnteW2EtekEtWl06KD86XFxcXHxcXC8pfVxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWJzb2x1dGVfcGF0aChwYXRoLCBiYXNlZGlyID0gbmlsKVxuICAgICAgc2VwID0gU0VQQVJBVE9SXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgbmV3X3BhcnRzID0gW11cblxuICAgICAgcGF0aCA9IHBhdGgucmVzcG9uZF90bz8oOnRvX3BhdGgpID8gcGF0aC50b19wYXRoIDogcGF0aFxuICAgICAgYmFzZWRpciB8fD0gRGlyLnB3ZFxuICAgICAgcGF0aF9hYnMgICAgPSBgcGF0aC5zdWJzdHIoMCwgc2VwLmxlbmd0aCkgPT09IHNlcCB8fCB3aW5kb3dzX3Jvb3RfcngudGVzdChwYXRoKWBcbiAgICAgIGJhc2VkaXJfYWJzID0gYGJhc2VkaXIuc3Vic3RyKDAsIHNlcC5sZW5ndGgpID09PSBzZXAgfHwgd2luZG93c19yb290X3J4LnRlc3QoYmFzZWRpcilgXG5cbiAgICAgIGlmIHBhdGhfYWJzXG4gICAgICAgIHBhcnRzICAgICAgID0gcGF0aC5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKVxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChwYXRoKSA/ICcnIDogI3twYXRoLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcbiAgICAgICAgYWJzICAgICAgICAgPSB0cnVlXG4gICAgICBlbHNlXG4gICAgICAgIHBhcnRzICAgICAgID0gYmFzZWRpci5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKSArIHBhdGguc3BsaXQoL1sje3NlcF9jaGFyc31dLylcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QoYmFzZWRpcikgPyAnJyA6ICN7YmFzZWRpci5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXG4gICAgICAgIGFicyAgICAgICAgID0gYmFzZWRpcl9hYnNcbiAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIHBhcnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocGFydCA9PT0gbmlsKSB8fFxuICAgICAgICAgICAgKHBhcnQgPT09ICcnICAmJiAoKG5ld19wYXJ0cy5sZW5ndGggPT09IDApIHx8IGFicykpIHx8XG4gICAgICAgICAgICAocGFydCA9PT0gJy4nICYmICgobmV3X3BhcnRzLmxlbmd0aCA9PT0gMCkgfHwgYWJzKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgICAgICAgbmV3X3BhcnRzLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdfcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFicyAmJiBwYXJ0c1swXSAhPT0gJy4nKSB7XG4gICAgICAgICAgI3tuZXdfcGFydHMudW5zaGlmdCAnLid9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV3X3BhdGggPSBuZXdfcGFydHMuam9pbihzZXApXG4gICAgICBuZXdfcGF0aCA9IGxlYWRpbmdfc2VwICsgbmV3X3BhdGggaWYgYWJzXG4gICAgICBuZXdfcGF0aFxuICAgIGVuZFxuXG4gICAgZGVmIGV4cGFuZF9wYXRoKHBhdGgsIGJhc2VkaXIgPSBuaWwpXG4gICAgICBzZXAgPSBTRVBBUkFUT1JcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBpZiBgcGF0aFswXSA9PT0gJ34nIHx8IChiYXNlZGlyICYmIGJhc2VkaXJbMF0gPT09ICd+JylgXG4gICAgICAgIGhvbWUgPSBEaXIuaG9tZVxuICAgICAgICByYWlzZShBcmd1bWVudEVycm9yLCBcImNvdWxkbid0IGZpbmQgSE9NRSBlbnZpcm9ubWVudCAtLSBleHBhbmRpbmcgYH4nXCIpIHVubGVzcyBob21lXG4gICAgICAgIGxlYWRpbmdfc2VwID0gYHdpbmRvd3Nfcm9vdF9yeC50ZXN0KGhvbWUpID8gJycgOiAje2hvbWUuc3ViKC9eKFsje3NlcF9jaGFyc31dKykuKiQvLCAnXFwxJyl9YFxuICAgICAgICByYWlzZShBcmd1bWVudEVycm9yLCAnbm9uLWFic29sdXRlIGhvbWUnKSB1bmxlc3MgaG9tZS5zdGFydF93aXRoPyhsZWFkaW5nX3NlcClcblxuICAgICAgICBob21lICAgICAgICAgICAgKz0gc2VwXG4gICAgICAgIGhvbWVfcGF0aF9yZWdleHAgPSAvXlxcfig/OiN7c2VwfXwkKS9cbiAgICAgICAgcGF0aCAgICAgICAgICAgICA9IHBhdGguc3ViKGhvbWVfcGF0aF9yZWdleHAsIGhvbWUpXG4gICAgICAgIGJhc2VkaXIgICAgICAgICAgPSBiYXNlZGlyLnN1Yihob21lX3BhdGhfcmVnZXhwLCBob21lKSBpZiBiYXNlZGlyXG4gICAgICBlbmRcbiAgICAgIGFic29sdXRlX3BhdGgocGF0aCwgYmFzZWRpcilcbiAgICBlbmRcbiAgICBhbGlhcyByZWFscGF0aCBleHBhbmRfcGF0aFxuXG4gICAgJXh7XG4gICAgICAvLyBDb2VyY2UgYSBnaXZlbiBwYXRoIHRvIGEgcGF0aCBzdHJpbmcgdXNpbmcgI3RvX3BhdGggYW5kICN0b19zdHJcbiAgICAgIGZ1bmN0aW9uICRjb2VyY2VfdG9fcGF0aChwYXRoKSB7XG4gICAgICAgIGlmICgkdHJ1dGh5KCN7YHBhdGhgLnJlc3BvbmRfdG8/KDp0b19wYXRoKX0pKSB7XG4gICAgICAgICAgcGF0aCA9IHBhdGguJHRvX3BhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggPSAje09wYWwuY29lcmNlX3RvIShgcGF0aGAsIFN0cmluZywgOnRvX3N0cil9O1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYSBSZWdFeHAgY29tcGF0aWJsZSBjaGFyIGNsYXNzXG4gICAgICBmdW5jdGlvbiAkc2VwX2NoYXJzKCkge1xuICAgICAgICBpZiAoI3tBTFRfU0VQQVJBVE9SfSA9PT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuIE9wYWwuZXNjYXBlX3JlZ2V4cCgje1NFUEFSQVRPUn0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBPcGFsLmVzY2FwZV9yZWdleHAoI3tTRVBBUkFUT1IgKyBBTFRfU0VQQVJBVE9SfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYgZGlybmFtZShwYXRoKVxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIHBhdGggPSBgJGNvZXJjZV90b19wYXRoKHBhdGgpYFxuICAgICAgJXh7XG4gICAgICAgIHZhciBhYnNvbHV0ZSA9IHBhdGgubWF0Y2gobmV3IFJlZ0V4cCgje1wiXlsje3NlcF9jaGFyc31dXCJ9KSk7XG5cbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJbI3tzZXBfY2hhcnN9XSskXCJ9KSwgJycpOyAvLyByZW1vdmUgdHJhaWxpbmcgc2VwYXJhdG9yc1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlteI3tzZXBfY2hhcnN9XSskXCJ9KSwgJycpOyAvLyByZW1vdmUgdHJhaWxpbmcgYmFzZW5hbWVcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJbI3tzZXBfY2hhcnN9XSskXCJ9KSwgJycpOyAvLyByZW1vdmUgZmluYWwgdHJhaWxpbmcgc2VwYXJhdG9yc1xuXG4gICAgICAgIGlmIChwYXRoID09PSAnJykge1xuICAgICAgICAgIHJldHVybiBhYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGJhc2VuYW1lKG5hbWUsIHN1ZmZpeCA9IG5pbClcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBuYW1lID0gYCRjb2VyY2VfdG9fcGF0aChuYW1lKWBcbiAgICAgICV4e1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1ZmZpeCAhPT0gbmlsKSB7XG4gICAgICAgICAgc3VmZml4ID0gI3tPcGFsLmNvZXJjZV90byEoc3VmZml4LCBTdHJpbmcsIDp0b19zdHIpfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1ZmZpeCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIiguKVsje3NlcF9jaGFyc31dKiRcIn0pLCAnJDEnKTtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCJeKD86LipbI3tzZXBfY2hhcnN9XSk/KFteI3tzZXBfY2hhcnN9XSspJFwifSksICckMScpO1xuXG4gICAgICAgIGlmIChzdWZmaXggPT09IFwiLipcIikge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xcLlteXFwuXSskLywgJycpO1xuICAgICAgICB9IGVsc2UgaWYoc3VmZml4ICE9PSBudWxsKSB7XG4gICAgICAgICAgc3VmZml4ID0gT3BhbC5lc2NhcGVfcmVnZXhwKHN1ZmZpeCk7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXcgUmVnRXhwKCN7XCIje3N1ZmZpeH0kXCJ9KSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgZXh0bmFtZShwYXRoKVxuICAgICAgYHBhdGggPSAkY29lcmNlX3RvX3BhdGgocGF0aClgXG4gICAgICBmaWxlbmFtZSA9IGJhc2VuYW1lKHBhdGgpXG4gICAgICByZXR1cm4gJycgaWYgZmlsZW5hbWUuZW1wdHk/XG4gICAgICBsYXN0X2RvdF9pZHggPSBmaWxlbmFtZVsxLi4tMV0ucmluZGV4KCcuJylcbiAgICAgICMgZXh0ZW5zaW9uIG5hbWUgbXVzdCBjb250YWlucyBhdCBsZWFzdCBvbmUgY2hhcmFjdGVyIC4oc29tZXRoaW5nKVxuICAgICAgbGFzdF9kb3RfaWR4Lm5pbD8gfHwgbGFzdF9kb3RfaWR4ICsgMSA9PSBmaWxlbmFtZS5sZW5ndGggLSAxID8gJycgOiBmaWxlbmFtZVsobGFzdF9kb3RfaWR4ICsgMSkuLi0xXVxuICAgIGVuZFxuXG4gICAgZGVmIGV4aXN0PyhwYXRoKVxuICAgICAgYE9wYWwubW9kdWxlc1sje3BhdGh9XSAhPSBudWxsYFxuICAgIGVuZFxuICAgIGFsaWFzIGV4aXN0cz8gZXhpc3Q/XG5cbiAgICBkZWYgZGlyZWN0b3J5PyhwYXRoKVxuICAgICAgZmlsZXMgPSBbXVxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPcGFsLm1vZHVsZXMpIHtcbiAgICAgICAgICAje2ZpbGVzfS5wdXNoKGtleSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGF0aCA9IHBhdGguZ3N1YigvKF4uI3tTRVBBUkFUT1J9K3wje1NFUEFSQVRPUn0rJCkvKVxuICAgICAgZmlsZSA9IGZpbGVzLmZpbmQgeyB8ZnwgZiA9fiAvXiN7cGF0aH0vIH1cbiAgICAgIGZpbGVcbiAgICBlbmRcblxuICAgIGRlZiBqb2luKCpwYXRocylcbiAgICAgIGlmIHBhdGhzLmVtcHR5P1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIGVuZFxuICAgICAgcmVzdWx0ID0gJydcbiAgICAgIHBhdGhzID0gcGF0aHMuZmxhdHRlbi5lYWNoX3dpdGhfaW5kZXgubWFwIGRvIHxpdGVtLCBpbmRleHxcbiAgICAgICAgaWYgaW5kZXggPT0gMCAmJiBpdGVtLmVtcHR5P1xuICAgICAgICAgIFNFUEFSQVRPUlxuICAgICAgICBlbHNpZiBwYXRocy5sZW5ndGggPT0gaW5kZXggKyAxICYmIGl0ZW0uZW1wdHk/XG4gICAgICAgICAgU0VQQVJBVE9SXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpdGVtXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBwYXRocyA9IHBhdGhzLnJlamVjdCgmOmVtcHR5PylcbiAgICAgIHBhdGhzLmVhY2hfd2l0aF9pbmRleCBkbyB8aXRlbSwgaW5kZXh8XG4gICAgICAgIG5leHRfaXRlbSA9IHBhdGhzW2luZGV4ICsgMV1cbiAgICAgICAgaWYgbmV4dF9pdGVtLm5pbD9cbiAgICAgICAgICByZXN1bHQgPSBcIiN7cmVzdWx0fSN7aXRlbX1cIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgaXRlbS5lbmRfd2l0aD8oU0VQQVJBVE9SKSAmJiBuZXh0X2l0ZW0uc3RhcnRfd2l0aD8oU0VQQVJBVE9SKVxuICAgICAgICAgICAgaXRlbSA9IGl0ZW0uc3ViKC8je1NFUEFSQVRPUn0rJC8sICcnKVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIHJlc3VsdCA9IGlmIGl0ZW0uZW5kX3dpdGg/KFNFUEFSQVRPUikgfHwgbmV4dF9pdGVtLnN0YXJ0X3dpdGg/KFNFUEFSQVRPUilcbiAgICAgICAgICAgICAgICAgICAgIFwiI3tyZXN1bHR9I3tpdGVtfVwiXG4gICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgXCIje3Jlc3VsdH0je2l0ZW19I3tTRVBBUkFUT1J9XCJcbiAgICAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuXG4gICAgZGVmIHNwbGl0KHBhdGgpXG4gICAgICBwYXRoLnNwbGl0KFNFUEFSQVRPUilcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsIjAiLCJ3aW5kb3dzX3Jvb3RfcngiLCJhYnNvbHV0ZV9wYXRoIiwic2VwIiwic2VwX2NoYXJzIiwibmV3X3BhcnRzIiwicGF0aCIsInJlc3BvbmRfdG8/IiwidG9fcGF0aCIsImJhc2VkaXIiLCIkcmV0X29yXzEiLCJwd2QiLCJwYXRoX2FicyIsImJhc2VkaXJfYWJzIiwicGFydHMiLCJzcGxpdCIsImxlYWRpbmdfc2VwIiwic3ViIiwiYWJzIiwiKyIsInVuc2hpZnQiLCJuZXdfcGF0aCIsImpvaW4iLCJleHBhbmRfcGF0aCIsImhvbWUiLCJyYWlzZSIsInN0YXJ0X3dpdGg/IiwiaG9tZV9wYXRoX3JlZ2V4cCIsImNvZXJjZV90byEiLCJkaXJuYW1lIiwiYmFzZW5hbWUiLCJuYW1lIiwic3VmZml4IiwiZXh0bmFtZSIsImZpbGVuYW1lIiwiZW1wdHk/IiwibGFzdF9kb3RfaWR4IiwiW10iLCIxIiwiLTEiLCJyaW5kZXgiLCIkcmV0X29yXzIiLCJuaWw/IiwiPT0iLCItIiwibGVuZ3RoIiwiZXhpc3Q/IiwiZGlyZWN0b3J5PyIsImZpbGVzIiwiZ3N1YiIsImZpbGUiLCJmaW5kIiwiZiIsIj1+IiwicGF0aHMiLCJyZXN1bHQiLCJtYXAiLCJmbGF0dGVuIiwiZWFjaF93aXRoX2luZGV4IiwiJHJldF9vcl8zIiwiaW5kZXgiLCJpdGVtIiwiJHJldF9vcl80IiwicmVqZWN0IiwibmV4dF9pdGVtIiwiJHJldF9vcl81IiwiZW5kX3dpdGg/IiwiJHJldF9vcl82Iiwic2VsZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RUFFQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQSx5Q0FBWSx5Q0FBWSxHQUFaLENBQVosQ0FBQTtBQUFBLElBQ0EsNkNBQWdCLEdBQWhCLENBREE7QUFBQSxJQUVBLDhDQUFpQixHQUFqQixDQUZBO0FBQUEsSUFJQSwyQ0FBY0MsQ0FBZCxDQUpBO0FBQUEsSUFLQUMsa0JBQWtCLHFCQUxsQjtBQUFBLElBT0EsT0FBQTtBQUFBLE1BQUE7O0FBQUE7QUFDRTtBQUFBQyxNQUFBQSxpQ0FBQUEsbUJBQUFBLHlCQUFrQixJQUFELEVBQU8sT0FBeEJBO0FBQUFBLFFBQUFBOztBQUFBQTtBQVpKO0FBWTRCLFFBQUE7QUFBQSxRQUFBLFlBQVUsR0FBVjtBQUFBLFFBQUEsQ0FaNUI7QUFBQSxRQWFNQyxNQUFNLHlCQWJaO0FBQUEsUUFjTUMsWUFBYSxZ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QUFTcUQsSUFBVCxZQVBBO0FBREZyRSxFQUFBQSxHQUFBQSxXQUFBQSxFQUFhLGtCQUFiQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzOTY0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9wcm9jZXNzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFByb2Nlc3NcbiAgQF9fY2xvY2tzX18gPSBbXVxuICBkZWYgc2VsZi5fX3JlZ2lzdGVyX2Nsb2NrX18obmFtZSwgZnVuYylcbiAgICBjb25zdF9zZXQgbmFtZSwgQF9fY2xvY2tzX18uc2l6ZVxuICAgIEBfX2Nsb2Nrc19fIDw8IGZ1bmNcbiAgZW5kXG5cbiAgX19yZWdpc3Rlcl9jbG9ja19fIDpDTE9DS19SRUFMVElNRSwgYGZ1bmN0aW9uKCkgeyByZXR1cm4gRGF0ZS5ub3coKSB9YFxuXG4gIG1vbm90b25pYyA9IGZhbHNlXG5cbiAgJXh7XG4gICAgaWYgKE9wYWwuZ2xvYmFsLnBlcmZvcm1hbmNlKSB7XG4gICAgICBtb25vdG9uaWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChPcGFsLmdsb2JhbC5wcm9jZXNzICYmIHByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgICAvLyBsZXQgbm93IGJlIHRoZSBiYXNlIHRvIGdldCBzbWFsbGVyIG51bWJlcnNcbiAgICAgIHZhciBocnRpbWVfYmFzZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XG5cbiAgICAgIG1vbm90b25pYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWUoaHJ0aW1lX2Jhc2UpO1xuICAgICAgICB2YXIgdXMgPSAoaHJ0aW1lWzFdIC8gMTAwMCkgfCAwOyAvLyBjdXQgYmVsb3cgbWljcm9zZWNzO1xuICAgICAgICByZXR1cm4gKChocnRpbWVbMF0gKiAxMDAwKSArICh1cyAvIDEwMDApKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgX19yZWdpc3Rlcl9jbG9ja19fKDpDTE9DS19NT05PVE9OSUMsIG1vbm90b25pYykgaWYgbW9ub3RvbmljXG5cbiAgZGVmIHNlbGYucGlkXG4gICAgMFxuICBlbmRcblxuICBkZWYgc2VsZi50aW1lc1xuICAgIHQgPSBUaW1lLm5vdy50b19mXG4gICAgQmVuY2htYXJrOjpUbXMubmV3KHQsIHQsIHQsIHQsIHQpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNsb2NrX2dldHRpbWUoY2xvY2tfaWQsIHVuaXQgPSA6ZmxvYXRfc2Vjb25kKVxuICAgIChjbG9jayA9IEBfX2Nsb2Nrc19fW2Nsb2NrX2lkXSkgfHwgcmFpc2UoRXJybm86OkVJTlZBTCwgXCJjbG9ja19nZXR0aW1lKCN7Y2xvY2tfaWR9KSAje0BfX2Nsb2Nrc19fW2Nsb2NrX2lkXX1cIilcbiAgICAleHtcbiAgICAgIHZhciBtcyA9IGNsb2NrKCk7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSAnZmxvYXRfc2Vjb25kJzogICAgICByZXR1cm4gIChtcyAvIDEwMDApOyAgICAgICAgIC8vIG51bWJlciBvZiBzZWNvbmRzIGFzIGEgZmxvYXQgKGRlZmF1bHQpXG4gICAgICAgIGNhc2UgJ2Zsb2F0X21pbGxpc2Vjb25kJzogcmV0dXJuICAobXMgLyAxKTsgICAgICAgICAgICAvLyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFzIGEgZmxvYXRcbiAgICAgICAgY2FzZSAnZmxvYXRfbWljcm9zZWNvbmQnOiByZXR1cm4gIChtcyAqIDEwMDApOyAgICAgICAgIC8vIG51bWJlciBvZiBtaWNyb3NlY29uZHMgYXMgYSBmbG9hdFxuICAgICAgICBjYXNlICdzZWNvbmQnOiAgICAgICAgICAgIHJldHVybiAoKG1zIC8gMTAwMCkgICAgfCAwKTsgLy8gbnVtYmVyIG9mIHNlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6ICAgICAgIHJldHVybiAoKG1zIC8gMSkgICAgICAgfCAwKTsgLy8gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGNhc2UgJ21pY3Jvc2Vjb25kJzogICAgICAgcmV0dXJuICgobXMgKiAxMDAwKSAgICB8IDApOyAvLyBudW1iZXIgb2YgbWljcm9zZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgY2FzZSAnbmFub3NlY29uZCc6ICAgICAgICByZXR1cm4gKChtcyAqIDEwMDAwMDApIHwgMCk7IC8vIG51bWJlciBvZiBuYW5vc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGRlZmF1bHQ6ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bmV4cGVjdGVkIHVuaXQ6ICN7dW5pdH1cIn1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG5cbmNsYXNzIFNpZ25hbFxuICBkZWYgc2VsZi50cmFwKCopXG4gIGVuZFxuZW5kXG5cbmNsYXNzIEdDXG4gIGRlZiBzZWxmLnN0YXJ0XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJAX19jbG9ja3NfXyIsIl9fcmVnaXN0ZXJfY2xvY2tfXyIsInNlbGYiLCJjb25zdF9zZXQiLCJuYW1lIiwic2l6ZSIsIjw8IiwiZnVuYyIsIm1vbm90b25pYyIsInBpZCIsIjAiLCJ0aW1lcyIsInQiLCJub3ciLCJ0b19mIiwibmV3IiwiY2xvY2tfZ2V0dGltZSIsIiRyZXRfb3JfMSIsImNsb2NrIiwiW10iLCJjbG9ja19pZCIsInJhaXNlIiwidW5pdCIsInRyYXAiLCJzdGFydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsRUFBQUE7QUFBQUEsRUFBQUE7O0FBQUFBLElBQUFBOztBQUFBQTtBQUNFLElBQUFDLGtCQUFjLEVBQWQ7QUFBQSxJQUNBQyxVQUFJQyxJQUFKRCx5QkFBQUEsZ0NBQUFBLDhCQUE0QixJQUFELEVBQU8sSUFBbENBO0FBQUFBLE1BQUFBO0FBQUFBOztBQUFBQTtBQUNFLFVBQUFFLFdBQUFBLENBQVVDLE1BQU1KLGVBQUFL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NDA3NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tL2Zvcm1hdHRlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBSYW5kb21cbiAgbW9kdWxlIEZvcm1hdHRlclxuICAgIGRlZiBoZXgoY291bnQgPSBuaWwpXG4gICAgICBjb3VudCA9IFJhbmRvbS5fdmVyaWZ5X2NvdW50KGNvdW50KVxuICAgICAgJXh7XG4gICAgICAgIHZhciBieXRlcyA9ICN7Ynl0ZXMoY291bnQpfTtcbiAgICAgICAgdmFyIG91dCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgI3tjb3VudH07IGkrKykge1xuICAgICAgICAgIG91dCArPSBieXRlcy5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAje2BvdXRgLmVuY29kZSgnVVMtQVNDSUknKX07XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZG9tX2J5dGVzKGNvdW50ID0gbmlsKVxuICAgICAgYnl0ZXMoY291bnQpXG4gICAgZW5kXG5cbiAgICBkZWYgYmFzZTY0KGNvdW50ID0gbmlsKVxuICAgICAgQmFzZTY0LnN0cmljdF9lbmNvZGU2NChyYW5kb21fYnl0ZXMoY291bnQpKS5lbmNvZGUoJ1VTLUFTQ0lJJylcbiAgICBlbmRcblxuICAgIGRlZiB1cmxzYWZlX2Jhc2U2NChjb3VudCA9IG5pbCwgcGFkZGluZyA9IGZhbHNlKVxuICAgICAgQmFzZTY0LnVybHNhZmVfZW5jb2RlNjQocmFuZG9tX2J5dGVzKGNvdW50KSwgcGFkZGluZykuZW5jb2RlKCdVUy1BU0NJSScpXG4gICAgZW5kXG5cbiAgICBkZWYgdXVpZFxuICAgICAgc3RyID0gaGV4KDE2KS5zcGxpdCgnJylcbiAgICAgIHN0clsxMl0gPSAnNCdcbiAgICAgIHN0clsxNl0gPSBgKHBhcnNlSW50KCN7c3RyWzE2XX0sIDE2KSAmIDMgfCA4KS50b1N0cmluZygxNilgXG4gICAgICBzdHIgPSBbc3RyWzAuLi44XSwgc3RyWzguLi4xMl0sIHN0clsxMi4uLjE2XSwgc3RyWzE2Li4uMjBdLCBzdHJbMjAuLi4zMl1dXG4gICAgICBzdHIgPSBzdHIubWFwKCY6am9pbilcbiAgICAgIHN0ci5qb2luKCctJylcbiAgICBlbmRcblxuICAgICMgSW1wbGVtZW50ZWQgaW4gdGVybXMgb2YgYCNieXRlc2AgZm9yIFNlY3VyZVJhbmRvbSwgYnV0IFJhbmRvbSBvdmVycmlkZXMgdGhpc1xuICAgICMgbWV0aG9kIHRvIGltcGxlbWVudCBgI2J5dGVzYCBpbiB0ZXJtcyBvZiBgI3JhbmRvbV9mbG9hdGAuIE5vdCBwYXJ0IG9mIHN0YW5kYXJkXG4gICAgIyBSdWJ5IGludGVyZmFjZSAtIHVzZSByYW5kb21fbnVtYmVyIGZvciBwb3J0YWJpbGl0eS5cbiAgICBkZWYgcmFuZG9tX2Zsb2F0XG4gICAgICBicyA9IGJ5dGVzKDQpXG4gICAgICBudW0gPSAwXG4gICAgICA0LnRpbWVzIGRvIHxpfFxuICAgICAgICBudW0gPDw9IDhcbiAgICAgICAgbnVtIHw9IGJzW2ldLm9yZFxuICAgICAgZW5kXG4gICAgICBudW0uYWJzIC8gMHg3ZmZmZmZmZlxuICAgIGVuZFxuXG4gICAgZGVmIHJhbmRvbV9udW1iZXIobGltaXQgPSB1bmRlZmluZWQpXG4gICAgICAleHtcbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tRmxvYXQoKSB7XG4gICAgICAgICAgcmV0dXJuICN7cmFuZG9tX2Zsb2F0fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbUludChtYXgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihyYW5kb21GbG9hdCgpICogbWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbVJhbmdlKCkge1xuICAgICAgICAgIHZhciBtaW4gPSBsaW1pdC5iZWdpbixcbiAgICAgICAgICAgICAgbWF4ID0gbGltaXQuZW5kO1xuXG4gICAgICAgICAgaWYgKG1pbiA9PT0gbmlsIHx8IG1heCA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsZW5ndGggPSBtYXggLSBtaW47XG5cbiAgICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXggJSAxID09PSAwICYmIG1pbiAlIDEgPT09IDAgJiYgIWxpbWl0LmV4Y2wpIHtcbiAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByYW5kb21JbnQobGVuZ3RoKSArIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmRvbUZsb2F0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGltaXQuJCRpc19yYW5nZSkge1xuICAgICAgICAgIHJldHVybiByYW5kb21SYW5nZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbWl0LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGltaXQgJSAxID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmRvbUZsb2F0KCkgKiBsaW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGltaXQgPSAje09wYWwuY29lcmNlX3RvIShsaW1pdCwgSW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGFscGhhbnVtZXJpYyhjb3VudCA9IG5pbClcbiAgICAgIGNvdW50ID0gUmFuZG9tLl92ZXJpZnlfY291bnQoY291bnQpXG4gICAgICBtYXAgPSBbJzAnLi4nOScsICdhJy4uJ3onLCAnQScuLidaJ10ubWFwKCY6dG9fYSkuZmxhdHRlblxuICAgICAgQXJyYXkubmV3KGNvdW50KSBkbyB8aXxcbiAgICAgICAgbWFwW3JhbmRvbV9udW1iZXIobWFwLmxlbmd0aCldXG4gICAgICBlbmQuam9pblxuICAgIGVuZFxuICBlbmRcblxuICBpbmNsdWRlIFJhbmRvbTo6Rm9ybWF0dGVyXG4gIGV4dGVuZCBSYW5kb206OkZvcm1hdHRlclxuZW5kXG4iXSwibmFtZXMiOlsiY2xhc3MiLCJtb2R1bGUiLCJoZXgiLCJjb3VudCIsIl92ZXJpZnlfY291bnQiLCJieXRlcyIsImVuY29kZSIsInJhbmRvbV9ieXRlcyIsImJhc2U2NCIsInN0cmljdF9lbmNvZGU2NCIsInVybHNhZmVfYmFzZTY0IiwidXJsc2FmZV9lbmNvZGU2NCIsInBhZGRpbmciLCJ1dWlkIiwic3RyIiwiMTYiLCJzcGxpdCIsIiR3cml0ZXIiLCIxMiIsIltdPSIsIi0iLCIxIiwiW10iLCIwIiwiOCIsIjIwIiwiMzIiLCJtYXAiLCJqb2luIiwicmFuZG9tX2Zsb2F0IiwiYnMiLCI0IiwibnVtIiwidGltZXMiLCI8PCIsInwiLCJpIiwib3JkIiwiLyIsImFicyIsIjIxNDc0ODM2NDciLCJyYW5kb21fbnVtYmVyIiwicmFpc2UiLCJsaW1pdCIsImNvZXJjZV90byEiLCJhbHBoYW51bWVyaWMiLCJmbGF0dGVuIiwibmV3IiwibGVuZ3RoIiwiaW5jbHVkZSIsImV4dGVuZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQ0UsSUFBQUM7QUFBQUEsSUFBQUE7O0FBQUFBLE1BQUFBOztBQUFBQTtBQUNFO0FBQUFDLE1BQUFBLHVCQUFBQSxtQkFBQUEsZUFBUSxLQUFSQTtBQUFBQSxRQUFBQTs7QUFBQUE7QUFISjtBQUdZLFFBQUE7QUFBQSxRQUFBLFVBQVEsR0FBUjtBQUFBLFFBQUEsQ0FIWjtBQUFBLFFBSU1DLFFBQVEsc0JBQUFDLGVBQUFBLENBQXFCRCxLQUFyQkMsQ0FKZDtBQUFBO0FBTUEsd0JBQXNCQyxPQUFBQSxDQUFNRixLQUFORSxDQUFhO0FBQ25DO0FBQ0EsNEJBQThCRixLQUFNO0FBQ3BDO0FBQ0E7QUFDQSxlQUFpQixDQUFDLEdBQUQsQ0FBQUcsUUFBQUEsQ0FBYSxVQUFiQSxDQUF5QjtBQUMxQyxNQVpBO0FBR0lKLE1BQUFBLENBQUFBLCtCQUFBQSxDQUFBO0FBQUE7QUFZQUssTUFBQUEsZ0NBQUFBLDRCQUFBQSx3QkFBaUIsS0FBakJBO0FBQUFBLFFBQUFBOztBQUFBQTtBQWZKO0FBZXFCLFFBQUE7QUFBQSxRQUFBLFVBQVEsR0FBUjtBQUFBLFFBQUEsQ0FmckI7QUFBQSxRQWdCTSxXQUFBRixPQUFBQSxDQUFNRixLQUFORSxDQWhCTjtBQWVJRSxNQUFBQSxDQUFBQSx3Q0FBQUEsQ0FaQTtBQUFBO0FBZ0JBQyxNQUFBQSwwQkFBQUEsc0JBQUFBLGtCQUFXLEtBQVhBO0FBQUFBLFFBQUFBOztBQUFBQTtBQW5CSjtBQW1CZSxRQUFBO0FBQUEsUUFBQSxVQUFRLEdBQVI7QUFBQSxRQUFBLENBbkJmO0FBQUEsUUFvQk0sT0FBQSxzQkFBQUMsaUJBQUFBLEtBQXVCRixjQUFBQSxDQUFhSixL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LEVBQUssR0FBTCxRQUFELEVBQVcsT0FBQSxHQUFBLEVBQUssR0FBTCxRQUFYLEVBQXFCLE9BQUEsR0FBQSxFQUFLLEdBQUwsUUFBckIsQ0FBQUEsT0FBQUEsRUFBQUEsRUFBQUEsRUFBb0MsaUJBQXBDQSxDQUFBbUIsU0FBQUEsQ0FBQUEsQ0FqSFo7QUFBQSxRQWtITSxPQUFBQyxNQUFBLHFCQUFBQSxPQUFBQSxFQUFBQSxDQUFVNUMsS0FBVjRDLENBQUFBLEVBbEhOLGlCQWtIMkIsQ0FsSDNCLEVBQUE7O0FBQUE7QUFBQTtBQWtIMkIsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBbEgzQjtBQUFBLFVBbUhRLE9BQUFwQixHQUFBTCxPQUFBQSxLQUFJbUIsZUFBQUEsQ0FBY2QsR0FBQXFCLFFBQUFBLENBQUFBLENBQWRQLENBQUpuQixDQW5IUixDQUFBLG1CQUFBLGtCQUFBLE1Ba0hNeUIsQ0FBQW5CLE1BQUFBLENBQUFBLENBbEhOO0FBK0dJaUIsTUFBQUEsQ0FBQUEsd0NBQUFBLENBQUFBLHdCQTVHQTtBQURGNUMsSUFBQUEsR0FBQUEsV0FBQUEsV0FBQTtBQUFBLFFBc0hBZ0QsU0FBQUEsQ0FBUSxJQUFBLHNCQUFBLGNBQVJBLENBdEhBO0FBQUEsSUF1SEEsV0FBQUMsUUFBQUEsQ0FBTyxJQUFBLHNCQUFBLGNBQVBBLENBdkhBO0FBREZsRCxFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0MjgxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5kb20ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBmYWxzeVxuXG5jbGFzcyBSYW5kb21cbiAgYXR0cl9yZWFkZXIgOnNlZWQsIDpzdGF0ZVxuXG4gIGRlZiBzZWxmLl92ZXJpZnlfY291bnQoY291bnQpXG4gICAgJXh7XG4gICAgICBpZiAoJGZhbHN5KGNvdW50KSkgY291bnQgPSAxNjtcbiAgICAgIGlmICh0eXBlb2YgY291bnQgIT09IFwibnVtYmVyXCIpIGNvdW50ID0gI3tgY291bnRgLnRvX2ludH07XG4gICAgICBpZiAoY291bnQgPCAwKSAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBzdHJpbmcgc2l6ZSAob3Igc2l6ZSB0b28gYmlnKSd9O1xuICAgICAgY291bnQgPSBNYXRoLmZsb29yKGNvdW50KTtcbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKHNlZWQgPSBSYW5kb20ubmV3X3NlZWQpXG4gICAgc2VlZCA9IE9wYWwuY29lcmNlX3RvIShzZWVkLCBJbnRlZ2VyLCA6dG9faW50KVxuICAgIEBzdGF0ZSA9IHNlZWRcbiAgICByZXNlZWQoc2VlZClcbiAgZW5kXG5cbiAgZGVmIHJlc2VlZChzZWVkKVxuICAgIEBzZWVkID0gc2VlZFxuICAgIGBzZWxmLiRybmcgPSBPcGFsLiQkcmFuZC5yZXNlZWQoc2VlZClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ld19zZWVkXG4gICAgYE9wYWwuJCRyYW5kLm5ld19zZWVkKClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnJhbmQobGltaXQgPSB1bmRlZmluZWQpXG4gICAgREVGQVVMVC5yYW5kKGxpbWl0KVxuICBlbmRcblxuICBkZWYgc2VsZi5zcmFuZChuID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIG4gPSBPcGFsLmNvZXJjZV90byEobiwgSW50ZWdlciwgOnRvX2ludClcblxuICAgIHByZXZpb3VzX3NlZWQgPSBERUZBVUxULnNlZWRcbiAgICBERUZBVUxULnJlc2VlZChuKVxuICAgIHByZXZpb3VzX3NlZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYudXJhbmRvbShzaXplKVxuICAgIDo6U2VjdXJlUmFuZG9tLmJ5dGVzKHNpemUpXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIFJhbmRvbSA9PT0gb3RoZXJcblxuICAgIHNlZWQgPT0gb3RoZXIuc2VlZCAmJiBzdGF0ZSA9PSBvdGhlci5zdGF0ZVxuICBlbmRcblxuICBkZWYgYnl0ZXMobGVuZ3RoKVxuICAgIGxlbmd0aCA9IFJhbmRvbS5fdmVyaWZ5X2NvdW50KGxlbmd0aClcblxuICAgIEFycmF5Lm5ldyhsZW5ndGgpIHsgcmFuZCgyNTUpLmNociB9LmpvaW4uZW5jb2RlKCdBU0NJSS04QklUJylcbiAgZW5kXG5cbiAgZGVmIHNlbGYuYnl0ZXMobGVuZ3RoKVxuICAgIERFRkFVTFQuYnl0ZXMobGVuZ3RoKVxuICBlbmRcblxuICBkZWYgcmFuZChsaW1pdCA9IHVuZGVmaW5lZClcbiAgICByYW5kb21fbnVtYmVyKGxpbWl0KVxuICBlbmRcblxuICAjIE5vdCBwYXJ0IG9mIHRoZSBSdWJ5IGludGVyZmFjZSAodXNlICNyYW5kb21fbnVtYmVyIGZvciBwb3J0YWJpbGl0eSksIGJ1dFxuICAjIHVzZWQgYnkgUmFuZG9tOjpGb3JtYXR0ZXIgYXMgYSBzaG9ydGN1dCwgYXMgZm9yIFJhbmRvbSBpbnRlcmZhY2UgdGhlIGZsb2F0XG4gICMgUk5HIGlzIHByaW1hcnkuXG4gIGRlZiByYW5kb21fZmxvYXRcbiAgICAleHtcbiAgICAgIHNlbGYuc3RhdGUrKztcbiAgICAgIHJldHVybiBPcGFsLiQkcmFuZC5yYW5kKHNlbGYuJHJuZyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5yYW5kb21fZmxvYXRcbiAgICBERUZBVUxULnJhbmRvbV9mbG9hdFxuICBlbmRcblxuICBkZWYgc2VsZi5nZW5lcmF0b3I9KGdlbmVyYXRvcilcbiAgICBgT3BhbC4kJHJhbmQgPSAje2dlbmVyYXRvcn1gXG5cbiAgICBpZiBjb25zdF9kZWZpbmVkPyA6REVGQVVMVFxuICAgICAgREVGQVVMVC5yZXNlZWRcbiAgICBlbHNlXG4gICAgICBjb25zdF9zZXQgOkRFRkFVTFQsIG5ldyhuZXdfc2VlZClcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsImF0dHJfcmVhZGVyIiwiX3ZlcmlmeV9jb3VudCIsInNlbGYiLCJ0b19pbnQiLCJyYWlzZSIsImluaXRpYWxpemUiLCJuZXdfc2VlZCIsInNlZWQiLCJjb2VyY2VfdG8hIiwiQHN0YXRlIiwicmVzZWVkIiwiQHNlZWQiLCJyYW5kIiwibGltaXQiLCJzcmFuZCIsIm4iLCJwcmV2aW91c19zZWVkIiwidXJhbmRvbSIsImJ5dGVzIiwic2l6ZSIsIj09IiwiPT09Iiwib3RoZXIiLCIkcmV0X29yXzEiLCJzdGF0ZSIsImxlbmd0aCIsIm5ldyIsIjI1NSIsImNociIsImpvaW4iLCJlbmNvZGUiLCJyYW5kb21fbnVtYmVyIiwicmFuZG9tX2Zsb2F0IiwiZ2VuZXJhdG9yPSIsImdlbmVyYXRvciIsImNvbnN0X2RlZmluZWQ/IiwiY29uc3Rfc2V0Il0sIm1hcHBpbmdzIjoiOzs7OztFQUVBLE9BQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxRQUFBQyxhQUFBQSxDQUFZLFFBQU8sT0FBbkJBLENBQUE7QUFBQSxJQUVBQyxVQUFJQyxJQUFKRCxvQkFBQUEsMEJBQUFBLHlCQUF1QixLQUF2QkE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBRUY7QUFDQSw2Q0FBK0MsQ0FBQyxLQUFELENBQUFFLFFBQUFBLENBQUFBLENBQWU7QUFDOUQseUJBQXVCQyxPQUFBQSxDQUFNLCtCQUFlLHdDQUFyQkEsQ0FBOEQ7QUFDckY7QUFDQTtBQUNBO0FBUEVILElBQUFBLENBQUFBLHFDQUFBQSxDQUZBO0FBQUE7QUFZQUksSUFBQUEsOEJBQUFBLHVCQUFBQSxzQkFBZSxJQUFmQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFoQkY7QUFnQmlCLE1BQUE7QUFBQSxNQUFBLFNBQU8sc0JBQUFDLFVBQUFBLENBQUFBLENBQVA7QUFBQSxNQUFBLENBaEJqQjtBQUFBLE1BaUJJQyxPQUFPLG9CQUFBQyxlQUFBQSxDQUFnQkQsTUFBTSx5QkFBUyxRQUEvQkMsQ0FqQlg7QUFBQSxNQWtCSUMsYUFBU0YsSUFsQmI7QUFBQSxNQW1CSSxXQUFBRyxRQUFBQSxDQUFPSCxJQUFQRyxDQW5C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QUFkUDtBQURGQSxJQUFBQSxDQUFBQSw4QkFBQUEsQ0F2REE7QUFBQTtBQTJEQU4sSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBUyxLQUFUQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUEvREYsTUFBQTtBQUFBLE1BZ0VJLFdBQUFtQixlQUFBQSxDQUFjbEIsS0FBZGtCLENBaEVKO0FBK0RFbkIsSUFBQUEsQ0FBQUEsOEJBQUFBLENBM0RBO0FBQUE7QUFrRUFvQixJQUFBQSxnQ0FBQUEsMEJBQUFBLHdCQUFBQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFFRjtBQUNBO0FBQ0E7QUFKRUEsSUFBQUEsQ0FBQUEscUNBQUFBLENBbEVBO0FBQUEsSUF5RUFBLFVBQUk5QixJQUFKOEIsbUJBQUFBLDBCQUFBQSx3QkFBQUE7QUFBQUEsTUFBQUE7O0FBQUFBLE1BQ0UsT0FBQSx1QkFBQUEsY0FBQUEsQ0FBQUE7QUFERkEsSUFBQUEsQ0FBQUEscUNBQUFBLENBekVBO0FBQUEsSUE2RUEsT0FBQUMsQ0FBQUEsVUFBSS9CLElBQUorQixpQkFBQUEsMEJBQUFBLFNBQW9CLFNBQXBCQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFDRSxNQUFDLGNBQWdCQyxTQUFqQjtBQUFBLE1BRUEsSUFBQSxZQUFHQyxtQkFBQUEsQ0FBZSxTQUFmQSxDQUFILENBQUE7QUFBQSxRQUNFLE9BQUEsdUJBQUF6QixRQUFBQSxDQUFBQTtBQURGLE1BQUE7QUFBQSxRQUdFLFdBQUEwQixXQUFBQSxDQUFVLGVBQVVWLEtBQUFBLEtBQUlwQixVQUFBQSxDQUFBQSxDQUFKb0IsQ0FBcEJVO0FBSEYsTUFBQSxDQUZBO0FBREZILElBQUFBLENBQUFBLHFDQUFBQSxDQUFBQSxzQkE3RUE7QUFERmxDLEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ0MjEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmRvbS9tZXJzZW5uZV90d2lzdGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgVGhpcyBpcyBiYXNlZCBvbiBhbiBhZGFwdGF0aW9uIG9mIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEncyBjb2RlXG4jIGRvbmUgYnkgU2VhbiBNY0N1bGxvdWdoIDxiYW5rc2VhbkBnbWFpbC5jb20+IGFuZCBEYXZlIEhlaXR6bWFuXG4jIDxkYXZlaGVpdHptYW5AeWFob28uY29tPiwgc3Vic2VxdWVudGx5IHJlYWRhcHRlZCBmcm9tIGFuIHVwZGF0ZWQgdmVyc2lvbiBvZlxuIyBydWJ5J3MgcmFuZG9tLmMgKHJldiBjMzhhMTgzMDMyYTc4MjZkZjFhZGFiZDhhYTA3MjVjNzEzZDUzZTFjKS5cbiNcbiMgVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBub3RpY2UgZnJvbSByYW5kb20uYyBmb2xsb3dzLlxuI1xuIyAgIFRoaXMgaXMgYmFzZWQgb24gdHJpbW1lZCB2ZXJzaW9uIG9mIE1UMTk5MzcuICBUbyBnZXQgdGhlIG9yaWdpbmFsIHZlcnNpb24sXG4jICAgY29udGFjdCA8aHR0cDovL3d3dy5tYXRoLnNjaS5oaXJvc2hpbWEtdS5hYy5qcC9+bS1tYXQvTVQvZW10Lmh0bWw+LlxuI1xuIyAgIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgbm90aWNlIGZvbGxvd3MuXG4jXG4jICAgICAgQSBDLXByb2dyYW0gZm9yIE1UMTk5MzcsIHdpdGggaW5pdGlhbGl6YXRpb24gaW1wcm92ZWQgMjAwMi8yLzEwLlxuIyAgICAgIENvZGVkIGJ5IFRha3VqaSBOaXNoaW11cmEgYW5kIE1ha290byBNYXRzdW1vdG8uXG4jICAgICAgVGhpcyBpcyBhIGZhc3RlciB2ZXJzaW9uIGJ5IHRha2luZyBTaGF3biBDb2t1cydzIG9wdGltaXphdGlvbixcbiMgICAgICBNYXR0aGUgQmVsbGV3J3Mgc2ltcGxpZmljYXRpb24sIElzYWt1IFdhZGEncyByZWFsIHZlcnNpb24uXG4jXG4jICAgICAgQmVmb3JlIHVzaW5nLCBpbml0aWFsaXplIHRoZSBzdGF0ZSBieSB1c2luZyBpbml0X2dlbnJhbmQobXQsIHNlZWQpXG4jICAgICAgb3IgaW5pdF9ieV9hcnJheShtdCwgaW5pdF9rZXksIGtleV9sZW5ndGgpLlxuI1xuIyAgICAgIENvcHlyaWdodCAoQykgMTk5NyAtIDIwMDIsIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEsXG4jICAgICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiNcbiMgICAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiMgICAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiMgICAgICBhcmUgbWV0OlxuI1xuIyAgICAgICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiMgICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiNcbiMgICAgICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4jICAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4jICAgICAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuI1xuIyAgICAgICAgMy4gVGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZVxuIyAgICAgICAgICAgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuXG4jICAgICAgICAgICBwZXJtaXNzaW9uLlxuI1xuIyAgICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiMgICAgICBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4jICAgICAgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4jICAgICAgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXG4jICAgICAgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4jICAgICAgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuIyAgICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuIyAgICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiMgICAgICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuIyAgICAgIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuIyAgICAgIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuI1xuI1xuIyAgICAgIEFueSBmZWVkYmFjayBpcyB2ZXJ5IHdlbGNvbWUuXG4jICAgICAgaHR0cDovL3d3dy5tYXRoLmtlaW8uYWMuanAvbWF0dW1vdG8vZW10Lmh0bWxcbiMgICAgICBlbWFpbDogbWF0dW1vdG9AbWF0aC5rZWlvLmFjLmpwXG5tZXJzZW5uZV90d2lzdGVyID0gJXh7KGZ1bmN0aW9uKCkge1xuICAvKiBQZXJpb2QgcGFyYW1ldGVycyAqL1xuICB2YXIgTiA9IDYyNDtcbiAgdmFyIE0gPSAzOTc7XG4gIHZhciBNQVRSSVhfQSA9IDB4OTkwOGIwZGY7ICAgICAgLyogY29uc3RhbnQgdmVjdG9yIGEgKi9cbiAgdmFyIFVNQVNLID0gMHg4MDAwMDAwMDsgICAgICAgICAvKiBtb3N0IHNpZ25pZmljYW50IHctciBiaXRzICovXG4gIHZhciBMTUFTSyA9IDB4N2ZmZmZmZmY7ICAgICAgICAgLyogbGVhc3Qgc2lnbmlmaWNhbnQgciBiaXRzICovXG4gIHZhciBNSVhCSVRTID0gZnVuY3Rpb24odSx2KSB7IHJldHVybiAoICgodSkgJiBVTUFTSykgfCAoKHYpICYgTE1BU0spICk7IH07XG4gIHZhciBUV0lTVCA9IGZ1bmN0aW9uKHUsdikgeyByZXR1cm4gKE1JWEJJVFMoKHUpLCh2KSkgPj4+IDEpIF4gKCh2ICYgMHgxKSA/IE1BVFJJWF9BIDogMHgwKTsgfTtcblxuICBmdW5jdGlvbiBpbml0KHMpIHtcbiAgICB2YXIgbXQgPSB7bGVmdDogMCwgbmV4dDogTiwgc3RhdGU6IG5ldyBBcnJheShOKX07XG4gICAgaW5pdF9nZW5yYW5kKG10LCBzKTtcbiAgICByZXR1cm4gbXQ7XG4gIH1cblxuICAvKiBpbml0aWFsaXplcyBtdFtOXSB3aXRoIGEgc2VlZCAqL1xuICBmdW5jdGlvbiBpbml0X2dlbnJhbmQobXQsIHMpIHtcbiAgICB2YXIgaiwgaTtcbiAgICBtdC5zdGF0ZVswXSA9IHMgPj4+IDA7XG4gICAgZm9yIChqPTE7IGo8TjsgaisrKSB7XG4gICAgICBtdC5zdGF0ZVtqXSA9ICgxODEyNDMzMjUzICogKChtdC5zdGF0ZVtqLTFdIF4gKG10LnN0YXRlW2otMV0gPj4gMzApID4+PiAwKSkgKyBqKTtcbiAgICAgIC8qIFNlZSBLbnV0aCBUQU9DUCBWb2wyLiAzcmQgRWQuIFAuMTA2IGZvciBtdWx0aXBsaWVyLiAqL1xuICAgICAgLyogSW4gdGhlIHByZXZpb3VzIHZlcnNpb25zLCBNU0JzIG9mIHRoZSBzZWVkIGFmZmVjdCAgICovXG4gICAgICAvKiBvbmx5IE1TQnMgb2YgdGhlIGFycmF5IHN0YXRlW10uICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgIC8qIDIwMDIvMDEvMDkgbW9kaWZpZWQgYnkgTWFrb3RvIE1hdHN1bW90byAgICAgICAgICAgICAqL1xuICAgICAgbXQuc3RhdGVbal0gJj0gMHhmZmZmZmZmZjsgIC8qIGZvciA+MzIgYml0IG1hY2hpbmVzICovXG4gICAgfVxuICAgIG10LmxlZnQgPSAxO1xuICAgIG10Lm5leHQgPSBOO1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgTiB3b3JkcyBhdCBvbmUgdGltZSAqL1xuICBmdW5jdGlvbiBuZXh0X3N0YXRlKG10KSB7XG4gICAgdmFyIHAgPSAwLCBfcCA9IG10LnN0YXRlO1xuICAgIHZhciBqO1xuXG4gICAgbXQubGVmdCA9IE47XG4gICAgbXQubmV4dCA9IDA7XG5cbiAgICBmb3IgKGo9Ti1NKzE7IC0tajsgcCsrKVxuICAgICAgX3BbcF0gPSBfcFtwKyhNKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wW3ArKDEpXSk7XG5cbiAgICBmb3IgKGo9TTsgLS1qOyBwKyspXG4gICAgICBfcFtwXSA9IF9wW3ArKE0tTildIF4gVFdJU1QoX3BbcCsoMCldLCBfcFtwKygxKV0pO1xuXG4gICAgX3BbcF0gPSBfcFtwKyhNLU4pXSBeIFRXSVNUKF9wW3ArKDApXSwgX3BbMF0pO1xuICB9XG5cbiAgLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwweGZmZmZmZmZmXS1pbnRlcnZhbCAqL1xuICBmdW5jdGlvbiBnZW5yYW5kX2ludDMyKG10KSB7XG4gICAgLyogbXQgbXVzdCBiZSBpbml0aWFsaXplZCAqL1xuICAgIHZhciB5O1xuXG4gICAgaWYgKC0tbXQubGVmdCA8PSAwKSBuZXh0X3N0YXRlKG10KTtcbiAgICB5ID0gbXQuc3RhdGVbbXQubmV4dCsrXTtcblxuICAgIC8qIFRlbXBlcmluZyAqL1xuICAgIHkgXj0gKHkgPj4+IDExKTtcbiAgICB5IF49ICh5IDw8IDcpICYgMHg5ZDJjNTY4MDtcbiAgICB5IF49ICh5IDw8IDE1KSAmIDB4ZWZjNjAwMDA7XG4gICAgeSBePSAoeSA+Pj4gMTgpO1xuXG4gICAgcmV0dXJuIHkgPj4+IDA7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRfcGFpcl90b19yZWFsX2V4Y2x1c2l2ZShhLCBiKSB7XG4gICAgYSA+Pj49IDU7XG4gICAgYiA+Pj49IDY7XG4gICAgcmV0dXJuKGEqNjcxMDg4NjQuMCtiKSooMS4wLzkwMDcxOTkyNTQ3NDA5OTIuMCk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDEpIHdpdGggNTMtYml0IHJlc29sdXRpb25cbiAgZnVuY3Rpb24gZ2VucmFuZF9yZWFsKG10KSB7XG4gICAgLyogbXQgbXVzdCBiZSBpbml0aWFsaXplZCAqL1xuICAgIHZhciBhID0gZ2VucmFuZF9pbnQzMihtdCksIGIgPSBnZW5yYW5kX2ludDMyKG10KTtcbiAgICByZXR1cm4gaW50X3BhaXJfdG9fcmVhbF9leGNsdXNpdmUoYSwgYik7XG4gIH1cblxuICByZXR1cm4geyBnZW5yYW5kX3JlYWw6IGdlbnJhbmRfcmVhbCwgaW5pdDogaW5pdCB9O1xufSkoKX1cblxuY2xhc3MgUmFuZG9tXG4gIGB2YXIgTUFYX0lOVCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IE1hdGgucG93KDIsIDUzKSAtIDFgXG5cbiAgTUVSU0VOTkVfVFdJU1RFUl9HRU5FUkFUT1IgPSBge1xuICAgIG5ld19zZWVkOiBmdW5jdGlvbigpIHsgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIE1BWF9JTlQpOyB9LFxuICAgIHJlc2VlZDogZnVuY3Rpb24oc2VlZCkgeyByZXR1cm4gbWVyc2VubmVfdHdpc3Rlci5pbml0KHNlZWQpOyB9LFxuICAgIHJhbmQ6IGZ1bmN0aW9uKG10KSB7IHJldHVybiBtZXJzZW5uZV90d2lzdGVyLmdlbnJhbmRfcmVhbChtdCk7IH1cbiAgfWBcblxuICBzZWxmLmdlbmVyYXRvciA9IE1FUlNFTk5FX1RXSVNURVJfR0VORVJBVE9SXG5lbmRcbiJdLCJuYW1lcyI6WyJtZXJzZW5uZV90d2lzdGVyIiwiY2xhc3MiLCIkd3JpdGVyIiwiZ2VuZXJhdG9yPSIsInNlbGYiLCItIiwiMSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBc0RBLEVBQUFBLG1CQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQWhGQTtBQUFBLEVBa0ZBLE9BQUFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFDLDREQUFEO0FBQUEsSUFFQSwwREFBOEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsR0FKRSxDQUZBO0FBQUE7QUExSUYsSUFBQUMsVUFBQSxDQWtKbUIsMENBbEpuQixDQUFBO0FBQUEsSUFrSkVDLE1BQUFDLElBQUFELGNBQUFBLEVBbEpGLFVBQUFELE9BQUEsQ0FrSkVDLENBbEpGO0FBQUEsSUFBQSxPQUFBRCxPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQSxRQUFBLENBQUFHLEVBQUFDLENBQUFELENBQUEsQ0FBQSxDQTBJRTtBQURGSixFQUFBQSxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQSxXQWxGQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NTMwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi91bnN1cHBvcnRlZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIleHtcbiAgdmFyIHdhcm5pbmdzID0ge307XG5cbiAgZnVuY3Rpb24gaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUobWVzc2FnZSkge1xuICAgIHN3aXRjaCAoT3BhbC5jb25maWcudW5zdXBwb3J0ZWRfZmVhdHVyZXNfc2V2ZXJpdHkpIHtcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICAje0tlcm5lbC5yYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgbWVzc2FnZWB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIHdhcm4obWVzc2FnZSlcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIGlnbm9yZVxuICAgICAgLy8gbm9vcFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oc3RyaW5nKSB7XG4gICAgaWYgKHdhcm5pbmdzW3N0cmluZ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuaW5nc1tzdHJpbmddID0gdHJ1ZTtcbiAgICAje3dhcm4oYHN0cmluZ2ApfTtcbiAgfVxufVxuXG5jbGFzcyBTdHJpbmdcbiAgYHZhciBFUlJPUiA9IFwiU3RyaW5nIyVzIG5vdCBzdXBwb3J0ZWQuIE11dGFibGUgU3RyaW5nIG1ldGhvZHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gT3BhbC5cImBcblxuICBkZWYgPDwoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJzw8J1xuICBlbmRcblxuICBkZWYgY2FwaXRhbGl6ZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2NhcGl0YWxpemUhJ1xuICBlbmRcblxuICBkZWYgY2hvbXAhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdjaG9tcCEnXG4gIGVuZFxuXG4gIGRlZiBjaG9wISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnY2hvcCEnXG4gIGVuZFxuXG4gIGRlZiBkb3duY2FzZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2Rvd25jYXNlISdcbiAgZW5kXG5cbiAgZGVmIGdzdWIhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdnc3ViISdcbiAgZW5kXG5cbiAgZGVmIGxzdHJpcCEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2xzdHJpcCEnXG4gIGVuZFxuXG4gIGRlZiBuZXh0ISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnbmV4dCEnXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAncmV2ZXJzZSEnXG4gIGVuZFxuXG4gIGRlZiBzbGljZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3NsaWNlISdcbiAgZW5kXG5cbiAgZGVmIHNxdWVlemUhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzcXVlZXplISdcbiAgZW5kXG5cbiAgZGVmIHN0cmlwISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3RyaXAhJ1xuICBlbmRcblxuICBkZWYgc3ViISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3ViISdcbiAgZW5kXG5cbiAgZGVmIHN1Y2MhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzdWNjISdcbiAgZW5kXG5cbiAgZGVmIHN3YXBjYXNlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3dhcGNhc2UhJ1xuICBlbmRcblxuICBkZWYgdHIhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICd0ciEnXG4gIGVuZFxuXG4gIGRlZiB0cl9zISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAndHJfcyEnXG4gIGVuZFxuXG4gIGRlZiB1cGNhc2UhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICd1cGNhc2UhJ1xuICBlbmRcblxuICBkZWYgcHJlcGVuZCgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAncHJlcGVuZCdcbiAgZW5kXG5cbiAgZGVmIFtdPSgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnW109J1xuICBlbmRcblxuICBkZWYgY2xlYXIoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2NsZWFyJ1xuICBlbmRcblxuICBkZWYgZW5jb2RlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnZW5jb2RlISdcbiAgZW5kXG5cbiAgZGVmIHVuaWNvZGVfbm9ybWFsaXplISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAndW5pY29kZV9ub3JtYWxpemUhJ1xuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGB2YXIgRVJST1IgPSBcIk9iamVjdCBmcmVlemluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wYWxcImBcblxuICBkZWYgZnJlZXplXG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmcm96ZW4/XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGB2YXIgRVJST1IgPSBcIk9iamVjdCB0YWludGluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wYWxcImBcblxuICBkZWYgdGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHVudGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRhaW50ZWQ/XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuXG5jbGFzcyBNb2R1bGVcbiAgZGVmIHB1YmxpYygqbWV0aG9kcylcbiAgICAleHtcbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLiQkbW9kdWxlX2Z1bmN0aW9uID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBwcml2YXRlIHB1YmxpY1xuXG4gIGFsaWFzIHByb3RlY3RlZCBwdWJsaWNcblxuICBhbGlhcyBuZXN0aW5nIHB1YmxpY1xuXG4gIGRlZiBwcml2YXRlX2NsYXNzX21ldGhvZCgqKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgcHVibGljX2NsYXNzX21ldGhvZCBwcml2YXRlX2NsYXNzX21ldGhvZFxuXG4gIGRlZiBwcml2YXRlX21ldGhvZF9kZWZpbmVkPyhvYmopXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHByaXZhdGVfY29uc3RhbnQoKilcbiAgZW5kXG5cbiAgYWxpYXMgcHJvdGVjdGVkX21ldGhvZF9kZWZpbmVkPyBwcml2YXRlX21ldGhvZF9kZWZpbmVkP1xuXG4gIGFsaWFzIHB1YmxpY19pbnN0YW5jZV9tZXRob2RzIGluc3RhbmNlX21ldGhvZHNcblxuICBhbGlhcyBwdWJsaWNfaW5zdGFuY2VfbWV0aG9kIGluc3RhbmNlX21ldGhvZFxuXG4gIGFsaWFzIHB1YmxpY19tZXRob2RfZGVmaW5lZD8gbWV0aG9kX2RlZmluZWQ/XG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICBkZWYgcHJpdmF0ZV9tZXRob2RzKCopXG4gICAgW11cbiAgZW5kXG5cbiAgYWxpYXMgcHJpdmF0ZV9pbnN0YW5jZV9tZXRob2RzIHByaXZhdGVfbWV0aG9kc1xuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgZGVmIGV2YWwoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBcIlRvIHVzZSBLZXJuZWwjZXZhbCwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnb3BhbC1wYXJzZXInLiBcIlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9ibG9iLyN7UlVCWV9FTkdJTkVfVkVSU0lPTn0vZG9jcy9vcGFsX3BhcnNlci5tZCBmb3IgZGV0YWlscy5cIlxuICBlbmRcbmVuZFxuXG5kZWYgc2VsZi5wdWJsaWMoKilcbiAgIyBzdHViXG5lbmRcblxuZGVmIHNlbGYucHJpdmF0ZSgqKVxuICAjIHN0dWJcbmVuZFxuIl0sIm5hbWVzIjpbInJhaXNlIiwid2FybiIsImNsYXNzIiwiPDwiLCIlIiwiY2FwaXRhbGl6ZSEiLCJjaG9tcCEiLCJjaG9wISIsImRvd25jYXNlISIsImdzdWIhIiwibHN0cmlwISIsIm5leHQhIiwicmV2ZXJzZSEiLCJzbGljZSEiLCJzcXVlZXplISIsInN0cmlwISIsInN1YiEiLCJzdWNjISIsInN3YXBjYXNlISIsInRyISIsInRyX3MhIiwidXBjYXNlISIsInByZXBlbmQiLCJbXT0iLCJjbGVhciIsImVuY29kZSEiLCJ1bmljb2RlX25vcm1hbGl6ZSEiLCJtb2R1bGUiLCJmcmVlemUiLCJzZWxmIiwiZnJvemVuPyIsInRhaW50IiwidW50YWludCIsInRhaW50ZWQ/IiwicHVibGljIiwicHJpdmF0ZV9jbGFzc19tZXRob2QiLCJwcml2YXRlX21ldGhvZF9kZWZpbmVkPyIsInByaXZhdGVfY29uc3RhbnQiLCJwcml2YXRlX21ldGhvZHMiLCJldmFsIiwicHJpdmF0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFRLHNCQUFBQSxPQUFBQSxDQUFhLHFDQUFzQixPQUFuQ0E7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTUMsTUFBQUEsQ0FBTSxNQUFOQSxDQUFlO0FBQ3JCO0FBdkJBO0FBQUEsRUEwQkFDO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFDLHdGQUFEO0FBQUE7QUFFQUMsSUFBQUEsc0JBQUFBLG1CQUFBQSxTQTlCRixFQThCRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBOUJGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQStCSSxXQUFBSCxPQUFBQSxDQUFNLHFDQUFxQixDQUFDLEtBQUQsQ0FBQUksTUFBQUEsQ0FBVSxJQUFWQSxDQUEzQkosQ0EvQko7QUE4QkVHLElBQUFBLENBQUFBLCtCQUFBQSxDQUZBO0FBQUE7QUFNQUUsSUFBQUEsK0JBQUFBLDRCQUFBQSxTQWxDRixFQWtDRUE7QUFBQUEsTUFBQUE7O0FBQUFBO0FBbENGO0FBQUEsTUFBQSw0REFBQTtBQUFBLE1BQUE7QUFBQSxNQW1DSSxXQUFBTCxPQUFBQSxDQUFNLHFDQUFxQixDQUFDLEtBQUQsQ0FBQUksTUFBQUEsQ0FBVSxhQUFWQSxDQUEzQkosQ0FuQ0o7QUFrQ0VLLElBQUFBLENB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QUFBLENBQUFBLG1CQXJOQTs7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0OTYzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9vcGFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ29wYWwvYmFzZSdcbnJlcXVpcmUgJ29wYWwvbWluaSdcblxucmVxdWlyZSAnY29yZWxpYi9rZXJuZWwvZm9ybWF0J1xucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcnXG5yZXF1aXJlICdjb3JlbGliL21hdGgnXG5yZXF1aXJlICdjb3JlbGliL2NvbXBsZXgnXG5yZXF1aXJlICdjb3JlbGliL3JhdGlvbmFsJ1xucmVxdWlyZSAnY29yZWxpYi90aW1lJ1xucmVxdWlyZSAnY29yZWxpYi9zdHJ1Y3QnXG5yZXF1aXJlICdjb3JlbGliL2lvJ1xucmVxdWlyZSAnY29yZWxpYi9tYWluJ1xucmVxdWlyZSAnY29yZWxpYi9kaXInXG5yZXF1aXJlICdjb3JlbGliL2ZpbGUnXG5yZXF1aXJlICdjb3JlbGliL3Byb2Nlc3MnXG5yZXF1aXJlICdjb3JlbGliL3JhbmRvbS9mb3JtYXR0ZXInXG5yZXF1aXJlICdjb3JlbGliL3JhbmRvbSdcbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tL21lcnNlbm5lX3R3aXN0ZXInXG5cbnJlcXVpcmUgJ2NvcmVsaWIvdW5zdXBwb3J0ZWQnXG4iXSwibmFtZXMiOlsicmVxdWlyZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsTUFBQUEsU0FBQUEsQ0FBUSxXQUFSQSxDQUFBO0FBQUEsTUFDQUEsU0FBQUEsQ0FBUSxXQUFSQSxDQURBO0FBQUEsTUFHQUEsU0FBQUEsQ0FBUSx1QkFBUkEsQ0FIQTtBQUFBLE1BSUFBLFNBQUFBLENBQVEseUJBQVJBLENBSkE7QUFBQSxNQUtBQSxTQUFBQSxDQUFRLGNBQVJBLENBTEE7QUFBQSxNQU1BQSxTQUFBQSxDQUFRLGlCQUFSQSxDQU5BO0FBQUEsTUFPQUEsU0FBQUEsQ0FBUSxrQkFBUkEsQ0FQQTtBQUFBLE1BUUFBLFNBQUFBLENBQVEsY0FBUkEsQ0FSQTtBQUFBLE1BU0FBLFNBQUFBLENBQVEsZ0JBQVJBLENBVEE7QUFBQSxNQVVBQSxTQUFBQSxDQUFRLFlBQVJBLENBVkE7QUFBQSxNQVdBQSxTQUFBQSxDQUFRLGNBQVJBLENBWEE7QUFBQSxNQVlBQSxTQUFBQSxDQUFRLGFBQVJBLENBWkE7QUFBQSxNQWFBQSxTQUFBQSxDQUFRLGNBQVJBLENBYkE7QUFBQSxNQWNBQSxTQUFBQSxDQUFRLGlCQUFSQSxDQWRBO0FBQUEsTUFlQUEsU0FBQUEsQ0FBUSwwQkFBUkEsQ0FmQTtBQUFBLE1BZ0JBQSxTQUFBQSxDQUFRLGdCQUFSQSxDQWhCQTtBQUFBLE1BaUJBQSxTQUFBQSxDQUFRLGlDQUFSQSxDQWpCQTtBQUFBLEVBbUJBLFdBQUFBLFNBQUFBLENBQVEscUJBQVJBLENBbkJBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ5ODksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL29zdHJ1Y3QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgT3BlblN0cnVjdFxuICBkZWYgaW5pdGlhbGl6ZShoYXNoID0gbmlsKVxuICAgIEB0YWJsZSA9IHt9XG5cbiAgICBpZiBoYXNoXG4gICAgICBoYXNoLmVhY2hfcGFpciBkbyB8a2V5LCB2YWx1ZXxcbiAgICAgICAgQHRhYmxlW25ld19vc3RydWN0X21lbWJlcihrZXkpXSA9IHZhbHVlXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIFtdKG5hbWUpXG4gICAgQHRhYmxlW25hbWUudG9fc3ltXVxuICBlbmRcblxuICBkZWYgW109KG5hbWUsIHZhbHVlKVxuICAgIEB0YWJsZVtuZXdfb3N0cnVjdF9tZW1iZXIobmFtZSldID0gdmFsdWVcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG5hbWUsICphcmdzKVxuICAgIGlmIGFyZ3MubGVuZ3RoID4gMlxuICAgICAgcmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje25hbWV9JyBmb3IgIzxPcGVuU3RydWN0PlwiLCBuYW1lKVxuICAgIGVuZFxuICAgIGlmIG5hbWUuZW5kX3dpdGg/ICc9J1xuICAgICAgaWYgYXJncy5sZW5ndGggIT0gMVxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMSknXG4gICAgICBlbmRcbiAgICAgIEB0YWJsZVtuZXdfb3N0cnVjdF9tZW1iZXIobmFtZVswLi4tMl0pXSA9IGFyZ3NbMF1cbiAgICBlbHNlXG4gICAgICBAdGFibGVbbmFtZS50b19zeW1dXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1pZCwgaW5jbHVkZV9wcml2YXRlID0gZmFsc2UpICMgOm5vZG9jOlxuICAgIG1uYW1lID0gbWlkLnRvX3MuY2hvbXAoJz0nKS50b19zeW1cbiAgICBAdGFibGUmLmtleT8obW5hbWUpIHx8IHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3BhaXJcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfcGFpciB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBAdGFibGUuZWFjaF9wYWlyIGRvIHxwYWlyfFxuICAgICAgeWllbGQgcGFpclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pc19hPyhPcGVuU3RydWN0KVxuXG4gICAgQHRhYmxlID09IG90aGVyLmluc3RhbmNlX3ZhcmlhYmxlX2dldCg6QHRhYmxlKVxuICBlbmRcblxuICBkZWYgPT09KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb3RoZXIuaXNfYT8oT3BlblN0cnVjdClcblxuICAgIEB0YWJsZSA9PT0gb3RoZXIuaW5zdGFuY2VfdmFyaWFibGVfZ2V0KDpAdGFibGUpXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb3RoZXIuaXNfYT8oT3BlblN0cnVjdClcblxuICAgIEB0YWJsZS5lcWw/IG90aGVyLmluc3RhbmNlX3ZhcmlhYmxlX2dldCg6QHRhYmxlKVxuICBlbmRcblxuICBkZWYgdG9faFxuICAgIEB0YWJsZS5kdXBcbiAgZW5kXG5cbiAgZGVmIHRvX25cbiAgICBAdGFibGUudG9fblxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIEB0YWJsZS5oYXNoXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDp0YWJsZVxuXG4gIGRlZiBkZWxldGVfZmllbGQobmFtZSlcbiAgICBzeW0gPSBuYW1lLnRvX3N5bVxuICAgIGJlZ2luXG4gICAgICBzaW5nbGV0b25fY2xhc3MuX19zZW5kX18oOnJlbW92ZV9tZXRob2QsIHN5bSwgXCIje3N5bX09XCIpXG4gICAgcmVzY3VlIE5hbWVFcnJvclxuICAgIGVuZFxuICAgIEB0YWJsZS5kZWxldGUgc3ltXG4gIGVuZFxuXG4gIGRlZiBuZXdfb3N0cnVjdF9tZW1iZXIobmFtZSlcbiAgICBuYW1lID0gbmFtZS50b19zeW1cbiAgICB1bmxlc3MgcmVzcG9uZF90bz8obmFtZSlcbiAgICAgIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKG5hbWUpIHsgQHRhYmxlW25hbWVdIH1cbiAgICAgIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKFwiI3tuYW1lfT1cIikgeyB8eHwgQHRhYmxlW25hbWVdID0geCB9XG4gICAgZW5kXG4gICAgbmFtZVxuICBlbmRcblxuICBgdmFyIG9zdHJ1Y3RfaWRzO2BcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgdmFyIHRvcCA9IChvc3RydWN0X2lkcyA9PT0gdW5kZWZpbmVkKSxcbiAgICAgICAgICBvc3RydWN0X2lkID0gI3tfX2lkX199O1xuICAgIH1cbiAgICBiZWdpblxuICAgICAgcmVzdWx0ID0gXCIjPCN7c2VsZi5jbGFzc31cIlxuICAgICAgJXh7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBvc3RydWN0X2lkcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvc3RydWN0X2lkcy5oYXNPd25Qcm9wZXJ0eShvc3RydWN0X2lkKSkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnIC4uLj4nO1xuICAgICAgICB9XG4gICAgICAgIG9zdHJ1Y3RfaWRzW29zdHJ1Y3RfaWRdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9ICcgJyBpZiBAdGFibGUuYW55P1xuXG4gICAgICByZXN1bHQgKz0gZWFjaF9wYWlyLm1hcCBkbyB8bmFtZSwgdmFsdWV8XG4gICAgICAgIFwiI3tuYW1lfT0je3ZhbHVlLmluc3BlY3R9XCJcbiAgICAgIGVuZC5qb2luICcsICdcblxuICAgICAgcmVzdWx0ICs9ICc+J1xuXG4gICAgICByZXN1bHRcbiAgICBlbnN1cmVcbiAgICAgICV4e1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgb3N0cnVjdF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG5lbmRcbiJdLCJuYW1lcyI6WyJjbGFzcyIsImluaXRpYWxpemUiLCJAdGFibGUiLCJoYXNoIiwiZWFjaF9wYWlyIiwiJHdyaXRlciIsIm5ld19vc3RydWN0X21lbWJlciIsImtleSIsInZhbHVlIiwiW109IiwiLSIsIjEiLCJbXSIsIm5hbWUiLCJ0b19zeW0iLCJtZXRob2RfbWlzc2luZyIsIj4iLCJhcmdzIiwibGVuZ3RoIiwiMiIsInJhaXNlIiwibmV3IiwiZW5kX3dpdGg/IiwiIT0iLCIwIiwiLTIiLCJyZXNwb25kX3RvX21pc3Npbmc/IiwibW5hbWUiLCJtaWQiLCJ0b19zIiwiY2hvbXAiLCIkcmV0X29yXzEiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsInBhaXIiLCI9PSIsIm90aGVyIiwiaXNfYT8iLCJpbnN0YW5jZV92YXJpYWJsZV9nZXQiLCI9PT0iLCJlcWw/IiwidG9faCIsImR1cCIsInRvX24iLCJhdHRyX3JlYWRlciIsImRlbGV0ZV9maWVsZCIsInN5bSIsInNpbmdsZXRvbl9jbGFzcyIsIl9fc2VuZF9fIiwiZGVsZXRlIiwicmVzcG9uZF90bz8iLCJkZWZpbmVfc2luZ2xldG9uX21ldGhvZCIsIngiLCJpbnNwZWN0IiwiX19pZF9fIiwicmVzdWx0Iiwic2VsZiIsImFueT8iLCIrIiwibWFwIiwiam9pbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7RUFBQSxPQUFBQTtBQUFBQSxFQUFBQTs7QUFBQUEsSUFBQUE7O0FBQUFBO0FBQUFBO0FBQ0U7QUFBQUMsSUFBQUEsOEJBQUFBLDJCQUFBQSxzQkFBZSxJQUFmQTtBQUFBQSxNQUFBQTs7QUFBQUE7QUFGRjtBQUVpQixNQUFBO0FBQUEsTUFBQSxTQUFPLEdBQVA7QUFBQSxNQUFBLENBRmpCO0FBQUEsTUFHSUMsYUFBUyxZQUFBLEVBSGI7QUFBQSxNQUtJLElBQUEsUUFBR0MsSUFBSCxDQUFBO0FBQUEsUUFDRSxPQUFBQyxNQUFBRCxJQUFBQyxhQUFBQSxFQUFBQSxFQUFBQSxFQU5OLGdCQU15QixHQUFELEVBQU0sS0FOOUIsRUFBQTtBQUFBOztBQUFBO0FBQUE7QUFNeUIsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBTnpCO0FBQUE7QUFNOEIsVUFBQTtBQUFBLFVBQUE7QUFBQSxVQUFBLENBTjlCO0FBQUEsVUFBQUMsVUFBQSxLQU9lQyxvQkFBQUEsQ0FBbUJDLEdBQW5CRCxDQVBmLEVBTzBDRSxLQVAxQyxDQUFBO0FBQUEsVUFPUUMsTUFBQVAsVUFBQU8sT0FBQUEsRUFQUixVQUFBSixPQUFBLENBT1FJLENBUFI7QUFBQSxVQUFBLE9BQUFKLE9BQUEsQ0FBQUssVUFBQUwsT0FBQSxDQUFBLFFBQUEsQ0FBQUssRUFBQUMsQ0FBQUQsQ0FBQSxDQUFBLENBQUEsa0JBQUEsaUJBQUEsS0FNTU47QUFERixNQUFBO0FBQUE7QUFBQSxNQUFBLENBTEo7QUFFRUgsSUFBQUEsQ0FBQUEsdUNBQUFBLENBQUE7QUFBQTtB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QkEsQ0F5R007QUFBQSxNQW1CQSxPQUFBSCxNQW5CQTtBQUFBLE1BQUE7QUFBQTtBQXNCTjtBQUNBO0FBQ0E7QUFDQTtBQXpCTSxNQUFBLENBQUEsTUFERixDQUpBO0FBREZGLElBQUFBLENBQUFBLG9DQUFBQSxDQWpHQTtBQUFBLElBb0lBLE9BQUEsaUJBQU0sTUFBTixFQUFXLFNBQVgsQ0FwSUE7QUFERnJELEVBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBOzsifX0seyJvZmZzZXQiOnsibGluZSI6MjUyNjYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL25hdGl2ZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIFByb3ZpZGVzIGEgY29tcGxldGUgc2V0IG9mIHRvb2xzIHRvIHdyYXAgbmF0aXZlIEphdmFTY3JpcHRcbiMgaW50byBuaWNlIFJ1Ynkgb2JqZWN0cy5cbiNcbiMgQGV4YW1wbGVcbiNcbiMgICAkJC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdwJykuY2xhc3NMaXN0LmFkZCgnYmx1ZScpXG4jICAgIyA9PiBhZGRzIFwiYmx1ZVwiIGNsYXNzIHRvIDxwPlxuI1xuIyAgICQkLmxvY2F0aW9uLmhyZWYgPSAnaHR0cHM6Ly9nb29nbGUuY29tJ1xuIyAgICMgPT4gY2hhbmdlcyBwYWdlIGxvY2F0aW9uXG4jXG4jICAgZG9fbGF0ZXIgPSAkJFs6c2V0VGltZW91dF0gIyBBY2Nlc3NpbmcgdGhlIFwic2V0VGltZW91dFwiIHByb3BlcnR5XG4jICAgZG9fbGF0ZXIuY2FsbCgtPnsgcHV0cyA6aGVsbG99LCA1MDApXG4jXG4jIGAkJGAgYW5kIGAkZ2xvYmFsYCB3cmFwIGBPcGFsLmdsb2JhbGAsIHdoaWNoIHRoZSBPcGFsIEpTIHJ1bnRpbWVcbiMgc2V0cyB0byB0aGUgZ2xvYmFsIGB0aGlzYCBvYmplY3QuXG4jXG5tb2R1bGUgTmF0aXZlXG4gIGRlZiBzZWxmLmlzX2E/KG9iamVjdCwga2xhc3MpXG4gICAgJXh7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gI3tvYmplY3R9IGluc3RhbmNlb2YgI3t0cnlfY29udmVydChrbGFzcyl9O1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQodmFsdWUsIGRlZmF1bHQgPSBuaWwpXG4gICAgJXh7XG4gICAgICBpZiAoI3tuYXRpdmU/KHZhbHVlKX0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWV9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3t2YWx1ZS5yZXNwb25kX3RvPyA6dG9fbn0pIHtcbiAgICAgICAgcmV0dXJuICN7dmFsdWUudG9fbn07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7ZGVmYXVsdH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5jb252ZXJ0KHZhbHVlKVxuICAgICV4e1xuICAgICAgaWYgKCN7bmF0aXZlPyh2YWx1ZSl9KSB7XG4gICAgICAgIHJldHVybiAje3ZhbHVlfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7dmFsdWUucmVzcG9uZF90bz8gOnRvX259KSB7XG4gICAgICAgIHJldHVybiAje3ZhbHVlLnRvX259O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCIje3ZhbHVlLmluc3BlY3R9IGlzbid0IG5hdGl2ZVwifTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNhbGwob2JqLCBrZXksICphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcHJvcCA9ICN7b2JqfVsje2tleX1dO1xuXG4gICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBjb252ZXJ0ZWQgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IGFyZ3NbaV0sXG4gICAgICAgICAgICAgIGNvbnYgPSAje3RyeV9jb252ZXJ0KGBpdGVtYCl9O1xuXG4gICAgICAgICAgY29udmVydGVkW2ldID0gY29udiA9PT0gbmlsID8gaXRlbSA6IGNvbnY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgIGNvbnZlcnRlZC5wdXNoKGJsb2NrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAje05hdGl2ZShgcHJvcC5hcHBseSgje29ian0sIGNvbnZlcnRlZClgKX07XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7TmF0aXZlKGBwcm9wYCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYucHJvYygmYmxvY2spXG4gICAgcmFpc2UgTG9jYWxKdW1wRXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICA6Oktlcm5lbC5wcm9jIHsgfCphcmdzfFxuICAgICAgYXJncy5tYXAhIHsgfGFyZ3wgTmF0aXZlKGFyZykgfVxuICAgICAgaW5zdGFuY2UgPSBOYXRpdmUoYHRoaXNgKVxuXG4gICAgICAleHtcbiAgICAgICAgLy8gaWYgZ2xvYmFsIGlzIGN1cnJlbnQgc2NvcGUsIHJ1biB0aGUgYmxvY2sgaW4gdGhlIHNjb3BlIGl0IHdhcyBkZWZpbmVkXG4gICAgICAgIGlmICh0aGlzID09PSBPcGFsLmdsb2JhbCkge1xuICAgICAgICAgIHJldHVybiBibG9jay5hcHBseShzZWxmLCAje2FyZ3N9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmXyA9IGJsb2NrLiQkcztcbiAgICAgICAgYmxvY2suJCRzID0gbnVsbDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBibG9jay5hcHBseSgje2luc3RhbmNlfSwgI3thcmdzfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgYmxvY2suJCRzID0gc2VsZl87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIG1vZHVsZSBIZWxwZXJzXG4gICAgIyBFeHBvc2VzIGEgbmF0aXZlIEphdmFTY3JpcHQgbWV0aG9kIHRvIFJ1YnlcbiAgICAjXG4gICAgI1xuICAgICMgQHBhcmFtIG5ldyBbU3RyaW5nXVxuICAgICMgICAgICAgVGhlIG5hbWUgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgbWV0aG9kLlxuICAgICNcbiAgICAjIEBwYXJhbSBvbGQgW1N0cmluZ11cbiAgICAjICAgICAgIFRoZSBuYW1lIG9mIHRoZSBuYXRpdmUgSmF2YVNjcmlwdCBtZXRob2QgdG8gYmUgZXhwb3NlZC5cbiAgICAjICAgICAgIElmIHRoZSBuYW1lIGVuZHMgd2l0aCBcIj1cIiAoZS5nLiBgZm9vPWApIGl0IHdpbGwgYmUgaW50ZXJwcmV0ZWQgYXNcbiAgICAjICAgICAgIGEgcHJvcGVydHkgc2V0dGVyLiAoZGVmYXVsdDogdGhlIHZhbHVlIG9mIFwibmV3XCIpXG4gICAgI1xuICAgICMgQHBhcmFtIGFzIFtDbGFzc11cbiAgICAjICAgICAgIElmIHByb3ZpZGVkIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIG9yaWdpbmFsIG1ldGhvZCB3aWxsIGJlXG4gICAgIyAgICAgICByZXR1cm5lZCBhcyBpbnN0YW5jZXMgb2YgdGhlIHBhc3NlZCBjbGFzcy4gVGhlIGNsYXNzIHBhc3NlZCB0byBcImFzXCJcbiAgICAjICAgICAgIGlzIGV4cGVjdGVkIHRvIGFjY2VwdCBhIG5hdGl2ZSBKYXZhU2NyaXB0IHZhbHVlLlxuICAgICNcbiAgICAjIEBleGFtcGxlXG4gICAgI1xuICAgICMgICBjbGFzcyBFbGVtZW50XG4gICAgIyAgICAgZXh0ZW5kIE5hdGl2ZTo6SGVscGVyc1xuICAgICNcbiAgICAjICAgICBhbGlhc19uYXRpdmUgOmFkZF9jbGFzcywgOmFkZENsYXNzXG4gICAgIyAgICAgYWxpYXNfbmF0aXZlIDpzaG93XG4gICAgIyAgICAgYWxpYXNfbmF0aXZlIDpoaWRlXG4gICAgI1xuICAgICMgICAgIGRlZiBpbml0aWFsaXplKHNlbGVjdG9yKVxuICAgICMgICAgICAgQG5hdGl2ZSA9IGAkKCN7c2VsZWN0b3J9KWBcbiAgICAjICAgICBlbmRcbiAgICAjICAgZW5kXG4gICAgI1xuICAgICMgICB0aXRsZXMgPSBFbGVtZW50Lm5ldygnaDEnKVxuICAgICMgICB0aXRsZXMuYWRkX2NsYXNzIDpmb29cbiAgICAjICAgdGl0bGVzLmhpZGVcbiAgICAjICAgdGl0bGVzLnNob3dcbiAgICAjXG4gICAgZGVmIGFsaWFzX25hdGl2ZShuZXcsIG9sZCA9IG5ldywgYXM6IG5pbClcbiAgICAgIGlmIG9sZC5lbmRfd2l0aD8gJz0nXG4gICAgICAgIGRlZmluZV9tZXRob2QgbmV3IGRvIHx2YWx1ZXxcbiAgICAgICAgICBgI3tAbmF0aXZlfVsje29sZFswLi4tMl19XSA9ICN7TmF0aXZlLmNvbnZlcnQodmFsdWUpfWBcblxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIGVuZFxuICAgICAgZWxzaWYgYXNcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuZXcgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAgICAgdmFsdWUgPSBOYXRpdmUuY2FsbChAbmF0aXZlLCBvbGQsICphcmdzLCAmYmxvY2spXG4gICAgICAgICAgaWYgdmFsdWVcbiAgICAgICAgICAgIGFzLm5ldyh2YWx1ZS50b19uKVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuZXcgZG8gfCphcmdzLCAmYmxvY2t8XG4gICAgICAgICAgTmF0aXZlLmNhbGwoQG5hdGl2ZSwgb2xkLCAqYXJncywgJmJsb2NrKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIG5hdGl2ZV9yZWFkZXIoKm5hbWVzKVxuICAgICAgbmFtZXMuZWFjaCBkbyB8bmFtZXxcbiAgICAgICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICAgICAgTmF0aXZlKGAje0BuYXRpdmV9W25hbWVdYClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBuYXRpdmVfd3JpdGVyKCpuYW1lcylcbiAgICAgIG5hbWVzLmVhY2ggZG8gfG5hbWV8XG4gICAgICAgIGRlZmluZV9tZXRob2QgXCIje25hbWV9PVwiIGRvIHx2YWx1ZXxcbiAgICAgICAgICBOYXRpdmUoYCN7QG5hdGl2ZX1bbmFtZV0gPSB2YWx1ZWApXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgbmF0aXZlX2FjY2Vzc29yKCpuYW1lcylcbiAgICAgIG5hdGl2ZV9yZWFkZXIoKm5hbWVzKVxuICAgICAgbmF0aXZlX3dyaXRlcigqbmFtZXMpXG4gICAgZW5kXG4gIGVuZFxuXG4gIG1vZHVsZSBXcmFwcGVyXG4gICAgZGVmIGluaXRpYWxpemUobmF0aXZlKVxuICAgICAgdW5sZXNzIDo6S2VybmVsLm5hdGl2ZT8obmF0aXZlKVxuICAgICAgICA6Oktlcm5lbC5yYWlzZSBBcmd1bWVudEVycm9yLCBcIiN7bmF0aXZlLmluc3BlY3R9IGlzbid0IG5hdGl2ZVwiXG4gICAgICBlbmRcblxuICAgICAgQG5hdGl2ZSA9IG5hdGl2ZVxuICAgIGVuZFxuXG4gICAgIyBSZXR1cm5zIHRoZSBpbnRlcm5hbCBuYXRpdmUgSmF2YVNjcmlwdCB2YWx1ZVxuICAgIGRlZiB0b19uXG4gICAgICBAbmF0aXZlXG4gICAgZW5kXG5cbiAgICBkZWYgc2VsZi5pbmNsdWRlZChrbGFzcylcbiAgICAgIGtsYXNzLmV4dGVuZCBIZWxwZXJzXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmluY2x1ZGVkKGJhc2UpXG4gICAgd2FybiAnSW5jbHVkaW5nIDo6TmF0aXZlIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSBpbmNsdWRlIE5hdGl2ZTo6V3JhcHBlciBpbnN0ZWFkLidcbiAgICBiYXNlLmluY2x1ZGUgV3JhcHBlclxuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBuYXRpdmU/KHZhbHVlKVxuICAgIGB2YWx1ZSA9PSBudWxsIHx8ICF2YWx1ZS4kJGNsYXNzYFxuICBlbmRcblxuICAjIFdyYXBzIGEgbmF0aXZlIEphdmFTY3JpcHQgd2l0aCBgTmF0aXZlOjpPYmplY3QubmV3YFxuICAjXG4gICMgQHJldHVybiBbTmF0aXZlOjpPYmplY3RdIFRoZSB3cmFwcGVkIG9iamVjdCBpZiBpdCBpcyBuYXRpdmVcbiAgIyBAcmV0dXJuIFtuaWxdIGZvciBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICMgQHJldHVybiBbb2JqXSBUaGUgb2JqZWN0IGl0c2VsZiBpZiBpdCdzIG5vdCBuYXRpdmVcbiAgZGVmIE5hdGl2ZShvYmopXG4gICAgaWYgYCN7b2JqfSA9PSBudWxsYFxuICAgICAgbmlsXG4gICAgZWxzaWYgbmF0aXZlPyhvYmopXG4gICAgICBOYXRpdmU6Ok9iamVjdC5uZXcob2JqKVxuICAgIGVsc2lmIG9iai5pc19hPyhBcnJheSlcbiAgICAgIG9iai5tYXAgZG8gfG98XG4gICAgICAgIE5hdGl2ZShvKVxuICAgICAgZW5kXG4gICAgZWxzaWYgb2JqLmlzX2E/KFByb2MpXG4gICAgICBwcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgICBOYXRpdmUob2JqLmNhbGwoKmFyZ3MsICZibG9jaykpXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBvYmpcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgX0FycmF5IEFycmF5XG5cbiAgIyBXcmFwcyBhcnJheS1saWtlIEphdmFTY3JpcHQgb2JqZWN0cyBpbiBOYXRpdmU6OkFycmF5XG4gIGRlZiBBcnJheShvYmplY3QsICphcmdzLCAmYmxvY2spXG4gICAgaWYgbmF0aXZlPyhvYmplY3QpXG4gICAgICByZXR1cm4gTmF0aXZlOjpBcnJheS5uZXcob2JqZWN0LCAqYXJncywgJmJsb2NrKS50b19hXG4gICAgZW5kXG4gICAgX0FycmF5KG9iamVjdClcbiAgZW5kXG5lbmRcblxuY2xhc3MgTmF0aXZlOjpPYmplY3QgPCBCYXNpY09iamVjdFxuICBpbmNsdWRlIDo6TmF0aXZlOjpXcmFwcGVyXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGAje0BuYXRpdmV9ID09PSAjezo6TmF0aXZlLnRyeV9jb252ZXJ0KG90aGVyKX1gXG4gIGVuZFxuXG4gIGRlZiBoYXNfa2V5PyhuYW1lKVxuICAgIGBPcGFsLmhhc093blByb3BlcnR5LmNhbGwoI3tAbmF0aXZlfSwgI3tuYW1lfSlgXG4gIGVuZFxuXG4gIGFsaWFzIGtleT8gaGFzX2tleT9cbiAgYWxpYXMgaW5jbHVkZT8gaGFzX2tleT9cbiAgYWxpYXMgbWVtYmVyPyBoYXNfa2V5P1xuXG4gIGRlZiBlYWNoKCphcmdzKVxuICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiAje0BuYXRpdmV9KSB7XG4gICAgICAgICAgI3t5aWVsZCBga2V5YCwgYCN7QG5hdGl2ZX1ba2V5XWB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZlxuICAgIGVsc2VcbiAgICAgIG1ldGhvZF9taXNzaW5nKDplYWNoLCAqYXJncylcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIFtdKGtleSlcbiAgICAleHtcbiAgICAgIHZhciBwcm9wID0gI3tAbmF0aXZlfVtrZXldO1xuXG4gICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAjezo6TmF0aXZlLmNhbGwoQG5hdGl2ZSwga2V5KX1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXT0oa2V5LCB2YWx1ZSlcbiAgICBuYXRpdmUgPSA6Ok5hdGl2ZS50cnlfY29udmVydCh2YWx1ZSlcblxuICAgIGlmIGAje25hdGl2ZX0gPT09IG5pbGBcbiAgICAgIGAje0BuYXRpdmV9W2tleV0gPSAje3ZhbHVlfWBcbiAgICBlbHNlXG4gICAgICBgI3tAbmF0aXZlfVtrZXldID0gI3tuYXRpdmV9YFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbWVyZ2UhKG90aGVyKVxuICAgICV4e1xuICAgICAgb3RoZXIgPSAjezo6TmF0aXZlLmNvbnZlcnQob3RoZXIpfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvdGhlcikge1xuICAgICAgICAje0BuYXRpdmV9W3Byb3BdID0gb3RoZXJbcHJvcF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVzcG9uZF90bz8obmFtZSwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICA6Oktlcm5lbC5pbnN0YW5jZV9tZXRob2QoOnJlc3BvbmRfdG8/KS5iaW5kKHNlbGYpLmNhbGwobmFtZSwgaW5jbHVkZV9hbGwpXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG5hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgYE9wYWwuaGFzT3duUHJvcGVydHkuY2FsbCgje0BuYXRpdmV9LCAje25hbWV9KWBcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG1pZCwgKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChtaWQuY2hhckF0KG1pZC5sZW5ndGggLSAxKSA9PT0gJz0nKSB7XG4gICAgICAgIHJldHVybiAje3NlbGZbbWlkLnNsaWNlKDAsIG1pZC5sZW5ndGggLSAxKV0gPSBhcmdzWzBdfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3s6Ok5hdGl2ZS5jYWxsKEBuYXRpdmUsIG1pZCwgKmFyZ3MsICZibG9jayl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5pbD9cbiAgICBmYWxzZVxuICBlbmRcblxuICBkZWYgaXNfYT8oa2xhc3MpXG4gICAgYE9wYWwuaXNfYShzZWxmLCBrbGFzcylgXG4gIGVuZFxuXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG5cbiAgZGVmIGluc3RhbmNlX29mPyhrbGFzcylcbiAgICBgc2VsZi4kJGNsYXNzID09PSBrbGFzc2BcbiAgZW5kXG5cbiAgZGVmIGNsYXNzXG4gICAgYHNlbGYuJCRjbGFzc2BcbiAgZW5kXG5cbiAgZGVmIHRvX2Eob3B0aW9ucyA9IHt9LCAmYmxvY2spXG4gICAgOjpOYXRpdmU6OkFycmF5Lm5ldyhAbmF0aXZlLCBvcHRpb25zLCAmYmxvY2spLnRvX2FcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8TmF0aXZlOiN7YFN0cmluZygje0BuYXRpdmV9KWB9PlwiXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5hdGl2ZTo6QXJyYXlcbiAgaW5jbHVkZSBOYXRpdmU6OldyYXBwZXJcbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgZGVmIGluaXRpYWxpemUobmF0aXZlLCBvcHRpb25zID0ge30sICZibG9jaylcbiAgICBzdXBlcihuYXRpdmUpXG5cbiAgICBAZ2V0ICAgID0gb3B0aW9uc1s6Z2V0XSB8fCBvcHRpb25zWzphY2Nlc3NdXG4gICAgQG5hbWVkICA9IG9wdGlvbnNbOm5hbWVkXVxuICAgIEBzZXQgICAgPSBvcHRpb25zWzpzZXRdIHx8IG9wdGlvbnNbOmFjY2Vzc11cbiAgICBAbGVuZ3RoID0gb3B0aW9uc1s6bGVuZ3RoXSB8fCA6bGVuZ3RoXG4gICAgQGJsb2NrICA9IGJsb2NrXG5cbiAgICBpZiBgI3tsZW5ndGh9ID09IG51bGxgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbm8gbGVuZ3RoIGZvdW5kIG9uIHRoZSBhcnJheS1saWtlIG9iamVjdCdcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9ICN7bGVuZ3RofTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCAje3NlbGZbYGlgXX0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIFtdKGluZGV4KVxuICAgIHJlc3VsdCA9IGNhc2UgaW5kZXhcbiAgICAgICAgICAgICB3aGVuIFN0cmluZywgU3ltYm9sXG4gICAgICAgICAgICAgICBAbmFtZWQgPyBgI3tAbmF0aXZlfVsje0BuYW1lZH1dKCN7aW5kZXh9KWAgOiBgI3tAbmF0aXZlfVsje2luZGV4fV1gXG4gICAgICAgICAgICAgd2hlbiBJbnRlZ2VyXG4gICAgICAgICAgICAgICBAZ2V0ID8gYCN7QG5hdGl2ZX1bI3tAZ2V0fV0oI3tpbmRleH0pYCA6IGAje0BuYXRpdmV9WyN7aW5kZXh9XWBcbiAgICAgICAgICAgICBlbmRcblxuICAgIGlmIHJlc3VsdFxuICAgICAgaWYgQGJsb2NrXG4gICAgICAgIEBibG9jay5jYWxsKHJlc3VsdClcbiAgICAgIGVsc2VcbiAgICAgICAgTmF0aXZlKHJlc3VsdClcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgW109KGluZGV4LCB2YWx1ZSlcbiAgICBpZiBAc2V0XG4gICAgICBgI3tAbmF0aXZlfVsje0BzZXR9XSgje2luZGV4fSwgI3tOYXRpdmUuY29udmVydCh2YWx1ZSl9KWBcbiAgICBlbHNlXG4gICAgICBgI3tAbmF0aXZlfVsje2luZGV4fV0gPSAje05hdGl2ZS5jb252ZXJ0KHZhbHVlKX1gXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBsYXN0KGNvdW50ID0gbmlsKVxuICAgIGlmIGNvdW50XG4gICAgICBpbmRleCAgPSBsZW5ndGggLSAxXG4gICAgICByZXN1bHQgPSBbXVxuXG4gICAgICB3aGlsZSBpbmRleCA+PSAwXG4gICAgICAgIHJlc3VsdCA8PCBzZWxmW2luZGV4XVxuICAgICAgICBpbmRleCAgLT0gMVxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdFxuICAgIGVsc2VcbiAgICAgIHNlbGZbbGVuZ3RoIC0gMV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGAje0BuYXRpdmV9WyN7QGxlbmd0aH1dYFxuICBlbmRcblxuICBhbGlhcyB0b19hcnkgdG9fYVxuXG4gIGRlZiBpbnNwZWN0XG4gICAgdG9fYS5pbnNwZWN0XG4gIGVuZFxuZW5kXG5cbmNsYXNzIE51bWVyaWNcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBQcm9jXG4gICMgQHJldHVybiBpdHNlbGYgKGFuIGluc3RhbmNlIG9mIGBGdW5jdGlvbmApXG4gIGRlZiB0b19uXG4gICAgc2VsZlxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBSZWdleHBcbiAgIyBAcmV0dXJuIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IHZhbHVlICh3aXRoIGB2YWx1ZU9mYCkuXG4gIGRlZiB0b19uXG4gICAgYHNlbGYudmFsdWVPZigpYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBNYXRjaERhdGFcbiAgIyBAcmV0dXJuIHRoZSBhcnJheSBvZiBtYXRjaGVzXG4gIGRlZiB0b19uXG4gICAgQG1hdGNoZXNcbiAgZW5kXG5lbmRcblxuY2xhc3MgU3RydWN0XG4gICMgQHJldHVybiBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhlIG1lbWJlcnMgYXMga2V5cyBhbmQgdGhlaXJcbiAgIyB2YWx1ZXMgYXMgdmFsdWVzLlxuICBkZWYgdG9fblxuICAgIHJlc3VsdCA9IGB7fWBcblxuICAgIGVhY2hfcGFpciBkbyB8bmFtZSwgdmFsdWV8XG4gICAgICBgI3tyZXN1bHR9WyN7bmFtZX1dID0gI3tOYXRpdmUudHJ5X2NvbnZlcnQodmFsdWUsIHZhbHVlKX1gXG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5lbmRcblxuY2xhc3MgQXJyYXlcbiAgIyBSZXR1bnMgYSBjb3B5IG9mIGl0c2VsZiB0cnlpbmcgdG8gY2FsbCAjdG9fbiBvbiBlYWNoIG1lbWJlci5cbiAgZGVmIHRvX25cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IHNlbGZbaV07XG5cbiAgICAgICAgcmVzdWx0LnB1c2goI3tOYXRpdmUudHJ5X2NvbnZlcnQoYG9iamAsIGBvYmpgKX0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5lbmRcblxuY2xhc3MgQm9vbGVhblxuICAjIEByZXR1cm4gdGhlIGludGVybmFsIEphdmFTY3JpcHQgdmFsdWUgKHdpdGggYHZhbHVlT2ZgKS5cbiAgZGVmIHRvX25cbiAgICBgc2VsZi52YWx1ZU9mKClgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFRpbWVcbiAgIyBAcmV0dXJuIGl0c2VsZiAoYW4gaW5zdGFuY2Ugb2YgYERhdGVgKS5cbiAgZGVmIHRvX25cbiAgICBzZWxmXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5pbENsYXNzXG4gICMgQHJldHVybiB0aGUgY29ycmVzcG9uZGluZyBKYXZhU2NyaXB0IHZhbHVlIChgbnVsbGApLlxuICBkZWYgdG9fblxuICAgIGBudWxsYFxuICBlbmRcbmVuZFxuXG5jbGFzcyBIYXNoXG4gIGFsaWFzIF9pbml0aWFsaXplIGluaXRpYWxpemVcblxuICBkZWYgaW5pdGlhbGl6ZShkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKGRlZmF1bHRzICE9IG51bGwgJiZcbiAgICAgICAgICAgKGRlZmF1bHRzLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICBkZWZhdWx0cy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSkge1xuICAgICAgICB2YXIgc21hcCA9IHNlbGYuJCRzbWFwLFxuICAgICAgICAgICAga2V5cyA9IHNlbGYuJCRrZXlzLFxuICAgICAgICAgICAga2V5LCB2YWx1ZTtcblxuICAgICAgICBmb3IgKGtleSBpbiBkZWZhdWx0cykge1xuICAgICAgICAgIHZhbHVlID0gZGVmYXVsdHNba2V5XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgICAgKHZhbHVlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCkpIHtcbiAgICAgICAgICAgIHNtYXBba2V5XSA9ICN7SGFzaC5uZXcoYHZhbHVlYCl9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICBpZiAoaXRlbSAmJlxuICAgICAgICAgICAgICAgICAgIChpdGVtLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY29uc3RydWN0b3IgPT09IE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gI3tIYXNoLm5ldyhgaXRlbWApfTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiAje05hdGl2ZShgaXRlbWApfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc21hcFtrZXldID0gdmFsdWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc21hcFtrZXldID0gI3tOYXRpdmUoYHZhbHVlYCl9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje19pbml0aWFsaXplKGRlZmF1bHRzLCAmYmxvY2spfTtcbiAgICB9XG4gIGVuZFxuXG4gICMgQHJldHVybiBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBidXQgY2FsbGluZyAjdG9fbiBvblxuICAjIGFsbCB2YWx1ZXMuXG4gIGRlZiB0b19uXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgICAga2V5cyA9IHNlbGYuJCRrZXlzLFxuICAgICAgICAgIHNtYXAgPSBzZWxmLiQkc21hcCxcbiAgICAgICAgICBrZXksIHZhbHVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W2tleV0gPSAje05hdGl2ZS50cnlfY29udmVydChgdmFsdWVgLCBgdmFsdWVgKX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcbmVuZFxuXG5jbGFzcyBNb2R1bGVcbiAgIyBFeHBvc2VzIHRoZSBjdXJyZW50IG1vZHVsZSBhcyBhIHByb3BlcnR5IG9mXG4gICMgdGhlIGdsb2JhbCBvYmplY3QgKGUuZy4gYHdpbmRvd2ApLlxuICBkZWYgbmF0aXZlX21vZHVsZVxuICAgIGBPcGFsLmdsb2JhbFsje25hbWV9XSA9ICN7c2VsZn1gXG4gIGVuZFxuZW5kXG5cbmNsYXNzIENsYXNzXG4gIGRlZiBuYXRpdmVfYWxpYXMobmV3X2pzaWQsIGV4aXN0aW5nX21pZClcbiAgICAleHtcbiAgICAgIHZhciBhbGlhc2VkID0gI3tzZWxmfS5wcm90b3R5cGVbJyQnICsgI3tleGlzdGluZ19taWR9XTtcbiAgICAgIGlmICghYWxpYXNlZCkge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje2V4aXN0aW5nX21pZH0nIGZvciBjbGFzcyBgI3tpbnNwZWN0fSdcIiwgZXhpc3RpbmdfbWlkKX07XG4gICAgICB9XG4gICAgICAje3NlbGZ9LnByb3RvdHlwZVsje25ld19qc2lkfV0gPSBhbGlhc2VkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hdGl2ZV9jbGFzc1xuICAgIG5hdGl2ZV9tb2R1bGVcbiAgICBgc2VsZltcIm5ld1wiXSA9IHNlbGYuJG5ld2BcbiAgZW5kXG5lbmRcblxuIyBFeHBvc2VzIHRoZSBnbG9iYWwgdmFsdWUgKHdvdWxkIGJlIGB3aW5kb3dgIGluc2lkZSBhIGJyb3dzZXIpXG4kJCA9ICRnbG9iYWwgPSBOYXRpdmUoYE9wYWwuZ2xvYmFsYClcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJpc19hPyIsInNlbGYiLCJvYmplY3QiLCJ0cnlfY29udmVydCIsImtsYXNzIiwibmF0aXZlPyIsInZhbHVlIiwicmVzcG9uZF90bz8iLCJ0b19uIiwiZGVmYXVsdCQiLCJjb252ZXJ0IiwicmFpc2UiLCJpbnNwZWN0IiwiY2FsbCIsIm9iaiIsImtleSIsIk5hdGl2ZSIsInByb2MiLCJibG9jayIsIm1hcCEiLCJhcmdzIiwiYXJnIiwiaW5zdGFuY2UiLCJhbGlhc19uYXRpdmUiLCJuZXckIiwib2xkIiwiZW5kX3dpdGg/IiwiZGVmaW5lX21ldGhvZCIsIkBuYXRpdmUiLCJbXSIsIjAiLCItMiIsImFzIiwibmV3IiwibmF0aXZlX3JlYWRlciIsImVhY2giLCJuYW1lcyIsIm5hbWUiLCJuYXRpdmVfd3JpdGVyIiwibmF0aXZlX2FjY2Vzc29yIiwiaW5pdGlhbGl6ZSIsIm5hdGl2ZSQiLCJpbmNsdWRlZCIsImV4dGVuZCIsIndhcm4iLCJiYXNlIiwiaW5jbHVkZSIsIm1hcCIsIm8iLCJBcnJheSIsInRvX2EiLCJfQXJyYXkiLCJjbGFzcyIsIj09Iiwib3RoZXIiLCJoYXNfa2V5PyIsImJsb2NrX2dpdmVuPyIsIm1ldGhvZF9taXNzaW5nIiwiW109IiwibWVyZ2UhIiwiaW5zdGFuY2VfbWV0aG9kIiwiYmluZCIsImluY2x1ZGVfYWxsIiwicmVzcG9uZF90b19taXNzaW5nPyIsIiR3cml0ZXIiLCJtaWQiLCJzbGljZSIsIi0iLCJsZW5ndGgiLCIxIiwibmlsPyIsImluc3RhbmNlX29mPyIsIm9wdGlvbnMiLCJAZ2V0IiwiJHJldF9vcl8xIiwiQG5hbWVkIiwiQHNldCIsIiRyZXRfb3JfMiIsIkBsZW5ndGgiLCIkcmV0X29yXzMiLCJAYmxvY2siLCJlbnVtX2ZvciIsInJlc3VsdCIsImluZGV4IiwibGFzdCIsImNvdW50IiwiPj0iLCI8PCIsIkBtYXRjaGVzIiwiZWFjaF9wYWlyIiwiX2luaXRpYWxpemUiLCJkZWZhdWx0cyIsIm5hdGl2ZV9tb2R1bGUiLCJuYXRpdmVfYWxpYXMiLCJleGlzdGluZ19taWQiLCJuZXdfanNpZCIsIm5hdGl2ZV9jbGFzcyIsIiQkIiwiJGdsb2JhbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBaUJBLEVBQUFBO0FBQUFBLEVBQUFBOztBQUFBQSxJQUFBQTs7QUFBQUE7QUFDRSxJQUFBQyxVQUFJQyxJQUFKRCxZQUFBQSxzQkFBQUEsU0FBZSxNQUFELEVBQVMsS0FBdkJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQUVGO0FBQ0EsZUFBaUJFLE1BQU8sZ0JBQWNDLGFBQUFBLENBQVlDLEtBQVpELENBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSRUgsSUFBQUEsQ0FBQUEsaUNBQUFBLENBQUE7QUFBQSxJQVdBRyxVQUFJRixJQUFKRSxrQkFBQUEsd0JBQUFBLHVCQUFxQixLQUFELEVBQVEsUUFBNUJBO0FBQUFBLE1BQUFBOztBQUFBQTtBQTlCRjtBQThC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QUFBLFdBQUFBLEVBQUFBLElBQUFBLFdBamxCQTtBQUFBLEVBbW1CQSxPQUFBNkMsQ0FBQUEsV0FBS0MsQ0FBQUEsb0JBQVVsRixRQUFBQSxDQUFRLFdBQVJBLENBQVZrRixDQUFMRCxDQW5tQkE7OyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjIxMywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImFwcC5qcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdvc3RydWN0J1xucmVxdWlyZSAnbmF0aXZlJ1xuIyB0byBjb21waWxlOiBvcGFsIC1jIGFwcC5qcy5yYiA+IGFwcC5qc1xuIyBkb2M6IGh0dHBzOi8vb3BhbHJiLmNvbS9cblxuIyMjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAjIyNcbiMjIyBEZWZpbmUgYXZhaWxhYmxlIHNlbGVjdGlvbnMgIyMjXG4jIyMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICMjI1xuZGVhdGhfeWVhciA9ICgxODAwLi4yMDIwKS50b19hXG5wZXJzb25hbGl0eSA9IFtcIlNwaXJpdGVkXCIsIFwiSGF1bnRpbmdcIiwgXCJUcmFuc3BhcmVudFwiXVxuYWxpZ25tZW50ID0gW1xuICBcIkxhd2Z1bCBnb29kXCIsIFwiTmV1dHJhbCBnb29kXCIsIFwiQ2hhb3RpYyBnb29kXCIsXG4gIFwiTGF3ZnVsIG5ldXRyYWxcIiwgXCJUcnVlIG5ldXRyYWxcIiwgXCJDaGFvdGljIG5ldXRyYWxcIixcbiAgXCJMYXdmdWwgZXZpbFwiLCBcIk5ldXRyYWwgZXZpbFwiLCBcIkNoYW90aWMgZXZpbFwiLFxuXVxuZmFjZSA9ICgxLi43KS5tYXAgeyB8aXwgXCIjI3tpfVwiIH1cbmNvbG91ciA9IFtcIiNGRkM5OTZcIiwgXCIjRkY4NDc0XCIsIFwiIzlGNUY4MFwiLCBcIiM1ODNENzJcIl1cbm9jY3VwYXRpb24gPSBbIFwiVW5lbXBsb3llZFwiLCBcIlN0dWRlbnRcIiwgXCJMaWJyYXJpYW5cIiwgXCJNdXNpY2lhblwiLCBcIkdhbWVyXCIsIFwiQ3VzdG9tZXIgU2VydmljZVwiLCBcIk1jRG9uYWxkJ3NcIiBdXG5cbiMgbWFwIGNvbnRhaW5pbmcgYWxsIGF2YWlsYWJsZSBvcHRpb25zIHRvIHNlbGVjdCBmcm9tXG4jIG9yZGVyIGFmZmVjdHMgaG93IHRoZSBzZWxlY3Rpb25zIGFyZSBkaXNwbGF5ZWQgJiBjYWxjdWxhdGVkXG5hbGxfc2VsZWN0aW9ucyA9IHtcbiAgZGVhdGhfeWVhcjogZGVhdGhfeWVhcixcbiAgcGVyc29uYWxpdHk6IHBlcnNvbmFsaXR5LFxuICBhbGlnbm1lbnQ6IGFsaWdubWVudCxcbiAgZmFjZTogZmFjZSxcbiAgY29sb3VyOiBjb2xvdXIsXG4gIG9jY3VwYXRpb246IG9jY3VwYXRpb25cbn1cbiMgdG90YWwgbm8uIG9mIHBvc3NpYmxlIHNlbGVjdGlvbnMgPSBwcm9kdWN0IG9mIGxlbmd0aCBvZiBhbGwgYXJyYXlzXG50b3RhbF9zZWxlY3Rpb25zX2NvdW50ID0gYWxsX3NlbGVjdGlvbnMudmFsdWVzLm1hcCB7IHx4fCB4Lmxlbmd0aCB9LnJlZHVjZSg6KilcblxuXG4jIyMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAjIyNcbiMjIyBNZXRob2QgdG8gdXBkYXRlIFVJIHdpdGggc2xpZGVyIHZhbHVlICMjI1xuIyMjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIyMjXG5kZWYgdXBkYXRlKG51bSwgdG90YWxfc2VsZWN0aW9uc19jb3VudCwgYWxsX3NlbGVjdGlvbnMpXG4gIG51bSAtPSAxICAjIG51bSByYW5nZSBmcm9tIDAgdG8gdG90YWxfc2VsZWN0aW9uc19jb3VudC0xXG5cbiAgcmVzdWx0ID0ge31cbiAgaSA9IHRvdGFsX3NlbGVjdGlvbnNfY291bnRcbiAgXG4gICMgY2FsY3VsYXRlIGV4cGVjdGVkIHZhbHVlIGZvciBlYWNoIHNlbGVjdGlvblxuICBmb3IgayBpbiBhbGxfc2VsZWN0aW9ucy5rZXlzXG4gICAgaSA9IChpIC8gYWxsX3NlbGVjdGlvbnNba10ubGVuZ3RoKS50b19pXG4gICAgcSwgciA9IG51bS5kaXZtb2QoaSlcbiAgICBudW0gPSByXG4gICAgcmVzdWx0W2tdID0gYWxsX3NlbGVjdGlvbnNba11bcV1cbiAgZW5kXG5cbiAgcmVzdWx0LmVhY2ggZG8gfGssIHZ8XG4gICAgJCRbOmRvY3VtZW50XS5nZXRFbGVtZW50QnlJZChcIiN7a31Db2xcIikuaW5uZXJIVE1MID0gXCIje3Z9XCJcbiAgZW5kXG5cbiAgIyB1cGRhdGUgY29sb3VyIGFuZCBpbWFnZSB1c2luZyB2YWx1ZXMgZnJvbSA6Y29sb3VyIGFuZCA6ZmFjZSByZXNwZWN0aXZlbHlcbiAgJCRbOmRvY3VtZW50XS5nZXRFbGVtZW50QnlJZChcImNoYXJhY3RlckNvbnRhaW5lclwiKS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByZXN1bHRbOmNvbG91cl1cbiAgJCRbOmRvY3VtZW50XS5nZXRFbGVtZW50QnlJZChcImNoYXJhY3RlckNvbnRhaW5lclwiKS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcInVybCgnaW1nL2dob3N0I3tyZXN1bHRbOmZhY2VdWzEuLi0xXX0ucG5nJylcIlxuZW5kXG5cbiMjIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIyMjXG4jIyMgSW5pdGlhbGl6ZSBVSSBjb21wb25lbnRzICMjI1xuIyMjIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAjIyNcbiMgdGFibGUgcm93c1xuc3RhdHNfdGFibGUgPSAkJFs6ZG9jdW1lbnRdLmdldEVsZW1lbnRCeUlkKFwic3RhdHNUYWJsZVwiKVxuc3RhdHNfdGFibGUuaW5uZXJIVE1MID0gYWxsX3NlbGVjdGlvbnMua2V5cy5tYXAgeyB8a3wgXCI8dHI+PHRkPiN7ay5zcGxpdCgnXycpLmpvaW4oJyAnKS5jYXBpdGFsaXplfTwvdGQ+PHRkIGNsYXNzPSdzdGF0c1Jlc3VsdCcgaWQ9JyN7a31Db2wnPjwvdGQ+PC90cj5cIiB9LmpvaW4oXCJcIilcblxuIyBzbGlkZXJcbnNsaWRlcl9jb250YWluZXIgPSAkJFs6ZG9jdW1lbnRdLmdldEVsZW1lbnRCeUlkKFwic2xpZGVyQ29udGFpbmVyXCIpXG5zbGlkZXJfY29udGFpbmVyLmlubmVySFRNTCA9ICV7XG4gIDxidXR0b24gaWQ9J21pbnVzQnRuJyBjbGFzcz0nYnV0dG9uQ2xhc3MnPi08L2J1dHRvbj5cbiAgPGlucHV0IHR5cGU9J3JhbmdlJyBtaW49JzEnIG1heD0nI3t0b3RhbF9zZWxlY3Rpb25zX2NvdW50fScgdmFsdWU9JzAnIGNsYXNzPSdzbGlkZXJDbGFzcycgaWQ9J3NsaWRlcic+XG4gIDxidXR0b24gaWQ9J3BsdXNCdG4nIGNsYXNzPSdidXR0b25DbGFzcyc+KzwvYnV0dG9uPlxufVxuXG4jIGNsaWNrIGV2ZW50IGZvciBzbGlkZXJcbnRoZV9zbGlkZXIgPSAkJFs6ZG9jdW1lbnRdLmdldEVsZW1lbnRCeUlkKFwic2xpZGVyXCIpXG50aGVfc2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIgOmlucHV0IGRvIHxldmVudHxcbiAgdXBkYXRlKHRoZV9zbGlkZXIudmFsdWUudG9faSwgdG90YWxfc2VsZWN0aW9uc19jb3VudCwgYWxsX3NlbGVjdGlvbnMpXG5lbmRcblxuIyBjbGljayBldmVudHMgZm9yIHRoZSB0d28gYnV0dG9ucyBiZXNpZGUgc2xpZGVyXG5taW51c19idG4gPSAkJFs6ZG9jdW1lbnRdLmdldEVsZW1lbnRCeUlkKFwibWludXNCdG5cIilcbm1pbnVzX2J0bi5hZGRFdmVudExpc3RlbmVyIDpjbGljayBkbyB8ZXZlbnR8XG4gIHNsaWRlcl92YWx1ZSA9ICQkWzpkb2N1bWVudF0uZ2V0RWxlbWVudEJ5SWQoXCJzbGlkZXJcIikudmFsdWUudG9faVxuICBpZiBzbGlkZXJfdmFsdWUgPiAxICMgc2xpZGVyIHZhbHVlIHJhbmdlIGZyb20gMSB0byB0b3RhbF9zZWxlY3Rpb25zX2NvdW50XG4gICAgJCRbOmRvY3VtZW50XS5nZXRFbGVtZW50QnlJZChcInNsaWRlclwiKS52YWx1ZSA9IHNsaWRlcl92YWx1ZSAtIDFcbiAgICB1cGRhdGUoc2xpZGVyX3ZhbHVlIC0gMSwgdG90YWxfc2VsZWN0aW9uc19jb3VudCwgYWxsX3NlbGVjdGlvbnMpXG4gIGVuZFxuZW5kXG5cbnBsdXNfYnRuID0gJCRbOmRvY3VtZW50XS5nZXRFbGVtZW50QnlJZChcInBsdXNCdG5cIilcbnBsdXNfYnRuLmFkZEV2ZW50TGlzdGVuZXIgOmNsaWNrIGRvIHxldmVudHxcbiAgc2xpZGVyX3ZhbHVlID0gJCRbOmRvY3VtZW50XS5nZXRFbGVtZW50QnlJZChcInNsaWRlclwiKS52YWx1ZS50b19pXG4gIGlmIHNsaWRlcl92YWx1ZSA8IHRvdGFsX3NlbGVjdGlvbnNfY291bnQgIyBzbGlkZXIgdmFsdWUgcmFuZ2UgZnJvbSAxIHRvIHRvdGFsX3NlbGVjdGlvbnNfY291bnRcbiAgICAkJFs6ZG9jdW1lbnRdLmdldEVsZW1lbnRCeUlkKFwic2xpZGVyXCIpLnZhbHVlID0gc2xpZGVyX3ZhbHVlICsgMVxuICAgIHVwZGF0ZShzbGlkZXJfdmFsdWUgKyAxLCB0b3RhbF9zZWxlY3Rpb25zX2NvdW50LCBhbGxfc2VsZWN0aW9ucylcbiAgZW5kXG5lbmRcblxuIyBjbGljayBldmVudCBmb3IgYnV0dG9uXG5idG4gPSAkJFs6ZG9jdW1lbnRdLmdldEVsZW1lbnRCeUlkKFwiY3JlYXRlQnRuXCIpXG5idG4uYWRkRXZlbnRMaXN0ZW5lciA6Y2xpY2sgZG8gfGV2ZW50fFxuICByZXN1bHQgPSBhbGxfc2VsZWN0aW9ucy5lYWNoX2tleS5tYXAgZG8gfGt8XG4gICAgdiA9ICQkWzpkb2N1bWVudF0uZ2V0RWxlbWVudEJ5SWQoXCIje2t9Q29sXCIpLmlubmVySFRNTFxuICAgIFwiI3trLnNwbGl0KCdfJykuam9pbignICcpLmNhcGl0YWxpemV9OiAje3Z9XCJcbiAgZW5kLnRvX2Euam9pbignOyAnKVxuICB0eHQgPSAkJFs6ZG9jdW1lbnRdLmdldEVsZW1lbnRCeUlkKFwiY3JlYXRlZENvbnRhaW5lclwiKS5pbm5lckhUTUxcbiAgJCRbOmRvY3VtZW50XS5nZXRFbGVtZW50QnlJZChcImNyZWF0ZWRDb250YWluZXJcIikuaW5uZXJIVE1MID0gXCJDcmVhdGVkOiAje3Jlc3VsdH08YnIgLz4je3R4dH1cIlxuZW5kXG5cbiMgcG9wdWxhdGUgd2l0aCBzbGlkZXIgdmFsdWUgMSBhcyBkZWZhdWx0XG51cGRhdGUoMSwgdG90YWxfc2VsZWN0aW9uc19jb3VudCwgYWxsX3NlbGVjdGlvbnMpXG5cbnAgXCJTdWNjZXNzZnVsbHkgaW5pdGlhbGl6ZWRcIlxuIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJkZWF0aF95ZWFyIiwiMTgwMCIsIjIwMjAiLCJ0b19hIiwicGVyc29uYWxpdHkiLCJhbGlnbm1lbnQiLCJmYWNlIiwibWFwIiwiMSIsIjciLCJpIiwiY29sb3VyIiwib2NjdXBhdGlvbiIsImFsbF9zZWxlY3Rpb25zIiwidG90YWxfc2VsZWN0aW9uc19jb3VudCIsInZhbHVlcyIsIngiLCJsZW5ndGgiLCJyZWR1Y2UiLCJ1cGRhdGUiLCJudW0iLCItIiwicmVzdWx0IiwiZWFjaCIsImtleXMiLCJrIiwiLyIsIltdIiwidG9faSIsImRpdm1vZCIsInEiLCJyIiwiJHdyaXRlciIsIltdPSIsInYiLCJpbm5lckhUTUw9IiwiJCQiLCJnZXRFbGVtZW50QnlJZCIsImJhY2tncm91bmRDb2xvcj0iLCJzdHlsZSIsIi0xIiwiYmFja2dyb3VuZEltYWdlPSIsInN0YXRzX3RhYmxlIiwic3BsaXQiLCJqb2luIiwiY2FwaXRhbGl6ZSIsInNsaWRlcl9jb250YWluZXIiLCJ0aGVfc2xpZGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInZhbHVlIiwibWludXNfYnRuIiwic2xpZGVyX3ZhbHVlIiwiPiIsInZhbHVlPSIsInBsdXNfYnRuIiwiPCIsIisiLCJidG4iLCJlYWNoX2tleSIsImlubmVySFRNTCIsInR4dCIsInAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFBQSxTQUFBQSxDQUFRLFNBQVJBLENBQUE7QUFBQSxNQUNBQSxTQUFBQSxDQUFRLFFBQVJBLENBREE7QUFBQSxFQVFBQyxh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
